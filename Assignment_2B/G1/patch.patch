diff -ruN xv6-public/.cvsignore xv6-public_new/.cvsignore
--- xv6-public/.cvsignore	2021-09-30 23:28:57.620391300 +0530
+++ xv6-public_new/.cvsignore	1970-01-01 05:30:00.000000000 +0530
@@ -1,16 +0,0 @@
-*.asm
-*.d
-*.sym
-_*
-kernel
-user1
-userfs
-usertests
-xv6.img
-vectors.S
-bochsout.txt
-bootblock
-bootother
-bootother.out
-parport.out
-fmt
diff -ruN xv6-public/.dir-locals.el xv6-public_new/.dir-locals.el
--- xv6-public/.dir-locals.el	2021-09-30 23:28:57.622394300 +0530
+++ xv6-public_new/.dir-locals.el	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
-((c-mode
-  (indent-tabs-mode . nil)
-  (c-file-style . "bsd")
-  (c-basic-offset . 2)))
diff -ruN xv6-public/.gdbinit.tmpl xv6-public_new/.gdbinit.tmpl
--- xv6-public/.gdbinit.tmpl	2021-09-30 23:28:57.624394800 +0530
+++ xv6-public_new/.gdbinit.tmpl	1970-01-01 05:30:00.000000000 +0530
@@ -1,27 +0,0 @@
-set $lastcs = -1
-
-define hook-stop
-  # There doesn't seem to be a good way to detect if we're in 16- or
-  # 32-bit mode, but in 32-bit mode we always run with CS == 8 in the
-  # kernel and CS == 35 in user space
-  if $cs == 8 || $cs == 35
-    if $lastcs != 8 && $lastcs != 35
-      set architecture i386
-    end
-    x/i $pc
-  else
-    if $lastcs == -1 || $lastcs == 8 || $lastcs == 35
-      set architecture i8086
-    end
-    # Translate the segment:offset into a physical address
-    printf "[%4x:%4x] ", $cs, $eip
-    x/i $cs*16+$eip
-  end
-  set $lastcs = $cs
-end
-
-echo + target remote localhost:1234\n
-target remote localhost:1234
-
-echo + symbol-file kernel\n
-symbol-file kernel
diff -ruN xv6-public/.git/HEAD xv6-public_new/.git/HEAD
--- xv6-public/.git/HEAD	2021-09-30 23:28:57.536394100 +0530
+++ xv6-public_new/.git/HEAD	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-ref: refs/heads/master
diff -ruN xv6-public/.git/config xv6-public_new/.git/config
--- xv6-public/.git/config	2021-09-30 23:28:57.585392900 +0530
+++ xv6-public_new/.git/config	1970-01-01 05:30:00.000000000 +0530
@@ -1,12 +0,0 @@
-[core]
-	repositoryformatversion = 0
-	filemode = true
-	bare = false
-	logallrefupdates = true
-	ignorecase = true
-[remote "origin"]
-	url = git://github.com/mit-pdos/xv6-public.git
-	fetch = +refs/heads/*:refs/remotes/origin/*
-[branch "master"]
-	remote = origin
-	merge = refs/heads/master
diff -ruN xv6-public/.git/description xv6-public_new/.git/description
--- xv6-public/.git/description	2021-09-30 23:28:45.879944000 +0530
+++ xv6-public_new/.git/description	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-Unnamed repository; edit this file 'description' to name the repository.
diff -ruN xv6-public/.git/hooks/applypatch-msg.sample xv6-public_new/.git/hooks/applypatch-msg.sample
--- xv6-public/.git/hooks/applypatch-msg.sample	2021-09-30 23:28:45.913930500 +0530
+++ xv6-public_new/.git/hooks/applypatch-msg.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message taken by
-# applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.  The hook is
-# allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "applypatch-msg".
-
-. git-sh-setup
-commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
-test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
-:
diff -ruN xv6-public/.git/hooks/commit-msg.sample xv6-public_new/.git/hooks/commit-msg.sample
--- xv6-public/.git/hooks/commit-msg.sample	2021-09-30 23:28:45.927928500 +0530
+++ xv6-public_new/.git/hooks/commit-msg.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message.
-# Called by "git commit" with one argument, the name of the file
-# that has the commit message.  The hook should exit with non-zero
-# status after issuing an appropriate message if it wants to stop the
-# commit.  The hook is allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "commit-msg".
-
-# Uncomment the below to add a Signed-off-by line to the message.
-# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
-# hook is more suited to it.
-#
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-
-# This example catches duplicate Signed-off-by lines.
-
-test "" = "$(grep '^Signed-off-by: ' "$1" |
-	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
-	echo >&2 Duplicate Signed-off-by lines.
-	exit 1
-}
diff -ruN xv6-public/.git/hooks/fsmonitor-watchman.sample xv6-public_new/.git/hooks/fsmonitor-watchman.sample
--- xv6-public/.git/hooks/fsmonitor-watchman.sample	2021-09-30 23:28:45.886930500 +0530
+++ xv6-public_new/.git/hooks/fsmonitor-watchman.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,109 +0,0 @@
-#!/usr/bin/perl
-
-use strict;
-use warnings;
-use IPC::Open2;
-
-# An example hook script to integrate Watchman
-# (https://facebook.github.io/watchman/) with git to speed up detecting
-# new and modified files.
-#
-# The hook is passed a version (currently 1) and a time in nanoseconds
-# formatted as a string and outputs to stdout all files that have been
-# modified since the given time. Paths must be relative to the root of
-# the working tree and separated by a single NUL.
-#
-# To enable this hook, rename this file to "query-watchman" and set
-# 'git config core.fsmonitor .git/hooks/query-watchman'
-#
-my ($version, $time) = @ARGV;
-
-# Check the hook interface version
-
-if ($version == 1) {
-	# convert nanoseconds to seconds
-	# subtract one second to make sure watchman will return all changes
-	$time = int ($time / 1000000000) - 1;
-} else {
-	die "Unsupported query-fsmonitor hook version '$version'.\n" .
-	    "Falling back to scanning...\n";
-}
-
-my $git_work_tree;
-if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-	$git_work_tree = Win32::GetCwd();
-	$git_work_tree =~ tr/\\/\//;
-} else {
-	require Cwd;
-	$git_work_tree = Cwd::cwd();
-}
-
-my $retry = 1;
-
-launch_watchman();
-
-sub launch_watchman {
-
-	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	    or die "open2() failed: $!\n" .
-	    "Falling back to scanning...\n";
-
-	# In the query expression below we're asking for names of files that
-	# changed since $time but were not transient (ie created after
-	# $time but no longer exist).
-	#
-	# To accomplish this, we're using the "since" generator to use the
-	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only.
-
-	my $query = <<"	END";
-		["query", "$git_work_tree", {
-			"since": $time,
-			"fields": ["name"]
-		}]
-	END
-
-	print CHLD_IN $query;
-	close CHLD_IN;
-	my $response = do {local $/; <CHLD_OUT>};
-
-	die "Watchman: command returned no output.\n" .
-	    "Falling back to scanning...\n" if $response eq "";
-	die "Watchman: command returned invalid output: $response\n" .
-	    "Falling back to scanning...\n" unless $response =~ /^\{/;
-
-	my $json_pkg;
-	eval {
-		require JSON::XS;
-		$json_pkg = "JSON::XS";
-		1;
-	} or do {
-		require JSON::PP;
-		$json_pkg = "JSON::PP";
-	};
-
-	my $o = $json_pkg->new->utf8->decode($response);
-
-	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
-		$retry--;
-		qx/watchman watch "$git_work_tree"/;
-		die "Failed to make watchman watch '$git_work_tree'.\n" .
-		    "Falling back to scanning...\n" if $? != 0;
-
-		# Watchman will always return all files on the first query so
-		# return the fast "everything is dirty" flag to git and do the
-		# Watchman query just to get it over with now so we won't pay
-		# the cost in git to look up each individual file.
-		print "/\0";
-		eval { launch_watchman() };
-		exit 0;
-	}
-
-	die "Watchman: $o->{error}.\n" .
-	    "Falling back to scanning...\n" if $o->{error};
-
-	binmode STDOUT, ":utf8";
-	local $, = "\0";
-	print @{$o->{files}};
-}
diff -ruN xv6-public/.git/hooks/post-update.sample xv6-public_new/.git/hooks/post-update.sample
--- xv6-public/.git/hooks/post-update.sample	2021-09-30 23:28:45.931929200 +0530
+++ xv6-public_new/.git/hooks/post-update.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare a packed repository for use over
-# dumb transports.
-#
-# To enable this hook, rename this file to "post-update".
-
-exec git update-server-info
diff -ruN xv6-public/.git/hooks/pre-applypatch.sample xv6-public_new/.git/hooks/pre-applypatch.sample
--- xv6-public/.git/hooks/pre-applypatch.sample	2021-09-30 23:28:45.896929900 +0530
+++ xv6-public_new/.git/hooks/pre-applypatch.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed
-# by applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-applypatch".
-
-. git-sh-setup
-precommit="$(git rev-parse --git-path hooks/pre-commit)"
-test -x "$precommit" && exec "$precommit" ${1+"$@"}
-:
diff -ruN xv6-public/.git/hooks/pre-commit.sample xv6-public_new/.git/hooks/pre-commit.sample
--- xv6-public/.git/hooks/pre-commit.sample	2021-09-30 23:28:45.918931800 +0530
+++ xv6-public_new/.git/hooks/pre-commit.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,49 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git commit" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message if
-# it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-commit".
-
-if git rev-parse --verify HEAD >/dev/null 2>&1
-then
-	against=HEAD
-else
-	# Initial commit: diff against an empty tree object
-	against=$(git hash-object -t tree /dev/null)
-fi
-
-# If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --bool hooks.allownonascii)
-
-# Redirect output to stderr.
-exec 1>&2
-
-# Cross platform projects tend to avoid non-ASCII filenames; prevent
-# them from being added to the repository. We exploit the fact that the
-# printable range starts at the space character and ends with tilde.
-if [ "$allownonascii" != "true" ] &&
-	# Note that the use of brackets around a tr range is ok here, (it's
-	# even required, for portability to Solaris 10's /usr/bin/tr), since
-	# the square bracket bytes happen to fall in the designated range.
-	test $(git diff --cached --name-only --diff-filter=A -z $against |
-	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
-then
-	cat <<\EOF
-Error: Attempt to add a non-ASCII file name.
-
-This can cause problems if you want to work with people on other platforms.
-
-To be portable it is advisable to rename the file.
-
-If you know what you are doing you can disable this check using:
-
-  git config hooks.allownonascii true
-EOF
-	exit 1
-fi
-
-# If there are whitespace errors, print the offending file names and fail.
-exec git diff-index --check --cached $against --
diff -ruN xv6-public/.git/hooks/pre-merge-commit.sample xv6-public_new/.git/hooks/pre-merge-commit.sample
--- xv6-public/.git/hooks/pre-merge-commit.sample	2021-09-30 23:28:45.909928800 +0530
+++ xv6-public_new/.git/hooks/pre-merge-commit.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,13 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git merge" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message to
-# stderr if it wants to stop the merge commit.
-#
-# To enable this hook, rename this file to "pre-merge-commit".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/pre-commit" &&
-        exec "$GIT_DIR/hooks/pre-commit"
-:
diff -ruN xv6-public/.git/hooks/pre-push.sample xv6-public_new/.git/hooks/pre-push.sample
--- xv6-public/.git/hooks/pre-push.sample	2021-09-30 23:28:45.900931700 +0530
+++ xv6-public_new/.git/hooks/pre-push.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,53 +0,0 @@
-#!/bin/sh
-
-# An example hook script to verify what is about to be pushed.  Called by "git
-# push" after it has checked the remote status, but before anything has been
-# pushed.  If this script exits with a non-zero status nothing will be pushed.
-#
-# This hook is called with the following parameters:
-#
-# $1 -- Name of the remote to which the push is being done
-# $2 -- URL to which the push is being done
-#
-# If pushing without using a named remote those arguments will be equal.
-#
-# Information about the commits which are being pushed is supplied as lines to
-# the standard input in the form:
-#
-#   <local ref> <local sha1> <remote ref> <remote sha1>
-#
-# This sample shows how to prevent push of commits where the log message starts
-# with "WIP" (work in progress).
-
-remote="$1"
-url="$2"
-
-z40=0000000000000000000000000000000000000000
-
-while read local_ref local_sha remote_ref remote_sha
-do
-	if [ "$local_sha" = $z40 ]
-	then
-		# Handle delete
-		:
-	else
-		if [ "$remote_sha" = $z40 ]
-		then
-			# New branch, examine all commits
-			range="$local_sha"
-		else
-			# Update to existing branch, examine new commits
-			range="$remote_sha..$local_sha"
-		fi
-
-		# Check for WIP commit
-		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
-		if [ -n "$commit" ]
-		then
-			echo >&2 "Found WIP commit in $local_ref, not pushing"
-			exit 1
-		fi
-	fi
-done
-
-exit 0
diff -ruN xv6-public/.git/hooks/pre-rebase.sample xv6-public_new/.git/hooks/pre-rebase.sample
--- xv6-public/.git/hooks/pre-rebase.sample	2021-09-30 23:28:45.936929100 +0530
+++ xv6-public_new/.git/hooks/pre-rebase.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,169 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2006, 2008 Junio C Hamano
-#
-# The "pre-rebase" hook is run just before "git rebase" starts doing
-# its job, and can prevent the command from running by exiting with
-# non-zero status.
-#
-# The hook is called with the following parameters:
-#
-# $1 -- the upstream the series was forked from.
-# $2 -- the branch being rebased (or empty when rebasing the current branch).
-#
-# This sample shows how to prevent topic branches that are already
-# merged to 'next' branch from getting rebased, because allowing it
-# would result in rebasing already published history.
-
-publish=next
-basebranch="$1"
-if test "$#" = 2
-then
-	topic="refs/heads/$2"
-else
-	topic=`git symbolic-ref HEAD` ||
-	exit 0 ;# we do not interrupt rebasing detached HEAD
-fi
-
-case "$topic" in
-refs/heads/??/*)
-	;;
-*)
-	exit 0 ;# we do not interrupt others.
-	;;
-esac
-
-# Now we are dealing with a topic branch being rebased
-# on top of master.  Is it OK to rebase it?
-
-# Does the topic really exist?
-git show-ref -q "$topic" || {
-	echo >&2 "No such branch $topic"
-	exit 1
-}
-
-# Is topic fully merged to master?
-not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
-if test -z "$not_in_master"
-then
-	echo >&2 "$topic is fully merged to master; better remove it."
-	exit 1 ;# we could allow it, but there is no point.
-fi
-
-# Is topic ever merged to next?  If so you should not be rebasing it.
-only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
-only_next_2=`git rev-list ^master           ${publish} | sort`
-if test "$only_next_1" = "$only_next_2"
-then
-	not_in_topic=`git rev-list "^$topic" master`
-	if test -z "$not_in_topic"
-	then
-		echo >&2 "$topic is already up to date with master"
-		exit 1 ;# we could allow it, but there is no point.
-	else
-		exit 0
-	fi
-else
-	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
-	/usr/bin/perl -e '
-		my $topic = $ARGV[0];
-		my $msg = "* $topic has commits already merged to public branch:\n";
-		my (%not_in_next) = map {
-			/^([0-9a-f]+) /;
-			($1 => 1);
-		} split(/\n/, $ARGV[1]);
-		for my $elem (map {
-				/^([0-9a-f]+) (.*)$/;
-				[$1 => $2];
-			} split(/\n/, $ARGV[2])) {
-			if (!exists $not_in_next{$elem->[0]}) {
-				if ($msg) {
-					print STDERR $msg;
-					undef $msg;
-				}
-				print STDERR " $elem->[1]\n";
-			}
-		}
-	' "$topic" "$not_in_next" "$not_in_master"
-	exit 1
-fi
-
-<<\DOC_END
-
-This sample hook safeguards topic branches that have been
-published from being rewound.
-
-The workflow assumed here is:
-
- * Once a topic branch forks from "master", "master" is never
-   merged into it again (either directly or indirectly).
-
- * Once a topic branch is fully cooked and merged into "master",
-   it is deleted.  If you need to build on top of it to correct
-   earlier mistakes, a new topic branch is created by forking at
-   the tip of the "master".  This is not strictly necessary, but
-   it makes it easier to keep your history simple.
-
- * Whenever you need to test or publish your changes to topic
-   branches, merge them into "next" branch.
-
-The script, being an example, hardcodes the publish branch name
-to be "next", but it is trivial to make it configurable via
-$GIT_DIR/config mechanism.
-
-With this workflow, you would want to know:
-
-(1) ... if a topic branch has ever been merged to "next".  Young
-    topic branches can have stupid mistakes you would rather
-    clean up before publishing, and things that have not been
-    merged into other branches can be easily rebased without
-    affecting other people.  But once it is published, you would
-    not want to rewind it.
-
-(2) ... if a topic branch has been fully merged to "master".
-    Then you can delete it.  More importantly, you should not
-    build on top of it -- other people may already want to
-    change things related to the topic as patches against your
-    "master", so if you need further changes, it is better to
-    fork the topic (perhaps with the same name) afresh from the
-    tip of "master".
-
-Let's look at this example:
-
-		   o---o---o---o---o---o---o---o---o---o "next"
-		  /       /           /           /
-		 /   a---a---b A     /           /
-		/   /               /           /
-	       /   /   c---c---c---c B         /
-	      /   /   /             \         /
-	     /   /   /   b---b C     \       /
-	    /   /   /   /             \     /
-    ---o---o---o---o---o---o---o---o---o---o---o "master"
-
-
-A, B and C are topic branches.
-
- * A has one fix since it was merged up to "next".
-
- * B has finished.  It has been fully merged up to "master" and "next",
-   and is ready to be deleted.
-
- * C has not merged to "next" at all.
-
-We would want to allow C to be rebased, refuse A, and encourage
-B to be deleted.
-
-To compute (1):
-
-	git rev-list ^master ^topic next
-	git rev-list ^master        next
-
-	if these match, topic has not merged in next at all.
-
-To compute (2):
-
-	git rev-list master..topic
-
-	if this is empty, it is fully merged to "master".
-
-DOC_END
diff -ruN xv6-public/.git/hooks/pre-receive.sample xv6-public_new/.git/hooks/pre-receive.sample
--- xv6-public/.git/hooks/pre-receive.sample	2021-09-30 23:28:45.904929600 +0530
+++ xv6-public_new/.git/hooks/pre-receive.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to make use of push options.
-# The example simply echoes all push options that start with 'echoback='
-# and rejects all pushes when the "reject" push option is used.
-#
-# To enable this hook, rename this file to "pre-receive".
-
-if test -n "$GIT_PUSH_OPTION_COUNT"
-then
-	i=0
-	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
-	do
-		eval "value=\$GIT_PUSH_OPTION_$i"
-		case "$value" in
-		echoback=*)
-			echo "echo from the pre-receive-hook: ${value#*=}" >&2
-			;;
-		reject)
-			exit 1
-		esac
-		i=$((i + 1))
-	done
-fi
diff -ruN xv6-public/.git/hooks/prepare-commit-msg.sample xv6-public_new/.git/hooks/prepare-commit-msg.sample
--- xv6-public/.git/hooks/prepare-commit-msg.sample	2021-09-30 23:28:45.922929600 +0530
+++ xv6-public_new/.git/hooks/prepare-commit-msg.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,42 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare the commit log message.
-# Called by "git commit" with the name of the file that has the
-# commit message, followed by the description of the commit
-# message's source.  The hook's purpose is to edit the commit
-# message file.  If the hook fails with a non-zero status,
-# the commit is aborted.
-#
-# To enable this hook, rename this file to "prepare-commit-msg".
-
-# This hook includes three examples. The first one removes the
-# "# Please enter the commit message..." help message.
-#
-# The second includes the output of "git diff --name-status -r"
-# into the message, just before the "git status" output.  It is
-# commented because it doesn't cope with --amend or with squashed
-# commits.
-#
-# The third example adds a Signed-off-by line to the message, that can
-# still be edited.  This is rarely a good idea.
-
-COMMIT_MSG_FILE=$1
-COMMIT_SOURCE=$2
-SHA1=$3
-
-/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
-
-# case "$COMMIT_SOURCE,$SHA1" in
-#  ,|template,)
-#    /usr/bin/perl -i.bak -pe '
-#       print "\n" . `git diff --cached --name-status -r`
-# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
-#  *) ;;
-# esac
-
-# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
-# if test -z "$COMMIT_SOURCE"
-# then
-#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
-# fi
diff -ruN xv6-public/.git/hooks/update.sample xv6-public_new/.git/hooks/update.sample
--- xv6-public/.git/hooks/update.sample	2021-09-30 23:28:45.891932300 +0530
+++ xv6-public_new/.git/hooks/update.sample	1970-01-01 05:30:00.000000000 +0530
@@ -1,128 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to block unannotated tags from entering.
-# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
-#
-# To enable this hook, rename this file to "update".
-#
-# Config
-# ------
-# hooks.allowunannotated
-#   This boolean sets whether unannotated tags will be allowed into the
-#   repository.  By default they won't be.
-# hooks.allowdeletetag
-#   This boolean sets whether deleting tags will be allowed in the
-#   repository.  By default they won't be.
-# hooks.allowmodifytag
-#   This boolean sets whether a tag may be modified after creation. By default
-#   it won't be.
-# hooks.allowdeletebranch
-#   This boolean sets whether deleting branches will be allowed in the
-#   repository.  By default they won't be.
-# hooks.denycreatebranch
-#   This boolean sets whether remotely creating branches will be denied
-#   in the repository.  By default this is allowed.
-#
-
-# --- Command line
-refname="$1"
-oldrev="$2"
-newrev="$3"
-
-# --- Safety check
-if [ -z "$GIT_DIR" ]; then
-	echo "Don't run this script from the command line." >&2
-	echo " (if you want, you could supply GIT_DIR then run" >&2
-	echo "  $0 <ref> <oldrev> <newrev>)" >&2
-	exit 1
-fi
-
-if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
-	exit 1
-fi
-
-# --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
-
-# check for no description
-projectdesc=$(sed -e '1q' "$GIT_DIR/description")
-case "$projectdesc" in
-"Unnamed repository"* | "")
-	echo "*** Project description file hasn't been set" >&2
-	exit 1
-	;;
-esac
-
-# --- Check types
-# if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
-if [ "$newrev" = "$zero" ]; then
-	newrev_type=delete
-else
-	newrev_type=$(git cat-file -t $newrev)
-fi
-
-case "$refname","$newrev_type" in
-	refs/tags/*,commit)
-		# un-annotated tag
-		short_refname=${refname##refs/tags/}
-		if [ "$allowunannotated" != "true" ]; then
-			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
-			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,delete)
-		# delete tag
-		if [ "$allowdeletetag" != "true" ]; then
-			echo "*** Deleting a tag is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,tag)
-		# annotated tag
-		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
-		then
-			echo "*** Tag '$refname' already exists." >&2
-			echo "*** Modifying a tag is not allowed in this repository." >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,commit)
-		# branch
-		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
-			echo "*** Creating a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,delete)
-		# delete branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/remotes/*,commit)
-		# tracking branch
-		;;
-	refs/remotes/*,delete)
-		# delete tracking branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	*)
-		# Anything else (is there anything else?)
-		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
-		exit 1
-		;;
-esac
-
-# --- Finished
-exit 0
Binary files xv6-public/.git/index and xv6-public_new/.git/index differ
diff -ruN xv6-public/.git/info/exclude xv6-public_new/.git/info/exclude
--- xv6-public/.git/info/exclude	2021-09-30 23:28:45.943930500 +0530
+++ xv6-public_new/.git/info/exclude	1970-01-01 05:30:00.000000000 +0530
@@ -1,6 +0,0 @@
-# git ls-files --others --exclude-from=.git/info/exclude
-# Lines that start with '#' are comments.
-# For a project mostly in C, the following would be a good set of
-# exclude patterns (uncomment them if you want to use them):
-# *.[oa]
-# *~
diff -ruN xv6-public/.git/logs/HEAD xv6-public_new/.git/logs/HEAD
--- xv6-public/.git/logs/HEAD	2021-09-30 23:28:57.559391400 +0530
+++ xv6-public_new/.git/logs/HEAD	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 anuraag <anuraag@DESKTOP-QEFMQFQ.localdomain> 1633024737 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
diff -ruN xv6-public/.git/logs/refs/heads/master xv6-public_new/.git/logs/refs/heads/master
--- xv6-public/.git/logs/refs/heads/master	2021-09-30 23:28:57.569392400 +0530
+++ xv6-public_new/.git/logs/refs/heads/master	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 anuraag <anuraag@DESKTOP-QEFMQFQ.localdomain> 1633024737 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
diff -ruN xv6-public/.git/logs/refs/remotes/origin/HEAD xv6-public_new/.git/logs/refs/remotes/origin/HEAD
--- xv6-public/.git/logs/refs/remotes/origin/HEAD	2021-09-30 23:28:57.523394000 +0530
+++ xv6-public_new/.git/logs/refs/remotes/origin/HEAD	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 anuraag <anuraag@DESKTOP-QEFMQFQ.localdomain> 1633024737 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
Binary files xv6-public/.git/objects/pack/pack-12ca327ecdd26d679901b04fa869cf247b06c9ef.idx and xv6-public_new/.git/objects/pack/pack-12ca327ecdd26d679901b04fa869cf247b06c9ef.idx differ
Binary files xv6-public/.git/objects/pack/pack-12ca327ecdd26d679901b04fa869cf247b06c9ef.pack and xv6-public_new/.git/objects/pack/pack-12ca327ecdd26d679901b04fa869cf247b06c9ef.pack differ
diff -ruN xv6-public/.git/packed-refs xv6-public_new/.git/packed-refs
--- xv6-public/.git/packed-refs	2021-09-30 23:28:57.489393100 +0530
+++ xv6-public_new/.git/packed-refs	1970-01-01 05:30:00.000000000 +0530
@@ -1,28 +0,0 @@
-# pack-refs with: peeled fully-peeled sorted 
-eeb7b415dbcb12cc362d0783e41c3d1f44066b17 refs/remotes/origin/master
-af0e851a3a8a7d13bc2f2d596b58500594040892 refs/tags/osdi12-submit
-^8286b58087750e09bac3815219e0382a0bb2b159
-9e698c587b135db17b38a5838976805b9c01e338 refs/tags/symlinks
-05e0b1218dcebe1f40028531b51926df8ae52be0 refs/tags/xv6-2006
-^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
-42f3c3f7be9717b66ba6e133a113c0f751c53133 refs/tags/xv6-2007
-adcd16c3f7588b4a28d37495f05e94278c9e3a1e refs/tags/xv6-2008
-124fe7e457c0dc9b671c7ffccb56004eb61da4f0 refs/tags/xv6-2010
-5922cdbbcc4fdbd76eec9e0dad9f650e4c86ee99 refs/tags/xv6-rev0
-^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
-81f31a773dd49b001437eaed3975438585ff9911 refs/tags/xv6-rev1
-^42f3c3f7be9717b66ba6e133a113c0f751c53133
-b818915f793cd20c5d1e24f668534a9d690f3cc8 refs/tags/xv6-rev11
-30dab73b68b816877dc8f78504ceca0808c976eb refs/tags/xv6-rev3
-^074ac7ccd43c08d01a237ce6f14cac10715a51ef
-113005d48f09a4e3939940d72a77bf6973ea8755 refs/tags/xv6-rev4
-^124fe7e457c0dc9b671c7ffccb56004eb61da4f0
-d6aa754494b37e32862b1f78d53deedc53f66a15 refs/tags/xv6-rev5
-^ae603ff5e79bb7b5eea4147425752f33d29fe558
-3e9d6413d331b4c912d55bfac253af1629d4bac9 refs/tags/xv6-rev6
-^e64c661ae8b91bd7e858bb1895bef96e6ac2b4bb
-ccc25c0fac59067d88af52ad9f3b8cee97c3810a refs/tags/xv6-rev7
-^2ae8392a5c203a7b1bc5b8bff5eabc8b5eab8972
-7d6f95e327f1c18570d5dd187e3d92e1aadae2cf refs/tags/xv6-rev8
-^9ba21267e796eb462a657392906e3cbccaedcc99
-5bf3fbee00fb27cb8cb4eca72dcd9fc4c288ed71 refs/tags/xv6-rev9
diff -ruN xv6-public/.git/refs/heads/master xv6-public_new/.git/refs/heads/master
--- xv6-public/.git/refs/heads/master	2021-09-30 23:28:57.556394600 +0530
+++ xv6-public_new/.git/refs/heads/master	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-eeb7b415dbcb12cc362d0783e41c3d1f44066b17
diff -ruN xv6-public/.git/refs/remotes/origin/HEAD xv6-public_new/.git/refs/remotes/origin/HEAD
--- xv6-public/.git/refs/remotes/origin/HEAD	2021-09-30 23:28:57.524396400 +0530
+++ xv6-public_new/.git/refs/remotes/origin/HEAD	1970-01-01 05:30:00.000000000 +0530
@@ -1 +0,0 @@
-ref: refs/remotes/origin/master
diff -ruN xv6-public/.gitignore xv6-public_new/.gitignore
--- xv6-public/.gitignore	2021-09-30 23:28:57.626396600 +0530
+++ xv6-public_new/.gitignore	1970-01-01 05:30:00.000000000 +0530
@@ -1,16 +0,0 @@
-*~
-_*
-*.o
-*.d
-*.asm
-*.sym
-*.img
-vectors.S
-bootblock
-entryother
-initcode
-initcode.out
-kernel
-kernelmemfs
-mkfs
-.gdbinit
diff -ruN xv6-public/BUGS xv6-public_new/BUGS
--- xv6-public/BUGS	2021-09-30 23:28:57.628393500 +0530
+++ xv6-public_new/BUGS	1970-01-01 05:30:00.000000000 +0530
@@ -1,7 +0,0 @@
-formatting:
-	need to fix PAGEBREAK mechanism
-
-sh:
-	can't always runcmd in child -- breaks cd.
-	maybe should hard-code PATH=/ ?
-
diff -ruN xv6-public/LICENSE xv6-public_new/LICENSE
--- xv6-public/LICENSE	2021-09-30 23:28:57.630390900 +0530
+++ xv6-public_new/LICENSE	1970-01-01 05:30:00.000000000 +0530
@@ -1,24 +0,0 @@
-The xv6 software is:
-
-Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
-                        Massachusetts Institute of Technology
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
diff -ruN xv6-public/Makefile xv6-public_new/Makefile
--- xv6-public/Makefile	2021-09-30 23:28:57.632395800 +0530
+++ xv6-public_new/Makefile	1970-01-01 05:30:00.000000000 +0530
@@ -1,286 +0,0 @@
-OBJS = \
-	bio.o\
-	console.o\
-	exec.o\
-	file.o\
-	fs.o\
-	ide.o\
-	ioapic.o\
-	kalloc.o\
-	kbd.o\
-	lapic.o\
-	log.o\
-	main.o\
-	mp.o\
-	picirq.o\
-	pipe.o\
-	proc.o\
-	sleeplock.o\
-	spinlock.o\
-	string.o\
-	swtch.o\
-	syscall.o\
-	sysfile.o\
-	sysproc.o\
-	trapasm.o\
-	trap.o\
-	uart.o\
-	vectors.o\
-	vm.o\
-
-# Cross-compiling (e.g., on Mac OS X)
-# TOOLPREFIX = i386-jos-elf
-
-# Using native tools (e.g., on X86 Linux)
-#TOOLPREFIX = 
-
-# Try to infer the correct TOOLPREFIX if not set
-ifndef TOOLPREFIX
-TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
-	then echo 'i386-jos-elf-'; \
-	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
-	then echo ''; \
-	else echo "***" 1>&2; \
-	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
-	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
-	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
-	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
-	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
-	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
-	echo "***" 1>&2; exit 1; fi)
-endif
-
-# If the makefile can't find QEMU, specify its path here
-# QEMU = qemu-system-i386
-
-# Try to infer the correct QEMU
-ifndef QEMU
-QEMU = $(shell if which qemu > /dev/null; \
-	then echo qemu; exit; \
-	elif which qemu-system-i386 > /dev/null; \
-	then echo qemu-system-i386; exit; \
-	elif which qemu-system-x86_64 > /dev/null; \
-	then echo qemu-system-x86_64; exit; \
-	else \
-	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
-	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
-	echo "***" 1>&2; \
-	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
-	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
-	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
-	echo "***" 1>&2; exit 1)
-endif
-
-CC = $(TOOLPREFIX)gcc
-AS = $(TOOLPREFIX)gas
-LD = $(TOOLPREFIX)ld
-OBJCOPY = $(TOOLPREFIX)objcopy
-OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
-ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
-# FreeBSD ld wants ``elf_i386_fbsd''
-LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
-
-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
-CFLAGS += -fno-pie -no-pie
-endif
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
-CFLAGS += -fno-pie -nopie
-endif
-
-xv6.img: bootblock kernel
-	dd if=/dev/zero of=xv6.img count=10000
-	dd if=bootblock of=xv6.img conv=notrunc
-	dd if=kernel of=xv6.img seek=1 conv=notrunc
-
-xv6memfs.img: bootblock kernelmemfs
-	dd if=/dev/zero of=xv6memfs.img count=10000
-	dd if=bootblock of=xv6memfs.img conv=notrunc
-	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
-
-bootblock: bootasm.S bootmain.c
-	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
-	$(OBJDUMP) -S bootblock.o > bootblock.asm
-	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
-	./sign.pl bootblock
-
-entryother: entryother.S
-	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
-	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
-	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
-	$(OBJDUMP) -S bootblockother.o > entryother.asm
-
-initcode: initcode.S
-	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
-	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
-	$(OBJCOPY) -S -O binary initcode.out initcode
-	$(OBJDUMP) -S initcode.o > initcode.asm
-
-kernel: $(OBJS) entry.o entryother initcode kernel.ld
-	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
-	$(OBJDUMP) -S kernel > kernel.asm
-	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
-
-# kernelmemfs is a copy of kernel that maintains the
-# disk image in memory instead of writing to a disk.
-# This is not so useful for testing persistent storage or
-# exploring disk buffering implementations, but it is
-# great for testing the kernel on real hardware without
-# needing a scratch disk.
-MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
-kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
-	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
-	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
-	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
-
-tags: $(OBJS) entryother.S _init
-	etags *.S *.c
-
-vectors.S: vectors.pl
-	./vectors.pl > vectors.S
-
-ULIB = ulib.o usys.o printf.o umalloc.o
-
-_%: %.o $(ULIB)
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
-	$(OBJDUMP) -S $@ > $*.asm
-	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
-
-_forktest: forktest.o $(ULIB)
-	# forktest has less library code linked in - needs to be small
-	# in order to be able to max out the proc table.
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
-	$(OBJDUMP) -S _forktest > forktest.asm
-
-mkfs: mkfs.c fs.h
-	gcc -Werror -Wall -o mkfs mkfs.c
-
-# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
-# that disk image changes after first build are persistent until clean.  More
-# details:
-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
-.PRECIOUS: %.o
-
-UPROGS=\
-	_cat\
-	_echo\
-	_forktest\
-	_grep\
-	_init\
-	_kill\
-	_ln\
-	_ls\
-	_mkdir\
-	_rm\
-	_sh\
-	_stressfs\
-	_usertests\
-	_wc\
-	_zombie\
-
-fs.img: mkfs README $(UPROGS)
-	./mkfs fs.img README $(UPROGS)
-
--include *.d
-
-clean: 
-	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
-	*.o *.d *.asm *.sym vectors.S bootblock entryother \
-	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
-	xv6memfs.img mkfs .gdbinit \
-	$(UPROGS)
-
-# make a printout
-FILES = $(shell grep -v '^\#' runoff.list)
-PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
-
-xv6.pdf: $(PRINT)
-	./runoff
-	ls -l xv6.pdf
-
-print: xv6.pdf
-
-# run in emulators
-
-bochs : fs.img xv6.img
-	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
-	bochs -q
-
-# try to generate a unique GDB port
-GDBPORT = $(shell expr `id -u` % 5000 + 25000)
-# QEMU's gdb stub command line changed in 0.11
-QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
-	then echo "-gdb tcp::$(GDBPORT)"; \
-	else echo "-s -p $(GDBPORT)"; fi)
-ifndef CPUS
-CPUS := 2
-endif
-QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
-
-qemu: fs.img xv6.img
-	$(QEMU) -serial mon:stdio $(QEMUOPTS)
-
-qemu-memfs: xv6memfs.img
-	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
-
-qemu-nox: fs.img xv6.img
-	$(QEMU) -nographic $(QEMUOPTS)
-
-.gdbinit: .gdbinit.tmpl
-	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
-
-qemu-gdb: fs.img xv6.img .gdbinit
-	@echo "*** Now run 'gdb'." 1>&2
-	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
-
-qemu-nox-gdb: fs.img xv6.img .gdbinit
-	@echo "*** Now run 'gdb'." 1>&2
-	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
-
-# CUT HERE
-# prepare dist for students
-# after running make dist, probably want to
-# rename it to rev0 or rev1 or so on and then
-# check in that version.
-
-EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
-	printf.c umalloc.c\
-	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
-	.gdbinit.tmpl gdbutil\
-
-dist:
-	rm -rf dist
-	mkdir dist
-	for i in $(FILES); \
-	do \
-		grep -v PAGEBREAK $$i >dist/$$i; \
-	done
-	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
-	echo >dist/runoff.spec
-	cp $(EXTRA) dist
-
-dist-test:
-	rm -rf dist
-	make dist
-	rm -rf dist-test
-	mkdir dist-test
-	cp dist/* dist-test
-	cd dist-test; $(MAKE) print
-	cd dist-test; $(MAKE) bochs || true
-	cd dist-test; $(MAKE) qemu
-
-# update this rule (change rev#) when it is time to
-# make a new revision.
-tar:
-	rm -rf /tmp/xv6
-	mkdir -p /tmp/xv6
-	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
-	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
-
-.PHONY: dist-test dist
diff -ruN xv6-public/Notes xv6-public_new/Notes
--- xv6-public/Notes	2021-09-30 23:28:57.634395800 +0530
+++ xv6-public_new/Notes	1970-01-01 05:30:00.000000000 +0530
@@ -1,123 +0,0 @@
-bochs 2.2.6:
-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
-bochs CVS after 2.2.6:
-./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
-
-bootmain.c doesn't work right if the ELF sections aren't
-sector-aligned. so you can't use ld -N. and the sections may also need
-to be non-zero length, only really matters for tiny "kernels".
-
-kernel loaded at 1 megabyte. stack same place that bootasm.S left it.
-
-kinit() should find real mem size
-  and rescue useable memory below 1 meg
-
-no paging, no use of page table hardware, just segments
-
-no user area: no magic kernel stack mapping
-  so no copying of kernel stack during fork
-  though there is a kernel stack page for each process
-
-no kernel malloc(), just kalloc() for user core
-
-user pointers aren't valid in the kernel
-
-are interrupts turned on in the kernel? yes.
-
-pass curproc explicitly, or implicit from cpu #?
-  e.g. argument to newproc()?
-  hmm, you need a global curproc[cpu] for trap() &c
-
-no stack expansion
-
-test running out of memory, process slots
-
-we can't really use a separate stack segment, since stack addresses
-need to work correctly as ordinary pointers. the same may be true of
-data vs text. how can we have a gap between data and stack, so that
-both can grow, without committing 4GB of physical memory? does this
-mean we need paging?
-
-perhaps have fixed-size stack, put it in the data segment?
-
-oops, if kernel stack is in contiguous user phys mem, then moving
-users' memory (e.g. to expand it) will wreck any pointers into the
-kernel stack.
-
-do we need to set fs and gs? so user processes can't abuse them?
-
-setupsegs() may modify current segment table, is that legal?
-
-trap() ought to lgdt on return, since currently only done in swtch()
-
-protect hardware interrupt vectors from user INT instructions?
-
-test out-of-fd cases for creating pipe.
-test pipe reader closes then write
-test two readers, two writers.
-test children being inherited by grandparent &c
-
-some sleep()s should be interruptible by kill()
-
-locks
-  init_lock
-    sequences CPU startup
-  proc_table_lock
-    also protects next_pid
-  per-fd lock *just* protects count read-modify-write
-    also maybe freeness?
-  memory allocator
-  printf
-
-in general, the table locks protect both free-ness and
-  public variables of table elements
-  in many cases you can use table elements w/o a lock
-  e.g. if you are the process, or you are using an fd
-
-lock order
-  per-pipe lock
-  proc_table_lock fd_table_lock kalloc_lock
-  console_lock
-
-do you have to be holding the mutex in order to call wakeup()? yes
-
-device interrupts don't clear FL_IF
-  so a recursive timer interrupt is possible
-
-what does inode->busy mean?
-  might be held across disk reads
-  no-one is allowed to do anything to the inode
-  protected by inode_table_lock
-inode->count counts in-memory pointers to the struct
-  prevents inode[] element from being re-used
-  protected by inode_table_lock
-
-blocks and inodes have ad-hoc sleep-locks
-  provide a single mechanism?
-
-kalloc() can return 0; do callers handle this right?
-
-test: one process unlinks a file while another links to it
-test: one process opens a file while another deletes it
-test: deadlock d/.. vs ../d, two processes.
-test: dup() shared fd->off
-test: does echo foo > x truncate x?
-
-sh: ioredirection incorrect now we have pipes
-sh: chain of pipes won't work, also ugly that parent closes fdarray entries too
-sh: dynamic memory allocation?
-sh: should sh support ; () &
-sh: stop stdin on ctrl-d (for cat > y)
-
-really should have bdwrite() for file content
-  and make some inode updates async
-  so soft updates make sense
-
-disk scheduling
-echo foo > bar should truncate bar
-  so O_CREATE should not truncate
-  but O_TRUNC should
-
-make it work on a real machine
-release before acquire at end of sleep?
-check 2nd disk (i.e. if not in .bochsrc)
diff -ruN xv6-public/README xv6-public_new/README
--- xv6-public/README	2021-09-30 23:28:57.636391400 +0530
+++ xv6-public_new/README	1970-01-01 05:30:00.000000000 +0530
@@ -1,51 +0,0 @@
-NOTE: we have stopped maintaining the x86 version of xv6, and switched
-our efforts to the RISC-V version
-(https://github.com/mit-pdos/xv6-riscv.git)
-
-xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
-Version 6 (v6).  xv6 loosely follows the structure and style of v6,
-but is implemented for a modern x86-based multiprocessor using ANSI C.
-
-ACKNOWLEDGMENTS
-
-xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
-to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
-2000)). See also https://pdos.csail.mit.edu/6.828/, which
-provides pointers to on-line resources for v6.
-
-xv6 borrows code from the following sources:
-    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
-    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
-    FreeBSD (ioapic.c)
-    NetBSD (console.c)
-
-The following people have made contributions: Russ Cox (context switching,
-locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
-Clements.
-
-We are also grateful for the bug reports and patches contributed by Silas
-Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
-Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
-Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
-Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
-Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
-Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
-Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
-Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
-Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
-
-The code in the files that constitute xv6 is
-Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
-
-ERROR REPORTS
-
-We don't process error reports (see note on top of this file).
-
-BUILDING AND RUNNING XV6
-
-To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
-"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
-will need to install a cross-compiler gcc suite capable of producing
-x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
-Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
-simulator and run "make qemu".
\ No newline at end of file
diff -ruN xv6-public/TRICKS xv6-public_new/TRICKS
--- xv6-public/TRICKS	2021-09-30 23:28:57.638391300 +0530
+++ xv6-public_new/TRICKS	1970-01-01 05:30:00.000000000 +0530
@@ -1,140 +0,0 @@
-This file lists subtle things that might not be commented 
-as well as they should be in the source code and that
-might be worth pointing out in a longer explanation or in class.
-
----
-
-[2009/07/12: No longer relevant; forkret1 changed
-and this is now cleaner.]
-
-forkret1 in trapasm.S is called with a tf argument.
-In order to use it, forkret1 copies the tf pointer into
-%esp and then jumps to trapret, which pops the 
-register state out of the trap frame.  If an interrupt
-came in between the mov tf, %esp and the iret that
-goes back out to user space, the interrupt stack frame
-would end up scribbling over the tf and whatever memory
-lay under it.
-
-Why is this safe?  Because forkret1 is only called
-the first time a process returns to user space, and
-at that point, cp->tf is set to point to a trap frame
-constructed at the top of cp's kernel stack.  So tf 
-*is* a valid %esp that can hold interrupt state.
-
-If other tf's were used in forkret1, we could add
-a cli before the mov tf, %esp.
-
----
-
-In pushcli, must cli() no matter what.  It is not safe to do
-
-  if(cpus[cpu()].ncli == 0)
-    cli();
-  cpus[cpu()].ncli++;
-
-because if interrupts are off then we might call cpu(), get
-rescheduled to a different cpu, look at cpus[oldcpu].ncli,
-and wrongly decide not to disable interrupts on the new cpu.
-
-Instead do 
-
-  cli();
-  cpus[cpu()].ncli++;
-
-always.
-
----
-
-There is a (harmless) race in pushcli, which does
-
-	eflags = readeflags();
-	cli();
-	if(c->ncli++ == 0)
-		c->intena = eflags & FL_IF;
-
-Consider a bottom-level pushcli.  
-If interrupts are disabled already, then the right thing
-happens: read_eflags finds that FL_IF is not set,
-and intena = 0.  If interrupts are enabled, then
-it is less clear that the right thing happens:
-the readeflags can execute, then the process
-can get preempted and rescheduled on another cpu,
-and then once it starts running, perhaps with 
-interrupts disabled (can happen since the scheduler
-only enables interrupts once per scheduling loop,
-not every time it schedules a process), it will 
-incorrectly record that interrupts *were* enabled.
-This doesn't matter, because if it was safe to be
-running with interrupts enabled before the context
-switch, it is still safe (and arguably more correct)
-to run with them enabled after the context switch too.
-
-In fact it would be safe if scheduler always set
-	c->intena = 1;
-before calling swtch, and perhaps it should.
-
----
-
-The x86's processor-ordering memory model 
-matches spin locks well, so no explicit memory
-synchronization instructions are required in
-acquire and release.  
-
-Consider two sequences of code on different CPUs:
-
-CPU0
-A;
-release(lk);
-
-and
-
-CPU1
-acquire(lk);
-B;
-
-We want to make sure that:
-  - all reads in B see the effects of writes in A.
-  - all reads in A do *not* see the effects of writes in B.
- 
-The x86 guarantees that writes in A will go out
-to memory before the write of lk->locked = 0 in 
-release(lk).  It further guarantees that CPU1 
-will observe CPU0's write of lk->locked = 0 only
-after observing the earlier writes by CPU0.
-So any reads in B are guaranteed to observe the
-effects of writes in A.
-
-According to the Intel manual behavior spec, the
-second condition requires a serialization instruction
-in release, to avoid reads in A happening after giving
-up lk.  No Intel SMP processor in existence actually
-moves reads down after writes, but the language in
-the spec allows it.  There is no telling whether future
-processors will need it.
-
----
-
-The code in fork needs to read np->pid before
-setting np->state to RUNNABLE.  The following
-is not a correct way to do this:
-
-	int
-	fork(void)
-	{
-	  ...
-	  np->state = RUNNABLE;
-	  return np->pid; // oops
-	}
-
-After setting np->state to RUNNABLE, some other CPU
-might run the process, it might exit, and then it might
-get reused for a different process (with a new pid), all
-before the return statement.  So it's not safe to just
-"return np->pid". Even saving a copy of np->pid before
-setting np->state isn't safe, since the compiler is
-allowed to re-order statements.
-
-The real code saves a copy of np->pid, then acquires a lock
-around the write to np->state. The acquire() prevents the
-compiler from re-ordering.
diff -ruN xv6-public/asm.h xv6-public_new/asm.h
--- xv6-public/asm.h	2021-09-30 23:28:57.640392900 +0530
+++ xv6-public_new/asm.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,18 +0,0 @@
-//
-// assembler macros to create x86 segments
-//
-
-#define SEG_NULLASM                                             \
-        .word 0, 0;                                             \
-        .byte 0, 0, 0, 0
-
-// The 0xC0 means the limit is in 4096-byte units
-// and (for executable segments) 32-bit mode.
-#define SEG_ASM(type,base,lim)                                  \
-        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
-        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
-                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
-
-#define STA_X     0x8       // Executable segment
-#define STA_W     0x2       // Writeable (non-executable segments)
-#define STA_R     0x2       // Readable (executable segments)
diff -ruN xv6-public/bio.c xv6-public_new/bio.c
--- xv6-public/bio.c	2021-09-30 23:28:57.642391800 +0530
+++ xv6-public_new/bio.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,144 +0,0 @@
-// Buffer cache.
-//
-// The buffer cache is a linked list of buf structures holding
-// cached copies of disk block contents.  Caching disk blocks
-// in memory reduces the number of disk reads and also provides
-// a synchronization point for disk blocks used by multiple processes.
-//
-// Interface:
-// * To get a buffer for a particular disk block, call bread.
-// * After changing buffer data, call bwrite to write it to disk.
-// * When done with the buffer, call brelse.
-// * Do not use the buffer after calling brelse.
-// * Only one process at a time can use a buffer,
-//     so do not keep them longer than necessary.
-//
-// The implementation uses two state flags internally:
-// * B_VALID: the buffer data has been read from the disk.
-// * B_DIRTY: the buffer data has been modified
-//     and needs to be written to disk.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-
-struct {
-  struct spinlock lock;
-  struct buf buf[NBUF];
-
-  // Linked list of all buffers, through prev/next.
-  // head.next is most recently used.
-  struct buf head;
-} bcache;
-
-void
-binit(void)
-{
-  struct buf *b;
-
-  initlock(&bcache.lock, "bcache");
-
-//PAGEBREAK!
-  // Create linked list of buffers
-  bcache.head.prev = &bcache.head;
-  bcache.head.next = &bcache.head;
-  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    initsleeplock(&b->lock, "buffer");
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
-  }
-}
-
-// Look through buffer cache for block on device dev.
-// If not found, allocate a buffer.
-// In either case, return locked buffer.
-static struct buf*
-bget(uint dev, uint blockno)
-{
-  struct buf *b;
-
-  acquire(&bcache.lock);
-
-  // Is the block already cached?
-  for(b = bcache.head.next; b != &bcache.head; b = b->next){
-    if(b->dev == dev && b->blockno == blockno){
-      b->refcnt++;
-      release(&bcache.lock);
-      acquiresleep(&b->lock);
-      return b;
-    }
-  }
-
-  // Not cached; recycle an unused buffer.
-  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
-  // because log.c has modified it but not yet committed it.
-  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
-      b->dev = dev;
-      b->blockno = blockno;
-      b->flags = 0;
-      b->refcnt = 1;
-      release(&bcache.lock);
-      acquiresleep(&b->lock);
-      return b;
-    }
-  }
-  panic("bget: no buffers");
-}
-
-// Return a locked buf with the contents of the indicated block.
-struct buf*
-bread(uint dev, uint blockno)
-{
-  struct buf *b;
-
-  b = bget(dev, blockno);
-  if((b->flags & B_VALID) == 0) {
-    iderw(b);
-  }
-  return b;
-}
-
-// Write b's contents to disk.  Must be locked.
-void
-bwrite(struct buf *b)
-{
-  if(!holdingsleep(&b->lock))
-    panic("bwrite");
-  b->flags |= B_DIRTY;
-  iderw(b);
-}
-
-// Release a locked buffer.
-// Move to the head of the MRU list.
-void
-brelse(struct buf *b)
-{
-  if(!holdingsleep(&b->lock))
-    panic("brelse");
-
-  releasesleep(&b->lock);
-
-  acquire(&bcache.lock);
-  b->refcnt--;
-  if (b->refcnt == 0) {
-    // no one is waiting for it.
-    b->next->prev = b->prev;
-    b->prev->next = b->next;
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
-  }
-  
-  release(&bcache.lock);
-}
-//PAGEBREAK!
-// Blank page.
-
diff -ruN xv6-public/bootasm.S xv6-public_new/bootasm.S
--- xv6-public/bootasm.S	2021-09-30 23:28:57.644392200 +0530
+++ xv6-public_new/bootasm.S	1970-01-01 05:30:00.000000000 +0530
@@ -1,88 +0,0 @@
-#include "asm.h"
-#include "memlayout.h"
-#include "mmu.h"
-
-# Start the first CPU: switch to 32-bit protected mode, jump into C.
-# The BIOS loads this code from the first sector of the hard disk into
-# memory at physical address 0x7c00 and starts executing in real mode
-# with %cs=0 %ip=7c00.
-
-.code16                       # Assemble for 16-bit mode
-.globl start
-start:
-  cli                         # BIOS enabled interrupts; disable
-
-  # Zero data segment registers DS, ES, and SS.
-  xorw    %ax,%ax             # Set %ax to zero
-  movw    %ax,%ds             # -> Data Segment
-  movw    %ax,%es             # -> Extra Segment
-  movw    %ax,%ss             # -> Stack Segment
-
-  # Physical address line A20 is tied to zero so that the first PCs 
-  # with 2 MB would run software that assumed 1 MB.  Undo that.
-seta20.1:
-  inb     $0x64,%al               # Wait for not busy
-  testb   $0x2,%al
-  jnz     seta20.1
-
-  movb    $0xd1,%al               # 0xd1 -> port 0x64
-  outb    %al,$0x64
-
-seta20.2:
-  inb     $0x64,%al               # Wait for not busy
-  testb   $0x2,%al
-  jnz     seta20.2
-
-  movb    $0xdf,%al               # 0xdf -> port 0x60
-  outb    %al,$0x60
-
-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
-  # virtual addresses map directly to physical addresses so that the
-  # effective memory map doesn't change during the transition.
-  lgdt    gdtdesc
-  movl    %cr0, %eax
-  orl     $CR0_PE, %eax
-  movl    %eax, %cr0
-
-//PAGEBREAK!
-  # Complete the transition to 32-bit protected mode by using a long jmp
-  # to reload %cs and %eip.  The segment descriptors are set up with no
-  # translation, so that the mapping is still the identity mapping.
-  ljmp    $(SEG_KCODE<<3), $start32
-
-.code32  # Tell assembler to generate 32-bit code now.
-start32:
-  # Set up the protected-mode data segment registers
-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
-  movw    %ax, %ds                # -> DS: Data Segment
-  movw    %ax, %es                # -> ES: Extra Segment
-  movw    %ax, %ss                # -> SS: Stack Segment
-  movw    $0, %ax                 # Zero segments not ready for use
-  movw    %ax, %fs                # -> FS
-  movw    %ax, %gs                # -> GS
-
-  # Set up the stack pointer and call into C.
-  movl    $start, %esp
-  call    bootmain
-
-  # If bootmain returns (it shouldn't), trigger a Bochs
-  # breakpoint if running under Bochs, then loop.
-  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
-  movw    %ax, %dx
-  outw    %ax, %dx
-  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
-  outw    %ax, %dx
-spin:
-  jmp     spin
-
-# Bootstrap GDT
-.p2align 2                                # force 4 byte alignment
-gdt:
-  SEG_NULLASM                             # null seg
-  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
-  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg
-
-gdtdesc:
-  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
-  .long   gdt                             # address gdt
-
diff -ruN xv6-public/bootmain.c xv6-public_new/bootmain.c
--- xv6-public/bootmain.c	2021-09-30 23:28:57.647395400 +0530
+++ xv6-public_new/bootmain.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,96 +0,0 @@
-// Boot loader.
-//
-// Part of the boot block, along with bootasm.S, which calls bootmain().
-// bootasm.S has put the processor into protected 32-bit mode.
-// bootmain() loads an ELF kernel image from the disk starting at
-// sector 1 and then jumps to the kernel entry routine.
-
-#include "types.h"
-#include "elf.h"
-#include "x86.h"
-#include "memlayout.h"
-
-#define SECTSIZE  512
-
-void readseg(uchar*, uint, uint);
-
-void
-bootmain(void)
-{
-  struct elfhdr *elf;
-  struct proghdr *ph, *eph;
-  void (*entry)(void);
-  uchar* pa;
-
-  elf = (struct elfhdr*)0x10000;  // scratch space
-
-  // Read 1st page off disk
-  readseg((uchar*)elf, 4096, 0);
-
-  // Is this an ELF executable?
-  if(elf->magic != ELF_MAGIC)
-    return;  // let bootasm.S handle error
-
-  // Load each program segment (ignores ph flags).
-  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
-  eph = ph + elf->phnum;
-  for(; ph < eph; ph++){
-    pa = (uchar*)ph->paddr;
-    readseg(pa, ph->filesz, ph->off);
-    if(ph->memsz > ph->filesz)
-      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
-  }
-
-  // Call the entry point from the ELF header.
-  // Does not return!
-  entry = (void(*)(void))(elf->entry);
-  entry();
-}
-
-void
-waitdisk(void)
-{
-  // Wait for disk ready.
-  while((inb(0x1F7) & 0xC0) != 0x40)
-    ;
-}
-
-// Read a single sector at offset into dst.
-void
-readsect(void *dst, uint offset)
-{
-  // Issue command.
-  waitdisk();
-  outb(0x1F2, 1);   // count = 1
-  outb(0x1F3, offset);
-  outb(0x1F4, offset >> 8);
-  outb(0x1F5, offset >> 16);
-  outb(0x1F6, (offset >> 24) | 0xE0);
-  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
-
-  // Read data.
-  waitdisk();
-  insl(0x1F0, dst, SECTSIZE/4);
-}
-
-// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
-// Might copy more than asked.
-void
-readseg(uchar* pa, uint count, uint offset)
-{
-  uchar* epa;
-
-  epa = pa + count;
-
-  // Round down to sector boundary.
-  pa -= offset % SECTSIZE;
-
-  // Translate from bytes to sectors; kernel starts at sector 1.
-  offset = (offset / SECTSIZE) + 1;
-
-  // If this is too slow, we could read lots of sectors at a time.
-  // We'd write more to memory than asked, but it doesn't matter --
-  // we load in increasing order.
-  for(; pa < epa; pa += SECTSIZE, offset++)
-    readsect(pa, offset);
-}
diff -ruN xv6-public/buf.h xv6-public_new/buf.h
--- xv6-public/buf.h	2021-09-30 23:28:57.648394800 +0530
+++ xv6-public_new/buf.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
-struct buf {
-  int flags;
-  uint dev;
-  uint blockno;
-  struct sleeplock lock;
-  uint refcnt;
-  struct buf *prev; // LRU cache list
-  struct buf *next;
-  struct buf *qnext; // disk queue
-  uchar data[BSIZE];
-};
-#define B_VALID 0x2  // buffer has been read from disk
-#define B_DIRTY 0x4  // buffer needs to be written to disk
-
diff -ruN xv6-public/cat.c xv6-public_new/cat.c
--- xv6-public/cat.c	2021-09-30 23:28:57.650396300 +0530
+++ xv6-public_new/cat.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,43 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-char buf[512];
-
-void
-cat(int fd)
-{
-  int n;
-
-  while((n = read(fd, buf, sizeof(buf))) > 0) {
-    if (write(1, buf, n) != n) {
-      printf(1, "cat: write error\n");
-      exit();
-    }
-  }
-  if(n < 0){
-    printf(1, "cat: read error\n");
-    exit();
-  }
-}
-
-int
-main(int argc, char *argv[])
-{
-  int fd, i;
-
-  if(argc <= 1){
-    cat(0);
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
-    }
-    cat(fd);
-    close(fd);
-  }
-  exit();
-}
diff -ruN xv6-public/console.c xv6-public_new/console.c
--- xv6-public/console.c	2021-09-30 23:28:57.652391800 +0530
+++ xv6-public_new/console.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,299 +0,0 @@
-// Console input and output.
-// Input is from the keyboard or serial port.
-// Output is written to the screen and serial port.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "traps.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "file.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-
-static void consputc(int);
-
-static int panicked = 0;
-
-static struct {
-  struct spinlock lock;
-  int locking;
-} cons;
-
-static void
-printint(int xx, int base, int sign)
-{
-  static char digits[] = "0123456789abcdef";
-  char buf[16];
-  int i;
-  uint x;
-
-  if(sign && (sign = xx < 0))
-    x = -xx;
-  else
-    x = xx;
-
-  i = 0;
-  do{
-    buf[i++] = digits[x % base];
-  }while((x /= base) != 0);
-
-  if(sign)
-    buf[i++] = '-';
-
-  while(--i >= 0)
-    consputc(buf[i]);
-}
-//PAGEBREAK: 50
-
-// Print to the console. only understands %d, %x, %p, %s.
-void
-cprintf(char *fmt, ...)
-{
-  int i, c, locking;
-  uint *argp;
-  char *s;
-
-  locking = cons.locking;
-  if(locking)
-    acquire(&cons.lock);
-
-  if (fmt == 0)
-    panic("null fmt");
-
-  argp = (uint*)(void*)(&fmt + 1);
-  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
-    if(c != '%'){
-      consputc(c);
-      continue;
-    }
-    c = fmt[++i] & 0xff;
-    if(c == 0)
-      break;
-    switch(c){
-    case 'd':
-      printint(*argp++, 10, 1);
-      break;
-    case 'x':
-    case 'p':
-      printint(*argp++, 16, 0);
-      break;
-    case 's':
-      if((s = (char*)*argp++) == 0)
-        s = "(null)";
-      for(; *s; s++)
-        consputc(*s);
-      break;
-    case '%':
-      consputc('%');
-      break;
-    default:
-      // Print unknown % sequence to draw attention.
-      consputc('%');
-      consputc(c);
-      break;
-    }
-  }
-
-  if(locking)
-    release(&cons.lock);
-}
-
-void
-panic(char *s)
-{
-  int i;
-  uint pcs[10];
-
-  cli();
-  cons.locking = 0;
-  // use lapiccpunum so that we can call panic from mycpu()
-  cprintf("lapicid %d: panic: ", lapicid());
-  cprintf(s);
-  cprintf("\n");
-  getcallerpcs(&s, pcs);
-  for(i=0; i<10; i++)
-    cprintf(" %p", pcs[i]);
-  panicked = 1; // freeze other CPU
-  for(;;)
-    ;
-}
-
-//PAGEBREAK: 50
-#define BACKSPACE 0x100
-#define CRTPORT 0x3d4
-static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
-
-static void
-cgaputc(int c)
-{
-  int pos;
-
-  // Cursor position: col + 80*row.
-  outb(CRTPORT, 14);
-  pos = inb(CRTPORT+1) << 8;
-  outb(CRTPORT, 15);
-  pos |= inb(CRTPORT+1);
-
-  if(c == '\n')
-    pos += 80 - pos%80;
-  else if(c == BACKSPACE){
-    if(pos > 0) --pos;
-  } else
-    crt[pos++] = (c&0xff) | 0x0700;  // black on white
-
-  if(pos < 0 || pos > 25*80)
-    panic("pos under/overflow");
-
-  if((pos/80) >= 24){  // Scroll up.
-    memmove(crt, crt+80, sizeof(crt[0])*23*80);
-    pos -= 80;
-    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
-  }
-
-  outb(CRTPORT, 14);
-  outb(CRTPORT+1, pos>>8);
-  outb(CRTPORT, 15);
-  outb(CRTPORT+1, pos);
-  crt[pos] = ' ' | 0x0700;
-}
-
-void
-consputc(int c)
-{
-  if(panicked){
-    cli();
-    for(;;)
-      ;
-  }
-
-  if(c == BACKSPACE){
-    uartputc('\b'); uartputc(' '); uartputc('\b');
-  } else
-    uartputc(c);
-  cgaputc(c);
-}
-
-#define INPUT_BUF 128
-struct {
-  char buf[INPUT_BUF];
-  uint r;  // Read index
-  uint w;  // Write index
-  uint e;  // Edit index
-} input;
-
-#define C(x)  ((x)-'@')  // Control-x
-
-void
-consoleintr(int (*getc)(void))
-{
-  int c, doprocdump = 0;
-
-  acquire(&cons.lock);
-  while((c = getc()) >= 0){
-    switch(c){
-    case C('P'):  // Process listing.
-      // procdump() locks cons.lock indirectly; invoke later
-      doprocdump = 1;
-      break;
-    case C('U'):  // Kill line.
-      while(input.e != input.w &&
-            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
-        input.e--;
-        consputc(BACKSPACE);
-      }
-      break;
-    case C('H'): case '\x7f':  // Backspace
-      if(input.e != input.w){
-        input.e--;
-        consputc(BACKSPACE);
-      }
-      break;
-    default:
-      if(c != 0 && input.e-input.r < INPUT_BUF){
-        c = (c == '\r') ? '\n' : c;
-        input.buf[input.e++ % INPUT_BUF] = c;
-        consputc(c);
-        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
-          input.w = input.e;
-          wakeup(&input.r);
-        }
-      }
-      break;
-    }
-  }
-  release(&cons.lock);
-  if(doprocdump) {
-    procdump();  // now call procdump() wo. cons.lock held
-  }
-}
-
-int
-consoleread(struct inode *ip, char *dst, int n)
-{
-  uint target;
-  int c;
-
-  iunlock(ip);
-  target = n;
-  acquire(&cons.lock);
-  while(n > 0){
-    while(input.r == input.w){
-      if(myproc()->killed){
-        release(&cons.lock);
-        ilock(ip);
-        return -1;
-      }
-      sleep(&input.r, &cons.lock);
-    }
-    c = input.buf[input.r++ % INPUT_BUF];
-    if(c == C('D')){  // EOF
-      if(n < target){
-        // Save ^D for next time, to make sure
-        // caller gets a 0-byte result.
-        input.r--;
-      }
-      break;
-    }
-    *dst++ = c;
-    --n;
-    if(c == '\n')
-      break;
-  }
-  release(&cons.lock);
-  ilock(ip);
-
-  return target - n;
-}
-
-int
-consolewrite(struct inode *ip, char *buf, int n)
-{
-  int i;
-
-  iunlock(ip);
-  acquire(&cons.lock);
-  for(i = 0; i < n; i++)
-    consputc(buf[i] & 0xff);
-  release(&cons.lock);
-  ilock(ip);
-
-  return n;
-}
-
-void
-consoleinit(void)
-{
-  initlock(&cons.lock, "console");
-
-  devsw[CONSOLE].write = consolewrite;
-  devsw[CONSOLE].read = consoleread;
-  cons.locking = 1;
-
-  ioapicenable(IRQ_KBD, 0);
-}
-
diff -ruN xv6-public/cuth xv6-public_new/cuth
--- xv6-public/cuth	2021-09-30 23:28:57.654391600 +0530
+++ xv6-public_new/cuth	1970-01-01 05:30:00.000000000 +0530
@@ -1,48 +0,0 @@
-#!/usr/bin/perl
-
-$| = 1;
-
-sub writefile($@){
-	my ($file, @lines) = @_;
-	
-	sleep(1);
-	open(F, ">$file") || die "open >$file: $!";
-	print F @lines;
-	close(F);
-}
-
-# Cut out #include lines that don't contribute anything.
-for($i=0; $i<@ARGV; $i++){
-	$file = $ARGV[$i];
-	if(!open(F, $file)){
-		print STDERR "open $file: $!\n";
-		next;
-	}
-	@lines = <F>;
-	close(F);
-	
-	$obj = "$file.o";
-	$obj =~ s/\.c\.o$/.o/;
-	system("touch $file");
-
-	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
-		print STDERR "make $obj failed: $rv\n";
-		next;
-	}
-
-	system("cp $file =$file");
-	for($j=@lines-1; $j>=0; $j--){
-		if($lines[$j] =~ /^#include/){
-			$old = $lines[$j];
-			$lines[$j] = "/* CUT-H */\n";
-			writefile($file, @lines);
-			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
-				$lines[$j] = $old;
-			}else{
-				print STDERR "$file $old";
-			}
-		}
-	}
-	writefile($file, grep {!/CUT-H/} @lines);
-	system("rm =$file");
-}
diff -ruN xv6-public/date.h xv6-public_new/date.h
--- xv6-public/date.h	2021-09-30 23:28:57.656392300 +0530
+++ xv6-public_new/date.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,8 +0,0 @@
-struct rtcdate {
-  uint second;
-  uint minute;
-  uint hour;
-  uint day;
-  uint month;
-  uint year;
-};
diff -ruN xv6-public/defs.h xv6-public_new/defs.h
--- xv6-public/defs.h	2021-09-30 23:28:57.658395800 +0530
+++ xv6-public_new/defs.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,190 +0,0 @@
-struct buf;
-struct context;
-struct file;
-struct inode;
-struct pipe;
-struct proc;
-struct rtcdate;
-struct spinlock;
-struct sleeplock;
-struct stat;
-struct superblock;
-
-// bio.c
-void            binit(void);
-struct buf*     bread(uint, uint);
-void            brelse(struct buf*);
-void            bwrite(struct buf*);
-
-// console.c
-void            consoleinit(void);
-void            cprintf(char*, ...);
-void            consoleintr(int(*)(void));
-void            panic(char*) __attribute__((noreturn));
-
-// exec.c
-int             exec(char*, char**);
-
-// file.c
-struct file*    filealloc(void);
-void            fileclose(struct file*);
-struct file*    filedup(struct file*);
-void            fileinit(void);
-int             fileread(struct file*, char*, int n);
-int             filestat(struct file*, struct stat*);
-int             filewrite(struct file*, char*, int n);
-
-// fs.c
-void            readsb(int dev, struct superblock *sb);
-int             dirlink(struct inode*, char*, uint);
-struct inode*   dirlookup(struct inode*, char*, uint*);
-struct inode*   ialloc(uint, short);
-struct inode*   idup(struct inode*);
-void            iinit(int dev);
-void            ilock(struct inode*);
-void            iput(struct inode*);
-void            iunlock(struct inode*);
-void            iunlockput(struct inode*);
-void            iupdate(struct inode*);
-int             namecmp(const char*, const char*);
-struct inode*   namei(char*);
-struct inode*   nameiparent(char*, char*);
-int             readi(struct inode*, char*, uint, uint);
-void            stati(struct inode*, struct stat*);
-int             writei(struct inode*, char*, uint, uint);
-
-// ide.c
-void            ideinit(void);
-void            ideintr(void);
-void            iderw(struct buf*);
-
-// ioapic.c
-void            ioapicenable(int irq, int cpu);
-extern uchar    ioapicid;
-void            ioapicinit(void);
-
-// kalloc.c
-char*           kalloc(void);
-void            kfree(char*);
-void            kinit1(void*, void*);
-void            kinit2(void*, void*);
-
-// kbd.c
-void            kbdintr(void);
-
-// lapic.c
-void            cmostime(struct rtcdate *r);
-int             lapicid(void);
-extern volatile uint*    lapic;
-void            lapiceoi(void);
-void            lapicinit(void);
-void            lapicstartap(uchar, uint);
-void            microdelay(int);
-
-// log.c
-void            initlog(int dev);
-void            log_write(struct buf*);
-void            begin_op();
-void            end_op();
-
-// mp.c
-extern int      ismp;
-void            mpinit(void);
-
-// picirq.c
-void            picenable(int);
-void            picinit(void);
-
-// pipe.c
-int             pipealloc(struct file**, struct file**);
-void            pipeclose(struct pipe*, int);
-int             piperead(struct pipe*, char*, int);
-int             pipewrite(struct pipe*, char*, int);
-
-//PAGEBREAK: 16
-// proc.c
-int             cpuid(void);
-void            exit(void);
-int             fork(void);
-int             growproc(int);
-int             kill(int);
-struct cpu*     mycpu(void);
-struct proc*    myproc();
-void            pinit(void);
-void            procdump(void);
-void            scheduler(void) __attribute__((noreturn));
-void            sched(void);
-void            setproc(struct proc*);
-void            sleep(void*, struct spinlock*);
-void            userinit(void);
-int             wait(void);
-void            wakeup(void*);
-void            yield(void);
-
-// swtch.S
-void            swtch(struct context**, struct context*);
-
-// spinlock.c
-void            acquire(struct spinlock*);
-void            getcallerpcs(void*, uint*);
-int             holding(struct spinlock*);
-void            initlock(struct spinlock*, char*);
-void            release(struct spinlock*);
-void            pushcli(void);
-void            popcli(void);
-
-// sleeplock.c
-void            acquiresleep(struct sleeplock*);
-void            releasesleep(struct sleeplock*);
-int             holdingsleep(struct sleeplock*);
-void            initsleeplock(struct sleeplock*, char*);
-
-// string.c
-int             memcmp(const void*, const void*, uint);
-void*           memmove(void*, const void*, uint);
-void*           memset(void*, int, uint);
-char*           safestrcpy(char*, const char*, int);
-int             strlen(const char*);
-int             strncmp(const char*, const char*, uint);
-char*           strncpy(char*, const char*, int);
-
-// syscall.c
-int             argint(int, int*);
-int             argptr(int, char**, int);
-int             argstr(int, char**);
-int             fetchint(uint, int*);
-int             fetchstr(uint, char**);
-void            syscall(void);
-
-// timer.c
-void            timerinit(void);
-
-// trap.c
-void            idtinit(void);
-extern uint     ticks;
-void            tvinit(void);
-extern struct spinlock tickslock;
-
-// uart.c
-void            uartinit(void);
-void            uartintr(void);
-void            uartputc(int);
-
-// vm.c
-void            seginit(void);
-void            kvmalloc(void);
-pde_t*          setupkvm(void);
-char*           uva2ka(pde_t*, char*);
-int             allocuvm(pde_t*, uint, uint);
-int             deallocuvm(pde_t*, uint, uint);
-void            freevm(pde_t*);
-void            inituvm(pde_t*, char*, uint);
-int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
-pde_t*          copyuvm(pde_t*, uint);
-void            switchuvm(struct proc*);
-void            switchkvm(void);
-int             copyout(pde_t*, uint, void*, uint);
-void            clearpteu(pde_t *pgdir, char *uva);
-
-// number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff -ruN xv6-public/dot-bochsrc xv6-public_new/dot-bochsrc
--- xv6-public/dot-bochsrc	2021-09-30 23:28:57.661393100 +0530
+++ xv6-public_new/dot-bochsrc	1970-01-01 05:30:00.000000000 +0530
@@ -1,738 +0,0 @@
-# You may now use double quotes around pathnames, in case
-# your pathname includes spaces.
-
-#=======================================================================
-# CONFIG_INTERFACE
-#
-# The configuration interface is a series of menus or dialog boxes that
-# allows you to change all the settings that control Bochs's behavior.
-# There are two choices of configuration interface: a text mode version
-# called "textconfig" and a graphical version called "wx".  The text
-# mode version uses stdin/stdout and is always compiled in.  The graphical
-# version is only available when you use "--with-wx" on the configure 
-# command.  If you do not write a config_interface line, Bochs will 
-# choose a default for you.
-#
-# NOTE: if you use the "wx" configuration interface, you must also use
-# the "wx" display library.
-#=======================================================================
-#config_interface: textconfig
-#config_interface: wx
-
-#=======================================================================
-# DISPLAY_LIBRARY
-#
-# The display library is the code that displays the Bochs VGA screen.  Bochs 
-# has a selection of about 10 different display library implementations for 
-# different platforms.  If you run configure with multiple --with-* options, 
-# the display_library command lets you choose which one you want to run with.
-# If you do not write a display_library line, Bochs will choose a default for
-# you.
-#
-# The choices are: 
-#   x              use X windows interface, cross platform
-#   win32          use native win32 libraries
-#   carbon         use Carbon library (for MacOS X)
-#   beos           use native BeOS libraries
-#   macintosh      use MacOS pre-10
-#   amigaos        use native AmigaOS libraries
-#   sdl            use SDL library, cross platform
-#   svga           use SVGALIB library for Linux, allows graphics without X11
-#   term           text only, uses curses/ncurses library, cross platform
-#   rfb            provides an interface to AT&T's VNC viewer, cross platform
-#   wx             use wxWidgets library, cross platform
-#   nogui          no display at all
-#
-# NOTE: if you use the "wx" configuration interface, you must also use
-# the "wx" display library.
-#
-# Specific options:
-# Some display libraries now support specific option to control their
-# behaviour. See the examples below for currently supported options.
-#=======================================================================
-#display_library: amigaos
-#display_library: beos
-#display_library: carbon
-#display_library: macintosh
-#display_library: nogui
-#display_library: rfb, options="timeout=60" # time to wait for client
-#display_library: sdl, options="fullscreen" # startup in fullscreen mode
-#display_library: term
-#display_library: win32, options="legacyF12" # use F12 to toggle mouse
-#display_library: wx
-#display_library: x
-
-#=======================================================================
-# ROMIMAGE:
-# The ROM BIOS controls what the PC does when it first powers on.
-# Normally, you can use a precompiled BIOS in the source or binary
-# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
-# starting at address 0xf0000, and it is exactly 64k long.
-# You can also use the environment variable $BXSHARE to specify the
-# location of the BIOS.
-# The usage of external large BIOS images (up to 512k) at memory top is
-# now supported, but we still recommend to use the BIOS distributed with
-# Bochs. Now the start address can be calculated from image size.
-#=======================================================================
-romimage: file=$BXSHARE/BIOS-bochs-latest
-#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top
-#romimage: file=mybios.bin # calculate start address from image size
-
-#=======================================================================
-# CPU:
-# This defines cpu-related parameters inside Bochs:
-#
-#  COUNT:
-#  Set the number of processors when Bochs is compiled for SMP emulation.
-#  Bochs currently supports up to 8 processors. If Bochs is compiled
-#  without SMP support, it won't accept values different from 1.
-#
-#  IPS:
-#  Emulated Instructions Per Second.  This is the number of IPS that bochs
-#  is capable of running on your machine. You can recompile Bochs with
-#  --enable-show-ips option enabled, to find your workstation's capability.
-#  Measured IPS value will then be logged into your log file or status bar
-#  (if supported by the gui).
-#
-#  IPS is used to calibrate many time-dependent events within the bochs 
-#  simulation.  For example, changing IPS affects the frequency of VGA
-#  updates, the duration of time before a key starts to autorepeat, and
-#  the measurement of BogoMips and other benchmarks.
-#
-#  Examples:
-#  Machine                                         Mips
-# ________________________________________________________________
-#  2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
-#  1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
-#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
-#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
-#=======================================================================
-cpu: count=2, ips=10000000
-
-#=======================================================================
-# MEGS
-# Set the number of Megabytes of physical memory you want to emulate. 
-# The default is 32MB, most OS's won't need more than that.
-# The maximum amount of memory supported is 2048Mb.
-#=======================================================================
-#megs: 256
-#megs: 128
-#megs: 64
-megs: 32
-#megs: 16
-#megs: 8
-
-#=======================================================================
-# OPTROMIMAGE[1-4]:
-# You may now load up to 4 optional ROM images. Be sure to use a 
-# read-only area, typically between C8000 and EFFFF. These optional
-# ROM images should not overwrite the rombios (located at
-# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
-# Those ROM images will be initialized by the bios if they contain 
-# the right signature (0x55AA) and a valid checksum.
-# It can also be a convenient way to upload some arbitrary code/data
-# in the simulation, that can be retrieved by the boot loader
-#=======================================================================
-#optromimage1: file=optionalrom.bin, address=0xd0000
-#optromimage2: file=optionalrom.bin, address=0xd1000
-#optromimage3: file=optionalrom.bin, address=0xd2000
-#optromimage4: file=optionalrom.bin, address=0xd3000
-
-#optramimage1: file=/path/file1.img, address=0x0010000
-#optramimage2: file=/path/file2.img, address=0x0020000
-#optramimage3: file=/path/file3.img, address=0x0030000
-#optramimage4: file=/path/file4.img, address=0x0040000
-
-#=======================================================================
-# VGAROMIMAGE
-# You now need to load a VGA ROM BIOS into C0000.
-#=======================================================================
-#vgaromimage: file=bios/VGABIOS-elpin-2.40
-vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
-#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
-
-#=======================================================================
-# VGA:
-# Here you can specify the display extension to be used. With the value
-# 'none' you can use standard VGA with no extension. Other supported
-# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
-#=======================================================================
-#vga: extension=cirrus
-#vga: extension=vbe
-vga: extension=none
-
-#=======================================================================
-# FLOPPYA:
-# Point this to pathname of floppy image file or device
-# This should be of a bootable floppy(image/device) if you're
-# booting from 'a' (or 'floppy').
-#
-# You can set the initial status of the media to 'ejected' or 'inserted'.
-#   floppya: 2_88=path, status=ejected             (2.88M 3.5" floppy)
-#   floppya: 1_44=path, status=inserted            (1.44M 3.5" floppy)
-#   floppya: 1_2=path, status=ejected              (1.2M  5.25" floppy)
-#   floppya: 720k=path, status=inserted            (720K  3.5" floppy)
-#   floppya: 360k=path, status=inserted            (360K  5.25" floppy)
-#   floppya: 320k=path, status=inserted            (320K  5.25" floppy)
-#   floppya: 180k=path, status=inserted            (180K  5.25" floppy)
-#   floppya: 160k=path, status=inserted            (160K  5.25" floppy)
-#   floppya: image=path, status=inserted           (guess type from image size)
-#
-# The path should be the name of a disk image file.  On Unix, you can use a raw
-# device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters
-# such as a: or b: as the path.  The parameter 'image' works with image files
-# only. In that case the size must match one of the supported types.
-#=======================================================================
-floppya: 1_44=/dev/fd0, status=inserted
-#floppya: image=../1.44, status=inserted
-#floppya: 1_44=/dev/fd0H1440, status=inserted
-#floppya: 1_2=../1_2, status=inserted
-#floppya: 1_44=a:, status=inserted
-#floppya: 1_44=a.img, status=inserted
-#floppya: 1_44=/dev/rfd0a, status=inserted
-
-#=======================================================================
-# FLOPPYB:
-# See FLOPPYA above for syntax
-#=======================================================================
-#floppyb: 1_44=b:, status=inserted
-floppyb: 1_44=b.img, status=inserted
-
-#=======================================================================
-# ATA0, ATA1, ATA2, ATA3
-# ATA controller for hard disks and cdroms
-#
-# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
-# 
-# These options enables up to 4 ata channels. For each channel
-# the two base io addresses and the irq must be specified.
-# 
-# ata0 and ata1 are enabled by default with the values shown below
-#
-# Examples:
-#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
-#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
-#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
-#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
-#=======================================================================
-ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
-ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
-ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
-ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
-
-#=======================================================================
-# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
-#
-# This defines the type and characteristics of all attached ata devices:
-#   type=       type of attached device [disk|cdrom] 
-#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
-#   mode=       only valid for disks [undoable|growing|volatile]
-#   path=       path of the image
-#   cylinders=  only valid for disks
-#   heads=      only valid for disks
-#   spt=        only valid for disks
-#   status=     only valid for cdroms [inserted|ejected]
-#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
-#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
-#   model=      string returned by identify device command
-#   journal=    optional filename of the redolog for undoable and volatile disks
-#   
-# Point this at a hard disk image file, cdrom iso file, or physical cdrom
-# device.  To create a hard disk image, try running bximage.  It will help you
-# choose the size and then suggest a line that works with it.
-#
-# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
-# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
-#
-# In windows, the drive letter + colon notation should be used for cdroms.
-# Depending on versions of windows and drivers, you may only be able to 
-# access the "first" cdrom in the system.  On MacOSX, use path="drive"
-# to access the physical drive.
-#
-# The path is always mandatory. For flat hard disk images created with
-# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
-# calculated using heads=16 and spt=63). For other hard disk images and modes
-# the cylinders, heads, and spt are mandatory.
-#
-# Default values are:
-#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
-#
-# The biosdetect option has currently no effect on the bios
-#
-# Examples:
-#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
-#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
-#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
-#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
-#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
-#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
-#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
-#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
-#=======================================================================
-ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
-ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
-#ata0-slave: type=cdrom, path=D:, status=inserted
-#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
-#ata0-slave: type=cdrom, path="drive", status=inserted
-#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
-
-#=======================================================================
-# BOOT:
-# This defines the boot sequence. Now you can specify up to 3 boot drives.
-# You can either boot from 'floppy', 'disk' or 'cdrom'
-# legacy 'a' and 'c' are also supported
-# Examples:
-#   boot: floppy
-#   boot: disk
-#   boot: cdrom
-#   boot: c
-#   boot: a
-#   boot: cdrom, floppy, disk
-#=======================================================================
-#boot: floppy
-boot: disk
-
-#=======================================================================
-# CLOCK:
-# This defines the parameters of the clock inside Bochs:
-#
-#  SYNC:
-#  TO BE COMPLETED (see Greg explanation in feature request #536329)
-#
-#  TIME0:
-#  Specifies the start (boot) time of the virtual machine. Use a time 
-#  value as returned by the time(2) system call. If no time0 value is 
-#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
-#  the simulation will be started at the current local host time.
-#  If time0 equal to 2 (special case) or if time0 equal 'utc',
-#  the simulation will be started at the current utc time.
-#
-# Syntax:
-#  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]
-#
-# Example:
-#   clock: sync=none,     time0=local       # Now (localtime)
-#   clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980
-#   clock: sync=none,     time0=631148400   # Mon Jan  1 00:00:00 1990
-#   clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999
-#   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
-#   clock: sync=none,     time0=1           # Now (localtime)
-#   clock: sync=none,     time0=utc         # Now (utc/gmt)
-# 
-# Default value are sync=none, time0=local
-#=======================================================================
-#clock: sync=none, time0=local
-
-
-#=======================================================================
-# FLOPPY_BOOTSIG_CHECK: disabled=[0|1]
-# Enables or disables the 0xaa55 signature check on boot floppies
-# Defaults to disabled=0
-# Examples:
-#   floppy_bootsig_check: disabled=0
-#   floppy_bootsig_check: disabled=1
-#=======================================================================
-#floppy_bootsig_check: disabled=1
-floppy_bootsig_check: disabled=0
-
-#=======================================================================
-# LOG:
-# Give the path of the log file you'd like Bochs debug and misc. verbiage
-# to be written to. If you don't use this option or set the filename to
-# '-' the output is written to the console. If you really don't want it,
-# make it "/dev/null" (Unix) or "nul" (win32). :^(
-#
-# Examples:
-#   log: ./bochs.out
-#   log: /dev/tty
-#=======================================================================
-#log: /dev/null
-log: bochsout.txt
-
-#=======================================================================
-# LOGPREFIX:
-# This handles the format of the string prepended to each log line.
-# You may use those special tokens :
-#   %t : 11 decimal digits timer tick
-#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
-#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
-#   %d : 5 characters string of the device, between brackets
-# 
-# Default : %t%e%d
-# Examples:
-#   logprefix: %t-%e-@%i-%d
-#   logprefix: %i%e%d
-#=======================================================================
-#logprefix: %t%e%d
-
-#=======================================================================
-# LOG CONTROLS
-#
-# Bochs now has four severity levels for event logging.
-#   panic: cannot proceed.  If you choose to continue after a panic, 
-#          don't be surprised if you get strange behavior or crashes.
-#   error: something went wrong, but it is probably safe to continue the
-#          simulation.
-#   info: interesting or useful messages.
-#   debug: messages useful only when debugging the code.  This may
-#          spit out thousands per second.
-#
-# For events of each level, you can choose to crash, report, or ignore.
-# TODO: allow choice based on the facility: e.g. crash on panics from
-#       everything except the cdrom, and only report those.
-#
-# If you are experiencing many panics, it can be helpful to change
-# the panic action to report instead of fatal.  However, be aware
-# that anything executed after a panic is uncharted territory and can 
-# cause bochs to become unstable.  The panic is a "graceful exit," so
-# if you disable it you may get a spectacular disaster instead.
-#=======================================================================
-panic: action=ask
-error: action=report
-info: action=report
-debug: action=ignore
-#pass: action=fatal
-
-#=======================================================================
-# DEBUGGER_LOG:
-# Give the path of the log file you'd like Bochs to log debugger output.
-# If you really don't want it, make it /dev/null or '-'. :^(
-#
-# Examples:
-#   debugger_log: ./debugger.out
-#=======================================================================
-#debugger_log: /dev/null
-#debugger_log: debugger.out
-debugger_log: -
-
-#=======================================================================
-# COM1, COM2, COM3, COM4:
-# This defines a serial port (UART type 16550A). In the 'term' you can specify
-# a device to use as com1. This can be a real serial line, or a pty.  To use
-# a pty (under X/Unix), create two windows (xterms, usually).  One of them will
-# run bochs, and the other will act as com1. Find out the tty the com1
-# window using the `tty' command, and use that as the `dev' parameter.
-# Then do `sleep 1000000' in the com1 window to keep the shell from
-# messing with things, and run bochs in the other window.  Serial I/O to
-# com1 (port 0x3f8) will all go to the other window.
-# Other serial modes are 'null' (no input/output), 'file' (output to a file
-# specified as the 'dev' parameter), 'raw' (use the real serial port - under
-# construction for win32), 'mouse' (standard serial mouse - requires
-# mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'
-# (connect a networking socket).
-#
-# Examples:
-#   com1: enabled=1, mode=null
-#   com1: enabled=1, mode=mouse
-#   com2: enabled=1, mode=file, dev=serial.out
-#   com3: enabled=1, mode=raw, dev=com1
-#   com3: enabled=1, mode=socket, dev=localhost:8888
-#=======================================================================
-#com1: enabled=1, mode=term, dev=/dev/ttyp9
-
-
-#=======================================================================
-# PARPORT1, PARPORT2:
-# This defines a parallel (printer) port. When turned on and an output file is
-# defined the emulated printer port sends characters printed by the guest OS
-# into the output file. On some platforms a device filename can be used to
-# send the data to the real parallel port (e.g. "/dev/lp0" on Linux, "lpt1" on
-# win32 platforms).
-#
-# Examples:
-#   parport1: enabled=1, file="parport.out"
-#   parport2: enabled=1, file="/dev/lp0"
-#   parport1: enabled=0
-#=======================================================================
-parport1: enabled=1, file="/dev/stdout"
-
-#=======================================================================
-# SB16:
-# This defines the SB16 sound emulation. It can have several of the
-# following properties.
-# All properties are in the format sb16: property=value
-# midi: The filename is where the midi data is sent. This can be a
-#       device or just a file if you want to record the midi data.
-# midimode:
-#      0=no data
-#      1=output to device (system dependent. midi denotes the device driver)
-#      2=SMF file output, including headers
-#      3=output the midi data stream to the file (no midi headers and no
-#        delta times, just command and data bytes)
-# wave: This is the device/file where wave output is stored
-# wavemode:
-#      0=no data
-#      1=output to device (system dependent. wave denotes the device driver)
-#      2=VOC file output, incl. headers
-#      3=output the raw wave stream to the file
-# log:  The file to write the sb16 emulator messages to.
-# loglevel:
-#      0=no log
-#      1=resource changes, midi program and bank changes
-#      2=severe errors
-#      3=all errors
-#      4=all errors plus all port accesses
-#      5=all errors and port accesses plus a lot of extra info
-# dmatimer:
-#      microseconds per second for a DMA cycle.  Make it smaller to fix
-#      non-continuous sound.  750000 is usually a good value.  This needs a
-#      reasonably correct setting for the IPS parameter of the CPU option.
-#
-# For an example look at the next line:
-#=======================================================================
-
-#sb16: midimode=1, midi=/dev/midi00, wavemode=1, wave=/dev/dsp, loglevel=2, log=sb16.log, dmatimer=600000
-
-#=======================================================================
-# VGA_UPDATE_INTERVAL:
-# Video memory is scanned for updates and screen updated every so many
-# virtual seconds.  The default is 40000, about 25Hz. Keep in mind that
-# you must tweak the 'cpu: ips=N' directive to be as close to the number
-# of emulated instructions-per-second your workstation can do, for this
-# to be accurate.
-#
-# Examples:
-#   vga_update_interval: 250000
-#=======================================================================
-vga_update_interval: 300000
-
-# using for Winstone '98 tests
-#vga_update_interval:  100000
-
-#=======================================================================
-# KEYBOARD_SERIAL_DELAY:
-# Approximate time in microseconds that it takes one character to
-# be transfered from the keyboard to controller over the serial path.
-# Examples:
-#   keyboard_serial_delay: 200
-#=======================================================================
-keyboard_serial_delay: 250
-
-#=======================================================================
-# KEYBOARD_PASTE_DELAY:
-# Approximate time in microseconds between attempts to paste
-# characters to the keyboard controller. This leaves time for the
-# guest os to deal with the flow of characters.  The ideal setting
-# depends on how your operating system processes characters.  The
-# default of 100000 usec (.1 seconds) was chosen because it works 
-# consistently in Windows.
-#
-# If your OS is losing characters during a paste, increase the paste
-# delay until it stops losing characters.
-#
-# Examples:
-#   keyboard_paste_delay: 100000
-#=======================================================================
-keyboard_paste_delay: 100000
-
-#=======================================================================
-# MOUSE: 
-# This option prevents Bochs from creating mouse "events" unless a mouse
-# is  enabled. The hardware emulation itself is not disabled by this.
-# You can turn the mouse on by setting enabled to 1, or turn it off by
-# setting enabled to 0. Unless you have a particular reason for enabling
-# the mouse by default, it is recommended that you leave it off.
-# You can also toggle the mouse usage at runtime (control key + middle
-# mouse button on X11, SDL, wxWidgets and Win32).
-# With the mouse type option you can select the type of mouse to emulate.
-# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
-# on PS/2), 'serial', 'serial_wheel' (one com port requires setting
-# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
-# connected with the 'mouse' device - requires PCI and USB support).
-#
-# Examples:
-#   mouse: enabled=1
-#   mouse: enabled=1, type=imps2
-#   mouse: enabled=1, type=serial
-#   mouse: enabled=0
-#=======================================================================
-mouse: enabled=0
-
-#=======================================================================
-# private_colormap: Request that the GUI create and use it's own
-#                   non-shared colormap.  This colormap will be used
-#                   when in the bochs window.  If not enabled, a
-#                   shared colormap scheme may be used.  Not implemented
-#                   on all GUI's.
-#
-# Examples:
-#   private_colormap: enabled=1
-#   private_colormap: enabled=0
-#=======================================================================
-private_colormap: enabled=0
-
-#=======================================================================
-# fullscreen: ONLY IMPLEMENTED ON AMIGA
-#             Request that Bochs occupy the entire screen instead of a 
-#             window.
-#
-# Examples:
-#   fullscreen: enabled=0
-#   fullscreen: enabled=1
-#=======================================================================
-#fullscreen: enabled=0
-#screenmode: name="sample"
-
-#=======================================================================
-# ne2k: NE2000 compatible ethernet adapter
-#
-# Examples:
-# ne2k: ioaddr=IOADDR, irq=IRQ, mac=MACADDR, ethmod=MODULE, ethdev=DEVICE, script=SCRIPT
-#
-# ioaddr, irq: You probably won't need to change ioaddr and irq, unless there
-# are IRQ conflicts.
-#
-# mac: The MAC address MUST NOT match the address of any machine on the net.
-# Also, the first byte must be an even number (bit 0 set means a multicast
-# address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast
-# address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may
-# be other restrictions too.  To be safe, just use the b0:c4... address.
-#
-# ethdev: The ethdev value is the name of the network interface on your host
-# platform.  On UNIX machines, you can get the name by running ifconfig.  On
-# Windows machines, you must run niclist to get the name of the ethdev.
-# Niclist source code is in misc/niclist.c and it is included in Windows 
-# binary releases.
-#
-# script: The script value is optional, and is the name of a script that 
-# is executed after bochs initialize the network interface. You can use 
-# this script to configure this network interface, or enable masquerading.
-# This is mainly useful for the tun/tap devices that only exist during
-# Bochs execution. The network interface name is supplied to the script
-# as first parameter
-#
-# If you don't want to make connections to any physical networks,
-# you can use the following 'ethmod's to simulate a virtual network.
-#   null: All packets are discarded, but logged to a few files.
-#   arpback: ARP is simulated. Disabled by default.
-#   vde:  Virtual Distributed Ethernet
-#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
-#         The virtual host uses 192.168.10.1.
-#         DHCP assigns 192.168.10.2 to the guest.
-#         TFTP uses the ethdev value for the root directory and doesn't
-#         overwrite files.
-#
-#=======================================================================
-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=fbsd, ethdev=en0 #macosx
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=fbsd, ethdev=xl0
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=linux, ethdev=eth0
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=win32, ethdev=MYCARD
-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tap, ethdev=tap0
-# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tuntap, ethdev=/dev/net/tun0, script=./tunconfig
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=null, ethdev=eth0
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vde, ethdev="/tmp/vde.ctl"
-# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vnet, ethdev="c:/temp"
-
-#=======================================================================
-# KEYBOARD_MAPPING:
-# This enables a remap of a physical localized keyboard to a 
-# virtualized us keyboard, as the PC architecture expects.
-# If enabled, the keymap file must be specified.
-# 
-# Examples:
-#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
-#=======================================================================
-keyboard_mapping: enabled=0, map=
-
-#=======================================================================
-# KEYBOARD_TYPE:
-# Type of keyboard return by a "identify keyboard" command to the
-# keyboard controler. It must be one of "xt", "at" or "mf".
-# Defaults to "mf". It should be ok for almost everybody. A known
-# exception is french macs, that do have a "at"-like keyboard.
-#
-# Examples:
-#   keyboard_type: mf
-#=======================================================================
-#keyboard_type: mf
-
-#=======================================================================
-# USER_SHORTCUT:
-# This defines the keyboard shortcut to be sent when you press the "user"
-# button in the headerbar. The shortcut string is a combination of maximum
-# 3 key names (listed below) separated with a '-' character. The old-style
-# syntax (without the '-') still works for the key combinations supported
-# in Bochs 2.2.1.
-# Valid key names:
-# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
-# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
-# "plus", "right", "shift", "space", "tab", "up", and "win".
-#
-# Example:
-#   user_shortcut: keys=ctrl-alt-del
-#=======================================================================
-#user_shortcut: keys=ctrl-alt-del
-
-#=======================================================================
-# I440FXSUPPORT:
-# This option controls the presence of the i440FX PCI chipset. You can
-# also specify the devices connected to PCI slots. Up to 5 slots are
-# available now. These devices are currently supported: ne2k, pcivga,
-# pcidev and pcipnic. If Bochs is compiled with Cirrus SVGA support
-# you'll have the additional choice 'cirrus'.
-#
-# Example:
-#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
-#=======================================================================
-#i440fxsupport: enabled=1
-
-#=======================================================================
-# USB1:
-# This option controls the presence of the USB root hub which is a part
-# of the i440FX PCI chipset. With the portX option you can connect devices
-# to the hub (currently supported: 'mouse' and 'keypad'). If you connect
-# the mouse to one of the ports and use the mouse option 'type=usb' you'll
-# have a 3-button USB mouse.
-#
-# Example:
-#   usb1: enabled=1, port1=mouse, port2=keypad
-#=======================================================================
-#usb1: enabled=1
-
-#=======================================================================
-# CMOSIMAGE:
-# This defines image file that can be loaded into the CMOS RAM at startup.
-# The rtc_init parameter controls whether initialize the RTC with values stored
-# in the image. By default the time0 argument given to the clock option is used.
-# With 'rtc_init=image' the image is the source for the initial time.
-#
-# Example:
-#   cmosimage: file=cmos.img, rtc_init=image
-#=======================================================================
-#cmosimage: file=cmos.img, rtc_init=time0
-
-#=======================================================================
-# other stuff
-#=======================================================================
-#magic_break: enabled=1
-#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
-#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
-#text_snapshot_check: enable
-
-#-------------------------
-# PCI host device mapping
-#-------------------------
-#pcidev: vendor=0x1234, device=0x5678
-
-#=======================================================================
-# GDBSTUB:
-# Enable GDB stub. See user documentation for details.
-# Default value is enabled=0.
-#=======================================================================
-#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0
-
-#=======================================================================
-# IPS:
-# The IPS directive is DEPRECATED. Use the parameter IPS of the CPU
-# directive instead.
-#=======================================================================
-#ips: 10000000
-
-#=======================================================================
-# for Macintosh, use the style of pathnames in the following
-# examples.
-#
-# vgaromimage: :bios:VGABIOS-elpin-2.40
-# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
-# floppya: 1_44=[fd:], status=inserted
-#=======================================================================
diff -ruN xv6-public/echo.c xv6-public_new/echo.c
--- xv6-public/echo.c	2021-09-30 23:28:57.663391000 +0530
+++ xv6-public_new/echo.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,13 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  for(i = 1; i < argc; i++)
-    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit();
-}
diff -ruN xv6-public/elf.h xv6-public_new/elf.h
--- xv6-public/elf.h	2021-09-30 23:28:57.665394500 +0530
+++ xv6-public_new/elf.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,42 +0,0 @@
-// Format of an ELF executable file
-
-#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
-
-// File header
-struct elfhdr {
-  uint magic;  // must equal ELF_MAGIC
-  uchar elf[12];
-  ushort type;
-  ushort machine;
-  uint version;
-  uint entry;
-  uint phoff;
-  uint shoff;
-  uint flags;
-  ushort ehsize;
-  ushort phentsize;
-  ushort phnum;
-  ushort shentsize;
-  ushort shnum;
-  ushort shstrndx;
-};
-
-// Program section header
-struct proghdr {
-  uint type;
-  uint off;
-  uint vaddr;
-  uint paddr;
-  uint filesz;
-  uint memsz;
-  uint flags;
-  uint align;
-};
-
-// Values for Proghdr type
-#define ELF_PROG_LOAD           1
-
-// Flag bits for Proghdr flags
-#define ELF_PROG_FLAG_EXEC      1
-#define ELF_PROG_FLAG_WRITE     2
-#define ELF_PROG_FLAG_READ      4
diff -ruN xv6-public/entry.S xv6-public_new/entry.S
--- xv6-public/entry.S	2021-09-30 23:28:57.667396100 +0530
+++ xv6-public_new/entry.S	1970-01-01 05:30:00.000000000 +0530
@@ -1,68 +0,0 @@
-# The xv6 kernel starts executing in this file. This file is linked with
-# the kernel C code, so it can refer to kernel symbols such as main().
-# The boot block (bootasm.S and bootmain.c) jumps to entry below.
-        
-# Multiboot header, for multiboot boot loaders like GNU Grub.
-# http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
-#
-# Using GRUB 2, you can boot xv6 from a file stored in a
-# Linux file system by copying kernel or kernelmemfs to /boot
-# and then adding this menu entry:
-#
-# menuentry "xv6" {
-# 	insmod ext2
-# 	set root='(hd0,msdos1)'
-# 	set kernel='/boot/kernel'
-# 	echo "Loading ${kernel}..."
-# 	multiboot ${kernel} ${kernel}
-# 	boot
-# }
-
-#include "asm.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "param.h"
-
-# Multiboot header.  Data to direct multiboot loader.
-.p2align 2
-.text
-.globl multiboot_header
-multiboot_header:
-  #define magic 0x1badb002
-  #define flags 0
-  .long magic
-  .long flags
-  .long (-magic-flags)
-
-# By convention, the _start symbol specifies the ELF entry point.
-# Since we haven't set up virtual memory yet, our entry point is
-# the physical address of 'entry'.
-.globl _start
-_start = V2P_WO(entry)
-
-# Entering xv6 on boot processor, with paging off.
-.globl entry
-entry:
-  # Turn on page size extension for 4Mbyte pages
-  movl    %cr4, %eax
-  orl     $(CR4_PSE), %eax
-  movl    %eax, %cr4
-  # Set page directory
-  movl    $(V2P_WO(entrypgdir)), %eax
-  movl    %eax, %cr3
-  # Turn on paging.
-  movl    %cr0, %eax
-  orl     $(CR0_PG|CR0_WP), %eax
-  movl    %eax, %cr0
-
-  # Set up the stack pointer.
-  movl $(stack + KSTACKSIZE), %esp
-
-  # Jump to main(), and switch to executing at
-  # high addresses. The indirect call is needed because
-  # the assembler produces a PC-relative instruction
-  # for a direct jump.
-  mov $main, %eax
-  jmp *%eax
-
-.comm stack, KSTACKSIZE
diff -ruN xv6-public/entryother.S xv6-public_new/entryother.S
--- xv6-public/entryother.S	2021-09-30 23:28:57.669396200 +0530
+++ xv6-public_new/entryother.S	1970-01-01 05:30:00.000000000 +0530
@@ -1,93 +0,0 @@
-#include "asm.h"
-#include "memlayout.h"
-#include "mmu.h"
-	
-# Each non-boot CPU ("AP") is started up in response to a STARTUP
-# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
-# Specification says that the AP will start in real mode with CS:IP
-# set to XY00:0000, where XY is an 8-bit value sent with the
-# STARTUP. Thus this code must start at a 4096-byte boundary.
-#
-# Because this code sets DS to zero, it must sit
-# at an address in the low 2^16 bytes.
-#
-# Startothers (in main.c) sends the STARTUPs one at a time.
-# It copies this code (start) at 0x7000.  It puts the address of
-# a newly allocated per-core stack in start-4,the address of the
-# place to jump to (mpenter) in start-8, and the physical address
-# of entrypgdir in start-12.
-#
-# This code combines elements of bootasm.S and entry.S.
-
-.code16           
-.globl start
-start:
-  cli            
-
-  # Zero data segment registers DS, ES, and SS.
-  xorw    %ax,%ax
-  movw    %ax,%ds
-  movw    %ax,%es
-  movw    %ax,%ss
-
-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
-  # virtual addresses map directly to physical addresses so that the
-  # effective memory map doesn't change during the transition.
-  lgdt    gdtdesc
-  movl    %cr0, %eax
-  orl     $CR0_PE, %eax
-  movl    %eax, %cr0
-
-  # Complete the transition to 32-bit protected mode by using a long jmp
-  # to reload %cs and %eip.  The segment descriptors are set up with no
-  # translation, so that the mapping is still the identity mapping.
-  ljmpl    $(SEG_KCODE<<3), $(start32)
-
-//PAGEBREAK!
-.code32  # Tell assembler to generate 32-bit code now.
-start32:
-  # Set up the protected-mode data segment registers
-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
-  movw    %ax, %ds                # -> DS: Data Segment
-  movw    %ax, %es                # -> ES: Extra Segment
-  movw    %ax, %ss                # -> SS: Stack Segment
-  movw    $0, %ax                 # Zero segments not ready for use
-  movw    %ax, %fs                # -> FS
-  movw    %ax, %gs                # -> GS
-
-  # Turn on page size extension for 4Mbyte pages
-  movl    %cr4, %eax
-  orl     $(CR4_PSE), %eax
-  movl    %eax, %cr4
-  # Use entrypgdir as our initial page table
-  movl    (start-12), %eax
-  movl    %eax, %cr3
-  # Turn on paging.
-  movl    %cr0, %eax
-  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
-  movl    %eax, %cr0
-
-  # Switch to the stack allocated by startothers()
-  movl    (start-4), %esp
-  # Call mpenter()
-  call	 *(start-8)
-
-  movw    $0x8a00, %ax
-  movw    %ax, %dx
-  outw    %ax, %dx
-  movw    $0x8ae0, %ax
-  outw    %ax, %dx
-spin:
-  jmp     spin
-
-.p2align 2
-gdt:
-  SEG_NULLASM
-  SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
-  SEG_ASM(STA_W, 0, 0xffffffff)
-
-
-gdtdesc:
-  .word   (gdtdesc - gdt - 1)
-  .long   gdt
-
diff -ruN xv6-public/exec.c xv6-public_new/exec.c
--- xv6-public/exec.c	2021-09-30 23:28:57.670395100 +0530
+++ xv6-public_new/exec.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,114 +0,0 @@
-#include "types.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "defs.h"
-#include "x86.h"
-#include "elf.h"
-
-int
-exec(char *path, char **argv)
-{
-  char *s, *last;
-  int i, off;
-  uint argc, sz, sp, ustack[3+MAXARG+1];
-  struct elfhdr elf;
-  struct inode *ip;
-  struct proghdr ph;
-  pde_t *pgdir, *oldpgdir;
-  struct proc *curproc = myproc();
-
-  begin_op();
-
-  if((ip = namei(path)) == 0){
-    end_op();
-    cprintf("exec: fail\n");
-    return -1;
-  }
-  ilock(ip);
-  pgdir = 0;
-
-  // Check ELF header
-  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
-    goto bad;
-  if(elf.magic != ELF_MAGIC)
-    goto bad;
-
-  if((pgdir = setupkvm()) == 0)
-    goto bad;
-
-  // Load program into memory.
-  sz = 0;
-  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
-    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
-      goto bad;
-    if(ph.type != ELF_PROG_LOAD)
-      continue;
-    if(ph.memsz < ph.filesz)
-      goto bad;
-    if(ph.vaddr + ph.memsz < ph.vaddr)
-      goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
-      goto bad;
-    if(ph.vaddr % PGSIZE != 0)
-      goto bad;
-    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
-      goto bad;
-  }
-  iunlockput(ip);
-  end_op();
-  ip = 0;
-
-  // Allocate two pages at the next page boundary.
-  // Make the first inaccessible.  Use the second as the user stack.
-  sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
-    goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
-  sp = sz;
-
-  // Push argument strings, prepare rest of stack in ustack.
-  for(argc = 0; argv[argc]; argc++) {
-    if(argc >= MAXARG)
-      goto bad;
-    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
-    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
-      goto bad;
-    ustack[3+argc] = sp;
-  }
-  ustack[3+argc] = 0;
-
-  ustack[0] = 0xffffffff;  // fake return PC
-  ustack[1] = argc;
-  ustack[2] = sp - (argc+1)*4;  // argv pointer
-
-  sp -= (3+argc+1) * 4;
-  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
-    goto bad;
-
-  // Save program name for debugging.
-  for(last=s=path; *s; s++)
-    if(*s == '/')
-      last = s+1;
-  safestrcpy(curproc->name, last, sizeof(curproc->name));
-
-  // Commit to the user image.
-  oldpgdir = curproc->pgdir;
-  curproc->pgdir = pgdir;
-  curproc->sz = sz;
-  curproc->tf->eip = elf.entry;  // main
-  curproc->tf->esp = sp;
-  switchuvm(curproc);
-  freevm(oldpgdir);
-  return 0;
-
- bad:
-  if(pgdir)
-    freevm(pgdir);
-  if(ip){
-    iunlockput(ip);
-    end_op();
-  }
-  return -1;
-}
diff -ruN xv6-public/fcntl.h xv6-public_new/fcntl.h
--- xv6-public/fcntl.h	2021-09-30 23:28:57.672391200 +0530
+++ xv6-public_new/fcntl.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
-#define O_RDONLY  0x000
-#define O_WRONLY  0x001
-#define O_RDWR    0x002
-#define O_CREATE  0x200
diff -ruN xv6-public/file.c xv6-public_new/file.c
--- xv6-public/file.c	2021-09-30 23:28:57.674395000 +0530
+++ xv6-public_new/file.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,157 +0,0 @@
-//
-// File descriptors
-//
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "file.h"
-
-struct devsw devsw[NDEV];
-struct {
-  struct spinlock lock;
-  struct file file[NFILE];
-} ftable;
-
-void
-fileinit(void)
-{
-  initlock(&ftable.lock, "ftable");
-}
-
-// Allocate a file structure.
-struct file*
-filealloc(void)
-{
-  struct file *f;
-
-  acquire(&ftable.lock);
-  for(f = ftable.file; f < ftable.file + NFILE; f++){
-    if(f->ref == 0){
-      f->ref = 1;
-      release(&ftable.lock);
-      return f;
-    }
-  }
-  release(&ftable.lock);
-  return 0;
-}
-
-// Increment ref count for file f.
-struct file*
-filedup(struct file *f)
-{
-  acquire(&ftable.lock);
-  if(f->ref < 1)
-    panic("filedup");
-  f->ref++;
-  release(&ftable.lock);
-  return f;
-}
-
-// Close file f.  (Decrement ref count, close when reaches 0.)
-void
-fileclose(struct file *f)
-{
-  struct file ff;
-
-  acquire(&ftable.lock);
-  if(f->ref < 1)
-    panic("fileclose");
-  if(--f->ref > 0){
-    release(&ftable.lock);
-    return;
-  }
-  ff = *f;
-  f->ref = 0;
-  f->type = FD_NONE;
-  release(&ftable.lock);
-
-  if(ff.type == FD_PIPE)
-    pipeclose(ff.pipe, ff.writable);
-  else if(ff.type == FD_INODE){
-    begin_op();
-    iput(ff.ip);
-    end_op();
-  }
-}
-
-// Get metadata about file f.
-int
-filestat(struct file *f, struct stat *st)
-{
-  if(f->type == FD_INODE){
-    ilock(f->ip);
-    stati(f->ip, st);
-    iunlock(f->ip);
-    return 0;
-  }
-  return -1;
-}
-
-// Read from file f.
-int
-fileread(struct file *f, char *addr, int n)
-{
-  int r;
-
-  if(f->readable == 0)
-    return -1;
-  if(f->type == FD_PIPE)
-    return piperead(f->pipe, addr, n);
-  if(f->type == FD_INODE){
-    ilock(f->ip);
-    if((r = readi(f->ip, addr, f->off, n)) > 0)
-      f->off += r;
-    iunlock(f->ip);
-    return r;
-  }
-  panic("fileread");
-}
-
-//PAGEBREAK!
-// Write to file f.
-int
-filewrite(struct file *f, char *addr, int n)
-{
-  int r;
-
-  if(f->writable == 0)
-    return -1;
-  if(f->type == FD_PIPE)
-    return pipewrite(f->pipe, addr, n);
-  if(f->type == FD_INODE){
-    // write a few blocks at a time to avoid exceeding
-    // the maximum log transaction size, including
-    // i-node, indirect block, allocation blocks,
-    // and 2 blocks of slop for non-aligned writes.
-    // this really belongs lower down, since writei()
-    // might be writing a device like the console.
-    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
-    int i = 0;
-    while(i < n){
-      int n1 = n - i;
-      if(n1 > max)
-        n1 = max;
-
-      begin_op();
-      ilock(f->ip);
-      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
-        f->off += r;
-      iunlock(f->ip);
-      end_op();
-
-      if(r < 0)
-        break;
-      if(r != n1)
-        panic("short filewrite");
-      i += r;
-    }
-    return i == n ? n : -1;
-  }
-  panic("filewrite");
-}
-
diff -ruN xv6-public/file.h xv6-public_new/file.h
--- xv6-public/file.h	2021-09-30 23:28:57.677395400 +0530
+++ xv6-public_new/file.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,37 +0,0 @@
-struct file {
-  enum { FD_NONE, FD_PIPE, FD_INODE } type;
-  int ref; // reference count
-  char readable;
-  char writable;
-  struct pipe *pipe;
-  struct inode *ip;
-  uint off;
-};
-
-
-// in-memory copy of an inode
-struct inode {
-  uint dev;           // Device number
-  uint inum;          // Inode number
-  int ref;            // Reference count
-  struct sleeplock lock; // protects everything below here
-  int valid;          // inode has been read from disk?
-
-  short type;         // copy of disk inode
-  short major;
-  short minor;
-  short nlink;
-  uint size;
-  uint addrs[NDIRECT+1];
-};
-
-// table mapping major device number to
-// device functions
-struct devsw {
-  int (*read)(struct inode*, char*, int);
-  int (*write)(struct inode*, char*, int);
-};
-
-extern struct devsw devsw[];
-
-#define CONSOLE 1
diff -ruN xv6-public/forktest.c xv6-public_new/forktest.c
--- xv6-public/forktest.c	2021-09-30 23:28:57.678394600 +0530
+++ xv6-public_new/forktest.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,56 +0,0 @@
-// Test that fork fails gracefully.
-// Tiny executable so that the limit can be filling the proc table.
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-#define N  1000
-
-void
-printf(int fd, const char *s, ...)
-{
-  write(fd, s, strlen(s));
-}
-
-void
-forktest(void)
-{
-  int n, pid;
-
-  printf(1, "fork test\n");
-
-  for(n=0; n<N; n++){
-    pid = fork();
-    if(pid < 0)
-      break;
-    if(pid == 0)
-      exit();
-  }
-
-  if(n == N){
-    printf(1, "fork claimed to work N times!\n", N);
-    exit();
-  }
-
-  for(; n > 0; n--){
-    if(wait() < 0){
-      printf(1, "wait stopped early\n");
-      exit();
-    }
-  }
-
-  if(wait() != -1){
-    printf(1, "wait got too many\n");
-    exit();
-  }
-
-  printf(1, "fork test OK\n");
-}
-
-int
-main(void)
-{
-  forktest();
-  exit();
-}
diff -ruN xv6-public/fs.c xv6-public_new/fs.c
--- xv6-public/fs.c	2021-09-30 23:28:57.681394200 +0530
+++ xv6-public_new/fs.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,670 +0,0 @@
-// File system implementation.  Five layers:
-//   + Blocks: allocator for raw disk blocks.
-//   + Log: crash recovery for multi-step updates.
-//   + Files: inode allocator, reading, writing, metadata.
-//   + Directories: inode with special contents (list of other inodes!)
-//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
-//
-// This file contains the low-level file system manipulation
-// routines.  The (higher-level) system call implementations
-// are in sysfile.c.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "stat.h"
-#include "mmu.h"
-#include "proc.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-#include "file.h"
-
-#define min(a, b) ((a) < (b) ? (a) : (b))
-static void itrunc(struct inode*);
-// there should be one superblock per disk device, but we run with
-// only one device
-struct superblock sb; 
-
-// Read the super block.
-void
-readsb(int dev, struct superblock *sb)
-{
-  struct buf *bp;
-
-  bp = bread(dev, 1);
-  memmove(sb, bp->data, sizeof(*sb));
-  brelse(bp);
-}
-
-// Zero a block.
-static void
-bzero(int dev, int bno)
-{
-  struct buf *bp;
-
-  bp = bread(dev, bno);
-  memset(bp->data, 0, BSIZE);
-  log_write(bp);
-  brelse(bp);
-}
-
-// Blocks.
-
-// Allocate a zeroed disk block.
-static uint
-balloc(uint dev)
-{
-  int b, bi, m;
-  struct buf *bp;
-
-  bp = 0;
-  for(b = 0; b < sb.size; b += BPB){
-    bp = bread(dev, BBLOCK(b, sb));
-    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
-      m = 1 << (bi % 8);
-      if((bp->data[bi/8] & m) == 0){  // Is block free?
-        bp->data[bi/8] |= m;  // Mark block in use.
-        log_write(bp);
-        brelse(bp);
-        bzero(dev, b + bi);
-        return b + bi;
-      }
-    }
-    brelse(bp);
-  }
-  panic("balloc: out of blocks");
-}
-
-// Free a disk block.
-static void
-bfree(int dev, uint b)
-{
-  struct buf *bp;
-  int bi, m;
-
-  bp = bread(dev, BBLOCK(b, sb));
-  bi = b % BPB;
-  m = 1 << (bi % 8);
-  if((bp->data[bi/8] & m) == 0)
-    panic("freeing free block");
-  bp->data[bi/8] &= ~m;
-  log_write(bp);
-  brelse(bp);
-}
-
-// Inodes.
-//
-// An inode describes a single unnamed file.
-// The inode disk structure holds metadata: the file's type,
-// its size, the number of links referring to it, and the
-// list of blocks holding the file's content.
-//
-// The inodes are laid out sequentially on disk at
-// sb.startinode. Each inode has a number, indicating its
-// position on the disk.
-//
-// The kernel keeps a cache of in-use inodes in memory
-// to provide a place for synchronizing access
-// to inodes used by multiple processes. The cached
-// inodes include book-keeping information that is
-// not stored on disk: ip->ref and ip->valid.
-//
-// An inode and its in-memory representation go through a
-// sequence of states before they can be used by the
-// rest of the file system code.
-//
-// * Allocation: an inode is allocated if its type (on disk)
-//   is non-zero. ialloc() allocates, and iput() frees if
-//   the reference and link counts have fallen to zero.
-//
-// * Referencing in cache: an entry in the inode cache
-//   is free if ip->ref is zero. Otherwise ip->ref tracks
-//   the number of in-memory pointers to the entry (open
-//   files and current directories). iget() finds or
-//   creates a cache entry and increments its ref; iput()
-//   decrements ref.
-//
-// * Valid: the information (type, size, &c) in an inode
-//   cache entry is only correct when ip->valid is 1.
-//   ilock() reads the inode from
-//   the disk and sets ip->valid, while iput() clears
-//   ip->valid if ip->ref has fallen to zero.
-//
-// * Locked: file system code may only examine and modify
-//   the information in an inode and its content if it
-//   has first locked the inode.
-//
-// Thus a typical sequence is:
-//   ip = iget(dev, inum)
-//   ilock(ip)
-//   ... examine and modify ip->xxx ...
-//   iunlock(ip)
-//   iput(ip)
-//
-// ilock() is separate from iget() so that system calls can
-// get a long-term reference to an inode (as for an open file)
-// and only lock it for short periods (e.g., in read()).
-// The separation also helps avoid deadlock and races during
-// pathname lookup. iget() increments ip->ref so that the inode
-// stays cached and pointers to it remain valid.
-//
-// Many internal file system functions expect the caller to
-// have locked the inodes involved; this lets callers create
-// multi-step atomic operations.
-//
-// The icache.lock spin-lock protects the allocation of icache
-// entries. Since ip->ref indicates whether an entry is free,
-// and ip->dev and ip->inum indicate which i-node an entry
-// holds, one must hold icache.lock while using any of those fields.
-//
-// An ip->lock sleep-lock protects all ip-> fields other than ref,
-// dev, and inum.  One must hold ip->lock in order to
-// read or write that inode's ip->valid, ip->size, ip->type, &c.
-
-struct {
-  struct spinlock lock;
-  struct inode inode[NINODE];
-} icache;
-
-void
-iinit(int dev)
-{
-  int i = 0;
-  
-  initlock(&icache.lock, "icache");
-  for(i = 0; i < NINODE; i++) {
-    initsleeplock(&icache.inode[i].lock, "inode");
-  }
-
-  readsb(dev, &sb);
-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
- inodestart %d bmap start %d\n", sb.size, sb.nblocks,
-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
-          sb.bmapstart);
-}
-
-static struct inode* iget(uint dev, uint inum);
-
-//PAGEBREAK!
-// Allocate an inode on device dev.
-// Mark it as allocated by  giving it type type.
-// Returns an unlocked but allocated and referenced inode.
-struct inode*
-ialloc(uint dev, short type)
-{
-  int inum;
-  struct buf *bp;
-  struct dinode *dip;
-
-  for(inum = 1; inum < sb.ninodes; inum++){
-    bp = bread(dev, IBLOCK(inum, sb));
-    dip = (struct dinode*)bp->data + inum%IPB;
-    if(dip->type == 0){  // a free inode
-      memset(dip, 0, sizeof(*dip));
-      dip->type = type;
-      log_write(bp);   // mark it allocated on the disk
-      brelse(bp);
-      return iget(dev, inum);
-    }
-    brelse(bp);
-  }
-  panic("ialloc: no inodes");
-}
-
-// Copy a modified in-memory inode to disk.
-// Must be called after every change to an ip->xxx field
-// that lives on disk, since i-node cache is write-through.
-// Caller must hold ip->lock.
-void
-iupdate(struct inode *ip)
-{
-  struct buf *bp;
-  struct dinode *dip;
-
-  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-  dip = (struct dinode*)bp->data + ip->inum%IPB;
-  dip->type = ip->type;
-  dip->major = ip->major;
-  dip->minor = ip->minor;
-  dip->nlink = ip->nlink;
-  dip->size = ip->size;
-  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
-  log_write(bp);
-  brelse(bp);
-}
-
-// Find the inode with number inum on device dev
-// and return the in-memory copy. Does not lock
-// the inode and does not read it from disk.
-static struct inode*
-iget(uint dev, uint inum)
-{
-  struct inode *ip, *empty;
-
-  acquire(&icache.lock);
-
-  // Is the inode already cached?
-  empty = 0;
-  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
-    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
-      ip->ref++;
-      release(&icache.lock);
-      return ip;
-    }
-    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
-      empty = ip;
-  }
-
-  // Recycle an inode cache entry.
-  if(empty == 0)
-    panic("iget: no inodes");
-
-  ip = empty;
-  ip->dev = dev;
-  ip->inum = inum;
-  ip->ref = 1;
-  ip->valid = 0;
-  release(&icache.lock);
-
-  return ip;
-}
-
-// Increment reference count for ip.
-// Returns ip to enable ip = idup(ip1) idiom.
-struct inode*
-idup(struct inode *ip)
-{
-  acquire(&icache.lock);
-  ip->ref++;
-  release(&icache.lock);
-  return ip;
-}
-
-// Lock the given inode.
-// Reads the inode from disk if necessary.
-void
-ilock(struct inode *ip)
-{
-  struct buf *bp;
-  struct dinode *dip;
-
-  if(ip == 0 || ip->ref < 1)
-    panic("ilock");
-
-  acquiresleep(&ip->lock);
-
-  if(ip->valid == 0){
-    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
-    dip = (struct dinode*)bp->data + ip->inum%IPB;
-    ip->type = dip->type;
-    ip->major = dip->major;
-    ip->minor = dip->minor;
-    ip->nlink = dip->nlink;
-    ip->size = dip->size;
-    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
-    brelse(bp);
-    ip->valid = 1;
-    if(ip->type == 0)
-      panic("ilock: no type");
-  }
-}
-
-// Unlock the given inode.
-void
-iunlock(struct inode *ip)
-{
-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
-    panic("iunlock");
-
-  releasesleep(&ip->lock);
-}
-
-// Drop a reference to an in-memory inode.
-// If that was the last reference, the inode cache entry can
-// be recycled.
-// If that was the last reference and the inode has no links
-// to it, free the inode (and its content) on disk.
-// All calls to iput() must be inside a transaction in
-// case it has to free the inode.
-void
-iput(struct inode *ip)
-{
-  acquiresleep(&ip->lock);
-  if(ip->valid && ip->nlink == 0){
-    acquire(&icache.lock);
-    int r = ip->ref;
-    release(&icache.lock);
-    if(r == 1){
-      // inode has no links and no other references: truncate and free.
-      itrunc(ip);
-      ip->type = 0;
-      iupdate(ip);
-      ip->valid = 0;
-    }
-  }
-  releasesleep(&ip->lock);
-
-  acquire(&icache.lock);
-  ip->ref--;
-  release(&icache.lock);
-}
-
-// Common idiom: unlock, then put.
-void
-iunlockput(struct inode *ip)
-{
-  iunlock(ip);
-  iput(ip);
-}
-
-//PAGEBREAK!
-// Inode content
-//
-// The content (data) associated with each inode is stored
-// in blocks on the disk. The first NDIRECT block numbers
-// are listed in ip->addrs[].  The next NINDIRECT blocks are
-// listed in block ip->addrs[NDIRECT].
-
-// Return the disk block address of the nth block in inode ip.
-// If there is no such block, bmap allocates one.
-static uint
-bmap(struct inode *ip, uint bn)
-{
-  uint addr, *a;
-  struct buf *bp;
-
-  if(bn < NDIRECT){
-    if((addr = ip->addrs[bn]) == 0)
-      ip->addrs[bn] = addr = balloc(ip->dev);
-    return addr;
-  }
-  bn -= NDIRECT;
-
-  if(bn < NINDIRECT){
-    // Load indirect block, allocating if necessary.
-    if((addr = ip->addrs[NDIRECT]) == 0)
-      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
-    bp = bread(ip->dev, addr);
-    a = (uint*)bp->data;
-    if((addr = a[bn]) == 0){
-      a[bn] = addr = balloc(ip->dev);
-      log_write(bp);
-    }
-    brelse(bp);
-    return addr;
-  }
-
-  panic("bmap: out of range");
-}
-
-// Truncate inode (discard contents).
-// Only called when the inode has no links
-// to it (no directory entries referring to it)
-// and has no in-memory reference to it (is
-// not an open file or current directory).
-static void
-itrunc(struct inode *ip)
-{
-  int i, j;
-  struct buf *bp;
-  uint *a;
-
-  for(i = 0; i < NDIRECT; i++){
-    if(ip->addrs[i]){
-      bfree(ip->dev, ip->addrs[i]);
-      ip->addrs[i] = 0;
-    }
-  }
-
-  if(ip->addrs[NDIRECT]){
-    bp = bread(ip->dev, ip->addrs[NDIRECT]);
-    a = (uint*)bp->data;
-    for(j = 0; j < NINDIRECT; j++){
-      if(a[j])
-        bfree(ip->dev, a[j]);
-    }
-    brelse(bp);
-    bfree(ip->dev, ip->addrs[NDIRECT]);
-    ip->addrs[NDIRECT] = 0;
-  }
-
-  ip->size = 0;
-  iupdate(ip);
-}
-
-// Copy stat information from inode.
-// Caller must hold ip->lock.
-void
-stati(struct inode *ip, struct stat *st)
-{
-  st->dev = ip->dev;
-  st->ino = ip->inum;
-  st->type = ip->type;
-  st->nlink = ip->nlink;
-  st->size = ip->size;
-}
-
-//PAGEBREAK!
-// Read data from inode.
-// Caller must hold ip->lock.
-int
-readi(struct inode *ip, char *dst, uint off, uint n)
-{
-  uint tot, m;
-  struct buf *bp;
-
-  if(ip->type == T_DEV){
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
-      return -1;
-    return devsw[ip->major].read(ip, dst, n);
-  }
-
-  if(off > ip->size || off + n < off)
-    return -1;
-  if(off + n > ip->size)
-    n = ip->size - off;
-
-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-    m = min(n - tot, BSIZE - off%BSIZE);
-    memmove(dst, bp->data + off%BSIZE, m);
-    brelse(bp);
-  }
-  return n;
-}
-
-// PAGEBREAK!
-// Write data to inode.
-// Caller must hold ip->lock.
-int
-writei(struct inode *ip, char *src, uint off, uint n)
-{
-  uint tot, m;
-  struct buf *bp;
-
-  if(ip->type == T_DEV){
-    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
-      return -1;
-    return devsw[ip->major].write(ip, src, n);
-  }
-
-  if(off > ip->size || off + n < off)
-    return -1;
-  if(off + n > MAXFILE*BSIZE)
-    return -1;
-
-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-    m = min(n - tot, BSIZE - off%BSIZE);
-    memmove(bp->data + off%BSIZE, src, m);
-    log_write(bp);
-    brelse(bp);
-  }
-
-  if(n > 0 && off > ip->size){
-    ip->size = off;
-    iupdate(ip);
-  }
-  return n;
-}
-
-//PAGEBREAK!
-// Directories
-
-int
-namecmp(const char *s, const char *t)
-{
-  return strncmp(s, t, DIRSIZ);
-}
-
-// Look for a directory entry in a directory.
-// If found, set *poff to byte offset of entry.
-struct inode*
-dirlookup(struct inode *dp, char *name, uint *poff)
-{
-  uint off, inum;
-  struct dirent de;
-
-  if(dp->type != T_DIR)
-    panic("dirlookup not DIR");
-
-  for(off = 0; off < dp->size; off += sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-      panic("dirlookup read");
-    if(de.inum == 0)
-      continue;
-    if(namecmp(name, de.name) == 0){
-      // entry matches path element
-      if(poff)
-        *poff = off;
-      inum = de.inum;
-      return iget(dp->dev, inum);
-    }
-  }
-
-  return 0;
-}
-
-// Write a new directory entry (name, inum) into the directory dp.
-int
-dirlink(struct inode *dp, char *name, uint inum)
-{
-  int off;
-  struct dirent de;
-  struct inode *ip;
-
-  // Check that name is not present.
-  if((ip = dirlookup(dp, name, 0)) != 0){
-    iput(ip);
-    return -1;
-  }
-
-  // Look for an empty dirent.
-  for(off = 0; off < dp->size; off += sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-      panic("dirlink read");
-    if(de.inum == 0)
-      break;
-  }
-
-  strncpy(de.name, name, DIRSIZ);
-  de.inum = inum;
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-    panic("dirlink");
-
-  return 0;
-}
-
-//PAGEBREAK!
-// Paths
-
-// Copy the next path element from path into name.
-// Return a pointer to the element following the copied one.
-// The returned path has no leading slashes,
-// so the caller can check *path=='\0' to see if the name is the last one.
-// If no name to remove, return 0.
-//
-// Examples:
-//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
-//   skipelem("///a//bb", name) = "bb", setting name = "a"
-//   skipelem("a", name) = "", setting name = "a"
-//   skipelem("", name) = skipelem("////", name) = 0
-//
-static char*
-skipelem(char *path, char *name)
-{
-  char *s;
-  int len;
-
-  while(*path == '/')
-    path++;
-  if(*path == 0)
-    return 0;
-  s = path;
-  while(*path != '/' && *path != 0)
-    path++;
-  len = path - s;
-  if(len >= DIRSIZ)
-    memmove(name, s, DIRSIZ);
-  else {
-    memmove(name, s, len);
-    name[len] = 0;
-  }
-  while(*path == '/')
-    path++;
-  return path;
-}
-
-// Look up and return the inode for a path name.
-// If parent != 0, return the inode for the parent and copy the final
-// path element into name, which must have room for DIRSIZ bytes.
-// Must be called inside a transaction since it calls iput().
-static struct inode*
-namex(char *path, int nameiparent, char *name)
-{
-  struct inode *ip, *next;
-
-  if(*path == '/')
-    ip = iget(ROOTDEV, ROOTINO);
-  else
-    ip = idup(myproc()->cwd);
-
-  while((path = skipelem(path, name)) != 0){
-    ilock(ip);
-    if(ip->type != T_DIR){
-      iunlockput(ip);
-      return 0;
-    }
-    if(nameiparent && *path == '\0'){
-      // Stop one level early.
-      iunlock(ip);
-      return ip;
-    }
-    if((next = dirlookup(ip, name, 0)) == 0){
-      iunlockput(ip);
-      return 0;
-    }
-    iunlockput(ip);
-    ip = next;
-  }
-  if(nameiparent){
-    iput(ip);
-    return 0;
-  }
-  return ip;
-}
-
-struct inode*
-namei(char *path)
-{
-  char name[DIRSIZ];
-  return namex(path, 0, name);
-}
-
-struct inode*
-nameiparent(char *path, char *name)
-{
-  return namex(path, 1, name);
-}
diff -ruN xv6-public/fs.h xv6-public_new/fs.h
--- xv6-public/fs.h	2021-09-30 23:28:57.683393700 +0530
+++ xv6-public_new/fs.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,57 +0,0 @@
-// On-disk file system format.
-// Both the kernel and user programs use this header file.
-
-
-#define ROOTINO 1  // root i-number
-#define BSIZE 512  // block size
-
-// Disk layout:
-// [ boot block | super block | log | inode blocks |
-//                                          free bit map | data blocks]
-//
-// mkfs computes the super block and builds an initial file system. The
-// super block describes the disk layout:
-struct superblock {
-  uint size;         // Size of file system image (blocks)
-  uint nblocks;      // Number of data blocks
-  uint ninodes;      // Number of inodes.
-  uint nlog;         // Number of log blocks
-  uint logstart;     // Block number of first log block
-  uint inodestart;   // Block number of first inode block
-  uint bmapstart;    // Block number of first free map block
-};
-
-#define NDIRECT 12
-#define NINDIRECT (BSIZE / sizeof(uint))
-#define MAXFILE (NDIRECT + NINDIRECT)
-
-// On-disk inode structure
-struct dinode {
-  short type;           // File type
-  short major;          // Major device number (T_DEV only)
-  short minor;          // Minor device number (T_DEV only)
-  short nlink;          // Number of links to inode in file system
-  uint size;            // Size of file (bytes)
-  uint addrs[NDIRECT+1];   // Data block addresses
-};
-
-// Inodes per block.
-#define IPB           (BSIZE / sizeof(struct dinode))
-
-// Block containing inode i
-#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
-
-// Bitmap bits per block
-#define BPB           (BSIZE*8)
-
-// Block of free map containing bit for block b
-#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
-
-// Directory is a file containing a sequence of dirent structures.
-#define DIRSIZ 14
-
-struct dirent {
-  ushort inum;
-  char name[DIRSIZ];
-};
-
diff -ruN xv6-public/gdbutil xv6-public_new/gdbutil
--- xv6-public/gdbutil	2021-09-30 23:28:57.685395400 +0530
+++ xv6-public_new/gdbutil	1970-01-01 05:30:00.000000000 +0530
@@ -1,291 +0,0 @@
-# -*- gdb-script -*-
-
-# Utility functions to pretty-print x86 segment/interrupt descriptors.
-# To load this file, run "source gdbutil" in gdb.
-# printdesc and printdescs are the main entry points.
-
-# IA32 2007, Volume 3A, Table 3-2
-set $STS_T16A = 0x1
-set $STS_LDT  = 0x2
-set $STS_T16B = 0x3
-set $STS_CG16 = 0x4
-set $STS_TG   = 0x5
-set $STS_IG16 = 0x6
-set $STS_TG16 = 0x7
-set $STS_T32A = 0x9
-set $STS_T32B = 0xB
-set $STS_CG32 = 0xC
-set $STS_IG32 = 0xE
-set $STS_TG32 = 0xF
-
-define outputsts
-  while 1
-    if $arg0 == $STS_T16A
-      echo STS_T16A
-      loop_break
-    end
-    if $arg0 == $STS_LDT
-      echo STS_LDT\ 
-      loop_break
-    end
-    if $arg0 == $STS_T16B
-      echo STS_T16B
-      loop_break
-    end
-    if $arg0 == $STS_CG16
-      echo STS_CG16
-      loop_break
-    end
-    if $arg0 == $STS_TG
-      echo STS_TG\ \ 
-      loop_break
-    end
-    if $arg0 == $STS_IG16
-      echo STS_IG16
-      loop_break
-    end
-    if $arg0 == $STS_TG16
-      echo STS_TG16
-      loop_break
-    end
-    if $arg0 == $STS_T32A
-      echo STS_T32A
-      loop_break
-    end
-    if $arg0 == $STS_T32B
-      echo STS_T32B
-      loop_break
-    end
-    if $arg0 == $STS_CG32
-      echo STS_CG32
-      loop_break
-    end
-    if $arg0 == $STS_IG32
-      echo STS_IG32
-      loop_break
-    end
-    if $arg0 == $STS_TG32
-      echo STS_TG32
-      loop_break
-    end
-    echo Reserved
-    loop_break
-  end
-end  
-
-# IA32 2007, Volume 3A, Table 3-1
-set $STA_X = 0x8
-set $STA_E = 0x4
-set $STA_C = 0x4
-set $STA_W = 0x2
-set $STA_R = 0x2
-set $STA_A = 0x1
-
-define outputsta
-  if $arg0 & $STA_X
-    # Code segment
-    echo code
-    if $arg0 & $STA_C
-      echo |STA_C
-    end
-    if $arg0 & $STA_R
-      echo |STA_R
-    end
-  else
-    # Data segment
-    echo data
-    if $arg0 & $STA_E
-      echo |STA_E
-    end
-    if $arg0 & $STA_W
-      echo |STA_W
-    end
-  end
-  if $arg0 & $STA_A
-    echo |STA_A
-  else
-    printf "      "
-  end
-end
-
-# xv6-specific
-set $SEG_KCODE = 1
-set $SEG_KDATA = 2
-set $SEG_KCPU  = 3
-set $SEG_UCODE = 4
-set $SEG_UDATA = 5
-set $SEG_TSS   = 6
-
-define outputcs
-  if ($arg0 & 4) == 0
-    if $arg0 >> 3 == $SEG_KCODE
-      printf "SEG_KCODE<<3"
-    end
-    if $arg0 >> 3 == $SEG_KDATA
-      printf "SEG_KDATA<<3"
-    end
-    if $arg0 >> 3 == $SEG_KCPU
-      printf "SEG_KCPU<<3"
-    end
-    if $arg0 >> 3 == $SEG_UCODE
-      printf "SEG_UCODE<<3"
-    end
-    if $arg0 >> 3 == $SEG_UDATA
-      printf "SEG_UDATA<<3"
-    end
-    if $arg0 >> 3 == $SEG_TSS
-      printf "SEG_TSS<<3"
-    end
-    if ($arg0 >> 3 < 1) + ($arg0 >> 3 > 6)
-      printf "GDT[%d]", $arg0 >> 3
-    end
-  else
-    printf "LDT[%d]", $arg0 >> 3
-  end
-  if ($arg0 & 3) > 0
-    printf "|"
-    outputdpl ($arg0&3)
-  end
-end
-
-define outputdpl
-  if $arg0 == 0
-    printf "DPL_KERN"
-  else
-    if $arg0 == 3
-      printf "DPL_USER"
-    else
-      printf "DPL%d", $arg0
-    end
-  end
-end
-
-define printdesc
-  if $argc != 1
-    echo Usage: printdesc expr
-  else
-    _printdesc ((uint*)&($arg0))[0] ((uint*)&($arg0))[1]
-    printf "\n"
-  end
-end
-
-document printdesc
-Print an x86 segment or gate descriptor.
-printdesc EXPR
-EXPR must evaluate to a descriptor value.  It can be of any C type.
-end
-
-define _printdesc
-  _printdesc1 $arg0 $arg1 ($arg1>>15&1) ($arg1>>13&3) ($arg1>>12&1) ($arg1>>8&15)
-end
-
-define _printdesc1
-  # 2:P 3:DPL 4:S 5:Type
-  if $arg2 == 0
-    printf "P = 0 (Not present)"
-  else
-    printf "type = "
-    if $arg4 == 0
-      # System segment
-      outputsts $arg5
-      printf " (0x%x)    ", $arg5
-      _printsysdesc $arg0 $arg1 $arg5
-    else
-      # Code/data segment
-      outputsta $arg5
-      printf "  "
-      _printsegdesc $arg0 $arg1
-    end
-
-    printf "  DPL = "
-    outputdpl $arg3
-    printf " (%d)", $arg3
-  end
-end
-
-define _printsysdesc
-  # 2:Type
-  # GDB's || is buggy
-  if ($arg2 == $STS_TG) + (($arg2&7) == $STS_IG16) + (($arg2&7) == $STS_TG16)
-    # Gate descriptor
-    _printgate $arg2 ($arg0>>16) ($arg0&0xFFFF) ($arg1>>16)
-  else
-    # System segment descriptor
-    _printsegdesc $arg0 $arg1
-  end
-end
-
-define _printgate
-  # IA32 2007, Voume 3A, Figure 5-2
-  # 0:Type 1:CS 2:Offset 15..0 3:Offset 31..16
-  printf "CS = "
-  outputcs $arg1
-  printf " (%d)", $arg1
-
-  if (($arg0&7) == $STS_IG16) + (($arg0&7) == $STS_TG16)
-    printf "  Offset = "
-    output/a $arg3 << 16 | $arg2
-  end
-end
-
-define _printsegdesc
-  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
-  _printsegdesc1 ($arg0>>16) ($arg1&0xFF) ($arg1>>24) ($arg0&0xFFFF) ($arg1>>16&15) ($arg1>>23&1)
-  if ($arg1>>12&1) == 1
-    printf "  AVL = %d", $arg1>>20&1
-    if ($arg1>>11&1) == 0
-      # Data segment
-      if ($arg1>>22&1) == 0
-        printf "  B = small (0) "
-      else
-        printf "  B = big (1)   "
-      end
-    else
-      # Code segment
-      printf "  D = "
-      if ($arg1>>22&1) == 0
-        printf "16-bit (0)"
-      else
-        printf "32-bit (1)"
-      end
-    end
-  end
-end
-
-define _printsegdesc1
-  # 0:Base 0..15  1:Base 16..23  2:Base 24..32  3:Limit 0..15  4:Limit 16..19  5:G
-  printf "base = 0x%08x", $arg0 | ($arg1<<16) | ($arg2<<24)
-  printf "  limit = 0x"
-  if $arg5 == 0
-    printf "%08x", $arg3 | ($arg4<<16)
-  else
-    printf "%08x", (($arg3 | ($arg4<<16)) << 12) | 0xFFF
-  end
-end
-
-define printdescs
-  if $argc < 1 || $argc > 2
-    echo Usage: printdescs expr [count]
-  else
-    if $argc == 1
-      _printdescs ($arg0) (sizeof($arg0)/sizeof(($arg0)[0]))
-    else
-      _printdescs ($arg0) ($arg1)
-    end
-  end
-end
-
-document printdescs
-Print an array of x86 segment or gate descriptors.
-printdescs EXPR [COUNT]
-EXPR must evaluate to an array of descriptors.
-end
-
-define _printdescs
-  set $i = 0
-  while $i < $arg1
-    printf "[%d] ", $i
-    printdesc $arg0[$i]
-    set $i = $i + 1
-  end
-end
diff -ruN xv6-public/grep.c xv6-public_new/grep.c
--- xv6-public/grep.c	2021-09-30 23:28:57.687391500 +0530
+++ xv6-public_new/grep.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,107 +0,0 @@
-// Simple grep.  Only supports ^ . * $ operators.
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-char buf[1024];
-int match(char*, char*);
-
-void
-grep(char *pattern, int fd)
-{
-  int n, m;
-  char *p, *q;
-
-  m = 0;
-  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
-    m += n;
-    buf[m] = '\0';
-    p = buf;
-    while((q = strchr(p, '\n')) != 0){
-      *q = 0;
-      if(match(pattern, p)){
-        *q = '\n';
-        write(1, p, q+1 - p);
-      }
-      p = q+1;
-    }
-    if(p == buf)
-      m = 0;
-    if(m > 0){
-      m -= p - buf;
-      memmove(buf, p, m);
-    }
-  }
-}
-
-int
-main(int argc, char *argv[])
-{
-  int fd, i;
-  char *pattern;
-
-  if(argc <= 1){
-    printf(2, "usage: grep pattern [file ...]\n");
-    exit();
-  }
-  pattern = argv[1];
-
-  if(argc <= 2){
-    grep(pattern, 0);
-    exit();
-  }
-
-  for(i = 2; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
-    }
-    grep(pattern, fd);
-    close(fd);
-  }
-  exit();
-}
-
-// Regexp matcher from Kernighan & Pike,
-// The Practice of Programming, Chapter 9.
-
-int matchhere(char*, char*);
-int matchstar(int, char*, char*);
-
-int
-match(char *re, char *text)
-{
-  if(re[0] == '^')
-    return matchhere(re+1, text);
-  do{  // must look at empty string
-    if(matchhere(re, text))
-      return 1;
-  }while(*text++ != '\0');
-  return 0;
-}
-
-// matchhere: search for re at beginning of text
-int matchhere(char *re, char *text)
-{
-  if(re[0] == '\0')
-    return 1;
-  if(re[1] == '*')
-    return matchstar(re[0], re+2, text);
-  if(re[0] == '$' && re[1] == '\0')
-    return *text == '\0';
-  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
-    return matchhere(re+1, text+1);
-  return 0;
-}
-
-// matchstar: search for c*re at beginning of text
-int matchstar(int c, char *re, char *text)
-{
-  do{  // a * matches zero or more instances
-    if(matchhere(re, text))
-      return 1;
-  }while(*text!='\0' && (*text++==c || c=='.'));
-  return 0;
-}
-
diff -ruN xv6-public/ide.c xv6-public_new/ide.c
--- xv6-public/ide.c	2021-09-30 23:28:57.689395500 +0530
+++ xv6-public_new/ide.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,168 +0,0 @@
-// Simple PIO-based (non-DMA) IDE driver code.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-#include "traps.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-
-#define SECTOR_SIZE   512
-#define IDE_BSY       0x80
-#define IDE_DRDY      0x40
-#define IDE_DF        0x20
-#define IDE_ERR       0x01
-
-#define IDE_CMD_READ  0x20
-#define IDE_CMD_WRITE 0x30
-#define IDE_CMD_RDMUL 0xc4
-#define IDE_CMD_WRMUL 0xc5
-
-// idequeue points to the buf now being read/written to the disk.
-// idequeue->qnext points to the next buf to be processed.
-// You must hold idelock while manipulating queue.
-
-static struct spinlock idelock;
-static struct buf *idequeue;
-
-static int havedisk1;
-static void idestart(struct buf*);
-
-// Wait for IDE disk to become ready.
-static int
-idewait(int checkerr)
-{
-  int r;
-
-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
-    ;
-  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
-    return -1;
-  return 0;
-}
-
-void
-ideinit(void)
-{
-  int i;
-
-  initlock(&idelock, "ide");
-  ioapicenable(IRQ_IDE, ncpu - 1);
-  idewait(0);
-
-  // Check if disk 1 is present
-  outb(0x1f6, 0xe0 | (1<<4));
-  for(i=0; i<1000; i++){
-    if(inb(0x1f7) != 0){
-      havedisk1 = 1;
-      break;
-    }
-  }
-
-  // Switch back to disk 0.
-  outb(0x1f6, 0xe0 | (0<<4));
-}
-
-// Start the request for b.  Caller must hold idelock.
-static void
-idestart(struct buf *b)
-{
-  if(b == 0)
-    panic("idestart");
-  if(b->blockno >= FSSIZE)
-    panic("incorrect blockno");
-  int sector_per_block =  BSIZE/SECTOR_SIZE;
-  int sector = b->blockno * sector_per_block;
-  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
-  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
-
-  if (sector_per_block > 7) panic("idestart");
-
-  idewait(0);
-  outb(0x3f6, 0);  // generate interrupt
-  outb(0x1f2, sector_per_block);  // number of sectors
-  outb(0x1f3, sector & 0xff);
-  outb(0x1f4, (sector >> 8) & 0xff);
-  outb(0x1f5, (sector >> 16) & 0xff);
-  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
-  if(b->flags & B_DIRTY){
-    outb(0x1f7, write_cmd);
-    outsl(0x1f0, b->data, BSIZE/4);
-  } else {
-    outb(0x1f7, read_cmd);
-  }
-}
-
-// Interrupt handler.
-void
-ideintr(void)
-{
-  struct buf *b;
-
-  // First queued buffer is the active request.
-  acquire(&idelock);
-
-  if((b = idequeue) == 0){
-    release(&idelock);
-    return;
-  }
-  idequeue = b->qnext;
-
-  // Read data if needed.
-  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
-    insl(0x1f0, b->data, BSIZE/4);
-
-  // Wake process waiting for this buf.
-  b->flags |= B_VALID;
-  b->flags &= ~B_DIRTY;
-  wakeup(b);
-
-  // Start disk on next buf in queue.
-  if(idequeue != 0)
-    idestart(idequeue);
-
-  release(&idelock);
-}
-
-//PAGEBREAK!
-// Sync buf with disk.
-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
-// Else if B_VALID is not set, read buf from disk, set B_VALID.
-void
-iderw(struct buf *b)
-{
-  struct buf **pp;
-
-  if(!holdingsleep(&b->lock))
-    panic("iderw: buf not locked");
-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
-    panic("iderw: nothing to do");
-  if(b->dev != 0 && !havedisk1)
-    panic("iderw: ide disk 1 not present");
-
-  acquire(&idelock);  //DOC:acquire-lock
-
-  // Append b to idequeue.
-  b->qnext = 0;
-  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
-    ;
-  *pp = b;
-
-  // Start disk if necessary.
-  if(idequeue == b)
-    idestart(b);
-
-  // Wait for request to finish.
-  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
-    sleep(b, &idelock);
-  }
-
-
-  release(&idelock);
-}
diff -ruN xv6-public/init.c xv6-public_new/init.c
--- xv6-public/init.c	2021-09-30 23:28:57.691395800 +0530
+++ xv6-public_new/init.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,37 +0,0 @@
-// init: The initial user-level program
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fcntl.h"
-
-char *argv[] = { "sh", 0 };
-
-int
-main(void)
-{
-  int pid, wpid;
-
-  if(open("console", O_RDWR) < 0){
-    mknod("console", 1, 1);
-    open("console", O_RDWR);
-  }
-  dup(0);  // stdout
-  dup(0);  // stderr
-
-  for(;;){
-    printf(1, "init: starting sh\n");
-    pid = fork();
-    if(pid < 0){
-      printf(1, "init: fork failed\n");
-      exit();
-    }
-    if(pid == 0){
-      exec("sh", argv);
-      printf(1, "init: exec sh failed\n");
-      exit();
-    }
-    while((wpid=wait()) >= 0 && wpid != pid)
-      printf(1, "zombie!\n");
-  }
-}
diff -ruN xv6-public/initcode.S xv6-public_new/initcode.S
--- xv6-public/initcode.S	2021-09-30 23:28:57.692395100 +0530
+++ xv6-public_new/initcode.S	1970-01-01 05:30:00.000000000 +0530
@@ -1,32 +0,0 @@
-# Initial process execs /init.
-# This code runs in user space.
-
-#include "syscall.h"
-#include "traps.h"
-
-
-# exec(init, argv)
-.globl start
-start:
-  pushl $argv
-  pushl $init
-  pushl $0  // where caller pc would be
-  movl $SYS_exec, %eax
-  int $T_SYSCALL
-
-# for(;;) exit();
-exit:
-  movl $SYS_exit, %eax
-  int $T_SYSCALL
-  jmp exit
-
-# char init[] = "/init\0";
-init:
-  .string "/init\0"
-
-# char *argv[] = { init, 0 };
-.p2align 2
-argv:
-  .long init
-  .long 0
-
diff -ruN xv6-public/ioapic.c xv6-public_new/ioapic.c
--- xv6-public/ioapic.c	2021-09-30 23:28:57.694395600 +0530
+++ xv6-public_new/ioapic.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,75 +0,0 @@
-// The I/O APIC manages hardware interrupts for an SMP system.
-// http://www.intel.com/design/chipsets/datashts/29056601.pdf
-// See also picirq.c.
-
-#include "types.h"
-#include "defs.h"
-#include "traps.h"
-
-#define IOAPIC  0xFEC00000   // Default physical address of IO APIC
-
-#define REG_ID     0x00  // Register index: ID
-#define REG_VER    0x01  // Register index: version
-#define REG_TABLE  0x10  // Redirection table base
-
-// The redirection table starts at REG_TABLE and uses
-// two registers to configure each interrupt.
-// The first (low) register in a pair contains configuration bits.
-// The second (high) register contains a bitmask telling which
-// CPUs can serve that interrupt.
-#define INT_DISABLED   0x00010000  // Interrupt disabled
-#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
-#define INT_ACTIVELOW  0x00002000  // Active low (vs high)
-#define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)
-
-volatile struct ioapic *ioapic;
-
-// IO APIC MMIO structure: write reg, then read or write data.
-struct ioapic {
-  uint reg;
-  uint pad[3];
-  uint data;
-};
-
-static uint
-ioapicread(int reg)
-{
-  ioapic->reg = reg;
-  return ioapic->data;
-}
-
-static void
-ioapicwrite(int reg, uint data)
-{
-  ioapic->reg = reg;
-  ioapic->data = data;
-}
-
-void
-ioapicinit(void)
-{
-  int i, id, maxintr;
-
-  ioapic = (volatile struct ioapic*)IOAPIC;
-  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
-  id = ioapicread(REG_ID) >> 24;
-  if(id != ioapicid)
-    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
-
-  // Mark all interrupts edge-triggered, active high, disabled,
-  // and not routed to any CPUs.
-  for(i = 0; i <= maxintr; i++){
-    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
-    ioapicwrite(REG_TABLE+2*i+1, 0);
-  }
-}
-
-void
-ioapicenable(int irq, int cpunum)
-{
-  // Mark interrupt edge-triggered, active high,
-  // enabled, and routed to the given cpunum,
-  // which happens to be that cpu's APIC ID.
-  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
-  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
-}
diff -ruN xv6-public/kalloc.c xv6-public_new/kalloc.c
--- xv6-public/kalloc.c	2021-09-30 23:28:57.697393500 +0530
+++ xv6-public_new/kalloc.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,96 +0,0 @@
-// Physical memory allocator, intended to allocate
-// memory for user processes, kernel stacks, page table pages,
-// and pipe buffers. Allocates 4096-byte pages.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "spinlock.h"
-
-void freerange(void *vstart, void *vend);
-extern char end[]; // first address after kernel loaded from ELF file
-                   // defined by the kernel linker script in kernel.ld
-
-struct run {
-  struct run *next;
-};
-
-struct {
-  struct spinlock lock;
-  int use_lock;
-  struct run *freelist;
-} kmem;
-
-// Initialization happens in two phases.
-// 1. main() calls kinit1() while still using entrypgdir to place just
-// the pages mapped by entrypgdir on free list.
-// 2. main() calls kinit2() with the rest of the physical pages
-// after installing a full page table that maps them on all cores.
-void
-kinit1(void *vstart, void *vend)
-{
-  initlock(&kmem.lock, "kmem");
-  kmem.use_lock = 0;
-  freerange(vstart, vend);
-}
-
-void
-kinit2(void *vstart, void *vend)
-{
-  freerange(vstart, vend);
-  kmem.use_lock = 1;
-}
-
-void
-freerange(void *vstart, void *vend)
-{
-  char *p;
-  p = (char*)PGROUNDUP((uint)vstart);
-  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
-    kfree(p);
-}
-//PAGEBREAK: 21
-// Free the page of physical memory pointed at by v,
-// which normally should have been returned by a
-// call to kalloc().  (The exception is when
-// initializing the allocator; see kinit above.)
-void
-kfree(char *v)
-{
-  struct run *r;
-
-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
-    panic("kfree");
-
-  // Fill with junk to catch dangling refs.
-  memset(v, 1, PGSIZE);
-
-  if(kmem.use_lock)
-    acquire(&kmem.lock);
-  r = (struct run*)v;
-  r->next = kmem.freelist;
-  kmem.freelist = r;
-  if(kmem.use_lock)
-    release(&kmem.lock);
-}
-
-// Allocate one 4096-byte page of physical memory.
-// Returns a pointer that the kernel can use.
-// Returns 0 if the memory cannot be allocated.
-char*
-kalloc(void)
-{
-  struct run *r;
-
-  if(kmem.use_lock)
-    acquire(&kmem.lock);
-  r = kmem.freelist;
-  if(r)
-    kmem.freelist = r->next;
-  if(kmem.use_lock)
-    release(&kmem.lock);
-  return (char*)r;
-}
-
diff -ruN xv6-public/kbd.c xv6-public_new/kbd.c
--- xv6-public/kbd.c	2021-09-30 23:28:57.699395600 +0530
+++ xv6-public_new/kbd.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,50 +0,0 @@
-#include "types.h"
-#include "x86.h"
-#include "defs.h"
-#include "kbd.h"
-
-int
-kbdgetc(void)
-{
-  static uint shift;
-  static uchar *charcode[4] = {
-    normalmap, shiftmap, ctlmap, ctlmap
-  };
-  uint st, data, c;
-
-  st = inb(KBSTATP);
-  if((st & KBS_DIB) == 0)
-    return -1;
-  data = inb(KBDATAP);
-
-  if(data == 0xE0){
-    shift |= E0ESC;
-    return 0;
-  } else if(data & 0x80){
-    // Key released
-    data = (shift & E0ESC ? data : data & 0x7F);
-    shift &= ~(shiftcode[data] | E0ESC);
-    return 0;
-  } else if(shift & E0ESC){
-    // Last character was an E0 escape; or with 0x80
-    data |= 0x80;
-    shift &= ~E0ESC;
-  }
-
-  shift |= shiftcode[data];
-  shift ^= togglecode[data];
-  c = charcode[shift & (CTL | SHIFT)][data];
-  if(shift & CAPSLOCK){
-    if('a' <= c && c <= 'z')
-      c += 'A' - 'a';
-    else if('A' <= c && c <= 'Z')
-      c += 'a' - 'A';
-  }
-  return c;
-}
-
-void
-kbdintr(void)
-{
-  consoleintr(kbdgetc);
-}
diff -ruN xv6-public/kbd.h xv6-public_new/kbd.h
--- xv6-public/kbd.h	2021-09-30 23:28:57.700394300 +0530
+++ xv6-public_new/kbd.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,112 +0,0 @@
-// PC keyboard interface constants
-
-#define KBSTATP         0x64    // kbd controller status port(I)
-#define KBS_DIB         0x01    // kbd data in buffer
-#define KBDATAP         0x60    // kbd data port(I)
-
-#define NO              0
-
-#define SHIFT           (1<<0)
-#define CTL             (1<<1)
-#define ALT             (1<<2)
-
-#define CAPSLOCK        (1<<3)
-#define NUMLOCK         (1<<4)
-#define SCROLLLOCK      (1<<5)
-
-#define E0ESC           (1<<6)
-
-// Special keycodes
-#define KEY_HOME        0xE0
-#define KEY_END         0xE1
-#define KEY_UP          0xE2
-#define KEY_DN          0xE3
-#define KEY_LF          0xE4
-#define KEY_RT          0xE5
-#define KEY_PGUP        0xE6
-#define KEY_PGDN        0xE7
-#define KEY_INS         0xE8
-#define KEY_DEL         0xE9
-
-// C('A') == Control-A
-#define C(x) (x - '@')
-
-static uchar shiftcode[256] =
-{
-  [0x1D] CTL,
-  [0x2A] SHIFT,
-  [0x36] SHIFT,
-  [0x38] ALT,
-  [0x9D] CTL,
-  [0xB8] ALT
-};
-
-static uchar togglecode[256] =
-{
-  [0x3A] CAPSLOCK,
-  [0x45] NUMLOCK,
-  [0x46] SCROLLLOCK
-};
-
-static uchar normalmap[256] =
-{
-  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
-  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
-  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
-  'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
-  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
-  '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
-  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-  [0x9C] '\n',      // KP_Enter
-  [0xB5] '/',       // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
-static uchar shiftmap[256] =
-{
-  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
-  '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
-  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
-  'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
-  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
-  '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
-  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
-  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
-  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-  [0x9C] '\n',      // KP_Enter
-  [0xB5] '/',       // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
-static uchar ctlmap[256] =
-{
-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
-  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
-  C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
-  C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
-  C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
-  NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
-  C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
-  [0x9C] '\r',      // KP_Enter
-  [0xB5] C('/'),    // KP_Div
-  [0xC8] KEY_UP,    [0xD0] KEY_DN,
-  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-  [0xCB] KEY_LF,    [0xCD] KEY_RT,
-  [0x97] KEY_HOME,  [0xCF] KEY_END,
-  [0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
diff -ruN xv6-public/kernel.ld xv6-public_new/kernel.ld
--- xv6-public/kernel.ld	2021-09-30 23:28:57.702395800 +0530
+++ xv6-public_new/kernel.ld	1970-01-01 05:30:00.000000000 +0530
@@ -1,64 +0,0 @@
-/* Simple linker script for the JOS kernel.
-   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
-
-OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
-OUTPUT_ARCH(i386)
-ENTRY(_start)
-
-SECTIONS
-{
-	/* Link the kernel at this address: "." means the current address */
-        /* Must be equal to KERNLINK */
-	. = 0x80100000;
-
-	.text : AT(0x100000) {
-		*(.text .stub .text.* .gnu.linkonce.t.*)
-	}
-
-	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
-
-	.rodata : {
-		*(.rodata .rodata.* .gnu.linkonce.r.*)
-	}
-
-	/* Include debugging information in kernel memory */
-	.stab : {
-		PROVIDE(__STAB_BEGIN__ = .);
-		*(.stab);
-		PROVIDE(__STAB_END__ = .);
-	}
-
-	.stabstr : {
-		PROVIDE(__STABSTR_BEGIN__ = .);
-		*(.stabstr);
-		PROVIDE(__STABSTR_END__ = .);
-	}
-
-	/* Adjust the address for the data segment to the next page */
-	. = ALIGN(0x1000);
-
-	/* Conventionally, Unix linkers provide pseudo-symbols
-	 * etext, edata, and end, at the end of the text, data, and bss.
-	 * For the kernel mapping, we need the address at the beginning
-	 * of the data section, but that's not one of the conventional
-	 * symbols, because the convention started before there was a
-	 * read-only rodata section between text and data. */
-	PROVIDE(data = .);
-
-	/* The data segment */
-	.data : {
-		*(.data)
-	}
-
-	PROVIDE(edata = .);
-
-	.bss : {
-		*(.bss)
-	}
-
-	PROVIDE(end = .);
-
-	/DISCARD/ : {
-		*(.eh_frame .note.GNU-stack)
-	}
-}
diff -ruN xv6-public/kill.c xv6-public_new/kill.c
--- xv6-public/kill.c	2021-09-30 23:28:57.704391900 +0530
+++ xv6-public_new/kill.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,17 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char **argv)
-{
-  int i;
-
-  if(argc < 2){
-    printf(2, "usage: kill pid...\n");
-    exit();
-  }
-  for(i=1; i<argc; i++)
-    kill(atoi(argv[i]));
-  exit();
-}
diff -ruN xv6-public/lapic.c xv6-public_new/lapic.c
--- xv6-public/lapic.c	2021-09-30 23:28:57.707394900 +0530
+++ xv6-public_new/lapic.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,229 +0,0 @@
-// The local APIC manages internal (non-I/O) interrupts.
-// See Chapter 8 & Appendix C of Intel processor manual volume 3.
-
-#include "param.h"
-#include "types.h"
-#include "defs.h"
-#include "date.h"
-#include "memlayout.h"
-#include "traps.h"
-#include "mmu.h"
-#include "x86.h"
-
-// Local APIC registers, divided by 4 for use as uint[] indices.
-#define ID      (0x0020/4)   // ID
-#define VER     (0x0030/4)   // Version
-#define TPR     (0x0080/4)   // Task Priority
-#define EOI     (0x00B0/4)   // EOI
-#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
-  #define ENABLE     0x00000100   // Unit Enable
-#define ESR     (0x0280/4)   // Error Status
-#define ICRLO   (0x0300/4)   // Interrupt Command
-  #define INIT       0x00000500   // INIT/RESET
-  #define STARTUP    0x00000600   // Startup IPI
-  #define DELIVS     0x00001000   // Delivery status
-  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
-  #define DEASSERT   0x00000000
-  #define LEVEL      0x00008000   // Level triggered
-  #define BCAST      0x00080000   // Send to all APICs, including self.
-  #define BUSY       0x00001000
-  #define FIXED      0x00000000
-#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]
-#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
-  #define X1         0x0000000B   // divide counts by 1
-  #define PERIODIC   0x00020000   // Periodic
-#define PCINT   (0x0340/4)   // Performance Counter LVT
-#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
-#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)
-#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)
-  #define MASKED     0x00010000   // Interrupt masked
-#define TICR    (0x0380/4)   // Timer Initial Count
-#define TCCR    (0x0390/4)   // Timer Current Count
-#define TDCR    (0x03E0/4)   // Timer Divide Configuration
-
-volatile uint *lapic;  // Initialized in mp.c
-
-//PAGEBREAK!
-static void
-lapicw(int index, int value)
-{
-  lapic[index] = value;
-  lapic[ID];  // wait for write to finish, by reading
-}
-
-void
-lapicinit(void)
-{
-  if(!lapic)
-    return;
-
-  // Enable local APIC; set spurious interrupt vector.
-  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
-
-  // The timer repeatedly counts down at bus frequency
-  // from lapic[TICR] and then issues an interrupt.
-  // If xv6 cared more about precise timekeeping,
-  // TICR would be calibrated using an external time source.
-  lapicw(TDCR, X1);
-  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
-  lapicw(TICR, 10000000);
-
-  // Disable logical interrupt lines.
-  lapicw(LINT0, MASKED);
-  lapicw(LINT1, MASKED);
-
-  // Disable performance counter overflow interrupts
-  // on machines that provide that interrupt entry.
-  if(((lapic[VER]>>16) & 0xFF) >= 4)
-    lapicw(PCINT, MASKED);
-
-  // Map error interrupt to IRQ_ERROR.
-  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
-
-  // Clear error status register (requires back-to-back writes).
-  lapicw(ESR, 0);
-  lapicw(ESR, 0);
-
-  // Ack any outstanding interrupts.
-  lapicw(EOI, 0);
-
-  // Send an Init Level De-Assert to synchronise arbitration ID's.
-  lapicw(ICRHI, 0);
-  lapicw(ICRLO, BCAST | INIT | LEVEL);
-  while(lapic[ICRLO] & DELIVS)
-    ;
-
-  // Enable interrupts on the APIC (but not on the processor).
-  lapicw(TPR, 0);
-}
-
-int
-lapicid(void)
-{
-  if (!lapic)
-    return 0;
-  return lapic[ID] >> 24;
-}
-
-// Acknowledge interrupt.
-void
-lapiceoi(void)
-{
-  if(lapic)
-    lapicw(EOI, 0);
-}
-
-// Spin for a given number of microseconds.
-// On real hardware would want to tune this dynamically.
-void
-microdelay(int us)
-{
-}
-
-#define CMOS_PORT    0x70
-#define CMOS_RETURN  0x71
-
-// Start additional processor running entry code at addr.
-// See Appendix B of MultiProcessor Specification.
-void
-lapicstartap(uchar apicid, uint addr)
-{
-  int i;
-  ushort *wrv;
-
-  // "The BSP must initialize CMOS shutdown code to 0AH
-  // and the warm reset vector (DWORD based at 40:67) to point at
-  // the AP startup code prior to the [universal startup algorithm]."
-  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
-  outb(CMOS_PORT+1, 0x0A);
-  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
-  wrv[0] = 0;
-  wrv[1] = addr >> 4;
-
-  // "Universal startup algorithm."
-  // Send INIT (level-triggered) interrupt to reset other CPU.
-  lapicw(ICRHI, apicid<<24);
-  lapicw(ICRLO, INIT | LEVEL | ASSERT);
-  microdelay(200);
-  lapicw(ICRLO, INIT | LEVEL);
-  microdelay(100);    // should be 10ms, but too slow in Bochs!
-
-  // Send startup IPI (twice!) to enter code.
-  // Regular hardware is supposed to only accept a STARTUP
-  // when it is in the halted state due to an INIT.  So the second
-  // should be ignored, but it is part of the official Intel algorithm.
-  // Bochs complains about the second one.  Too bad for Bochs.
-  for(i = 0; i < 2; i++){
-    lapicw(ICRHI, apicid<<24);
-    lapicw(ICRLO, STARTUP | (addr>>12));
-    microdelay(200);
-  }
-}
-
-#define CMOS_STATA   0x0a
-#define CMOS_STATB   0x0b
-#define CMOS_UIP    (1 << 7)        // RTC update in progress
-
-#define SECS    0x00
-#define MINS    0x02
-#define HOURS   0x04
-#define DAY     0x07
-#define MONTH   0x08
-#define YEAR    0x09
-
-static uint
-cmos_read(uint reg)
-{
-  outb(CMOS_PORT,  reg);
-  microdelay(200);
-
-  return inb(CMOS_RETURN);
-}
-
-static void
-fill_rtcdate(struct rtcdate *r)
-{
-  r->second = cmos_read(SECS);
-  r->minute = cmos_read(MINS);
-  r->hour   = cmos_read(HOURS);
-  r->day    = cmos_read(DAY);
-  r->month  = cmos_read(MONTH);
-  r->year   = cmos_read(YEAR);
-}
-
-// qemu seems to use 24-hour GWT and the values are BCD encoded
-void
-cmostime(struct rtcdate *r)
-{
-  struct rtcdate t1, t2;
-  int sb, bcd;
-
-  sb = cmos_read(CMOS_STATB);
-
-  bcd = (sb & (1 << 2)) == 0;
-
-  // make sure CMOS doesn't modify time while we read it
-  for(;;) {
-    fill_rtcdate(&t1);
-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
-        continue;
-    fill_rtcdate(&t2);
-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
-      break;
-  }
-
-  // convert
-  if(bcd) {
-#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
-    CONV(second);
-    CONV(minute);
-    CONV(hour  );
-    CONV(day   );
-    CONV(month );
-    CONV(year  );
-#undef     CONV
-  }
-
-  *r = t1;
-  r->year += 2000;
-}
diff -ruN xv6-public/ln.c xv6-public_new/ln.c
--- xv6-public/ln.c	2021-09-30 23:28:57.709393700 +0530
+++ xv6-public_new/ln.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,15 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-  if(argc != 3){
-    printf(2, "Usage: ln old new\n");
-    exit();
-  }
-  if(link(argv[1], argv[2]) < 0)
-    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit();
-}
diff -ruN xv6-public/log.c xv6-public_new/log.c
--- xv6-public/log.c	2021-09-30 23:28:57.711392700 +0530
+++ xv6-public_new/log.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,234 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-
-// Simple logging that allows concurrent FS system calls.
-//
-// A log transaction contains the updates of multiple FS system
-// calls. The logging system only commits when there are
-// no FS system calls active. Thus there is never
-// any reasoning required about whether a commit might
-// write an uncommitted system call's updates to disk.
-//
-// A system call should call begin_op()/end_op() to mark
-// its start and end. Usually begin_op() just increments
-// the count of in-progress FS system calls and returns.
-// But if it thinks the log is close to running out, it
-// sleeps until the last outstanding end_op() commits.
-//
-// The log is a physical re-do log containing disk blocks.
-// The on-disk log format:
-//   header block, containing block #s for block A, B, C, ...
-//   block A
-//   block B
-//   block C
-//   ...
-// Log appends are synchronous.
-
-// Contents of the header block, used for both the on-disk header block
-// and to keep track in memory of logged block# before commit.
-struct logheader {
-  int n;
-  int block[LOGSIZE];
-};
-
-struct log {
-  struct spinlock lock;
-  int start;
-  int size;
-  int outstanding; // how many FS sys calls are executing.
-  int committing;  // in commit(), please wait.
-  int dev;
-  struct logheader lh;
-};
-struct log log;
-
-static void recover_from_log(void);
-static void commit();
-
-void
-initlog(int dev)
-{
-  if (sizeof(struct logheader) >= BSIZE)
-    panic("initlog: too big logheader");
-
-  struct superblock sb;
-  initlock(&log.lock, "log");
-  readsb(dev, &sb);
-  log.start = sb.logstart;
-  log.size = sb.nlog;
-  log.dev = dev;
-  recover_from_log();
-}
-
-// Copy committed blocks from log to their home location
-static void
-install_trans(void)
-{
-  int tail;
-
-  for (tail = 0; tail < log.lh.n; tail++) {
-    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
-    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
-    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
-    bwrite(dbuf);  // write dst to disk
-    brelse(lbuf);
-    brelse(dbuf);
-  }
-}
-
-// Read the log header from disk into the in-memory log header
-static void
-read_head(void)
-{
-  struct buf *buf = bread(log.dev, log.start);
-  struct logheader *lh = (struct logheader *) (buf->data);
-  int i;
-  log.lh.n = lh->n;
-  for (i = 0; i < log.lh.n; i++) {
-    log.lh.block[i] = lh->block[i];
-  }
-  brelse(buf);
-}
-
-// Write in-memory log header to disk.
-// This is the true point at which the
-// current transaction commits.
-static void
-write_head(void)
-{
-  struct buf *buf = bread(log.dev, log.start);
-  struct logheader *hb = (struct logheader *) (buf->data);
-  int i;
-  hb->n = log.lh.n;
-  for (i = 0; i < log.lh.n; i++) {
-    hb->block[i] = log.lh.block[i];
-  }
-  bwrite(buf);
-  brelse(buf);
-}
-
-static void
-recover_from_log(void)
-{
-  read_head();
-  install_trans(); // if committed, copy from log to disk
-  log.lh.n = 0;
-  write_head(); // clear the log
-}
-
-// called at the start of each FS system call.
-void
-begin_op(void)
-{
-  acquire(&log.lock);
-  while(1){
-    if(log.committing){
-      sleep(&log, &log.lock);
-    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
-      // this op might exhaust log space; wait for commit.
-      sleep(&log, &log.lock);
-    } else {
-      log.outstanding += 1;
-      release(&log.lock);
-      break;
-    }
-  }
-}
-
-// called at the end of each FS system call.
-// commits if this was the last outstanding operation.
-void
-end_op(void)
-{
-  int do_commit = 0;
-
-  acquire(&log.lock);
-  log.outstanding -= 1;
-  if(log.committing)
-    panic("log.committing");
-  if(log.outstanding == 0){
-    do_commit = 1;
-    log.committing = 1;
-  } else {
-    // begin_op() may be waiting for log space,
-    // and decrementing log.outstanding has decreased
-    // the amount of reserved space.
-    wakeup(&log);
-  }
-  release(&log.lock);
-
-  if(do_commit){
-    // call commit w/o holding locks, since not allowed
-    // to sleep with locks.
-    commit();
-    acquire(&log.lock);
-    log.committing = 0;
-    wakeup(&log);
-    release(&log.lock);
-  }
-}
-
-// Copy modified blocks from cache to log.
-static void
-write_log(void)
-{
-  int tail;
-
-  for (tail = 0; tail < log.lh.n; tail++) {
-    struct buf *to = bread(log.dev, log.start+tail+1); // log block
-    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
-    memmove(to->data, from->data, BSIZE);
-    bwrite(to);  // write the log
-    brelse(from);
-    brelse(to);
-  }
-}
-
-static void
-commit()
-{
-  if (log.lh.n > 0) {
-    write_log();     // Write modified blocks from cache to log
-    write_head();    // Write header to disk -- the real commit
-    install_trans(); // Now install writes to home locations
-    log.lh.n = 0;
-    write_head();    // Erase the transaction from the log
-  }
-}
-
-// Caller has modified b->data and is done with the buffer.
-// Record the block number and pin in the cache with B_DIRTY.
-// commit()/write_log() will do the disk write.
-//
-// log_write() replaces bwrite(); a typical use is:
-//   bp = bread(...)
-//   modify bp->data[]
-//   log_write(bp)
-//   brelse(bp)
-void
-log_write(struct buf *b)
-{
-  int i;
-
-  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
-    panic("too big a transaction");
-  if (log.outstanding < 1)
-    panic("log_write outside of trans");
-
-  acquire(&log.lock);
-  for (i = 0; i < log.lh.n; i++) {
-    if (log.lh.block[i] == b->blockno)   // log absorbtion
-      break;
-  }
-  log.lh.block[i] = b->blockno;
-  if (i == log.lh.n)
-    log.lh.n++;
-  b->flags |= B_DIRTY; // prevent eviction
-  release(&log.lock);
-}
-
diff -ruN xv6-public/ls.c xv6-public_new/ls.c
--- xv6-public/ls.c	2021-09-30 23:28:57.718393100 +0530
+++ xv6-public_new/ls.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,85 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-
-char*
-fmtname(char *path)
-{
-  static char buf[DIRSIZ+1];
-  char *p;
-
-  // Find first character after last slash.
-  for(p=path+strlen(path); p >= path && *p != '/'; p--)
-    ;
-  p++;
-
-  // Return blank-padded name.
-  if(strlen(p) >= DIRSIZ)
-    return p;
-  memmove(buf, p, strlen(p));
-  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
-  return buf;
-}
-
-void
-ls(char *path)
-{
-  char buf[512], *p;
-  int fd;
-  struct dirent de;
-  struct stat st;
-
-  if((fd = open(path, 0)) < 0){
-    printf(2, "ls: cannot open %s\n", path);
-    return;
-  }
-
-  if(fstat(fd, &st) < 0){
-    printf(2, "ls: cannot stat %s\n", path);
-    close(fd);
-    return;
-  }
-
-  switch(st.type){
-  case T_FILE:
-    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
-    break;
-
-  case T_DIR:
-    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
-      printf(1, "ls: path too long\n");
-      break;
-    }
-    strcpy(buf, path);
-    p = buf+strlen(buf);
-    *p++ = '/';
-    while(read(fd, &de, sizeof(de)) == sizeof(de)){
-      if(de.inum == 0)
-        continue;
-      memmove(p, de.name, DIRSIZ);
-      p[DIRSIZ] = 0;
-      if(stat(buf, &st) < 0){
-        printf(1, "ls: cannot stat %s\n", buf);
-        continue;
-      }
-      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
-    }
-    break;
-  }
-  close(fd);
-}
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  if(argc < 2){
-    ls(".");
-    exit();
-  }
-  for(i=1; i<argc; i++)
-    ls(argv[i]);
-  exit();
-}
diff -ruN xv6-public/main.c xv6-public_new/main.c
--- xv6-public/main.c	2021-09-30 23:28:57.720396000 +0530
+++ xv6-public_new/main.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,116 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-
-static void startothers(void);
-static void mpmain(void)  __attribute__((noreturn));
-extern pde_t *kpgdir;
-extern char end[]; // first address after kernel loaded from ELF file
-
-// Bootstrap processor starts running C code here.
-// Allocate a real stack and switch to it, first
-// doing some setup required for memory allocator to work.
-int
-main(void)
-{
-  kinit1(end, P2V(4*1024*1024)); // phys page allocator
-  kvmalloc();      // kernel page table
-  mpinit();        // detect other processors
-  lapicinit();     // interrupt controller
-  seginit();       // segment descriptors
-  picinit();       // disable pic
-  ioapicinit();    // another interrupt controller
-  consoleinit();   // console hardware
-  uartinit();      // serial port
-  pinit();         // process table
-  tvinit();        // trap vectors
-  binit();         // buffer cache
-  fileinit();      // file table
-  ideinit();       // disk 
-  startothers();   // start other processors
-  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
-  userinit();      // first user process
-  mpmain();        // finish this processor's setup
-}
-
-// Other CPUs jump here from entryother.S.
-static void
-mpenter(void)
-{
-  switchkvm();
-  seginit();
-  lapicinit();
-  mpmain();
-}
-
-// Common CPU setup code.
-static void
-mpmain(void)
-{
-  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
-  idtinit();       // load idt register
-  xchg(&(mycpu()->started), 1); // tell startothers() we're up
-  scheduler();     // start running processes
-}
-
-pde_t entrypgdir[];  // For entry.S
-
-// Start the non-boot (AP) processors.
-static void
-startothers(void)
-{
-  extern uchar _binary_entryother_start[], _binary_entryother_size[];
-  uchar *code;
-  struct cpu *c;
-  char *stack;
-
-  // Write entry code to unused memory at 0x7000.
-  // The linker has placed the image of entryother.S in
-  // _binary_entryother_start.
-  code = P2V(0x7000);
-  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
-
-  for(c = cpus; c < cpus+ncpu; c++){
-    if(c == mycpu())  // We've started already.
-      continue;
-
-    // Tell entryother.S what stack to use, where to enter, and what
-    // pgdir to use. We cannot use kpgdir yet, because the AP processor
-    // is running in low  memory, so we use entrypgdir for the APs too.
-    stack = kalloc();
-    *(void**)(code-4) = stack + KSTACKSIZE;
-    *(void(**)(void))(code-8) = mpenter;
-    *(int**)(code-12) = (void *) V2P(entrypgdir);
-
-    lapicstartap(c->apicid, V2P(code));
-
-    // wait for cpu to finish mpmain()
-    while(c->started == 0)
-      ;
-  }
-}
-
-// The boot page table used in entry.S and entryother.S.
-// Page directories (and page tables) must start on page boundaries,
-// hence the __aligned__ attribute.
-// PTE_PS in a page directory entry enables 4Mbyte pages.
-
-__attribute__((__aligned__(PGSIZE)))
-pde_t entrypgdir[NPDENTRIES] = {
-  // Map VA's [0, 4MB) to PA's [0, 4MB)
-  [0] = (0) | PTE_P | PTE_W | PTE_PS,
-  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
-  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
-};
-
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-
diff -ruN xv6-public/memide.c xv6-public_new/memide.c
--- xv6-public/memide.c	2021-09-30 23:28:57.722391300 +0530
+++ xv6-public_new/memide.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,60 +0,0 @@
-// Fake IDE disk; stores blocks in memory.
-// Useful for running kernel without scratch disk.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-#include "traps.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "buf.h"
-
-extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
-
-static int disksize;
-static uchar *memdisk;
-
-void
-ideinit(void)
-{
-  memdisk = _binary_fs_img_start;
-  disksize = (uint)_binary_fs_img_size/BSIZE;
-}
-
-// Interrupt handler.
-void
-ideintr(void)
-{
-  // no-op
-}
-
-// Sync buf with disk.
-// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
-// Else if B_VALID is not set, read buf from disk, set B_VALID.
-void
-iderw(struct buf *b)
-{
-  uchar *p;
-
-  if(!holdingsleep(&b->lock))
-    panic("iderw: buf not locked");
-  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
-    panic("iderw: nothing to do");
-  if(b->dev != 1)
-    panic("iderw: request not for disk 1");
-  if(b->blockno >= disksize)
-    panic("iderw: block out of range");
-
-  p = memdisk + b->blockno*BSIZE;
-
-  if(b->flags & B_DIRTY){
-    b->flags &= ~B_DIRTY;
-    memmove(p, b->data, BSIZE);
-  } else
-    memmove(b->data, p, BSIZE);
-  b->flags |= B_VALID;
-}
diff -ruN xv6-public/memlayout.h xv6-public_new/memlayout.h
--- xv6-public/memlayout.h	2021-09-30 23:28:57.724394500 +0530
+++ xv6-public_new/memlayout.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,15 +0,0 @@
-// Memory layout
-
-#define EXTMEM  0x100000            // Start of extended memory
-#define PHYSTOP 0xE000000           // Top physical memory
-#define DEVSPACE 0xFE000000         // Other devices are at high addresses
-
-// Key addresses for address space layout (see kmap in vm.c for layout)
-#define KERNBASE 0x80000000         // First kernel virtual address
-#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
-
-#define V2P(a) (((uint) (a)) - KERNBASE)
-#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
-
-#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
-#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
diff -ruN xv6-public/mkdir.c xv6-public_new/mkdir.c
--- xv6-public/mkdir.c	2021-09-30 23:28:57.726393000 +0530
+++ xv6-public_new/mkdir.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,23 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  if(argc < 2){
-    printf(2, "Usage: mkdir files...\n");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if(mkdir(argv[i]) < 0){
-      printf(2, "mkdir: %s failed to create\n", argv[i]);
-      break;
-    }
-  }
-
-  exit();
-}
diff -ruN xv6-public/mkfs.c xv6-public_new/mkfs.c
--- xv6-public/mkfs.c	2021-09-30 23:28:57.728395100 +0530
+++ xv6-public_new/mkfs.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,297 +0,0 @@
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <fcntl.h>
-#include <assert.h>
-
-#define stat xv6_stat  // avoid clash with host struct stat
-#include "types.h"
-#include "fs.h"
-#include "stat.h"
-#include "param.h"
-
-#ifndef static_assert
-#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
-#endif
-
-#define NINODES 200
-
-// Disk layout:
-// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
-
-int nbitmap = FSSIZE/(BSIZE*8) + 1;
-int ninodeblocks = NINODES / IPB + 1;
-int nlog = LOGSIZE;
-int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
-int nblocks;  // Number of data blocks
-
-int fsfd;
-struct superblock sb;
-char zeroes[BSIZE];
-uint freeinode = 1;
-uint freeblock;
-
-
-void balloc(int);
-void wsect(uint, void*);
-void winode(uint, struct dinode*);
-void rinode(uint inum, struct dinode *ip);
-void rsect(uint sec, void *buf);
-uint ialloc(ushort type);
-void iappend(uint inum, void *p, int n);
-
-// convert to intel byte order
-ushort
-xshort(ushort x)
-{
-  ushort y;
-  uchar *a = (uchar*)&y;
-  a[0] = x;
-  a[1] = x >> 8;
-  return y;
-}
-
-uint
-xint(uint x)
-{
-  uint y;
-  uchar *a = (uchar*)&y;
-  a[0] = x;
-  a[1] = x >> 8;
-  a[2] = x >> 16;
-  a[3] = x >> 24;
-  return y;
-}
-
-int
-main(int argc, char *argv[])
-{
-  int i, cc, fd;
-  uint rootino, inum, off;
-  struct dirent de;
-  char buf[BSIZE];
-  struct dinode din;
-
-
-  static_assert(sizeof(int) == 4, "Integers must be 4 bytes!");
-
-  if(argc < 2){
-    fprintf(stderr, "Usage: mkfs fs.img files...\n");
-    exit(1);
-  }
-
-  assert((BSIZE % sizeof(struct dinode)) == 0);
-  assert((BSIZE % sizeof(struct dirent)) == 0);
-
-  fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
-  if(fsfd < 0){
-    perror(argv[1]);
-    exit(1);
-  }
-
-  // 1 fs block = 1 disk sector
-  nmeta = 2 + nlog + ninodeblocks + nbitmap;
-  nblocks = FSSIZE - nmeta;
-
-  sb.size = xint(FSSIZE);
-  sb.nblocks = xint(nblocks);
-  sb.ninodes = xint(NINODES);
-  sb.nlog = xint(nlog);
-  sb.logstart = xint(2);
-  sb.inodestart = xint(2+nlog);
-  sb.bmapstart = xint(2+nlog+ninodeblocks);
-
-  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
-         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
-
-  freeblock = nmeta;     // the first free block that we can allocate
-
-  for(i = 0; i < FSSIZE; i++)
-    wsect(i, zeroes);
-
-  memset(buf, 0, sizeof(buf));
-  memmove(buf, &sb, sizeof(sb));
-  wsect(1, buf);
-
-  rootino = ialloc(T_DIR);
-  assert(rootino == ROOTINO);
-
-  bzero(&de, sizeof(de));
-  de.inum = xshort(rootino);
-  strcpy(de.name, ".");
-  iappend(rootino, &de, sizeof(de));
-
-  bzero(&de, sizeof(de));
-  de.inum = xshort(rootino);
-  strcpy(de.name, "..");
-  iappend(rootino, &de, sizeof(de));
-
-  for(i = 2; i < argc; i++){
-    assert(index(argv[i], '/') == 0);
-
-    if((fd = open(argv[i], 0)) < 0){
-      perror(argv[i]);
-      exit(1);
-    }
-
-    // Skip leading _ in name when writing to file system.
-    // The binaries are named _rm, _cat, etc. to keep the
-    // build operating system from trying to execute them
-    // in place of system binaries like rm and cat.
-    if(argv[i][0] == '_')
-      ++argv[i];
-
-    inum = ialloc(T_FILE);
-
-    bzero(&de, sizeof(de));
-    de.inum = xshort(inum);
-    strncpy(de.name, argv[i], DIRSIZ);
-    iappend(rootino, &de, sizeof(de));
-
-    while((cc = read(fd, buf, sizeof(buf))) > 0)
-      iappend(inum, buf, cc);
-
-    close(fd);
-  }
-
-  // fix size of root inode dir
-  rinode(rootino, &din);
-  off = xint(din.size);
-  off = ((off/BSIZE) + 1) * BSIZE;
-  din.size = xint(off);
-  winode(rootino, &din);
-
-  balloc(freeblock);
-
-  exit(0);
-}
-
-void
-wsect(uint sec, void *buf)
-{
-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
-    perror("lseek");
-    exit(1);
-  }
-  if(write(fsfd, buf, BSIZE) != BSIZE){
-    perror("write");
-    exit(1);
-  }
-}
-
-void
-winode(uint inum, struct dinode *ip)
-{
-  char buf[BSIZE];
-  uint bn;
-  struct dinode *dip;
-
-  bn = IBLOCK(inum, sb);
-  rsect(bn, buf);
-  dip = ((struct dinode*)buf) + (inum % IPB);
-  *dip = *ip;
-  wsect(bn, buf);
-}
-
-void
-rinode(uint inum, struct dinode *ip)
-{
-  char buf[BSIZE];
-  uint bn;
-  struct dinode *dip;
-
-  bn = IBLOCK(inum, sb);
-  rsect(bn, buf);
-  dip = ((struct dinode*)buf) + (inum % IPB);
-  *ip = *dip;
-}
-
-void
-rsect(uint sec, void *buf)
-{
-  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
-    perror("lseek");
-    exit(1);
-  }
-  if(read(fsfd, buf, BSIZE) != BSIZE){
-    perror("read");
-    exit(1);
-  }
-}
-
-uint
-ialloc(ushort type)
-{
-  uint inum = freeinode++;
-  struct dinode din;
-
-  bzero(&din, sizeof(din));
-  din.type = xshort(type);
-  din.nlink = xshort(1);
-  din.size = xint(0);
-  winode(inum, &din);
-  return inum;
-}
-
-void
-balloc(int used)
-{
-  uchar buf[BSIZE];
-  int i;
-
-  printf("balloc: first %d blocks have been allocated\n", used);
-  assert(used < BSIZE*8);
-  bzero(buf, BSIZE);
-  for(i = 0; i < used; i++){
-    buf[i/8] = buf[i/8] | (0x1 << (i%8));
-  }
-  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
-  wsect(sb.bmapstart, buf);
-}
-
-#define min(a, b) ((a) < (b) ? (a) : (b))
-
-void
-iappend(uint inum, void *xp, int n)
-{
-  char *p = (char*)xp;
-  uint fbn, off, n1;
-  struct dinode din;
-  char buf[BSIZE];
-  uint indirect[NINDIRECT];
-  uint x;
-
-  rinode(inum, &din);
-  off = xint(din.size);
-  // printf("append inum %d at off %d sz %d\n", inum, off, n);
-  while(n > 0){
-    fbn = off / BSIZE;
-    assert(fbn < MAXFILE);
-    if(fbn < NDIRECT){
-      if(xint(din.addrs[fbn]) == 0){
-        din.addrs[fbn] = xint(freeblock++);
-      }
-      x = xint(din.addrs[fbn]);
-    } else {
-      if(xint(din.addrs[NDIRECT]) == 0){
-        din.addrs[NDIRECT] = xint(freeblock++);
-      }
-      rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
-      if(indirect[fbn - NDIRECT] == 0){
-        indirect[fbn - NDIRECT] = xint(freeblock++);
-        wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
-      }
-      x = xint(indirect[fbn-NDIRECT]);
-    }
-    n1 = min(n, (fbn + 1) * BSIZE - off);
-    rsect(x, buf);
-    bcopy(p, buf + off - (fbn * BSIZE), n1);
-    wsect(x, buf);
-    n -= n1;
-    off += n1;
-    p += n1;
-  }
-  din.size = xint(off);
-  winode(inum, &din);
-}
diff -ruN xv6-public/mmu.h xv6-public_new/mmu.h
--- xv6-public/mmu.h	2021-09-30 23:28:57.730394100 +0530
+++ xv6-public_new/mmu.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,181 +0,0 @@
-// This file contains definitions for the
-// x86 memory management unit (MMU).
-
-// Eflags register
-#define FL_IF           0x00000200      // Interrupt Enable
-
-// Control Register flags
-#define CR0_PE          0x00000001      // Protection Enable
-#define CR0_WP          0x00010000      // Write Protect
-#define CR0_PG          0x80000000      // Paging
-
-#define CR4_PSE         0x00000010      // Page size extension
-
-// various segment selectors.
-#define SEG_KCODE 1  // kernel code
-#define SEG_KDATA 2  // kernel data+stack
-#define SEG_UCODE 3  // user code
-#define SEG_UDATA 4  // user data+stack
-#define SEG_TSS   5  // this process's task state
-
-// cpu->gdt[NSEGS] holds the above segments.
-#define NSEGS     6
-
-#ifndef __ASSEMBLER__
-// Segment Descriptor
-struct segdesc {
-  uint lim_15_0 : 16;  // Low bits of segment limit
-  uint base_15_0 : 16; // Low bits of segment base address
-  uint base_23_16 : 8; // Middle bits of segment base address
-  uint type : 4;       // Segment type (see STS_ constants)
-  uint s : 1;          // 0 = system, 1 = application
-  uint dpl : 2;        // Descriptor Privilege Level
-  uint p : 1;          // Present
-  uint lim_19_16 : 4;  // High bits of segment limit
-  uint avl : 1;        // Unused (available for software use)
-  uint rsv1 : 1;       // Reserved
-  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
-  uint g : 1;          // Granularity: limit scaled by 4K when set
-  uint base_31_24 : 8; // High bits of segment base address
-};
-
-// Normal segment
-#define SEG(type, base, lim, dpl) (struct segdesc)    \
-{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
-  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
-#define SEG16(type, base, lim, dpl) (struct segdesc)  \
-{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
-  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
-#endif
-
-#define DPL_USER    0x3     // User DPL
-
-// Application segment type bits
-#define STA_X       0x8     // Executable segment
-#define STA_W       0x2     // Writeable (non-executable segments)
-#define STA_R       0x2     // Readable (executable segments)
-
-// System segment type bits
-#define STS_T32A    0x9     // Available 32-bit TSS
-#define STS_IG32    0xE     // 32-bit Interrupt Gate
-#define STS_TG32    0xF     // 32-bit Trap Gate
-
-// A virtual address 'la' has a three-part structure as follows:
-//
-// +--------10------+-------10-------+---------12----------+
-// | Page Directory |   Page Table   | Offset within Page  |
-// |      Index     |      Index     |                     |
-// +----------------+----------------+---------------------+
-//  \--- PDX(va) --/ \--- PTX(va) --/
-
-// page directory index
-#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
-
-// page table index
-#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
-
-// construct virtual address from indexes and offset
-#define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
-
-// Page directory and page table constants.
-#define NPDENTRIES      1024    // # directory entries per page directory
-#define NPTENTRIES      1024    // # PTEs per page table
-#define PGSIZE          4096    // bytes mapped by a page
-
-#define PTXSHIFT        12      // offset of PTX in a linear address
-#define PDXSHIFT        22      // offset of PDX in a linear address
-
-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
-
-// Page table/directory entry flags.
-#define PTE_P           0x001   // Present
-#define PTE_W           0x002   // Writeable
-#define PTE_U           0x004   // User
-#define PTE_PS          0x080   // Page Size
-
-// Address in page table or page directory entry
-#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
-
-#ifndef __ASSEMBLER__
-typedef uint pte_t;
-
-// Task state segment format
-struct taskstate {
-  uint link;         // Old ts selector
-  uint esp0;         // Stack pointers and segment selectors
-  ushort ss0;        //   after an increase in privilege level
-  ushort padding1;
-  uint *esp1;
-  ushort ss1;
-  ushort padding2;
-  uint *esp2;
-  ushort ss2;
-  ushort padding3;
-  void *cr3;         // Page directory base
-  uint *eip;         // Saved state from last task switch
-  uint eflags;
-  uint eax;          // More saved state (registers)
-  uint ecx;
-  uint edx;
-  uint ebx;
-  uint *esp;
-  uint *ebp;
-  uint esi;
-  uint edi;
-  ushort es;         // Even more saved state (segment selectors)
-  ushort padding4;
-  ushort cs;
-  ushort padding5;
-  ushort ss;
-  ushort padding6;
-  ushort ds;
-  ushort padding7;
-  ushort fs;
-  ushort padding8;
-  ushort gs;
-  ushort padding9;
-  ushort ldt;
-  ushort padding10;
-  ushort t;          // Trap on task switch
-  ushort iomb;       // I/O map base address
-};
-
-// Gate descriptors for interrupts and traps
-struct gatedesc {
-  uint off_15_0 : 16;   // low 16 bits of offset in segment
-  uint cs : 16;         // code segment selector
-  uint args : 5;        // # args, 0 for interrupt/trap gates
-  uint rsv1 : 3;        // reserved(should be zero I guess)
-  uint type : 4;        // type(STS_{IG32,TG32})
-  uint s : 1;           // must be 0 (system)
-  uint dpl : 2;         // descriptor(meaning new) privilege level
-  uint p : 1;           // Present
-  uint off_31_16 : 16;  // high bits of offset in segment
-};
-
-// Set up a normal interrupt/trap gate descriptor.
-// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
-//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
-// - sel: Code segment selector for interrupt/trap handler
-// - off: Offset in code segment for interrupt/trap handler
-// - dpl: Descriptor Privilege Level -
-//        the privilege level required for software to invoke
-//        this interrupt/trap gate explicitly using an int instruction.
-#define SETGATE(gate, istrap, sel, off, d)                \
-{                                                         \
-  (gate).off_15_0 = (uint)(off) & 0xffff;                \
-  (gate).cs = (sel);                                      \
-  (gate).args = 0;                                        \
-  (gate).rsv1 = 0;                                        \
-  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
-  (gate).s = 0;                                           \
-  (gate).dpl = (d);                                       \
-  (gate).p = 1;                                           \
-  (gate).off_31_16 = (uint)(off) >> 16;                  \
-}
-
-#endif
diff -ruN xv6-public/mp.c xv6-public_new/mp.c
--- xv6-public/mp.c	2021-09-30 23:28:57.732394100 +0530
+++ xv6-public_new/mp.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,139 +0,0 @@
-// Multiprocessor support
-// Search memory for MP description structures.
-// http://developer.intel.com/design/pentium/datashts/24201606.pdf
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mp.h"
-#include "x86.h"
-#include "mmu.h"
-#include "proc.h"
-
-struct cpu cpus[NCPU];
-int ncpu;
-uchar ioapicid;
-
-static uchar
-sum(uchar *addr, int len)
-{
-  int i, sum;
-
-  sum = 0;
-  for(i=0; i<len; i++)
-    sum += addr[i];
-  return sum;
-}
-
-// Look for an MP structure in the len bytes at addr.
-static struct mp*
-mpsearch1(uint a, int len)
-{
-  uchar *e, *p, *addr;
-
-  addr = P2V(a);
-  e = addr+len;
-  for(p = addr; p < e; p += sizeof(struct mp))
-    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
-      return (struct mp*)p;
-  return 0;
-}
-
-// Search for the MP Floating Pointer Structure, which according to the
-// spec is in one of the following three locations:
-// 1) in the first KB of the EBDA;
-// 2) in the last KB of system base memory;
-// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
-static struct mp*
-mpsearch(void)
-{
-  uchar *bda;
-  uint p;
-  struct mp *mp;
-
-  bda = (uchar *) P2V(0x400);
-  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
-    if((mp = mpsearch1(p, 1024)))
-      return mp;
-  } else {
-    p = ((bda[0x14]<<8)|bda[0x13])*1024;
-    if((mp = mpsearch1(p-1024, 1024)))
-      return mp;
-  }
-  return mpsearch1(0xF0000, 0x10000);
-}
-
-// Search for an MP configuration table.  For now,
-// don't accept the default configurations (physaddr == 0).
-// Check for correct signature, calculate the checksum and,
-// if correct, check the version.
-// To do: check extended table checksum.
-static struct mpconf*
-mpconfig(struct mp **pmp)
-{
-  struct mpconf *conf;
-  struct mp *mp;
-
-  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
-    return 0;
-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
-  if(memcmp(conf, "PCMP", 4) != 0)
-    return 0;
-  if(conf->version != 1 && conf->version != 4)
-    return 0;
-  if(sum((uchar*)conf, conf->length) != 0)
-    return 0;
-  *pmp = mp;
-  return conf;
-}
-
-void
-mpinit(void)
-{
-  uchar *p, *e;
-  int ismp;
-  struct mp *mp;
-  struct mpconf *conf;
-  struct mpproc *proc;
-  struct mpioapic *ioapic;
-
-  if((conf = mpconfig(&mp)) == 0)
-    panic("Expect to run on an SMP");
-  ismp = 1;
-  lapic = (uint*)conf->lapicaddr;
-  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
-    switch(*p){
-    case MPPROC:
-      proc = (struct mpproc*)p;
-      if(ncpu < NCPU) {
-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
-        ncpu++;
-      }
-      p += sizeof(struct mpproc);
-      continue;
-    case MPIOAPIC:
-      ioapic = (struct mpioapic*)p;
-      ioapicid = ioapic->apicno;
-      p += sizeof(struct mpioapic);
-      continue;
-    case MPBUS:
-    case MPIOINTR:
-    case MPLINTR:
-      p += 8;
-      continue;
-    default:
-      ismp = 0;
-      break;
-    }
-  }
-  if(!ismp)
-    panic("Didn't find a suitable machine");
-
-  if(mp->imcrp){
-    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
-    // But it would on real hardware.
-    outb(0x22, 0x70);   // Select IMCR
-    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
-  }
-}
diff -ruN xv6-public/mp.h xv6-public_new/mp.h
--- xv6-public/mp.h	2021-09-30 23:28:57.734395000 +0530
+++ xv6-public_new/mp.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,56 +0,0 @@
-// See MultiProcessor Specification Version 1.[14]
-
-struct mp {             // floating pointer
-  uchar signature[4];           // "_MP_"
-  void *physaddr;               // phys addr of MP config table
-  uchar length;                 // 1
-  uchar specrev;                // [14]
-  uchar checksum;               // all bytes must add up to 0
-  uchar type;                   // MP system config type
-  uchar imcrp;
-  uchar reserved[3];
-};
-
-struct mpconf {         // configuration table header
-  uchar signature[4];           // "PCMP"
-  ushort length;                // total table length
-  uchar version;                // [14]
-  uchar checksum;               // all bytes must add up to 0
-  uchar product[20];            // product id
-  uint *oemtable;               // OEM table pointer
-  ushort oemlength;             // OEM table length
-  ushort entry;                 // entry count
-  uint *lapicaddr;              // address of local APIC
-  ushort xlength;               // extended table length
-  uchar xchecksum;              // extended table checksum
-  uchar reserved;
-};
-
-struct mpproc {         // processor table entry
-  uchar type;                   // entry type (0)
-  uchar apicid;                 // local APIC id
-  uchar version;                // local APIC verison
-  uchar flags;                  // CPU flags
-    #define MPBOOT 0x02           // This proc is the bootstrap processor.
-  uchar signature[4];           // CPU signature
-  uint feature;                 // feature flags from CPUID instruction
-  uchar reserved[8];
-};
-
-struct mpioapic {       // I/O APIC table entry
-  uchar type;                   // entry type (2)
-  uchar apicno;                 // I/O APIC id
-  uchar version;                // I/O APIC version
-  uchar flags;                  // I/O APIC flags
-  uint *addr;                  // I/O APIC address
-};
-
-// Table entry types
-#define MPPROC    0x00  // One per processor
-#define MPBUS     0x01  // One per bus
-#define MPIOAPIC  0x02  // One per I/O APIC
-#define MPIOINTR  0x03  // One per bus interrupt source
-#define MPLINTR   0x04  // One per system interrupt source
-
-//PAGEBREAK!
-// Blank page.
diff -ruN xv6-public/param.h xv6-public_new/param.h
--- xv6-public/param.h	2021-09-30 23:28:57.736396500 +0530
+++ xv6-public_new/param.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
-#define NPROC        64  // maximum number of processes
-#define KSTACKSIZE 4096  // size of per-process kernel stack
-#define NCPU          8  // maximum number of CPUs
-#define NOFILE       16  // open files per process
-#define NFILE       100  // open files per system
-#define NINODE       50  // maximum number of active i-nodes
-#define NDEV         10  // maximum major device number
-#define ROOTDEV       1  // device number of file system root disk
-#define MAXARG       32  // max exec arguments
-#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
-#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
-#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
-#define FSSIZE       1000  // size of file system in blocks
-
diff -ruN xv6-public/picirq.c xv6-public_new/picirq.c
--- xv6-public/picirq.c	2021-09-30 23:28:57.738391300 +0530
+++ xv6-public_new/picirq.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,19 +0,0 @@
-#include "types.h"
-#include "x86.h"
-#include "traps.h"
-
-// I/O Addresses of the two programmable interrupt controllers
-#define IO_PIC1         0x20    // Master (IRQs 0-7)
-#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
-
-// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
-void
-picinit(void)
-{
-  // mask all interrupts
-  outb(IO_PIC1+1, 0xFF);
-  outb(IO_PIC2+1, 0xFF);
-}
-
-//PAGEBREAK!
-// Blank page.
diff -ruN xv6-public/pipe.c xv6-public_new/pipe.c
--- xv6-public/pipe.c	2021-09-30 23:28:57.740394200 +0530
+++ xv6-public_new/pipe.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,121 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "mmu.h"
-#include "proc.h"
-#include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "file.h"
-
-#define PIPESIZE 512
-
-struct pipe {
-  struct spinlock lock;
-  char data[PIPESIZE];
-  uint nread;     // number of bytes read
-  uint nwrite;    // number of bytes written
-  int readopen;   // read fd is still open
-  int writeopen;  // write fd is still open
-};
-
-int
-pipealloc(struct file **f0, struct file **f1)
-{
-  struct pipe *p;
-
-  p = 0;
-  *f0 = *f1 = 0;
-  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
-    goto bad;
-  if((p = (struct pipe*)kalloc()) == 0)
-    goto bad;
-  p->readopen = 1;
-  p->writeopen = 1;
-  p->nwrite = 0;
-  p->nread = 0;
-  initlock(&p->lock, "pipe");
-  (*f0)->type = FD_PIPE;
-  (*f0)->readable = 1;
-  (*f0)->writable = 0;
-  (*f0)->pipe = p;
-  (*f1)->type = FD_PIPE;
-  (*f1)->readable = 0;
-  (*f1)->writable = 1;
-  (*f1)->pipe = p;
-  return 0;
-
-//PAGEBREAK: 20
- bad:
-  if(p)
-    kfree((char*)p);
-  if(*f0)
-    fileclose(*f0);
-  if(*f1)
-    fileclose(*f1);
-  return -1;
-}
-
-void
-pipeclose(struct pipe *p, int writable)
-{
-  acquire(&p->lock);
-  if(writable){
-    p->writeopen = 0;
-    wakeup(&p->nread);
-  } else {
-    p->readopen = 0;
-    wakeup(&p->nwrite);
-  }
-  if(p->readopen == 0 && p->writeopen == 0){
-    release(&p->lock);
-    kfree((char*)p);
-  } else
-    release(&p->lock);
-}
-
-//PAGEBREAK: 40
-int
-pipewrite(struct pipe *p, char *addr, int n)
-{
-  int i;
-
-  acquire(&p->lock);
-  for(i = 0; i < n; i++){
-    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
-      if(p->readopen == 0 || myproc()->killed){
-        release(&p->lock);
-        return -1;
-      }
-      wakeup(&p->nread);
-      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
-    }
-    p->data[p->nwrite++ % PIPESIZE] = addr[i];
-  }
-  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
-  release(&p->lock);
-  return n;
-}
-
-int
-piperead(struct pipe *p, char *addr, int n)
-{
-  int i;
-
-  acquire(&p->lock);
-  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
-    if(myproc()->killed){
-      release(&p->lock);
-      return -1;
-    }
-    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
-  }
-  for(i = 0; i < n; i++){  //DOC: piperead-copy
-    if(p->nread == p->nwrite)
-      break;
-    addr[i] = p->data[p->nread++ % PIPESIZE];
-  }
-  wakeup(&p->nwrite);  //DOC: piperead-wakeup
-  release(&p->lock);
-  return i;
-}
diff -ruN xv6-public/pr.pl xv6-public_new/pr.pl
--- xv6-public/pr.pl	2021-09-30 23:28:57.743396100 +0530
+++ xv6-public_new/pr.pl	1970-01-01 05:30:00.000000000 +0530
@@ -1,36 +0,0 @@
-#!/usr/bin/perl
-
-use POSIX qw(strftime);
-
-if($ARGV[0] eq "-h"){
-	shift @ARGV;
-	$h = $ARGV[0];
-	shift @ARGV;
-}else{
-	$h = $ARGV[0];
-}
-
-$page = 0;
-$now = strftime "%b %e %H:%M %Y", localtime;
-
-@lines = <>;
-for($i=0; $i<@lines; $i+=50){
-	print "\n\n";
-	++$page;
-	print "$now  $h  Page $page\n";
-	print "\n\n";
-	for($j=$i; $j<@lines && $j<$i +50; $j++){
-		$lines[$j] =~ s!//DOC.*!!;
-		print $lines[$j];
-	}
-	for(; $j<$i+50; $j++){
-		print "\n";
-	}
-	$sheet = "";
-	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
-		$sheet = "Sheet $1";
-	}
-	print "\n\n";
-	print "$sheet\n";
-	print "\n\n";
-}
diff -ruN xv6-public/printf.c xv6-public_new/printf.c
--- xv6-public/printf.c	2021-09-30 23:28:57.745392200 +0530
+++ xv6-public_new/printf.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,85 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-static void
-putc(int fd, char c)
-{
-  write(fd, &c, 1);
-}
-
-static void
-printint(int fd, int xx, int base, int sgn)
-{
-  static char digits[] = "0123456789ABCDEF";
-  char buf[16];
-  int i, neg;
-  uint x;
-
-  neg = 0;
-  if(sgn && xx < 0){
-    neg = 1;
-    x = -xx;
-  } else {
-    x = xx;
-  }
-
-  i = 0;
-  do{
-    buf[i++] = digits[x % base];
-  }while((x /= base) != 0);
-  if(neg)
-    buf[i++] = '-';
-
-  while(--i >= 0)
-    putc(fd, buf[i]);
-}
-
-// Print to the given fd. Only understands %d, %x, %p, %s.
-void
-printf(int fd, const char *fmt, ...)
-{
-  char *s;
-  int c, i, state;
-  uint *ap;
-
-  state = 0;
-  ap = (uint*)(void*)&fmt + 1;
-  for(i = 0; fmt[i]; i++){
-    c = fmt[i] & 0xff;
-    if(state == 0){
-      if(c == '%'){
-        state = '%';
-      } else {
-        putc(fd, c);
-      }
-    } else if(state == '%'){
-      if(c == 'd'){
-        printint(fd, *ap, 10, 1);
-        ap++;
-      } else if(c == 'x' || c == 'p'){
-        printint(fd, *ap, 16, 0);
-        ap++;
-      } else if(c == 's'){
-        s = (char*)*ap;
-        ap++;
-        if(s == 0)
-          s = "(null)";
-        while(*s != 0){
-          putc(fd, *s);
-          s++;
-        }
-      } else if(c == 'c'){
-        putc(fd, *ap);
-        ap++;
-      } else if(c == '%'){
-        putc(fd, c);
-      } else {
-        // Unknown % sequence.  Print it to draw attention.
-        putc(fd, '%');
-        putc(fd, c);
-      }
-      state = 0;
-    }
-  }
-}
diff -ruN xv6-public/printpcs xv6-public_new/printpcs
--- xv6-public/printpcs	2021-09-30 23:28:57.747396300 +0530
+++ xv6-public_new/printpcs	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
-#!/bin/sh
-
-# Decode the symbols from a panic EIP list
-
-# Find a working addr2line
-for p in i386-jos-elf-addr2line addr2line; do
-    if which $p 2>&1 >/dev/null && \
-       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
-        break
-    fi
-done
-
-# Enable as much pretty-printing as this addr2line can do
-$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
diff -ruN xv6-public/proc.c xv6-public_new/proc.c
--- xv6-public/proc.c	2021-09-30 23:28:57.750396200 +0530
+++ xv6-public_new/proc.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,534 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "x86.h"
-#include "proc.h"
-#include "spinlock.h"
-
-struct {
-  struct spinlock lock;
-  struct proc proc[NPROC];
-} ptable;
-
-static struct proc *initproc;
-
-int nextpid = 1;
-extern void forkret(void);
-extern void trapret(void);
-
-static void wakeup1(void *chan);
-
-void
-pinit(void)
-{
-  initlock(&ptable.lock, "ptable");
-}
-
-// Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
-}
-
-// Must be called with interrupts disabled to avoid the caller being
-// rescheduled between reading lapicid and running through the loop.
-struct cpu*
-mycpu(void)
-{
-  int apicid, i;
-  
-  if(readeflags()&FL_IF)
-    panic("mycpu called with interrupts enabled\n");
-  
-  apicid = lapicid();
-  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
-  // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
-    if (cpus[i].apicid == apicid)
-      return &cpus[i];
-  }
-  panic("unknown apicid\n");
-}
-
-// Disable interrupts so that we are not rescheduled
-// while reading proc from the cpu structure
-struct proc*
-myproc(void) {
-  struct cpu *c;
-  struct proc *p;
-  pushcli();
-  c = mycpu();
-  p = c->proc;
-  popcli();
-  return p;
-}
-
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
-static struct proc*
-allocproc(void)
-{
-  struct proc *p;
-  char *sp;
-
-  acquire(&ptable.lock);
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
-      goto found;
-
-  release(&ptable.lock);
-  return 0;
-
-found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
-
-  release(&ptable.lock);
-
-  // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
-    p->state = UNUSED;
-    return 0;
-  }
-  sp = p->kstack + KSTACKSIZE;
-
-  // Leave room for trap frame.
-  sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
-
-  // Set up new context to start executing at forkret,
-  // which returns to trapret.
-  sp -= 4;
-  *(uint*)sp = (uint)trapret;
-
-  sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
-  memset(p->context, 0, sizeof *p->context);
-  p->context->eip = (uint)forkret;
-
-  return p;
-}
-
-//PAGEBREAK: 32
-// Set up first user process.
-void
-userinit(void)
-{
-  struct proc *p;
-  extern char _binary_initcode_start[], _binary_initcode_size[];
-
-  p = allocproc();
-  
-  initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
-    panic("userinit: out of memory?");
-  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
-  p->sz = PGSIZE;
-  memset(p->tf, 0, sizeof(*p->tf));
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-  p->tf->es = p->tf->ds;
-  p->tf->ss = p->tf->ds;
-  p->tf->eflags = FL_IF;
-  p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
-
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-  p->cwd = namei("/");
-
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
-  acquire(&ptable.lock);
-
-  p->state = RUNNABLE;
-
-  release(&ptable.lock);
-}
-
-// Grow current process's memory by n bytes.
-// Return 0 on success, -1 on failure.
-int
-growproc(int n)
-{
-  uint sz;
-  struct proc *curproc = myproc();
-
-  sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
-  }
-  curproc->sz = sz;
-  switchuvm(curproc);
-  return 0;
-}
-
-// Create a new process copying p as the parent.
-// Sets up stack to return as if from system call.
-// Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
-{
-  int i, pid;
-  struct proc *np;
-  struct proc *curproc = myproc();
-
-  // Allocate process.
-  if((np = allocproc()) == 0){
-    return -1;
-  }
-
-  // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
-    kfree(np->kstack);
-    np->kstack = 0;
-    np->state = UNUSED;
-    return -1;
-  }
-  np->sz = curproc->sz;
-  np->parent = curproc;
-  *np->tf = *curproc->tf;
-
-  // Clear %eax so that fork returns 0 in the child.
-  np->tf->eax = 0;
-
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
-      np->ofile[i] = filedup(curproc->ofile[i]);
-  np->cwd = idup(curproc->cwd);
-
-  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
-
-  pid = np->pid;
-
-  acquire(&ptable.lock);
-
-  np->state = RUNNABLE;
-
-  release(&ptable.lock);
-
-  return pid;
-}
-
-// Exit the current process.  Does not return.
-// An exited process remains in the zombie state
-// until its parent calls wait() to find out it exited.
-void
-exit(void)
-{
-  struct proc *curproc = myproc();
-  struct proc *p;
-  int fd;
-
-  if(curproc == initproc)
-    panic("init exiting");
-
-  // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
-      fileclose(curproc->ofile[fd]);
-      curproc->ofile[fd] = 0;
-    }
-  }
-
-  begin_op();
-  iput(curproc->cwd);
-  end_op();
-  curproc->cwd = 0;
-
-  acquire(&ptable.lock);
-
-  // Parent might be sleeping in wait().
-  wakeup1(curproc->parent);
-
-  // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
-      p->parent = initproc;
-      if(p->state == ZOMBIE)
-        wakeup1(initproc);
-    }
-  }
-
-  // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
-  sched();
-  panic("zombie exit");
-}
-
-// Wait for a child process to exit and return its pid.
-// Return -1 if this process has no children.
-int
-wait(void)
-{
-  struct proc *p;
-  int havekids, pid;
-  struct proc *curproc = myproc();
-  
-  acquire(&ptable.lock);
-  for(;;){
-    // Scan through table looking for exited children.
-    havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
-        continue;
-      havekids = 1;
-      if(p->state == ZOMBIE){
-        // Found one.
-        pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
-        freevm(p->pgdir);
-        p->pid = 0;
-        p->parent = 0;
-        p->name[0] = 0;
-        p->killed = 0;
-        p->state = UNUSED;
-        release(&ptable.lock);
-        return pid;
-      }
-    }
-
-    // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
-      release(&ptable.lock);
-      return -1;
-    }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
-  }
-}
-
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
-void
-scheduler(void)
-{
-  struct proc *p;
-  struct cpu *c = mycpu();
-  c->proc = 0;
-  
-  for(;;){
-    // Enable interrupts on this processor.
-    sti();
-
-    // Loop over process table looking for process to run.
-    acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      c->proc = 0;
-    }
-    release(&ptable.lock);
-
-  }
-}
-
-// Enter scheduler.  Must hold only ptable.lock
-// and have changed proc->state. Saves and restores
-// intena because intena is a property of this
-// kernel thread, not this CPU. It should
-// be proc->intena and proc->ncli, but that would
-// break in the few places where a lock is held but
-// there's no process.
-void
-sched(void)
-{
-  int intena;
-  struct proc *p = myproc();
-
-  if(!holding(&ptable.lock))
-    panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
-    panic("sched locks");
-  if(p->state == RUNNING)
-    panic("sched running");
-  if(readeflags()&FL_IF)
-    panic("sched interruptible");
-  intena = mycpu()->intena;
-  swtch(&p->context, mycpu()->scheduler);
-  mycpu()->intena = intena;
-}
-
-// Give up the CPU for one scheduling round.
-void
-yield(void)
-{
-  acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
-  sched();
-  release(&ptable.lock);
-}
-
-// A fork child's very first scheduling by scheduler()
-// will swtch here.  "Return" to user space.
-void
-forkret(void)
-{
-  static int first = 1;
-  // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
-
-  if (first) {
-    // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot
-    // be run from main().
-    first = 0;
-    iinit(ROOTDEV);
-    initlog(ROOTDEV);
-  }
-
-  // Return to "caller", actually trapret (see allocproc).
-}
-
-// Atomically release lock and sleep on chan.
-// Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
-{
-  struct proc *p = myproc();
-  
-  if(p == 0)
-    panic("sleep");
-
-  if(lk == 0)
-    panic("sleep without lk");
-
-  // Must acquire ptable.lock in order to
-  // change p->state and then call sched.
-  // Once we hold ptable.lock, we can be
-  // guaranteed that we won't miss any wakeup
-  // (wakeup runs with ptable.lock locked),
-  // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
-    release(lk);
-  }
-  // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
-
-  sched();
-
-  // Tidy up.
-  p->chan = 0;
-
-  // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
-    release(&ptable.lock);
-    acquire(lk);
-  }
-}
-
-//PAGEBREAK!
-// Wake up all processes sleeping on chan.
-// The ptable lock must be held.
-static void
-wakeup1(void *chan)
-{
-  struct proc *p;
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
-}
-
-// Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
-{
-  acquire(&ptable.lock);
-  wakeup1(chan);
-  release(&ptable.lock);
-}
-
-// Kill the process with the given pid.
-// Process won't exit until it returns
-// to user space (see trap in trap.c).
-int
-kill(int pid)
-{
-  struct proc *p;
-
-  acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
-      p->killed = 1;
-      // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
-        p->state = RUNNABLE;
-      release(&ptable.lock);
-      return 0;
-    }
-  }
-  release(&ptable.lock);
-  return -1;
-}
-
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
-{
-  static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
-  int i;
-  struct proc *p;
-  char *state;
-  uint pc[10];
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
-      continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
-    }
-    cprintf("\n");
-  }
-}
diff -ruN xv6-public/proc.h xv6-public_new/proc.h
--- xv6-public/proc.h	2021-09-30 23:28:57.752394400 +0530
+++ xv6-public_new/proc.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,58 +0,0 @@
-// Per-CPU state
-struct cpu {
-  uchar apicid;                // Local APIC ID
-  struct context *scheduler;   // swtch() here to enter scheduler
-  struct taskstate ts;         // Used by x86 to find stack for interrupt
-  struct segdesc gdt[NSEGS];   // x86 global descriptor table
-  volatile uint started;       // Has the CPU started?
-  int ncli;                    // Depth of pushcli nesting.
-  int intena;                  // Were interrupts enabled before pushcli?
-  struct proc *proc;           // The process running on this cpu or null
-};
-
-extern struct cpu cpus[NCPU];
-extern int ncpu;
-
-//PAGEBREAK: 17
-// Saved registers for kernel context switches.
-// Don't need to save all the segment registers (%cs, etc),
-// because they are constant across kernel contexts.
-// Don't need to save %eax, %ecx, %edx, because the
-// x86 convention is that the caller has saved them.
-// Contexts are stored at the bottom of the stack they
-// describe; the stack pointer is the address of the context.
-// The layout of the context matches the layout of the stack in swtch.S
-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
-// but it is on the stack and allocproc() manipulates it.
-struct context {
-  uint edi;
-  uint esi;
-  uint ebx;
-  uint ebp;
-  uint eip;
-};
-
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
-
-// Per-process state
-struct proc {
-  uint sz;                     // Size of process memory (bytes)
-  pde_t* pgdir;                // Page table
-  char *kstack;                // Bottom of kernel stack for this process
-  enum procstate state;        // Process state
-  int pid;                     // Process ID
-  struct proc *parent;         // Parent process
-  struct trapframe *tf;        // Trap frame for current syscall
-  struct context *context;     // swtch() here to run process
-  void *chan;                  // If non-zero, sleeping on chan
-  int killed;                  // If non-zero, have been killed
-  struct file *ofile[NOFILE];  // Open files
-  struct inode *cwd;           // Current directory
-  char name[16];               // Process name (debugging)
-};
-
-// Process memory is laid out contiguously, low addresses first:
-//   text
-//   original data and bss
-//   fixed-size stack
-//   expandable heap
diff -ruN xv6-public/rm.c xv6-public_new/rm.c
--- xv6-public/rm.c	2021-09-30 23:28:57.754392300 +0530
+++ xv6-public_new/rm.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,23 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(int argc, char *argv[])
-{
-  int i;
-
-  if(argc < 2){
-    printf(2, "Usage: rm files...\n");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if(unlink(argv[i]) < 0){
-      printf(2, "rm: %s failed to delete\n", argv[i]);
-      break;
-    }
-  }
-
-  exit();
-}
diff -ruN xv6-public/runoff xv6-public_new/runoff
--- xv6-public/runoff	2021-09-30 23:28:57.756394100 +0530
+++ xv6-public_new/runoff	1970-01-01 05:30:00.000000000 +0530
@@ -1,246 +0,0 @@
-#!/bin/sh
-
-echo This script takes a minute to run.  Be patient. 1>&2
-
-LC_CTYPE=C export LC_CTYPE
-
-# pad stdin to multiple of 120 lines
-pad()
-{
-	awk '{print} END{for(; NR%120!=0; NR++) print ""}'
-}
-
-# create formatted (numbered) files
-mkdir -p fmt
-rm -f fmt/*
-cp README fmt
-echo > fmt/blank
-files=`grep -v '^#' runoff.list | awk '{print $1}'`
-n=99
-for i in $files
-do
-	./runoff1 -n $n $i >fmt/$i
-	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
-	if [ "x$nn" != x ]; then
-		n=$nn
-	fi
-done
-
-# create table of contents
-cat toc.hdr >fmt/toc
-pr -e8 -t runoff.list | awk '
-/^[a-z0-9]/ {
-	s=$0
-	f="fmt/"$1
-	getline<f
-	close(f)
-	n=$1
-	printf("%02d %s\n", n/100, s);
-	printf("TOC: %04d %s\n", n, s) >"fmt/tocdata"
-	next
-}
-{
-	print
-}' | pr -3 -t >>fmt/toc
-cat toc.ftr >>fmt/toc
-
-# check for bad alignments
-perl -e '
-	$leftwarn = 0;
-	while(<>){
-		chomp;
-		s!#.*!!;
-		s!\s+! !g;
-		s! +$!!;
-		next if /^$/;
-		
-		if(/TOC: (\d+) (.*)/){
-			$toc{$2} = $1;
-			next;
-		}
-		
-		if(/sheet1: (left|right)$/){
-			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
-			$left = $1 eq "left" ? "13579" : "02468";
-			$right = $1 eq "left" ? "02468" : "13579";
-			next;
-		}
-		
-		if(/even: (.*)/){
-			$file = $1;
-			if(!defined($toc{$file})){
-				print STDERR "Have no toc for $file\n";
-				next;
-			}
-			if($toc{$file} =~ /^\d\d[^0]/){
-				print STDERR "$file does not start on a fresh page.\n";
-			}
-			next;
-		}
-		
-		if(/odd: (.*)/){
-			$file = $1;
-			if(!defined($toc{$file})){
-				print STDERR "Have no toc for $file\n";
-				next;
-			}
-			if($toc{$file} !~ /^\d\d5/){
-				print STDERR "$file does not start on a second half page.\n";
-			}
-			next;
-		}
-		
-		if(/(left|right): (.*)/){
-			$what = $1;
-			$file = $2;
-			if(!defined($toc{$file})){
-				print STDERR "Have no toc for $file\n";
-				next;
-			}
-			if($what eq "left" && !($toc{$file} =~ /^\d[$left][05]/)){
-				print STDERR "$file does not start on a left page [$toc{$file}]\n";
-			}
-			# why does this not work if I inline $x in the if?
-			$x = ($toc{$file} =~ /^\d[$right][05]/);
-			if($what eq "right" && !$x){
-				print STDERR "$file does not start on a right page [$toc{$file}] [$x]\n";
-			}
-			next;
-		}
-		
-		print STDERR "Unknown spec: $_\n";
-	}
-' fmt/tocdata runoff.spec
-
-# make definition list
-cd fmt
-perl -e '
-	while(<>) {
-		chomp;
-
-		s!//.*!!;
-		s!/\*([^*]|[*][^/])*\*/!!g;
-		s!\s! !g;
-		s! +$!!;
-
-		# look for declarations like char* x;
-		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
-			next;
-		}
-		if (/^[0-9]+ extern/) {
-			next;
-		}
-		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
-			next;
-		}
-		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
-			print "$1 $2\n"
-		}
-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
-			print "$1 $2 $3\n";
-		}
-		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
-			print "$1 $2\n";
-		}
-		
-		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
-			$isglobl{$2} = 1;
-		}
-		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
-			print "$1 $2\n";
-		}
-		
-		if (/\(/) {
-			next;
-		}
-
-		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
-			print "$1 $7\n";
-		}
-		
-		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
-			print "$1 $3\n";
-		}
-		# TODO: enum members
-	}
-' $files >defs
-
-(for i in $files
-do
-	case "$i" in
-	*.S)
-		cat $i | sed 's;#.*;;; s;//.*;;;'
-		;;
-	*)
-		cat $i | sed 's;//.*;;; s;"([^"\\]|\\.)*";;;'
-	esac
-done
-) >alltext
-
-perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
-	egrep -v ' (STUB|usage|main|if|for)$' >>defs
-#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
-#	>>defs
-(
->s.defs
-
-# make reference list
-for i in `awk '{print $2}' defs | sort -f | uniq`
-do
-	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
-	echo $i $defs >>s.defs
-	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
-	if [ "x$defs" != "x$uses" ]; then
-		echo $i $defs
-		echo $uses |fmt -29 | sed 's/^/    /'
-#	else
-#		echo $i defined but not used >&2
-	fi
-done
-) >refs
-
-# build defs list
-awk '
-{
-	printf("%04d %s\n", $2, $1);
-	for(i=3; i<=NF; i++)
-		printf("%04d    \" \n", $i);
-}
-' s.defs > t.defs
-
-# format the whole thing
-(
-	../pr.pl README
-	../pr.pl -h "table of contents" toc
-	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
-	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
-	# pr.pl -h "definitions" -2 t.defs | pad
-	# pr.pl -h "cross-references" -2 refs | pad
-	../pr.pl blank  # make sheet 1 start on left page
-	../pr.pl blank
-	for i in $files
-	do
-		../pr.pl -h "xv6/$i" $i
-	done
-) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
-grep Pages: all.ps
-
-# if we have the nice font, use it
-nicefont=LucidaSans-Typewriter83
-if [ ! -f ../$nicefont ]
-then
-	if git cat-file blob font:$nicefont > ../$nicefont~; then
-		mv ../$nicefont~ ../$nicefont
-	fi
-fi
-if [ -f ../$nicefont ]
-then
-	echo nicefont
-	(sed 1q all.ps; cat ../$nicefont; sed "1d; s/Courier/$nicefont/" all.ps) >allf.ps
-else
-	echo ugly font!
-	cp all.ps allf.ps
-fi
-ps2pdf allf.ps ../xv6.pdf
-# cd ..
-# pdftops xv6.pdf xv6.ps
diff -ruN xv6-public/runoff.list xv6-public_new/runoff.list
--- xv6-public/runoff.list	2021-09-30 23:28:57.758392400 +0530
+++ xv6-public_new/runoff.list	1970-01-01 05:30:00.000000000 +0530
@@ -1,80 +0,0 @@
-# basic headers
-types.h
-param.h
-memlayout.h
-defs.h
-x86.h
-asm.h
-mmu.h
-elf.h
-date.h
-
-# entering xv6
-entry.S
-entryother.S
-main.c
-
-# locks
-spinlock.h
-spinlock.c
-
-# processes
-vm.c
-proc.h
-proc.c
-swtch.S
-kalloc.c
-
-# system calls
-traps.h
-vectors.pl
-trapasm.S
-trap.c
-syscall.h
-syscall.c
-sysproc.c
-
-# file system
-buf.h
-sleeplock.h
-fcntl.h
-stat.h
-fs.h
-file.h
-ide.c
-bio.c
-sleeplock.c
-log.c
-fs.c
-file.c
-sysfile.c
-exec.c
-
-# pipes
-pipe.c
-
-# string operations
-string.c
-
-# low-level hardware
-mp.h
-mp.c
-lapic.c
-ioapic.c
-kbd.h
-kbd.c
-console.c
-uart.c
-
-# user-level
-initcode.S
-usys.S
-init.c
-sh.c
-
-# bootloader
-bootasm.S
-bootmain.c
-
-# link
-kernel.ld
diff -ruN xv6-public/runoff.spec xv6-public_new/runoff.spec
--- xv6-public/runoff.spec	2021-09-30 23:28:57.760392100 +0530
+++ xv6-public_new/runoff.spec	1970-01-01 05:30:00.000000000 +0530
@@ -1,102 +0,0 @@
-# Is sheet 01 (after the TOC) a left sheet or a right sheet?
-sheet1: left
-
-# "left" and "right" specify which page of a two-page spread a file
-# must start on.  "left" means that a file must start on the first of
-# the two pages.  "right" means it must start on the second of the two
-# pages.  The file may start in either column.
-#
-# "even" and "odd" specify which column a file must start on.  "even"
-# means it must start in the left of the two columns (00).  "odd" means it
-# must start in the right of the two columns (50).
-#
-# You'd think these would be the other way around.
-
-# types.h either
-# param.h either
-# defs.h either
-# x86.h either
-# asm.h either
-# mmu.h either
-# elf.h either
-# mp.h either
-
-even: entry.S  # mild preference
-even: entryother.S  # mild preference
-even: main.c
-# mp.c don't care at all
-# even: initcode.S
-# odd: init.c
-
-left: spinlock.h
-even: spinlock.h
-
-# This gets struct proc and allocproc on the same spread
-left: proc.h
-even: proc.h
-
-# goal is to have two action-packed 2-page spreads,
-# one with
-#     userinit growproc fork exit wait
-# and another with
-#     scheduler sched yield forkret sleep wakeup1 wakeup
-right: proc.c   # VERY important
-even: proc.c   # VERY important
-
-# A few more action packed spreads
-# page table creation and process loading
-#     walkpgdir mappages setupkvm switch[ku]vm inituvm (loaduvm)
-# process memory management
-#     allocuvm deallocuvm freevm
-left: vm.c
-
-even: kalloc.c  # mild preference
-
-# syscall.h either
-# trapasm.S either
-# traps.h either
-# even: trap.c
-# vectors.pl either
-# syscall.c either
-# sysproc.c either
-
-# buf.h either
-# dev.h either
-# fcntl.h either
-# stat.h either
-# file.h either
-# fs.h either
-# fsvar.h either
-# left: ide.c # mild preference
-even: ide.c
-# odd: bio.c
-
-# log.c fits nicely in a spread
-even: log.c
-left: log.c
-
-# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
-#	ialloc iupdate iget idup ilock iunlock iput iunlockput
-#	bmap itrunc stati readi writei
-#	namecmp dirlookup dirlink skipelem namex namei
-#	fileinit filealloc filedup fileclose filestat fileread filewrite
-# starting on 2nd column of a right page is not terrible either
-odd: fs.c   # VERY important
-left: fs.c  # mild preference
-# file.c either
-# exec.c either
-# sysfile.c either
-
-# Mild preference, but makes spreads of mp.c, lapic.c, and ioapic.c+picirq.c
-even: mp.c
-left: mp.c
-
-# even: pipe.c  # mild preference
-# string.c either
-# left: kbd.h  # mild preference
-even: kbd.h
-even: console.c
-odd: sh.c
-
-even: bootasm.S   # mild preference
-even: bootmain.c  # mild preference
diff -ruN xv6-public/runoff1 xv6-public_new/runoff1
--- xv6-public/runoff1	2021-09-30 23:28:57.762393600 +0530
+++ xv6-public_new/runoff1	1970-01-01 05:30:00.000000000 +0530
@@ -1,108 +0,0 @@
-#!/usr/bin/perl
-
-$n = 0;
-$v = 0;
-if($ARGV[0] eq "-v") {
-	$v = 1;
-	shift @ARGV;
-}
-if($ARGV[0] eq "-n") {
-	$n = $ARGV[1];
-	shift @ARGV;
-	shift @ARGV;
-}
-$n = int(($n+49)/50)*50 - 1;
-
-$file = $ARGV[0];
-@lines = <>;
-$linenum = 0;
-foreach (@lines) {
-	$linenum++;
-	chomp;
-	s/\s+$//;
-	if(length() >= 75){
-		print STDERR "$file:$linenum: line too long\n";
-	}
-}
-@outlines = ();
-$nextout = 0;
-
-for($i=0; $i<@lines; ){
-	# Skip leading blank lines.
-	$i++ while $i<@lines && $lines[$i] =~ /^$/;
-	last if $i>=@lines;
-
-	# If the rest of the file fits, use the whole thing.
-	if(@lines <= $i+50 && !grep { /PAGEBREAK/ } @lines){
-		$breakbefore = @lines;
-	}else{
-		# Find a good next page break;
-		# Hope for end of function.
-		# but settle for a blank line (but not first blank line
-		# in function, which comes after variable declarations).
-		$breakbefore = $i;
-		$lastblank = $i;
-		$sawbrace = 0;
-		$breaksize = 15;  # 15 lines to get to function
-		for($j=$i; $j<$i+50 && $j < @lines; $j++){
-			if($lines[$j] =~ /PAGEBREAK!/){
-				$lines[$j] = "";
-				$breakbefore = $j;
-				$breaksize = 100;
-				last;
-			}
-			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
-				$breaksize = $1;
-				$breakbefore = $j;
-				$lines[$j] = "";
-			}
-			if($lines[$j] =~ /^};?$/){
-				$breakbefore = $j+1;
-				$breaksize = 15;
-			}
-			if($lines[$j] =~ /^{$/){
-				$sawbrace = 1;
-			}
-			if($lines[$j] =~ /^$/){
-				if($sawbrace){
-					$sawbrace = 0;
-				}else{
-					$lastblank = $j;
-				}
-			}
-		}
-		if($j<@lines && $lines[$j] =~ /^$/){
-			$lastblank = $j;
-		}
-
-		# If we are not putting enough on a page, try a blank line.
-		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
-			if($v){
-				print STDERR "breakbefore $breakbefore i $i breaksize $breaksize\n";
-			}
-			$breakbefore = $lastblank;
-			$breaksize = 5;  # only 5 lines to get to blank line
-		}
-
-		# If we are not putting enough on a page, force a full page.
-		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
-			$breakbefore = $i + 50;
-			$breakbefore = @lines if @lines < $breakbefore;
-		}
-
-		if($breakbefore < $i+2){
-			$breakbefore = $i+2;
-		}
-	}
-
-	# Emit the page.
-	$i50 = $i + 50;
-	for(; $i<$breakbefore; $i++){
-		printf "%04d %s\n", ++$n, $lines[$i];
-	}
-
-	# Finish page
-	for($j=$i; $j<$i50; $j++){
-		printf "%04d \n", ++$n;
-	}
-}
diff -ruN xv6-public/sh.c xv6-public_new/sh.c
--- xv6-public/sh.c	2021-09-30 23:28:57.764394400 +0530
+++ xv6-public_new/sh.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,493 +0,0 @@
-// Shell.
-
-#include "types.h"
-#include "user.h"
-#include "fcntl.h"
-
-// Parsed command representation
-#define EXEC  1
-#define REDIR 2
-#define PIPE  3
-#define LIST  4
-#define BACK  5
-
-#define MAXARGS 10
-
-struct cmd {
-  int type;
-};
-
-struct execcmd {
-  int type;
-  char *argv[MAXARGS];
-  char *eargv[MAXARGS];
-};
-
-struct redircmd {
-  int type;
-  struct cmd *cmd;
-  char *file;
-  char *efile;
-  int mode;
-  int fd;
-};
-
-struct pipecmd {
-  int type;
-  struct cmd *left;
-  struct cmd *right;
-};
-
-struct listcmd {
-  int type;
-  struct cmd *left;
-  struct cmd *right;
-};
-
-struct backcmd {
-  int type;
-  struct cmd *cmd;
-};
-
-int fork1(void);  // Fork but panics on failure.
-void panic(char*);
-struct cmd *parsecmd(char*);
-
-// Execute cmd.  Never returns.
-void
-runcmd(struct cmd *cmd)
-{
-  int p[2];
-  struct backcmd *bcmd;
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-    exit();
-
-  switch(cmd->type){
-  default:
-    panic("runcmd");
-
-  case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    if(ecmd->argv[0] == 0)
-      exit();
-    exec(ecmd->argv[0], ecmd->argv);
-    printf(2, "exec %s failed\n", ecmd->argv[0]);
-    break;
-
-  case REDIR:
-    rcmd = (struct redircmd*)cmd;
-    close(rcmd->fd);
-    if(open(rcmd->file, rcmd->mode) < 0){
-      printf(2, "open %s failed\n", rcmd->file);
-      exit();
-    }
-    runcmd(rcmd->cmd);
-    break;
-
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    if(fork1() == 0)
-      runcmd(lcmd->left);
-    wait();
-    runcmd(lcmd->right);
-    break;
-
-  case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    if(pipe(p) < 0)
-      panic("pipe");
-    if(fork1() == 0){
-      close(1);
-      dup(p[1]);
-      close(p[0]);
-      close(p[1]);
-      runcmd(pcmd->left);
-    }
-    if(fork1() == 0){
-      close(0);
-      dup(p[0]);
-      close(p[0]);
-      close(p[1]);
-      runcmd(pcmd->right);
-    }
-    close(p[0]);
-    close(p[1]);
-    wait();
-    wait();
-    break;
-
-  case BACK:
-    bcmd = (struct backcmd*)cmd;
-    if(fork1() == 0)
-      runcmd(bcmd->cmd);
-    break;
-  }
-  exit();
-}
-
-int
-getcmd(char *buf, int nbuf)
-{
-  printf(2, "$ ");
-  memset(buf, 0, nbuf);
-  gets(buf, nbuf);
-  if(buf[0] == 0) // EOF
-    return -1;
-  return 0;
-}
-
-int
-main(void)
-{
-  static char buf[100];
-  int fd;
-
-  // Ensure that three file descriptors are open.
-  while((fd = open("console", O_RDWR)) >= 0){
-    if(fd >= 3){
-      close(fd);
-      break;
-    }
-  }
-
-  // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
-    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      // Chdir must be called by the parent, not the child.
-      buf[strlen(buf)-1] = 0;  // chop \n
-      if(chdir(buf+3) < 0)
-        printf(2, "cannot cd %s\n", buf+3);
-      continue;
-    }
-    if(fork1() == 0)
-      runcmd(parsecmd(buf));
-    wait();
-  }
-  exit();
-}
-
-void
-panic(char *s)
-{
-  printf(2, "%s\n", s);
-  exit();
-}
-
-int
-fork1(void)
-{
-  int pid;
-
-  pid = fork();
-  if(pid == -1)
-    panic("fork");
-  return pid;
-}
-
-//PAGEBREAK!
-// Constructors
-
-struct cmd*
-execcmd(void)
-{
-  struct execcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = EXEC;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
-{
-  struct redircmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = REDIR;
-  cmd->cmd = subcmd;
-  cmd->file = file;
-  cmd->efile = efile;
-  cmd->mode = mode;
-  cmd->fd = fd;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-pipecmd(struct cmd *left, struct cmd *right)
-{
-  struct pipecmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = PIPE;
-  cmd->left = left;
-  cmd->right = right;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-listcmd(struct cmd *left, struct cmd *right)
-{
-  struct listcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = LIST;
-  cmd->left = left;
-  cmd->right = right;
-  return (struct cmd*)cmd;
-}
-
-struct cmd*
-backcmd(struct cmd *subcmd)
-{
-  struct backcmd *cmd;
-
-  cmd = malloc(sizeof(*cmd));
-  memset(cmd, 0, sizeof(*cmd));
-  cmd->type = BACK;
-  cmd->cmd = subcmd;
-  return (struct cmd*)cmd;
-}
-//PAGEBREAK!
-// Parsing
-
-char whitespace[] = " \t\r\n\v";
-char symbols[] = "<|>&;()";
-
-int
-gettoken(char **ps, char *es, char **q, char **eq)
-{
-  char *s;
-  int ret;
-
-  s = *ps;
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  if(q)
-    *q = s;
-  ret = *s;
-  switch(*s){
-  case 0:
-    break;
-  case '|':
-  case '(':
-  case ')':
-  case ';':
-  case '&':
-  case '<':
-    s++;
-    break;
-  case '>':
-    s++;
-    if(*s == '>'){
-      ret = '+';
-      s++;
-    }
-    break;
-  default:
-    ret = 'a';
-    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
-      s++;
-    break;
-  }
-  if(eq)
-    *eq = s;
-
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  *ps = s;
-  return ret;
-}
-
-int
-peek(char **ps, char *es, char *toks)
-{
-  char *s;
-
-  s = *ps;
-  while(s < es && strchr(whitespace, *s))
-    s++;
-  *ps = s;
-  return *s && strchr(toks, *s);
-}
-
-struct cmd *parseline(char**, char*);
-struct cmd *parsepipe(char**, char*);
-struct cmd *parseexec(char**, char*);
-struct cmd *nulterminate(struct cmd*);
-
-struct cmd*
-parsecmd(char *s)
-{
-  char *es;
-  struct cmd *cmd;
-
-  es = s + strlen(s);
-  cmd = parseline(&s, es);
-  peek(&s, es, "");
-  if(s != es){
-    printf(2, "leftovers: %s\n", s);
-    panic("syntax");
-  }
-  nulterminate(cmd);
-  return cmd;
-}
-
-struct cmd*
-parseline(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  cmd = parsepipe(ps, es);
-  while(peek(ps, es, "&")){
-    gettoken(ps, es, 0, 0);
-    cmd = backcmd(cmd);
-  }
-  if(peek(ps, es, ";")){
-    gettoken(ps, es, 0, 0);
-    cmd = listcmd(cmd, parseline(ps, es));
-  }
-  return cmd;
-}
-
-struct cmd*
-parsepipe(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  cmd = parseexec(ps, es);
-  if(peek(ps, es, "|")){
-    gettoken(ps, es, 0, 0);
-    cmd = pipecmd(cmd, parsepipe(ps, es));
-  }
-  return cmd;
-}
-
-struct cmd*
-parseredirs(struct cmd *cmd, char **ps, char *es)
-{
-  int tok;
-  char *q, *eq;
-
-  while(peek(ps, es, "<>")){
-    tok = gettoken(ps, es, 0, 0);
-    if(gettoken(ps, es, &q, &eq) != 'a')
-      panic("missing file for redirection");
-    switch(tok){
-    case '<':
-      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
-      break;
-    case '>':
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
-    case '+':  // >>
-      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
-      break;
-    }
-  }
-  return cmd;
-}
-
-struct cmd*
-parseblock(char **ps, char *es)
-{
-  struct cmd *cmd;
-
-  if(!peek(ps, es, "("))
-    panic("parseblock");
-  gettoken(ps, es, 0, 0);
-  cmd = parseline(ps, es);
-  if(!peek(ps, es, ")"))
-    panic("syntax - missing )");
-  gettoken(ps, es, 0, 0);
-  cmd = parseredirs(cmd, ps, es);
-  return cmd;
-}
-
-struct cmd*
-parseexec(char **ps, char *es)
-{
-  char *q, *eq;
-  int tok, argc;
-  struct execcmd *cmd;
-  struct cmd *ret;
-
-  if(peek(ps, es, "("))
-    return parseblock(ps, es);
-
-  ret = execcmd();
-  cmd = (struct execcmd*)ret;
-
-  argc = 0;
-  ret = parseredirs(ret, ps, es);
-  while(!peek(ps, es, "|)&;")){
-    if((tok=gettoken(ps, es, &q, &eq)) == 0)
-      break;
-    if(tok != 'a')
-      panic("syntax");
-    cmd->argv[argc] = q;
-    cmd->eargv[argc] = eq;
-    argc++;
-    if(argc >= MAXARGS)
-      panic("too many args");
-    ret = parseredirs(ret, ps, es);
-  }
-  cmd->argv[argc] = 0;
-  cmd->eargv[argc] = 0;
-  return ret;
-}
-
-// NUL-terminate all the counted strings.
-struct cmd*
-nulterminate(struct cmd *cmd)
-{
-  int i;
-  struct backcmd *bcmd;
-  struct execcmd *ecmd;
-  struct listcmd *lcmd;
-  struct pipecmd *pcmd;
-  struct redircmd *rcmd;
-
-  if(cmd == 0)
-    return 0;
-
-  switch(cmd->type){
-  case EXEC:
-    ecmd = (struct execcmd*)cmd;
-    for(i=0; ecmd->argv[i]; i++)
-      *ecmd->eargv[i] = 0;
-    break;
-
-  case REDIR:
-    rcmd = (struct redircmd*)cmd;
-    nulterminate(rcmd->cmd);
-    *rcmd->efile = 0;
-    break;
-
-  case PIPE:
-    pcmd = (struct pipecmd*)cmd;
-    nulterminate(pcmd->left);
-    nulterminate(pcmd->right);
-    break;
-
-  case LIST:
-    lcmd = (struct listcmd*)cmd;
-    nulterminate(lcmd->left);
-    nulterminate(lcmd->right);
-    break;
-
-  case BACK:
-    bcmd = (struct backcmd*)cmd;
-    nulterminate(bcmd->cmd);
-    break;
-  }
-  return cmd;
-}
diff -ruN xv6-public/show1 xv6-public_new/show1
--- xv6-public/show1	2021-09-30 23:28:57.766395600 +0530
+++ xv6-public_new/show1	1970-01-01 05:30:00.000000000 +0530
@@ -1,3 +0,0 @@
-#!/bin/sh
-
-runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
diff -ruN xv6-public/sign.pl xv6-public_new/sign.pl
--- xv6-public/sign.pl	2021-09-30 23:28:57.768395000 +0530
+++ xv6-public_new/sign.pl	1970-01-01 05:30:00.000000000 +0530
@@ -1,19 +0,0 @@
-#!/usr/bin/perl
-
-open(SIG, $ARGV[0]) || die "open $ARGV[0]: $!";
-
-$n = sysread(SIG, $buf, 1000);
-
-if($n > 510){
-  print STDERR "boot block too large: $n bytes (max 510)\n";
-  exit 1;
-}
-
-print STDERR "boot block is $n bytes (max 510)\n";
-
-$buf .= "\0" x (510-$n);
-$buf .= "\x55\xAA";
-
-open(SIG, ">$ARGV[0]") || die "open >$ARGV[0]: $!";
-print SIG $buf;
-close SIG;
diff -ruN xv6-public/sleep1.p xv6-public_new/sleep1.p
--- xv6-public/sleep1.p	2021-09-30 23:28:57.770392700 +0530
+++ xv6-public_new/sleep1.p	1970-01-01 05:30:00.000000000 +0530
@@ -1,134 +0,0 @@
-/*
-This file defines a Promela model for xv6's
-acquire, release, sleep, and wakeup, along with
-a model of a simple producer/consumer queue.
-
-To run:
-	spinp sleep1.p
-
-(You may need to install Spin, available at http://spinroot.com/.)
-
-After a successful run spin prints something like:
-
-	unreached in proctype consumer
-		(0 of 37 states)
-	unreached in proctype producer
-		(0 of 23 states)
-
-After an unsuccessful run, the spinp script prints
-an execution trace that causes a deadlock.
-
-The safe body of producer reads:
-
-		acquire(lk);
-		x = value; value = x + 1; x = 0;
-		wakeup(0);
-		release(lk);
-		i = i + 1;
-
-If this is changed to:
-
-		x = value; value = x + 1; x = 0;
-		acquire(lk);
-		wakeup(0);
-		release(lk);
-		i = i + 1;
-
-then a deadlock can happen, because the non-atomic
-increment of value conflicts with the non-atomic 
-decrement in consumer, causing value to have a bad value.
-Try this.
-
-If it is changed to:
-
-		acquire(lk);
-		x = value; value = x + 1; x = 0;
-		release(lk);
-		wakeup(0);
-		i = i + 1;
-
-then nothing bad happens: it is okay to wakeup after release
-instead of before, although it seems morally wrong.
-*/
-
-#define ITER 4
-#define N 2
-
-bit lk;
-byte value;
-bit sleeping[N];
-
-inline acquire(x)
-{
-	atomic { x == 0; x = 1 }
-}
-
-inline release(x)
-{
-	assert x==1;
-	x = 0
-}
-
-inline sleep(cond, lk)
-{
-	assert !sleeping[_pid];
-	if
-	:: cond ->
-		skip
-	:: else ->
-		atomic { release(lk); sleeping[_pid] = 1 };
-		sleeping[_pid] == 0;
-		acquire(lk)
-	fi
-}
-
-inline wakeup()
-{
-	w = 0;
-	do
-	:: w < N ->
-		sleeping[w] = 0;
-		w = w + 1
-	:: else ->
-		break
-	od
-}
-
-active[N] proctype consumer()
-{
-	byte i, x;
-	
-	i = 0;
-	do
-	:: i < ITER ->
-		acquire(lk);
-		sleep(value > 0, lk);
-		x = value; value = x - 1; x = 0;
-		release(lk);
-		i = i + 1;
-	:: else ->
-		break
-	od;
-	i = 0;
-	skip
-}
-
-active[N] proctype producer()
-{
-	byte i, x, w;
-	
-	i = 0;
-	do
-	:: i < ITER ->
-		acquire(lk);
-		x = value; value = x + 1; x = 0;
-		release(lk);
-		wakeup();
-		i = i + 1;
-	:: else ->
-		break
-	od;
-	i = 0;
-	skip	
-}
-
diff -ruN xv6-public/sleeplock.c xv6-public_new/sleeplock.c
--- xv6-public/sleeplock.c	2021-09-30 23:28:57.773393400 +0530
+++ xv6-public_new/sleeplock.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,56 +0,0 @@
-// Sleeping locks
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "x86.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-
-void
-initsleeplock(struct sleeplock *lk, char *name)
-{
-  initlock(&lk->lk, "sleep lock");
-  lk->name = name;
-  lk->locked = 0;
-  lk->pid = 0;
-}
-
-void
-acquiresleep(struct sleeplock *lk)
-{
-  acquire(&lk->lk);
-  while (lk->locked) {
-    sleep(lk, &lk->lk);
-  }
-  lk->locked = 1;
-  lk->pid = myproc()->pid;
-  release(&lk->lk);
-}
-
-void
-releasesleep(struct sleeplock *lk)
-{
-  acquire(&lk->lk);
-  lk->locked = 0;
-  lk->pid = 0;
-  wakeup(lk);
-  release(&lk->lk);
-}
-
-int
-holdingsleep(struct sleeplock *lk)
-{
-  int r;
-  
-  acquire(&lk->lk);
-  r = lk->locked && (lk->pid == myproc()->pid);
-  release(&lk->lk);
-  return r;
-}
-
-
-
diff -ruN xv6-public/sleeplock.h xv6-public_new/sleeplock.h
--- xv6-public/sleeplock.h	2021-09-30 23:28:57.775397100 +0530
+++ xv6-public_new/sleeplock.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,10 +0,0 @@
-// Long-term locks for processes
-struct sleeplock {
-  uint locked;       // Is the lock held?
-  struct spinlock lk; // spinlock protecting this sleep lock
-  
-  // For debugging:
-  char *name;        // Name of lock.
-  int pid;           // Process holding lock
-};
-
diff -ruN xv6-public/spinlock.c xv6-public_new/spinlock.c
--- xv6-public/spinlock.c	2021-09-30 23:28:57.777395400 +0530
+++ xv6-public_new/spinlock.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,126 +0,0 @@
-// Mutual exclusion spin locks.
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "x86.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "spinlock.h"
-
-void
-initlock(struct spinlock *lk, char *name)
-{
-  lk->name = name;
-  lk->locked = 0;
-  lk->cpu = 0;
-}
-
-// Acquire the lock.
-// Loops (spins) until the lock is acquired.
-// Holding a lock for a long time may cause
-// other CPUs to waste time spinning to acquire it.
-void
-acquire(struct spinlock *lk)
-{
-  pushcli(); // disable interrupts to avoid deadlock.
-  if(holding(lk))
-    panic("acquire");
-
-  // The xchg is atomic.
-  while(xchg(&lk->locked, 1) != 0)
-    ;
-
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that the critical section's memory
-  // references happen after the lock is acquired.
-  __sync_synchronize();
-
-  // Record info about lock acquisition for debugging.
-  lk->cpu = mycpu();
-  getcallerpcs(&lk, lk->pcs);
-}
-
-// Release the lock.
-void
-release(struct spinlock *lk)
-{
-  if(!holding(lk))
-    panic("release");
-
-  lk->pcs[0] = 0;
-  lk->cpu = 0;
-
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that all the stores in the critical
-  // section are visible to other cores before the lock is released.
-  // Both the C compiler and the hardware may re-order loads and
-  // stores; __sync_synchronize() tells them both not to.
-  __sync_synchronize();
-
-  // Release the lock, equivalent to lk->locked = 0.
-  // This code can't use a C assignment, since it might
-  // not be atomic. A real OS would use C atomics here.
-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
-
-  popcli();
-}
-
-// Record the current call stack in pcs[] by following the %ebp chain.
-void
-getcallerpcs(void *v, uint pcs[])
-{
-  uint *ebp;
-  int i;
-
-  ebp = (uint*)v - 2;
-  for(i = 0; i < 10; i++){
-    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
-      break;
-    pcs[i] = ebp[1];     // saved %eip
-    ebp = (uint*)ebp[0]; // saved %ebp
-  }
-  for(; i < 10; i++)
-    pcs[i] = 0;
-}
-
-// Check whether this cpu is holding the lock.
-int
-holding(struct spinlock *lock)
-{
-  int r;
-  pushcli();
-  r = lock->locked && lock->cpu == mycpu();
-  popcli();
-  return r;
-}
-
-
-// Pushcli/popcli are like cli/sti except that they are matched:
-// it takes two popcli to undo two pushcli.  Also, if interrupts
-// are off, then pushcli, popcli leaves them off.
-
-void
-pushcli(void)
-{
-  int eflags;
-
-  eflags = readeflags();
-  cli();
-  if(mycpu()->ncli == 0)
-    mycpu()->intena = eflags & FL_IF;
-  mycpu()->ncli += 1;
-}
-
-void
-popcli(void)
-{
-  if(readeflags()&FL_IF)
-    panic("popcli - interruptible");
-  if(--mycpu()->ncli < 0)
-    panic("popcli");
-  if(mycpu()->ncli == 0 && mycpu()->intena)
-    sti();
-}
-
diff -ruN xv6-public/spinlock.h xv6-public_new/spinlock.h
--- xv6-public/spinlock.h	2021-09-30 23:28:57.779394800 +0530
+++ xv6-public_new/spinlock.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,11 +0,0 @@
-// Mutual exclusion lock.
-struct spinlock {
-  uint locked;       // Is the lock held?
-
-  // For debugging:
-  char *name;        // Name of lock.
-  struct cpu *cpu;   // The cpu holding the lock.
-  uint pcs[10];      // The call stack (an array of program counters)
-                     // that locked the lock.
-};
-
diff -ruN xv6-public/spinp xv6-public_new/spinp
--- xv6-public/spinp	2021-09-30 23:28:57.781391500 +0530
+++ xv6-public_new/spinp	1970-01-01 05:30:00.000000000 +0530
@@ -1,16 +0,0 @@
-#!/bin/sh
-
-if [ $# != 1 ] || [ ! -f "$1" ]; then
-	echo 'usage: spinp file.p' 1>&2
-	exit 1
-fi
-
-rm -f $1.trail
-spin -a $1 || exit 1
-cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
-pan -i
-rm pan.* pan
-if [ -f $1.trail ]; then
-	spin -t -p $1
-fi
-
diff -ruN xv6-public/stat.h xv6-public_new/stat.h
--- xv6-public/stat.h	2021-09-30 23:28:57.783394100 +0530
+++ xv6-public_new/stat.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,11 +0,0 @@
-#define T_DIR  1   // Directory
-#define T_FILE 2   // File
-#define T_DEV  3   // Device
-
-struct stat {
-  short type;  // Type of file
-  int dev;     // File system's disk device
-  uint ino;    // Inode number
-  short nlink; // Number of links to file
-  uint size;   // Size of file in bytes
-};
diff -ruN xv6-public/stressfs.c xv6-public_new/stressfs.c
--- xv6-public/stressfs.c	2021-09-30 23:28:57.785391300 +0530
+++ xv6-public_new/stressfs.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,49 +0,0 @@
-// Demonstrate that moving the "acquire" in iderw after the loop that
-// appends to the idequeue results in a race.
-
-// For this to work, you should also add a spin within iderw's
-// idequeue traversal loop.  Adding the following demonstrated a panic
-// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
-//    for (i = 0; i < 40000; i++)
-//      asm volatile("");
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-
-int
-main(int argc, char *argv[])
-{
-  int fd, i;
-  char path[] = "stressfs0";
-  char data[512];
-
-  printf(1, "stressfs starting\n");
-  memset(data, 'a', sizeof(data));
-
-  for(i = 0; i < 4; i++)
-    if(fork() > 0)
-      break;
-
-  printf(1, "write %d\n", i);
-
-  path[8] += i;
-  fd = open(path, O_CREATE | O_RDWR);
-  for(i = 0; i < 20; i++)
-//    printf(fd, "%d\n", i);
-    write(fd, data, sizeof(data));
-  close(fd);
-
-  printf(1, "read\n");
-
-  fd = open(path, O_RDONLY);
-  for (i = 0; i < 20; i++)
-    read(fd, data, sizeof(data));
-  close(fd);
-
-  wait();
-
-  exit();
-}
diff -ruN xv6-public/string.c xv6-public_new/string.c
--- xv6-public/string.c	2021-09-30 23:28:57.787391500 +0530
+++ xv6-public_new/string.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,105 +0,0 @@
-#include "types.h"
-#include "x86.h"
-
-void*
-memset(void *dst, int c, uint n)
-{
-  if ((int)dst%4 == 0 && n%4 == 0){
-    c &= 0xFF;
-    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
-  } else
-    stosb(dst, c, n);
-  return dst;
-}
-
-int
-memcmp(const void *v1, const void *v2, uint n)
-{
-  const uchar *s1, *s2;
-
-  s1 = v1;
-  s2 = v2;
-  while(n-- > 0){
-    if(*s1 != *s2)
-      return *s1 - *s2;
-    s1++, s2++;
-  }
-
-  return 0;
-}
-
-void*
-memmove(void *dst, const void *src, uint n)
-{
-  const char *s;
-  char *d;
-
-  s = src;
-  d = dst;
-  if(s < d && s + n > d){
-    s += n;
-    d += n;
-    while(n-- > 0)
-      *--d = *--s;
-  } else
-    while(n-- > 0)
-      *d++ = *s++;
-
-  return dst;
-}
-
-// memcpy exists to placate GCC.  Use memmove.
-void*
-memcpy(void *dst, const void *src, uint n)
-{
-  return memmove(dst, src, n);
-}
-
-int
-strncmp(const char *p, const char *q, uint n)
-{
-  while(n > 0 && *p && *p == *q)
-    n--, p++, q++;
-  if(n == 0)
-    return 0;
-  return (uchar)*p - (uchar)*q;
-}
-
-char*
-strncpy(char *s, const char *t, int n)
-{
-  char *os;
-
-  os = s;
-  while(n-- > 0 && (*s++ = *t++) != 0)
-    ;
-  while(n-- > 0)
-    *s++ = 0;
-  return os;
-}
-
-// Like strncpy but guaranteed to NUL-terminate.
-char*
-safestrcpy(char *s, const char *t, int n)
-{
-  char *os;
-
-  os = s;
-  if(n <= 0)
-    return os;
-  while(--n > 0 && (*s++ = *t++) != 0)
-    ;
-  *s = 0;
-  return os;
-}
-
-int
-strlen(const char *s)
-{
-  int n;
-
-  for(n = 0; s[n]; n++)
-    ;
-  return n;
-}
-
diff -ruN xv6-public/swtch.S xv6-public_new/swtch.S
--- xv6-public/swtch.S	2021-09-30 23:28:57.789390700 +0530
+++ xv6-public_new/swtch.S	1970-01-01 05:30:00.000000000 +0530
@@ -1,29 +0,0 @@
-# Context switch
-#
-#   void swtch(struct context **old, struct context *new);
-# 
-# Save the current registers on the stack, creating
-# a struct context, and save its address in *old.
-# Switch stacks to new and pop previously-saved registers.
-
-.globl swtch
-swtch:
-  movl 4(%esp), %eax
-  movl 8(%esp), %edx
-
-  # Save old callee-saved registers
-  pushl %ebp
-  pushl %ebx
-  pushl %esi
-  pushl %edi
-
-  # Switch stacks
-  movl %esp, (%eax)
-  movl %edx, %esp
-
-  # Load new callee-saved registers
-  popl %edi
-  popl %esi
-  popl %ebx
-  popl %ebp
-  ret
diff -ruN xv6-public/syscall.c xv6-public_new/syscall.c
--- xv6-public/syscall.c	2021-09-30 23:28:57.791391200 +0530
+++ xv6-public_new/syscall.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,145 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-#include "syscall.h"
-
-// User code makes a system call with INT T_SYSCALL.
-// System call number in %eax.
-// Arguments on the stack, from the user call to the C
-// library system call function. The saved user %esp points
-// to a saved program counter, and then the first argument.
-
-// Fetch the int at addr from the current process.
-int
-fetchint(uint addr, int *ip)
-{
-  struct proc *curproc = myproc();
-
-  if(addr >= curproc->sz || addr+4 > curproc->sz)
-    return -1;
-  *ip = *(int*)(addr);
-  return 0;
-}
-
-// Fetch the nul-terminated string at addr from the current process.
-// Doesn't actually copy the string - just sets *pp to point at it.
-// Returns length of string, not including nul.
-int
-fetchstr(uint addr, char **pp)
-{
-  char *s, *ep;
-  struct proc *curproc = myproc();
-
-  if(addr >= curproc->sz)
-    return -1;
-  *pp = (char*)addr;
-  ep = (char*)curproc->sz;
-  for(s = *pp; s < ep; s++){
-    if(*s == 0)
-      return s - *pp;
-  }
-  return -1;
-}
-
-// Fetch the nth 32-bit system call argument.
-int
-argint(int n, int *ip)
-{
-  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
-}
-
-// Fetch the nth word-sized system call argument as a pointer
-// to a block of memory of size bytes.  Check that the pointer
-// lies within the process address space.
-int
-argptr(int n, char **pp, int size)
-{
-  int i;
-  struct proc *curproc = myproc();
- 
-  if(argint(n, &i) < 0)
-    return -1;
-  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
-    return -1;
-  *pp = (char*)i;
-  return 0;
-}
-
-// Fetch the nth word-sized system call argument as a string pointer.
-// Check that the pointer is valid and the string is nul-terminated.
-// (There is no shared writable memory, so the string can't change
-// between this check and being used by the kernel.)
-int
-argstr(int n, char **pp)
-{
-  int addr;
-  if(argint(n, &addr) < 0)
-    return -1;
-  return fetchstr(addr, pp);
-}
-
-extern int sys_chdir(void);
-extern int sys_close(void);
-extern int sys_dup(void);
-extern int sys_exec(void);
-extern int sys_exit(void);
-extern int sys_fork(void);
-extern int sys_fstat(void);
-extern int sys_getpid(void);
-extern int sys_kill(void);
-extern int sys_link(void);
-extern int sys_mkdir(void);
-extern int sys_mknod(void);
-extern int sys_open(void);
-extern int sys_pipe(void);
-extern int sys_read(void);
-extern int sys_sbrk(void);
-extern int sys_sleep(void);
-extern int sys_unlink(void);
-extern int sys_wait(void);
-extern int sys_write(void);
-extern int sys_uptime(void);
-
-static int (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
-};
-
-void
-syscall(void)
-{
-  int num;
-  struct proc *curproc = myproc();
-
-  num = curproc->tf->eax;
-  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    curproc->tf->eax = syscalls[num]();
-  } else {
-    cprintf("%d %s: unknown sys call %d\n",
-            curproc->pid, curproc->name, num);
-    curproc->tf->eax = -1;
-  }
-}
diff -ruN xv6-public/syscall.h xv6-public_new/syscall.h
--- xv6-public/syscall.h	2021-09-30 23:28:57.793391700 +0530
+++ xv6-public_new/syscall.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,22 +0,0 @@
-// System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
-#define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
-#define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
-#define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
diff -ruN xv6-public/sysfile.c xv6-public_new/sysfile.c
--- xv6-public/sysfile.c	2021-09-30 23:28:57.795395000 +0530
+++ xv6-public_new/sysfile.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,444 +0,0 @@
-//
-// File-system system calls.
-// Mostly argument checking, since we don't trust
-// user code, and calls into file.c and fs.c.
-//
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "stat.h"
-#include "mmu.h"
-#include "proc.h"
-#include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "file.h"
-#include "fcntl.h"
-
-// Fetch the nth word-sized system call argument as a file descriptor
-// and return both the descriptor and the corresponding struct file.
-static int
-argfd(int n, int *pfd, struct file **pf)
-{
-  int fd;
-  struct file *f;
-
-  if(argint(n, &fd) < 0)
-    return -1;
-  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
-    return -1;
-  if(pfd)
-    *pfd = fd;
-  if(pf)
-    *pf = f;
-  return 0;
-}
-
-// Allocate a file descriptor for the given file.
-// Takes over file reference from caller on success.
-static int
-fdalloc(struct file *f)
-{
-  int fd;
-  struct proc *curproc = myproc();
-
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd] == 0){
-      curproc->ofile[fd] = f;
-      return fd;
-    }
-  }
-  return -1;
-}
-
-int
-sys_dup(void)
-{
-  struct file *f;
-  int fd;
-
-  if(argfd(0, 0, &f) < 0)
-    return -1;
-  if((fd=fdalloc(f)) < 0)
-    return -1;
-  filedup(f);
-  return fd;
-}
-
-int
-sys_read(void)
-{
-  struct file *f;
-  int n;
-  char *p;
-
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
-    return -1;
-  return fileread(f, p, n);
-}
-
-int
-sys_write(void)
-{
-  struct file *f;
-  int n;
-  char *p;
-
-  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
-    return -1;
-  return filewrite(f, p, n);
-}
-
-int
-sys_close(void)
-{
-  int fd;
-  struct file *f;
-
-  if(argfd(0, &fd, &f) < 0)
-    return -1;
-  myproc()->ofile[fd] = 0;
-  fileclose(f);
-  return 0;
-}
-
-int
-sys_fstat(void)
-{
-  struct file *f;
-  struct stat *st;
-
-  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
-    return -1;
-  return filestat(f, st);
-}
-
-// Create the path new as a link to the same inode as old.
-int
-sys_link(void)
-{
-  char name[DIRSIZ], *new, *old;
-  struct inode *dp, *ip;
-
-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
-    return -1;
-
-  begin_op();
-  if((ip = namei(old)) == 0){
-    end_op();
-    return -1;
-  }
-
-  ilock(ip);
-  if(ip->type == T_DIR){
-    iunlockput(ip);
-    end_op();
-    return -1;
-  }
-
-  ip->nlink++;
-  iupdate(ip);
-  iunlock(ip);
-
-  if((dp = nameiparent(new, name)) == 0)
-    goto bad;
-  ilock(dp);
-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
-    iunlockput(dp);
-    goto bad;
-  }
-  iunlockput(dp);
-  iput(ip);
-
-  end_op();
-
-  return 0;
-
-bad:
-  ilock(ip);
-  ip->nlink--;
-  iupdate(ip);
-  iunlockput(ip);
-  end_op();
-  return -1;
-}
-
-// Is the directory dp empty except for "." and ".." ?
-static int
-isdirempty(struct inode *dp)
-{
-  int off;
-  struct dirent de;
-
-  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
-    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-      panic("isdirempty: readi");
-    if(de.inum != 0)
-      return 0;
-  }
-  return 1;
-}
-
-//PAGEBREAK!
-int
-sys_unlink(void)
-{
-  struct inode *ip, *dp;
-  struct dirent de;
-  char name[DIRSIZ], *path;
-  uint off;
-
-  if(argstr(0, &path) < 0)
-    return -1;
-
-  begin_op();
-  if((dp = nameiparent(path, name)) == 0){
-    end_op();
-    return -1;
-  }
-
-  ilock(dp);
-
-  // Cannot unlink "." or "..".
-  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
-    goto bad;
-
-  if((ip = dirlookup(dp, name, &off)) == 0)
-    goto bad;
-  ilock(ip);
-
-  if(ip->nlink < 1)
-    panic("unlink: nlink < 1");
-  if(ip->type == T_DIR && !isdirempty(ip)){
-    iunlockput(ip);
-    goto bad;
-  }
-
-  memset(&de, 0, sizeof(de));
-  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
-    panic("unlink: writei");
-  if(ip->type == T_DIR){
-    dp->nlink--;
-    iupdate(dp);
-  }
-  iunlockput(dp);
-
-  ip->nlink--;
-  iupdate(ip);
-  iunlockput(ip);
-
-  end_op();
-
-  return 0;
-
-bad:
-  iunlockput(dp);
-  end_op();
-  return -1;
-}
-
-static struct inode*
-create(char *path, short type, short major, short minor)
-{
-  struct inode *ip, *dp;
-  char name[DIRSIZ];
-
-  if((dp = nameiparent(path, name)) == 0)
-    return 0;
-  ilock(dp);
-
-  if((ip = dirlookup(dp, name, 0)) != 0){
-    iunlockput(dp);
-    ilock(ip);
-    if(type == T_FILE && ip->type == T_FILE)
-      return ip;
-    iunlockput(ip);
-    return 0;
-  }
-
-  if((ip = ialloc(dp->dev, type)) == 0)
-    panic("create: ialloc");
-
-  ilock(ip);
-  ip->major = major;
-  ip->minor = minor;
-  ip->nlink = 1;
-  iupdate(ip);
-
-  if(type == T_DIR){  // Create . and .. entries.
-    dp->nlink++;  // for ".."
-    iupdate(dp);
-    // No ip->nlink++ for ".": avoid cyclic ref count.
-    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
-      panic("create dots");
-  }
-
-  if(dirlink(dp, name, ip->inum) < 0)
-    panic("create: dirlink");
-
-  iunlockput(dp);
-
-  return ip;
-}
-
-int
-sys_open(void)
-{
-  char *path;
-  int fd, omode;
-  struct file *f;
-  struct inode *ip;
-
-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
-    return -1;
-
-  begin_op();
-
-  if(omode & O_CREATE){
-    ip = create(path, T_FILE, 0, 0);
-    if(ip == 0){
-      end_op();
-      return -1;
-    }
-  } else {
-    if((ip = namei(path)) == 0){
-      end_op();
-      return -1;
-    }
-    ilock(ip);
-    if(ip->type == T_DIR && omode != O_RDONLY){
-      iunlockput(ip);
-      end_op();
-      return -1;
-    }
-  }
-
-  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
-    if(f)
-      fileclose(f);
-    iunlockput(ip);
-    end_op();
-    return -1;
-  }
-  iunlock(ip);
-  end_op();
-
-  f->type = FD_INODE;
-  f->ip = ip;
-  f->off = 0;
-  f->readable = !(omode & O_WRONLY);
-  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
-  return fd;
-}
-
-int
-sys_mkdir(void)
-{
-  char *path;
-  struct inode *ip;
-
-  begin_op();
-  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
-    end_op();
-    return -1;
-  }
-  iunlockput(ip);
-  end_op();
-  return 0;
-}
-
-int
-sys_mknod(void)
-{
-  struct inode *ip;
-  char *path;
-  int major, minor;
-
-  begin_op();
-  if((argstr(0, &path)) < 0 ||
-     argint(1, &major) < 0 ||
-     argint(2, &minor) < 0 ||
-     (ip = create(path, T_DEV, major, minor)) == 0){
-    end_op();
-    return -1;
-  }
-  iunlockput(ip);
-  end_op();
-  return 0;
-}
-
-int
-sys_chdir(void)
-{
-  char *path;
-  struct inode *ip;
-  struct proc *curproc = myproc();
-  
-  begin_op();
-  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
-    end_op();
-    return -1;
-  }
-  ilock(ip);
-  if(ip->type != T_DIR){
-    iunlockput(ip);
-    end_op();
-    return -1;
-  }
-  iunlock(ip);
-  iput(curproc->cwd);
-  end_op();
-  curproc->cwd = ip;
-  return 0;
-}
-
-int
-sys_exec(void)
-{
-  char *path, *argv[MAXARG];
-  int i;
-  uint uargv, uarg;
-
-  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
-    return -1;
-  }
-  memset(argv, 0, sizeof(argv));
-  for(i=0;; i++){
-    if(i >= NELEM(argv))
-      return -1;
-    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
-      return -1;
-    if(uarg == 0){
-      argv[i] = 0;
-      break;
-    }
-    if(fetchstr(uarg, &argv[i]) < 0)
-      return -1;
-  }
-  return exec(path, argv);
-}
-
-int
-sys_pipe(void)
-{
-  int *fd;
-  struct file *rf, *wf;
-  int fd0, fd1;
-
-  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
-    return -1;
-  if(pipealloc(&rf, &wf) < 0)
-    return -1;
-  fd0 = -1;
-  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
-    if(fd0 >= 0)
-      myproc()->ofile[fd0] = 0;
-    fileclose(rf);
-    fileclose(wf);
-    return -1;
-  }
-  fd[0] = fd0;
-  fd[1] = fd1;
-  return 0;
-}
diff -ruN xv6-public/sysproc.c xv6-public_new/sysproc.c
--- xv6-public/sysproc.c	2021-09-30 23:28:57.797393100 +0530
+++ xv6-public_new/sysproc.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,91 +0,0 @@
-#include "types.h"
-#include "x86.h"
-#include "defs.h"
-#include "date.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-
-int
-sys_fork(void)
-{
-  return fork();
-}
-
-int
-sys_exit(void)
-{
-  exit();
-  return 0;  // not reached
-}
-
-int
-sys_wait(void)
-{
-  return wait();
-}
-
-int
-sys_kill(void)
-{
-  int pid;
-
-  if(argint(0, &pid) < 0)
-    return -1;
-  return kill(pid);
-}
-
-int
-sys_getpid(void)
-{
-  return myproc()->pid;
-}
-
-int
-sys_sbrk(void)
-{
-  int addr;
-  int n;
-
-  if(argint(0, &n) < 0)
-    return -1;
-  addr = myproc()->sz;
-  if(growproc(n) < 0)
-    return -1;
-  return addr;
-}
-
-int
-sys_sleep(void)
-{
-  int n;
-  uint ticks0;
-
-  if(argint(0, &n) < 0)
-    return -1;
-  acquire(&tickslock);
-  ticks0 = ticks;
-  while(ticks - ticks0 < n){
-    if(myproc()->killed){
-      release(&tickslock);
-      return -1;
-    }
-    sleep(&ticks, &tickslock);
-  }
-  release(&tickslock);
-  return 0;
-}
-
-// return how many clock tick interrupts have occurred
-// since start.
-int
-sys_uptime(void)
-{
-  uint xticks;
-
-  acquire(&tickslock);
-  xticks = ticks;
-  release(&tickslock);
-  return xticks;
-}
diff -ruN xv6-public/toc.ftr xv6-public_new/toc.ftr
--- xv6-public/toc.ftr	2021-09-30 23:28:57.799393100 +0530
+++ xv6-public_new/toc.ftr	1970-01-01 05:30:00.000000000 +0530
@@ -1,13 +0,0 @@
-
-
-The source listing is preceded by a cross-reference that lists every defined 
-constant, struct, global variable, and function in xv6.  Each entry gives,
-on the same line as the name, the line number (or, in a few cases, numbers)
-where the name is defined.  Successive lines in an entry list the line
-numbers where the name is used.  For example, this entry:
-
-    swtch 2658
-        0374 2428 2466 2657 2658
-
-indicates that swtch is defined on line 2658 and is mentioned on five lines
-on sheets 03, 24, and 26.
diff -ruN xv6-public/toc.hdr xv6-public_new/toc.hdr
--- xv6-public/toc.hdr	2021-09-30 23:28:57.801391000 +0530
+++ xv6-public_new/toc.hdr	1970-01-01 05:30:00.000000000 +0530
@@ -1,6 +0,0 @@
-The numbers to the left of the file names in the table are sheet numbers.
-The source code has been printed in a double column format with fifty
-lines per column, giving one hundred lines per sheet (or page).
-Thus there is a convenient relationship between line numbers and sheet numbers.
-
-
diff -ruN xv6-public/trap.c xv6-public_new/trap.c
--- xv6-public/trap.c	2021-09-30 23:28:57.803395600 +0530
+++ xv6-public_new/trap.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,112 +0,0 @@
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-#include "traps.h"
-#include "spinlock.h"
-
-// Interrupt descriptor table (shared by all CPUs).
-struct gatedesc idt[256];
-extern uint vectors[];  // in vectors.S: array of 256 entry pointers
-struct spinlock tickslock;
-uint ticks;
-
-void
-tvinit(void)
-{
-  int i;
-
-  for(i = 0; i < 256; i++)
-    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
-  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
-
-  initlock(&tickslock, "time");
-}
-
-void
-idtinit(void)
-{
-  lidt(idt, sizeof(idt));
-}
-
-//PAGEBREAK: 41
-void
-trap(struct trapframe *tf)
-{
-  if(tf->trapno == T_SYSCALL){
-    if(myproc()->killed)
-      exit();
-    myproc()->tf = tf;
-    syscall();
-    if(myproc()->killed)
-      exit();
-    return;
-  }
-
-  switch(tf->trapno){
-  case T_IRQ0 + IRQ_TIMER:
-    if(cpuid() == 0){
-      acquire(&tickslock);
-      ticks++;
-      wakeup(&ticks);
-      release(&tickslock);
-    }
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_IDE:
-    ideintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_IDE+1:
-    // Bochs generates spurious IDE1 interrupts.
-    break;
-  case T_IRQ0 + IRQ_KBD:
-    kbdintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + IRQ_COM1:
-    uartintr();
-    lapiceoi();
-    break;
-  case T_IRQ0 + 7:
-  case T_IRQ0 + IRQ_SPURIOUS:
-    cprintf("cpu%d: spurious interrupt at %x:%x\n",
-            cpuid(), tf->cs, tf->eip);
-    lapiceoi();
-    break;
-
-  //PAGEBREAK: 13
-  default:
-    if(myproc() == 0 || (tf->cs&3) == 0){
-      // In kernel, it must be our mistake.
-      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
-              tf->trapno, cpuid(), tf->eip, rcr2());
-      panic("trap");
-    }
-    // In user space, assume process misbehaved.
-    cprintf("pid %d %s: trap %d err %d on cpu %d "
-            "eip 0x%x addr 0x%x--kill proc\n",
-            myproc()->pid, myproc()->name, tf->trapno,
-            tf->err, cpuid(), tf->eip, rcr2());
-    myproc()->killed = 1;
-  }
-
-  // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
-  // until it gets to the regular system call return.)
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
-
-  // Force process to give up CPU on clock tick.
-  // If interrupts were on while locks held, would need to check nlock.
-  if(myproc() && myproc()->state == RUNNING &&
-     tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
-
-  // Check if the process has been killed since we yielded
-  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
-    exit();
-}
diff -ruN xv6-public/trapasm.S xv6-public_new/trapasm.S
--- xv6-public/trapasm.S	2021-09-30 23:28:57.805394700 +0530
+++ xv6-public_new/trapasm.S	1970-01-01 05:30:00.000000000 +0530
@@ -1,32 +0,0 @@
-#include "mmu.h"
-
-  # vectors.S sends all traps here.
-.globl alltraps
-alltraps:
-  # Build trap frame.
-  pushl %ds
-  pushl %es
-  pushl %fs
-  pushl %gs
-  pushal
-  
-  # Set up data segments.
-  movw $(SEG_KDATA<<3), %ax
-  movw %ax, %ds
-  movw %ax, %es
-
-  # Call trap(tf), where tf=%esp
-  pushl %esp
-  call trap
-  addl $4, %esp
-
-  # Return falls through to trapret...
-.globl trapret
-trapret:
-  popal
-  popl %gs
-  popl %fs
-  popl %es
-  popl %ds
-  addl $0x8, %esp  # trapno and errcode
-  iret
diff -ruN xv6-public/traps.h xv6-public_new/traps.h
--- xv6-public/traps.h	2021-09-30 23:28:57.807397200 +0530
+++ xv6-public_new/traps.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,38 +0,0 @@
-// x86 trap and interrupt constants.
-
-// Processor-defined:
-#define T_DIVIDE         0      // divide error
-#define T_DEBUG          1      // debug exception
-#define T_NMI            2      // non-maskable interrupt
-#define T_BRKPT          3      // breakpoint
-#define T_OFLOW          4      // overflow
-#define T_BOUND          5      // bounds check
-#define T_ILLOP          6      // illegal opcode
-#define T_DEVICE         7      // device not available
-#define T_DBLFLT         8      // double fault
-// #define T_COPROC      9      // reserved (not used since 486)
-#define T_TSS           10      // invalid task switch segment
-#define T_SEGNP         11      // segment not present
-#define T_STACK         12      // stack exception
-#define T_GPFLT         13      // general protection fault
-#define T_PGFLT         14      // page fault
-// #define T_RES        15      // reserved
-#define T_FPERR         16      // floating point error
-#define T_ALIGN         17      // aligment check
-#define T_MCHK          18      // machine check
-#define T_SIMDERR       19      // SIMD floating point error
-
-// These are arbitrarily chosen, but with care not to overlap
-// processor defined exceptions or interrupt vectors.
-#define T_SYSCALL       64      // system call
-#define T_DEFAULT      500      // catchall
-
-#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
-
-#define IRQ_TIMER        0
-#define IRQ_KBD          1
-#define IRQ_COM1         4
-#define IRQ_IDE         14
-#define IRQ_ERROR       19
-#define IRQ_SPURIOUS    31
-
diff -ruN xv6-public/types.h xv6-public_new/types.h
--- xv6-public/types.h	2021-09-30 23:28:57.809392800 +0530
+++ xv6-public_new/types.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
-typedef unsigned int   uint;
-typedef unsigned short ushort;
-typedef unsigned char  uchar;
-typedef uint pde_t;
diff -ruN xv6-public/uart.c xv6-public_new/uart.c
--- xv6-public/uart.c	2021-09-30 23:28:57.811394800 +0530
+++ xv6-public_new/uart.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,77 +0,0 @@
-// Intel 8250 serial port (UART).
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "traps.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-#include "fs.h"
-#include "file.h"
-#include "mmu.h"
-#include "proc.h"
-#include "x86.h"
-
-#define COM1    0x3f8
-
-static int uart;    // is there a uart?
-
-void
-uartinit(void)
-{
-  char *p;
-
-  // Turn off the FIFO
-  outb(COM1+2, 0);
-
-  // 9600 baud, 8 data bits, 1 stop bit, parity off.
-  outb(COM1+3, 0x80);    // Unlock divisor
-  outb(COM1+0, 115200/9600);
-  outb(COM1+1, 0);
-  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
-  outb(COM1+4, 0);
-  outb(COM1+1, 0x01);    // Enable receive interrupts.
-
-  // If status is 0xFF, no serial port.
-  if(inb(COM1+5) == 0xFF)
-    return;
-  uart = 1;
-
-  // Acknowledge pre-existing interrupt conditions;
-  // enable interrupts.
-  inb(COM1+2);
-  inb(COM1+0);
-  ioapicenable(IRQ_COM1, 0);
-
-  // Announce that we're here.
-  for(p="xv6...\n"; *p; p++)
-    uartputc(*p);
-}
-
-void
-uartputc(int c)
-{
-  int i;
-
-  if(!uart)
-    return;
-  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
-    microdelay(10);
-  outb(COM1+0, c);
-}
-
-static int
-uartgetc(void)
-{
-  if(!uart)
-    return -1;
-  if(!(inb(COM1+5) & 0x01))
-    return -1;
-  return inb(COM1+0);
-}
-
-void
-uartintr(void)
-{
-  consoleintr(uartgetc);
-}
diff -ruN xv6-public/ulib.c xv6-public_new/ulib.c
--- xv6-public/ulib.c	2021-09-30 23:28:57.813393700 +0530
+++ xv6-public_new/ulib.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,106 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "fcntl.h"
-#include "user.h"
-#include "x86.h"
-
-char*
-strcpy(char *s, const char *t)
-{
-  char *os;
-
-  os = s;
-  while((*s++ = *t++) != 0)
-    ;
-  return os;
-}
-
-int
-strcmp(const char *p, const char *q)
-{
-  while(*p && *p == *q)
-    p++, q++;
-  return (uchar)*p - (uchar)*q;
-}
-
-uint
-strlen(const char *s)
-{
-  int n;
-
-  for(n = 0; s[n]; n++)
-    ;
-  return n;
-}
-
-void*
-memset(void *dst, int c, uint n)
-{
-  stosb(dst, c, n);
-  return dst;
-}
-
-char*
-strchr(const char *s, char c)
-{
-  for(; *s; s++)
-    if(*s == c)
-      return (char*)s;
-  return 0;
-}
-
-char*
-gets(char *buf, int max)
-{
-  int i, cc;
-  char c;
-
-  for(i=0; i+1 < max; ){
-    cc = read(0, &c, 1);
-    if(cc < 1)
-      break;
-    buf[i++] = c;
-    if(c == '\n' || c == '\r')
-      break;
-  }
-  buf[i] = '\0';
-  return buf;
-}
-
-int
-stat(const char *n, struct stat *st)
-{
-  int fd;
-  int r;
-
-  fd = open(n, O_RDONLY);
-  if(fd < 0)
-    return -1;
-  r = fstat(fd, st);
-  close(fd);
-  return r;
-}
-
-int
-atoi(const char *s)
-{
-  int n;
-
-  n = 0;
-  while('0' <= *s && *s <= '9')
-    n = n*10 + *s++ - '0';
-  return n;
-}
-
-void*
-memmove(void *vdst, const void *vsrc, int n)
-{
-  char *dst;
-  const char *src;
-
-  dst = vdst;
-  src = vsrc;
-  while(n-- > 0)
-    *dst++ = *src++;
-  return vdst;
-}
diff -ruN xv6-public/umalloc.c xv6-public_new/umalloc.c
--- xv6-public/umalloc.c	2021-09-30 23:28:57.815394500 +0530
+++ xv6-public_new/umalloc.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,90 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "param.h"
-
-// Memory allocator by Kernighan and Ritchie,
-// The C programming Language, 2nd ed.  Section 8.7.
-
-typedef long Align;
-
-union header {
-  struct {
-    union header *ptr;
-    uint size;
-  } s;
-  Align x;
-};
-
-typedef union header Header;
-
-static Header base;
-static Header *freep;
-
-void
-free(void *ap)
-{
-  Header *bp, *p;
-
-  bp = (Header*)ap - 1;
-  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
-    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
-      break;
-  if(bp + bp->s.size == p->s.ptr){
-    bp->s.size += p->s.ptr->s.size;
-    bp->s.ptr = p->s.ptr->s.ptr;
-  } else
-    bp->s.ptr = p->s.ptr;
-  if(p + p->s.size == bp){
-    p->s.size += bp->s.size;
-    p->s.ptr = bp->s.ptr;
-  } else
-    p->s.ptr = bp;
-  freep = p;
-}
-
-static Header*
-morecore(uint nu)
-{
-  char *p;
-  Header *hp;
-
-  if(nu < 4096)
-    nu = 4096;
-  p = sbrk(nu * sizeof(Header));
-  if(p == (char*)-1)
-    return 0;
-  hp = (Header*)p;
-  hp->s.size = nu;
-  free((void*)(hp + 1));
-  return freep;
-}
-
-void*
-malloc(uint nbytes)
-{
-  Header *p, *prevp;
-  uint nunits;
-
-  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
-  if((prevp = freep) == 0){
-    base.s.ptr = freep = prevp = &base;
-    base.s.size = 0;
-  }
-  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
-    if(p->s.size >= nunits){
-      if(p->s.size == nunits)
-        prevp->s.ptr = p->s.ptr;
-      else {
-        p->s.size -= nunits;
-        p += p->s.size;
-        p->s.size = nunits;
-      }
-      freep = prevp;
-      return (void*)(p + 1);
-    }
-    if(p == freep)
-      if((p = morecore(nunits)) == 0)
-        return 0;
-  }
-}
diff -ruN xv6-public/user.h xv6-public_new/user.h
--- xv6-public/user.h	2021-09-30 23:28:57.817395800 +0530
+++ xv6-public_new/user.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,39 +0,0 @@
-struct stat;
-struct rtcdate;
-
-// system calls
-int fork(void);
-int exit(void) __attribute__((noreturn));
-int wait(void);
-int pipe(int*);
-int write(int, const void*, int);
-int read(int, void*, int);
-int close(int);
-int kill(int);
-int exec(char*, char**);
-int open(const char*, int);
-int mknod(const char*, short, short);
-int unlink(const char*);
-int fstat(int fd, struct stat*);
-int link(const char*, const char*);
-int mkdir(const char*);
-int chdir(const char*);
-int dup(int);
-int getpid(void);
-char* sbrk(int);
-int sleep(int);
-int uptime(void);
-
-// ulib.c
-int stat(const char*, struct stat*);
-char* strcpy(char*, const char*);
-void *memmove(void*, const void*, int);
-char* strchr(const char*, char c);
-int strcmp(const char*, const char*);
-void printf(int, const char*, ...);
-char* gets(char*, int max);
-uint strlen(const char*);
-void* memset(void*, int, uint);
-void* malloc(uint);
-void free(void*);
-int atoi(const char*);
diff -ruN xv6-public/usertests.c xv6-public_new/usertests.c
--- xv6-public/usertests.c	2021-09-30 23:28:57.819394800 +0530
+++ xv6-public_new/usertests.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,1803 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-#include "fs.h"
-#include "fcntl.h"
-#include "syscall.h"
-#include "traps.h"
-#include "memlayout.h"
-
-char buf[8192];
-char name[3];
-char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
-int stdout = 1;
-
-// does chdir() call iput(p->cwd) in a transaction?
-void
-iputtest(void)
-{
-  printf(stdout, "iput test\n");
-
-  if(mkdir("iputdir") < 0){
-    printf(stdout, "mkdir failed\n");
-    exit();
-  }
-  if(chdir("iputdir") < 0){
-    printf(stdout, "chdir iputdir failed\n");
-    exit();
-  }
-  if(unlink("../iputdir") < 0){
-    printf(stdout, "unlink ../iputdir failed\n");
-    exit();
-  }
-  if(chdir("/") < 0){
-    printf(stdout, "chdir / failed\n");
-    exit();
-  }
-  printf(stdout, "iput test ok\n");
-}
-
-// does exit() call iput(p->cwd) in a transaction?
-void
-exitiputtest(void)
-{
-  int pid;
-
-  printf(stdout, "exitiput test\n");
-
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "fork failed\n");
-    exit();
-  }
-  if(pid == 0){
-    if(mkdir("iputdir") < 0){
-      printf(stdout, "mkdir failed\n");
-      exit();
-    }
-    if(chdir("iputdir") < 0){
-      printf(stdout, "child chdir failed\n");
-      exit();
-    }
-    if(unlink("../iputdir") < 0){
-      printf(stdout, "unlink ../iputdir failed\n");
-      exit();
-    }
-    exit();
-  }
-  wait();
-  printf(stdout, "exitiput test ok\n");
-}
-
-// does the error path in open() for attempt to write a
-// directory call iput() in a transaction?
-// needs a hacked kernel that pauses just after the namei()
-// call in sys_open():
-//    if((ip = namei(path)) == 0)
-//      return -1;
-//    {
-//      int i;
-//      for(i = 0; i < 10000; i++)
-//        yield();
-//    }
-void
-openiputtest(void)
-{
-  int pid;
-
-  printf(stdout, "openiput test\n");
-  if(mkdir("oidir") < 0){
-    printf(stdout, "mkdir oidir failed\n");
-    exit();
-  }
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "fork failed\n");
-    exit();
-  }
-  if(pid == 0){
-    int fd = open("oidir", O_RDWR);
-    if(fd >= 0){
-      printf(stdout, "open directory for write succeeded\n");
-      exit();
-    }
-    exit();
-  }
-  sleep(1);
-  if(unlink("oidir") != 0){
-    printf(stdout, "unlink failed\n");
-    exit();
-  }
-  wait();
-  printf(stdout, "openiput test ok\n");
-}
-
-// simple file system tests
-
-void
-opentest(void)
-{
-  int fd;
-
-  printf(stdout, "open test\n");
-  fd = open("echo", 0);
-  if(fd < 0){
-    printf(stdout, "open echo failed!\n");
-    exit();
-  }
-  close(fd);
-  fd = open("doesnotexist", 0);
-  if(fd >= 0){
-    printf(stdout, "open doesnotexist succeeded!\n");
-    exit();
-  }
-  printf(stdout, "open test ok\n");
-}
-
-void
-writetest(void)
-{
-  int fd;
-  int i;
-
-  printf(stdout, "small file test\n");
-  fd = open("small", O_CREATE|O_RDWR);
-  if(fd >= 0){
-    printf(stdout, "creat small succeeded; ok\n");
-  } else {
-    printf(stdout, "error: creat small failed!\n");
-    exit();
-  }
-  for(i = 0; i < 100; i++){
-    if(write(fd, "aaaaaaaaaa", 10) != 10){
-      printf(stdout, "error: write aa %d new file failed\n", i);
-      exit();
-    }
-    if(write(fd, "bbbbbbbbbb", 10) != 10){
-      printf(stdout, "error: write bb %d new file failed\n", i);
-      exit();
-    }
-  }
-  printf(stdout, "writes ok\n");
-  close(fd);
-  fd = open("small", O_RDONLY);
-  if(fd >= 0){
-    printf(stdout, "open small succeeded ok\n");
-  } else {
-    printf(stdout, "error: open small failed!\n");
-    exit();
-  }
-  i = read(fd, buf, 2000);
-  if(i == 2000){
-    printf(stdout, "read succeeded ok\n");
-  } else {
-    printf(stdout, "read failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(unlink("small") < 0){
-    printf(stdout, "unlink small failed\n");
-    exit();
-  }
-  printf(stdout, "small file test ok\n");
-}
-
-void
-writetest1(void)
-{
-  int i, fd, n;
-
-  printf(stdout, "big files test\n");
-
-  fd = open("big", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(stdout, "error: creat big failed!\n");
-    exit();
-  }
-
-  for(i = 0; i < MAXFILE; i++){
-    ((int*)buf)[0] = i;
-    if(write(fd, buf, 512) != 512){
-      printf(stdout, "error: write big file failed\n", i);
-      exit();
-    }
-  }
-
-  close(fd);
-
-  fd = open("big", O_RDONLY);
-  if(fd < 0){
-    printf(stdout, "error: open big failed!\n");
-    exit();
-  }
-
-  n = 0;
-  for(;;){
-    i = read(fd, buf, 512);
-    if(i == 0){
-      if(n == MAXFILE - 1){
-        printf(stdout, "read only %d blocks from big", n);
-        exit();
-      }
-      break;
-    } else if(i != 512){
-      printf(stdout, "read failed %d\n", i);
-      exit();
-    }
-    if(((int*)buf)[0] != n){
-      printf(stdout, "read content of block %d is %d\n",
-             n, ((int*)buf)[0]);
-      exit();
-    }
-    n++;
-  }
-  close(fd);
-  if(unlink("big") < 0){
-    printf(stdout, "unlink big failed\n");
-    exit();
-  }
-  printf(stdout, "big files ok\n");
-}
-
-void
-createtest(void)
-{
-  int i, fd;
-
-  printf(stdout, "many creates, followed by unlink test\n");
-
-  name[0] = 'a';
-  name[2] = '\0';
-  for(i = 0; i < 52; i++){
-    name[1] = '0' + i;
-    fd = open(name, O_CREATE|O_RDWR);
-    close(fd);
-  }
-  name[0] = 'a';
-  name[2] = '\0';
-  for(i = 0; i < 52; i++){
-    name[1] = '0' + i;
-    unlink(name);
-  }
-  printf(stdout, "many creates, followed by unlink; ok\n");
-}
-
-void dirtest(void)
-{
-  printf(stdout, "mkdir test\n");
-
-  if(mkdir("dir0") < 0){
-    printf(stdout, "mkdir failed\n");
-    exit();
-  }
-
-  if(chdir("dir0") < 0){
-    printf(stdout, "chdir dir0 failed\n");
-    exit();
-  }
-
-  if(chdir("..") < 0){
-    printf(stdout, "chdir .. failed\n");
-    exit();
-  }
-
-  if(unlink("dir0") < 0){
-    printf(stdout, "unlink dir0 failed\n");
-    exit();
-  }
-  printf(stdout, "mkdir test ok\n");
-}
-
-void
-exectest(void)
-{
-  printf(stdout, "exec test\n");
-  if(exec("echo", echoargv) < 0){
-    printf(stdout, "exec echo failed\n");
-    exit();
-  }
-}
-
-// simple fork and pipe read/write
-
-void
-pipe1(void)
-{
-  int fds[2], pid;
-  int seq, i, n, cc, total;
-
-  if(pipe(fds) != 0){
-    printf(1, "pipe() failed\n");
-    exit();
-  }
-  pid = fork();
-  seq = 0;
-  if(pid == 0){
-    close(fds[0]);
-    for(n = 0; n < 5; n++){
-      for(i = 0; i < 1033; i++)
-        buf[i] = seq++;
-      if(write(fds[1], buf, 1033) != 1033){
-        printf(1, "pipe1 oops 1\n");
-        exit();
-      }
-    }
-    exit();
-  } else if(pid > 0){
-    close(fds[1]);
-    total = 0;
-    cc = 1;
-    while((n = read(fds[0], buf, cc)) > 0){
-      for(i = 0; i < n; i++){
-        if((buf[i] & 0xff) != (seq++ & 0xff)){
-          printf(1, "pipe1 oops 2\n");
-          return;
-        }
-      }
-      total += n;
-      cc = cc * 2;
-      if(cc > sizeof(buf))
-        cc = sizeof(buf);
-    }
-    if(total != 5 * 1033){
-      printf(1, "pipe1 oops 3 total %d\n", total);
-      exit();
-    }
-    close(fds[0]);
-    wait();
-  } else {
-    printf(1, "fork() failed\n");
-    exit();
-  }
-  printf(1, "pipe1 ok\n");
-}
-
-// meant to be run w/ at most two CPUs
-void
-preempt(void)
-{
-  int pid1, pid2, pid3;
-  int pfds[2];
-
-  printf(1, "preempt: ");
-  pid1 = fork();
-  if(pid1 == 0)
-    for(;;)
-      ;
-
-  pid2 = fork();
-  if(pid2 == 0)
-    for(;;)
-      ;
-
-  pipe(pfds);
-  pid3 = fork();
-  if(pid3 == 0){
-    close(pfds[0]);
-    if(write(pfds[1], "x", 1) != 1)
-      printf(1, "preempt write error");
-    close(pfds[1]);
-    for(;;)
-      ;
-  }
-
-  close(pfds[1]);
-  if(read(pfds[0], buf, sizeof(buf)) != 1){
-    printf(1, "preempt read error");
-    return;
-  }
-  close(pfds[0]);
-  printf(1, "kill... ");
-  kill(pid1);
-  kill(pid2);
-  kill(pid3);
-  printf(1, "wait... ");
-  wait();
-  wait();
-  wait();
-  printf(1, "preempt ok\n");
-}
-
-// try to find any races between exit and wait
-void
-exitwait(void)
-{
-  int i, pid;
-
-  for(i = 0; i < 100; i++){
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      return;
-    }
-    if(pid){
-      if(wait() != pid){
-        printf(1, "wait wrong pid\n");
-        return;
-      }
-    } else {
-      exit();
-    }
-  }
-  printf(1, "exitwait ok\n");
-}
-
-void
-mem(void)
-{
-  void *m1, *m2;
-  int pid, ppid;
-
-  printf(1, "mem test\n");
-  ppid = getpid();
-  if((pid = fork()) == 0){
-    m1 = 0;
-    while((m2 = malloc(10001)) != 0){
-      *(char**)m2 = m1;
-      m1 = m2;
-    }
-    while(m1){
-      m2 = *(char**)m1;
-      free(m1);
-      m1 = m2;
-    }
-    m1 = malloc(1024*20);
-    if(m1 == 0){
-      printf(1, "couldn't allocate mem?!!\n");
-      kill(ppid);
-      exit();
-    }
-    free(m1);
-    printf(1, "mem ok\n");
-    exit();
-  } else {
-    wait();
-  }
-}
-
-// More file system tests
-
-// two processes write to the same file descriptor
-// is the offset shared? does inode locking work?
-void
-sharedfd(void)
-{
-  int fd, pid, i, n, nc, np;
-  char buf[10];
-
-  printf(1, "sharedfd test\n");
-
-  unlink("sharedfd");
-  fd = open("sharedfd", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(1, "fstests: cannot open sharedfd for writing");
-    return;
-  }
-  pid = fork();
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-  for(i = 0; i < 1000; i++){
-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
-      printf(1, "fstests: write sharedfd failed\n");
-      break;
-    }
-  }
-  if(pid == 0)
-    exit();
-  else
-    wait();
-  close(fd);
-  fd = open("sharedfd", 0);
-  if(fd < 0){
-    printf(1, "fstests: cannot open sharedfd for reading\n");
-    return;
-  }
-  nc = np = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i = 0; i < sizeof(buf); i++){
-      if(buf[i] == 'c')
-        nc++;
-      if(buf[i] == 'p')
-        np++;
-    }
-  }
-  close(fd);
-  unlink("sharedfd");
-  if(nc == 10000 && np == 10000){
-    printf(1, "sharedfd ok\n");
-  } else {
-    printf(1, "sharedfd oops %d %d\n", nc, np);
-    exit();
-  }
-}
-
-// four processes write different files at the same
-// time, to test block allocation.
-void
-fourfiles(void)
-{
-  int fd, pid, i, j, n, total, pi;
-  char *names[] = { "f0", "f1", "f2", "f3" };
-  char *fname;
-
-  printf(1, "fourfiles test\n");
-
-  for(pi = 0; pi < 4; pi++){
-    fname = names[pi];
-    unlink(fname);
-
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-
-    if(pid == 0){
-      fd = open(fname, O_CREATE | O_RDWR);
-      if(fd < 0){
-        printf(1, "create failed\n");
-        exit();
-      }
-
-      memset(buf, '0'+pi, 512);
-      for(i = 0; i < 12; i++){
-        if((n = write(fd, buf, 500)) != 500){
-          printf(1, "write failed %d\n", n);
-          exit();
-        }
-      }
-      exit();
-    }
-  }
-
-  for(pi = 0; pi < 4; pi++){
-    wait();
-  }
-
-  for(i = 0; i < 2; i++){
-    fname = names[i];
-    fd = open(fname, 0);
-    total = 0;
-    while((n = read(fd, buf, sizeof(buf))) > 0){
-      for(j = 0; j < n; j++){
-        if(buf[j] != '0'+i){
-          printf(1, "wrong char\n");
-          exit();
-        }
-      }
-      total += n;
-    }
-    close(fd);
-    if(total != 12*500){
-      printf(1, "wrong length %d\n", total);
-      exit();
-    }
-    unlink(fname);
-  }
-
-  printf(1, "fourfiles ok\n");
-}
-
-// four processes create and delete different files in same directory
-void
-createdelete(void)
-{
-  enum { N = 20 };
-  int pid, i, fd, pi;
-  char name[32];
-
-  printf(1, "createdelete test\n");
-
-  for(pi = 0; pi < 4; pi++){
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-
-    if(pid == 0){
-      name[0] = 'p' + pi;
-      name[2] = '\0';
-      for(i = 0; i < N; i++){
-        name[1] = '0' + i;
-        fd = open(name, O_CREATE | O_RDWR);
-        if(fd < 0){
-          printf(1, "create failed\n");
-          exit();
-        }
-        close(fd);
-        if(i > 0 && (i % 2 ) == 0){
-          name[1] = '0' + (i / 2);
-          if(unlink(name) < 0){
-            printf(1, "unlink failed\n");
-            exit();
-          }
-        }
-      }
-      exit();
-    }
-  }
-
-  for(pi = 0; pi < 4; pi++){
-    wait();
-  }
-
-  name[0] = name[1] = name[2] = 0;
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
-      name[0] = 'p' + pi;
-      name[1] = '0' + i;
-      fd = open(name, 0);
-      if((i == 0 || i >= N/2) && fd < 0){
-        printf(1, "oops createdelete %s didn't exist\n", name);
-        exit();
-      } else if((i >= 1 && i < N/2) && fd >= 0){
-        printf(1, "oops createdelete %s did exist\n", name);
-        exit();
-      }
-      if(fd >= 0)
-        close(fd);
-    }
-  }
-
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
-      name[0] = 'p' + i;
-      name[1] = '0' + i;
-      unlink(name);
-    }
-  }
-
-  printf(1, "createdelete ok\n");
-}
-
-// can I unlink a file and still read it?
-void
-unlinkread(void)
-{
-  int fd, fd1;
-
-  printf(1, "unlinkread test\n");
-  fd = open("unlinkread", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create unlinkread failed\n");
-    exit();
-  }
-  write(fd, "hello", 5);
-  close(fd);
-
-  fd = open("unlinkread", O_RDWR);
-  if(fd < 0){
-    printf(1, "open unlinkread failed\n");
-    exit();
-  }
-  if(unlink("unlinkread") != 0){
-    printf(1, "unlink unlinkread failed\n");
-    exit();
-  }
-
-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
-  write(fd1, "yyy", 3);
-  close(fd1);
-
-  if(read(fd, buf, sizeof(buf)) != 5){
-    printf(1, "unlinkread read failed");
-    exit();
-  }
-  if(buf[0] != 'h'){
-    printf(1, "unlinkread wrong data\n");
-    exit();
-  }
-  if(write(fd, buf, 10) != 10){
-    printf(1, "unlinkread write failed\n");
-    exit();
-  }
-  close(fd);
-  unlink("unlinkread");
-  printf(1, "unlinkread ok\n");
-}
-
-void
-linktest(void)
-{
-  int fd;
-
-  printf(1, "linktest\n");
-
-  unlink("lf1");
-  unlink("lf2");
-
-  fd = open("lf1", O_CREATE|O_RDWR);
-  if(fd < 0){
-    printf(1, "create lf1 failed\n");
-    exit();
-  }
-  if(write(fd, "hello", 5) != 5){
-    printf(1, "write lf1 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("lf1", "lf2") < 0){
-    printf(1, "link lf1 lf2 failed\n");
-    exit();
-  }
-  unlink("lf1");
-
-  if(open("lf1", 0) >= 0){
-    printf(1, "unlinked lf1 but it is still there!\n");
-    exit();
-  }
-
-  fd = open("lf2", 0);
-  if(fd < 0){
-    printf(1, "open lf2 failed\n");
-    exit();
-  }
-  if(read(fd, buf, sizeof(buf)) != 5){
-    printf(1, "read lf2 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("lf2", "lf2") >= 0){
-    printf(1, "link lf2 lf2 succeeded! oops\n");
-    exit();
-  }
-
-  unlink("lf2");
-  if(link("lf2", "lf1") >= 0){
-    printf(1, "link non-existant succeeded! oops\n");
-    exit();
-  }
-
-  if(link(".", "lf1") >= 0){
-    printf(1, "link . lf1 succeeded! oops\n");
-    exit();
-  }
-
-  printf(1, "linktest ok\n");
-}
-
-// test concurrent create/link/unlink of the same file
-void
-concreate(void)
-{
-  char file[3];
-  int i, pid, n, fd;
-  char fa[40];
-  struct {
-    ushort inum;
-    char name[14];
-  } de;
-
-  printf(1, "concreate test\n");
-  file[0] = 'C';
-  file[2] = '\0';
-  for(i = 0; i < 40; i++){
-    file[1] = '0' + i;
-    unlink(file);
-    pid = fork();
-    if(pid && (i % 3) == 1){
-      link("C0", file);
-    } else if(pid == 0 && (i % 5) == 1){
-      link("C0", file);
-    } else {
-      fd = open(file, O_CREATE | O_RDWR);
-      if(fd < 0){
-        printf(1, "concreate create %s failed\n", file);
-        exit();
-      }
-      close(fd);
-    }
-    if(pid == 0)
-      exit();
-    else
-      wait();
-  }
-
-  memset(fa, 0, sizeof(fa));
-  fd = open(".", 0);
-  n = 0;
-  while(read(fd, &de, sizeof(de)) > 0){
-    if(de.inum == 0)
-      continue;
-    if(de.name[0] == 'C' && de.name[2] == '\0'){
-      i = de.name[1] - '0';
-      if(i < 0 || i >= sizeof(fa)){
-        printf(1, "concreate weird file %s\n", de.name);
-        exit();
-      }
-      if(fa[i]){
-        printf(1, "concreate duplicate file %s\n", de.name);
-        exit();
-      }
-      fa[i] = 1;
-      n++;
-    }
-  }
-  close(fd);
-
-  if(n != 40){
-    printf(1, "concreate not enough files in directory listing\n");
-    exit();
-  }
-
-  for(i = 0; i < 40; i++){
-    file[1] = '0' + i;
-    pid = fork();
-    if(pid < 0){
-      printf(1, "fork failed\n");
-      exit();
-    }
-    if(((i % 3) == 0 && pid == 0) ||
-       ((i % 3) == 1 && pid != 0)){
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-      close(open(file, 0));
-    } else {
-      unlink(file);
-      unlink(file);
-      unlink(file);
-      unlink(file);
-    }
-    if(pid == 0)
-      exit();
-    else
-      wait();
-  }
-
-  printf(1, "concreate ok\n");
-}
-
-// another concurrent link/unlink/create test,
-// to look for deadlocks.
-void
-linkunlink()
-{
-  int pid, i;
-
-  printf(1, "linkunlink test\n");
-
-  unlink("x");
-  pid = fork();
-  if(pid < 0){
-    printf(1, "fork failed\n");
-    exit();
-  }
-
-  unsigned int x = (pid ? 1 : 97);
-  for(i = 0; i < 100; i++){
-    x = x * 1103515245 + 12345;
-    if((x % 3) == 0){
-      close(open("x", O_RDWR | O_CREATE));
-    } else if((x % 3) == 1){
-      link("cat", "x");
-    } else {
-      unlink("x");
-    }
-  }
-
-  if(pid)
-    wait();
-  else
-    exit();
-
-  printf(1, "linkunlink ok\n");
-}
-
-// directory that uses indirect blocks
-void
-bigdir(void)
-{
-  int i, fd;
-  char name[10];
-
-  printf(1, "bigdir test\n");
-  unlink("bd");
-
-  fd = open("bd", O_CREATE);
-  if(fd < 0){
-    printf(1, "bigdir create failed\n");
-    exit();
-  }
-  close(fd);
-
-  for(i = 0; i < 500; i++){
-    name[0] = 'x';
-    name[1] = '0' + (i / 64);
-    name[2] = '0' + (i % 64);
-    name[3] = '\0';
-    if(link("bd", name) != 0){
-      printf(1, "bigdir link failed\n");
-      exit();
-    }
-  }
-
-  unlink("bd");
-  for(i = 0; i < 500; i++){
-    name[0] = 'x';
-    name[1] = '0' + (i / 64);
-    name[2] = '0' + (i % 64);
-    name[3] = '\0';
-    if(unlink(name) != 0){
-      printf(1, "bigdir unlink failed");
-      exit();
-    }
-  }
-
-  printf(1, "bigdir ok\n");
-}
-
-void
-subdir(void)
-{
-  int fd, cc;
-
-  printf(1, "subdir test\n");
-
-  unlink("ff");
-  if(mkdir("dd") != 0){
-    printf(1, "subdir mkdir dd failed\n");
-    exit();
-  }
-
-  fd = open("dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create dd/ff failed\n");
-    exit();
-  }
-  write(fd, "ff", 2);
-  close(fd);
-
-  if(unlink("dd") >= 0){
-    printf(1, "unlink dd (non-empty dir) succeeded!\n");
-    exit();
-  }
-
-  if(mkdir("/dd/dd") != 0){
-    printf(1, "subdir mkdir dd/dd failed\n");
-    exit();
-  }
-
-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "create dd/dd/ff failed\n");
-    exit();
-  }
-  write(fd, "FF", 2);
-  close(fd);
-
-  fd = open("dd/dd/../ff", 0);
-  if(fd < 0){
-    printf(1, "open dd/dd/../ff failed\n");
-    exit();
-  }
-  cc = read(fd, buf, sizeof(buf));
-  if(cc != 2 || buf[0] != 'f'){
-    printf(1, "dd/dd/../ff wrong content\n");
-    exit();
-  }
-  close(fd);
-
-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
-    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
-    exit();
-  }
-
-  if(unlink("dd/dd/ff") != 0){
-    printf(1, "unlink dd/dd/ff failed\n");
-    exit();
-  }
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
-    exit();
-  }
-
-  if(chdir("dd") != 0){
-    printf(1, "chdir dd failed\n");
-    exit();
-  }
-  if(chdir("dd/../../dd") != 0){
-    printf(1, "chdir dd/../../dd failed\n");
-    exit();
-  }
-  if(chdir("dd/../../../dd") != 0){
-    printf(1, "chdir dd/../../dd failed\n");
-    exit();
-  }
-  if(chdir("./..") != 0){
-    printf(1, "chdir ./.. failed\n");
-    exit();
-  }
-
-  fd = open("dd/dd/ffff", 0);
-  if(fd < 0){
-    printf(1, "open dd/dd/ffff failed\n");
-    exit();
-  }
-  if(read(fd, buf, sizeof(buf)) != 2){
-    printf(1, "read dd/dd/ffff wrong len\n");
-    exit();
-  }
-  close(fd);
-
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
-    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
-    exit();
-  }
-
-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
-    printf(1, "create dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
-    printf(1, "create dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_CREATE) >= 0){
-    printf(1, "create dd succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_RDWR) >= 0){
-    printf(1, "open dd rdwr succeeded!\n");
-    exit();
-  }
-  if(open("dd", O_WRONLY) >= 0){
-    printf(1, "open dd wronly succeeded!\n");
-    exit();
-  }
-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
-    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
-    exit();
-  }
-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
-    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
-    exit();
-  }
-  if(link("dd/ff", "dd/dd/ffff") == 0){
-    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/ff/ff") == 0){
-    printf(1, "mkdir dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/xx/ff") == 0){
-    printf(1, "mkdir dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(mkdir("dd/dd/ffff") == 0){
-    printf(1, "mkdir dd/dd/ffff succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/xx/ff") == 0){
-    printf(1, "unlink dd/xx/ff succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/ff/ff") == 0){
-    printf(1, "unlink dd/ff/ff succeeded!\n");
-    exit();
-  }
-  if(chdir("dd/ff") == 0){
-    printf(1, "chdir dd/ff succeeded!\n");
-    exit();
-  }
-  if(chdir("dd/xx") == 0){
-    printf(1, "chdir dd/xx succeeded!\n");
-    exit();
-  }
-
-  if(unlink("dd/dd/ffff") != 0){
-    printf(1, "unlink dd/dd/ff failed\n");
-    exit();
-  }
-  if(unlink("dd/ff") != 0){
-    printf(1, "unlink dd/ff failed\n");
-    exit();
-  }
-  if(unlink("dd") == 0){
-    printf(1, "unlink non-empty dd succeeded!\n");
-    exit();
-  }
-  if(unlink("dd/dd") < 0){
-    printf(1, "unlink dd/dd failed\n");
-    exit();
-  }
-  if(unlink("dd") < 0){
-    printf(1, "unlink dd failed\n");
-    exit();
-  }
-
-  printf(1, "subdir ok\n");
-}
-
-// test writes that are larger than the log.
-void
-bigwrite(void)
-{
-  int fd, sz;
-
-  printf(1, "bigwrite test\n");
-
-  unlink("bigwrite");
-  for(sz = 499; sz < 12*512; sz += 471){
-    fd = open("bigwrite", O_CREATE | O_RDWR);
-    if(fd < 0){
-      printf(1, "cannot create bigwrite\n");
-      exit();
-    }
-    int i;
-    for(i = 0; i < 2; i++){
-      int cc = write(fd, buf, sz);
-      if(cc != sz){
-        printf(1, "write(%d) ret %d\n", sz, cc);
-        exit();
-      }
-    }
-    close(fd);
-    unlink("bigwrite");
-  }
-
-  printf(1, "bigwrite ok\n");
-}
-
-void
-bigfile(void)
-{
-  int fd, i, total, cc;
-
-  printf(1, "bigfile test\n");
-
-  unlink("bigfile");
-  fd = open("bigfile", O_CREATE | O_RDWR);
-  if(fd < 0){
-    printf(1, "cannot create bigfile");
-    exit();
-  }
-  for(i = 0; i < 20; i++){
-    memset(buf, i, 600);
-    if(write(fd, buf, 600) != 600){
-      printf(1, "write bigfile failed\n");
-      exit();
-    }
-  }
-  close(fd);
-
-  fd = open("bigfile", 0);
-  if(fd < 0){
-    printf(1, "cannot open bigfile\n");
-    exit();
-  }
-  total = 0;
-  for(i = 0; ; i++){
-    cc = read(fd, buf, 300);
-    if(cc < 0){
-      printf(1, "read bigfile failed\n");
-      exit();
-    }
-    if(cc == 0)
-      break;
-    if(cc != 300){
-      printf(1, "short read bigfile\n");
-      exit();
-    }
-    if(buf[0] != i/2 || buf[299] != i/2){
-      printf(1, "read bigfile wrong data\n");
-      exit();
-    }
-    total += cc;
-  }
-  close(fd);
-  if(total != 20*600){
-    printf(1, "read bigfile wrong total\n");
-    exit();
-  }
-  unlink("bigfile");
-
-  printf(1, "bigfile test ok\n");
-}
-
-void
-fourteen(void)
-{
-  int fd;
-
-  // DIRSIZ is 14.
-  printf(1, "fourteen test\n");
-
-  if(mkdir("12345678901234") != 0){
-    printf(1, "mkdir 12345678901234 failed\n");
-    exit();
-  }
-  if(mkdir("12345678901234/123456789012345") != 0){
-    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
-    exit();
-  }
-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-  if(fd < 0){
-    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
-    exit();
-  }
-  close(fd);
-  fd = open("12345678901234/12345678901234/12345678901234", 0);
-  if(fd < 0){
-    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
-    exit();
-  }
-  close(fd);
-
-  if(mkdir("12345678901234/12345678901234") == 0){
-    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
-    exit();
-  }
-  if(mkdir("123456789012345/12345678901234") == 0){
-    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
-    exit();
-  }
-
-  printf(1, "fourteen ok\n");
-}
-
-void
-rmdot(void)
-{
-  printf(1, "rmdot test\n");
-  if(mkdir("dots") != 0){
-    printf(1, "mkdir dots failed\n");
-    exit();
-  }
-  if(chdir("dots") != 0){
-    printf(1, "chdir dots failed\n");
-    exit();
-  }
-  if(unlink(".") == 0){
-    printf(1, "rm . worked!\n");
-    exit();
-  }
-  if(unlink("..") == 0){
-    printf(1, "rm .. worked!\n");
-    exit();
-  }
-  if(chdir("/") != 0){
-    printf(1, "chdir / failed\n");
-    exit();
-  }
-  if(unlink("dots/.") == 0){
-    printf(1, "unlink dots/. worked!\n");
-    exit();
-  }
-  if(unlink("dots/..") == 0){
-    printf(1, "unlink dots/.. worked!\n");
-    exit();
-  }
-  if(unlink("dots") != 0){
-    printf(1, "unlink dots failed!\n");
-    exit();
-  }
-  printf(1, "rmdot ok\n");
-}
-
-void
-dirfile(void)
-{
-  int fd;
-
-  printf(1, "dir vs file\n");
-
-  fd = open("dirfile", O_CREATE);
-  if(fd < 0){
-    printf(1, "create dirfile failed\n");
-    exit();
-  }
-  close(fd);
-  if(chdir("dirfile") == 0){
-    printf(1, "chdir dirfile succeeded!\n");
-    exit();
-  }
-  fd = open("dirfile/xx", 0);
-  if(fd >= 0){
-    printf(1, "create dirfile/xx succeeded!\n");
-    exit();
-  }
-  fd = open("dirfile/xx", O_CREATE);
-  if(fd >= 0){
-    printf(1, "create dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(mkdir("dirfile/xx") == 0){
-    printf(1, "mkdir dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(unlink("dirfile/xx") == 0){
-    printf(1, "unlink dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(link("README", "dirfile/xx") == 0){
-    printf(1, "link to dirfile/xx succeeded!\n");
-    exit();
-  }
-  if(unlink("dirfile") != 0){
-    printf(1, "unlink dirfile failed!\n");
-    exit();
-  }
-
-  fd = open(".", O_RDWR);
-  if(fd >= 0){
-    printf(1, "open . for writing succeeded!\n");
-    exit();
-  }
-  fd = open(".", 0);
-  if(write(fd, "x", 1) > 0){
-    printf(1, "write . succeeded!\n");
-    exit();
-  }
-  close(fd);
-
-  printf(1, "dir vs file OK\n");
-}
-
-// test that iput() is called at the end of _namei()
-void
-iref(void)
-{
-  int i, fd;
-
-  printf(1, "empty file name\n");
-
-  // the 50 is NINODE
-  for(i = 0; i < 50 + 1; i++){
-    if(mkdir("irefd") != 0){
-      printf(1, "mkdir irefd failed\n");
-      exit();
-    }
-    if(chdir("irefd") != 0){
-      printf(1, "chdir irefd failed\n");
-      exit();
-    }
-
-    mkdir("");
-    link("README", "");
-    fd = open("", O_CREATE);
-    if(fd >= 0)
-      close(fd);
-    fd = open("xx", O_CREATE);
-    if(fd >= 0)
-      close(fd);
-    unlink("xx");
-  }
-
-  chdir("/");
-  printf(1, "empty file name OK\n");
-}
-
-// test that fork fails gracefully
-// the forktest binary also does this, but it runs out of proc entries first.
-// inside the bigger usertests binary, we run out of memory first.
-void
-forktest(void)
-{
-  int n, pid;
-
-  printf(1, "fork test\n");
-
-  for(n=0; n<1000; n++){
-    pid = fork();
-    if(pid < 0)
-      break;
-    if(pid == 0)
-      exit();
-  }
-
-  if(n == 1000){
-    printf(1, "fork claimed to work 1000 times!\n");
-    exit();
-  }
-
-  for(; n > 0; n--){
-    if(wait() < 0){
-      printf(1, "wait stopped early\n");
-      exit();
-    }
-  }
-
-  if(wait() != -1){
-    printf(1, "wait got too many\n");
-    exit();
-  }
-
-  printf(1, "fork test OK\n");
-}
-
-void
-sbrktest(void)
-{
-  int fds[2], pid, pids[10], ppid;
-  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
-  uint amt;
-
-  printf(stdout, "sbrk test\n");
-  oldbrk = sbrk(0);
-
-  // can one sbrk() less than a page?
-  a = sbrk(0);
-  int i;
-  for(i = 0; i < 5000; i++){
-    b = sbrk(1);
-    if(b != a){
-      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
-      exit();
-    }
-    *b = 1;
-    a = b + 1;
-  }
-  pid = fork();
-  if(pid < 0){
-    printf(stdout, "sbrk test fork failed\n");
-    exit();
-  }
-  c = sbrk(1);
-  c = sbrk(1);
-  if(c != a + 1){
-    printf(stdout, "sbrk test failed post-fork\n");
-    exit();
-  }
-  if(pid == 0)
-    exit();
-  wait();
-
-  // can one grow address space to something big?
-#define BIG (100*1024*1024)
-  a = sbrk(0);
-  amt = (BIG) - (uint)a;
-  p = sbrk(amt);
-  if (p != a) {
-    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
-    exit();
-  }
-  lastaddr = (char*) (BIG-1);
-  *lastaddr = 99;
-
-  // can one de-allocate?
-  a = sbrk(0);
-  c = sbrk(-4096);
-  if(c == (char*)0xffffffff){
-    printf(stdout, "sbrk could not deallocate\n");
-    exit();
-  }
-  c = sbrk(0);
-  if(c != a - 4096){
-    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
-    exit();
-  }
-
-  // can one re-allocate that page?
-  a = sbrk(0);
-  c = sbrk(4096);
-  if(c != a || sbrk(0) != a + 4096){
-    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
-    exit();
-  }
-  if(*lastaddr == 99){
-    // should be zero
-    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
-    exit();
-  }
-
-  a = sbrk(0);
-  c = sbrk(-(sbrk(0) - oldbrk));
-  if(c != a){
-    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
-    exit();
-  }
-
-  // can we read the kernel's memory?
-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
-    ppid = getpid();
-    pid = fork();
-    if(pid < 0){
-      printf(stdout, "fork failed\n");
-      exit();
-    }
-    if(pid == 0){
-      printf(stdout, "oops could read %x = %x\n", a, *a);
-      kill(ppid);
-      exit();
-    }
-    wait();
-  }
-
-  // if we run the system out of memory, does it clean up the last
-  // failed allocation?
-  if(pipe(fds) != 0){
-    printf(1, "pipe() failed\n");
-    exit();
-  }
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if((pids[i] = fork()) == 0){
-      // allocate a lot of memory
-      sbrk(BIG - (uint)sbrk(0));
-      write(fds[1], "x", 1);
-      // sit around until killed
-      for(;;) sleep(1000);
-    }
-    if(pids[i] != -1)
-      read(fds[0], &scratch, 1);
-  }
-  // if those failed allocations freed up the pages they did allocate,
-  // we'll be able to allocate here
-  c = sbrk(4096);
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if(pids[i] == -1)
-      continue;
-    kill(pids[i]);
-    wait();
-  }
-  if(c == (char*)0xffffffff){
-    printf(stdout, "failed sbrk leaked memory\n");
-    exit();
-  }
-
-  if(sbrk(0) > oldbrk)
-    sbrk(-(sbrk(0) - oldbrk));
-
-  printf(stdout, "sbrk test OK\n");
-}
-
-void
-validateint(int *p)
-{
-  int res;
-  asm("mov %%esp, %%ebx\n\t"
-      "mov %3, %%esp\n\t"
-      "int %2\n\t"
-      "mov %%ebx, %%esp" :
-      "=a" (res) :
-      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
-      "ebx");
-}
-
-void
-validatetest(void)
-{
-  int hi, pid;
-  uint p;
-
-  printf(stdout, "validate test\n");
-  hi = 1100*1024;
-
-  for(p = 0; p <= (uint)hi; p += 4096){
-    if((pid = fork()) == 0){
-      // try to crash the kernel by passing in a badly placed integer
-      validateint((int*)p);
-      exit();
-    }
-    sleep(0);
-    sleep(0);
-    kill(pid);
-    wait();
-
-    // try to crash the kernel by passing in a bad string pointer
-    if(link("nosuchfile", (char*)p) != -1){
-      printf(stdout, "link should not succeed\n");
-      exit();
-    }
-  }
-
-  printf(stdout, "validate ok\n");
-}
-
-// does unintialized data start out zero?
-char uninit[10000];
-void
-bsstest(void)
-{
-  int i;
-
-  printf(stdout, "bss test\n");
-  for(i = 0; i < sizeof(uninit); i++){
-    if(uninit[i] != '\0'){
-      printf(stdout, "bss test failed\n");
-      exit();
-    }
-  }
-  printf(stdout, "bss test ok\n");
-}
-
-// does exec return an error if the arguments
-// are larger than a page? or does it write
-// below the stack and wreck the instructions/data?
-void
-bigargtest(void)
-{
-  int pid, fd;
-
-  unlink("bigarg-ok");
-  pid = fork();
-  if(pid == 0){
-    static char *args[MAXARG];
-    int i;
-    for(i = 0; i < MAXARG-1; i++)
-      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
-    args[MAXARG-1] = 0;
-    printf(stdout, "bigarg test\n");
-    exec("echo", args);
-    printf(stdout, "bigarg test ok\n");
-    fd = open("bigarg-ok", O_CREATE);
-    close(fd);
-    exit();
-  } else if(pid < 0){
-    printf(stdout, "bigargtest: fork failed\n");
-    exit();
-  }
-  wait();
-  fd = open("bigarg-ok", 0);
-  if(fd < 0){
-    printf(stdout, "bigarg test failed!\n");
-    exit();
-  }
-  close(fd);
-  unlink("bigarg-ok");
-}
-
-// what happens when the file system runs out of blocks?
-// answer: balloc panics, so this test is not useful.
-void
-fsfull()
-{
-  int nfiles;
-  int fsblocks = 0;
-
-  printf(1, "fsfull test\n");
-
-  for(nfiles = 0; ; nfiles++){
-    char name[64];
-    name[0] = 'f';
-    name[1] = '0' + nfiles / 1000;
-    name[2] = '0' + (nfiles % 1000) / 100;
-    name[3] = '0' + (nfiles % 100) / 10;
-    name[4] = '0' + (nfiles % 10);
-    name[5] = '\0';
-    printf(1, "writing %s\n", name);
-    int fd = open(name, O_CREATE|O_RDWR);
-    if(fd < 0){
-      printf(1, "open %s failed\n", name);
-      break;
-    }
-    int total = 0;
-    while(1){
-      int cc = write(fd, buf, 512);
-      if(cc < 512)
-        break;
-      total += cc;
-      fsblocks++;
-    }
-    printf(1, "wrote %d bytes\n", total);
-    close(fd);
-    if(total == 0)
-      break;
-  }
-
-  while(nfiles >= 0){
-    char name[64];
-    name[0] = 'f';
-    name[1] = '0' + nfiles / 1000;
-    name[2] = '0' + (nfiles % 1000) / 100;
-    name[3] = '0' + (nfiles % 100) / 10;
-    name[4] = '0' + (nfiles % 10);
-    name[5] = '\0';
-    unlink(name);
-    nfiles--;
-  }
-
-  printf(1, "fsfull test finished\n");
-}
-
-void
-uio()
-{
-  #define RTC_ADDR 0x70
-  #define RTC_DATA 0x71
-
-  ushort port = 0;
-  uchar val = 0;
-  int pid;
-
-  printf(1, "uio test\n");
-  pid = fork();
-  if(pid == 0){
-    port = RTC_ADDR;
-    val = 0x09;  /* year */
-    /* http://wiki.osdev.org/Inline_Assembly/Examples */
-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
-    port = RTC_DATA;
-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
-    printf(1, "uio: uio succeeded; test FAILED\n");
-    exit();
-  } else if(pid < 0){
-    printf (1, "fork failed\n");
-    exit();
-  }
-  wait();
-  printf(1, "uio test done\n");
-}
-
-void argptest()
-{
-  int fd;
-  fd = open("init", O_RDONLY);
-  if (fd < 0) {
-    printf(2, "open failed\n");
-    exit();
-  }
-  read(fd, sbrk(0) - 1, -1);
-  close(fd);
-  printf(1, "arg test passed\n");
-}
-
-unsigned long randstate = 1;
-unsigned int
-rand()
-{
-  randstate = randstate * 1664525 + 1013904223;
-  return randstate;
-}
-
-int
-main(int argc, char *argv[])
-{
-  printf(1, "usertests starting\n");
-
-  if(open("usertests.ran", 0) >= 0){
-    printf(1, "already ran user tests -- rebuild fs.img\n");
-    exit();
-  }
-  close(open("usertests.ran", O_CREATE));
-
-  argptest();
-  createdelete();
-  linkunlink();
-  concreate();
-  fourfiles();
-  sharedfd();
-
-  bigargtest();
-  bigwrite();
-  bigargtest();
-  bsstest();
-  sbrktest();
-  validatetest();
-
-  opentest();
-  writetest();
-  writetest1();
-  createtest();
-
-  openiputtest();
-  exitiputtest();
-  iputtest();
-
-  mem();
-  pipe1();
-  preempt();
-  exitwait();
-
-  rmdot();
-  fourteen();
-  bigfile();
-  subdir();
-  linktest();
-  unlinkread();
-  dirfile();
-  iref();
-  forktest();
-  bigdir(); // slow
-
-  uio();
-
-  exectest();
-
-  exit();
-}
diff -ruN xv6-public/usys.S xv6-public_new/usys.S
--- xv6-public/usys.S	2021-09-30 23:28:57.821391200 +0530
+++ xv6-public_new/usys.S	1970-01-01 05:30:00.000000000 +0530
@@ -1,31 +0,0 @@
-#include "syscall.h"
-#include "traps.h"
-
-#define SYSCALL(name) \
-  .globl name; \
-  name: \
-    movl $SYS_ ## name, %eax; \
-    int $T_SYSCALL; \
-    ret
-
-SYSCALL(fork)
-SYSCALL(exit)
-SYSCALL(wait)
-SYSCALL(pipe)
-SYSCALL(read)
-SYSCALL(write)
-SYSCALL(close)
-SYSCALL(kill)
-SYSCALL(exec)
-SYSCALL(open)
-SYSCALL(mknod)
-SYSCALL(unlink)
-SYSCALL(fstat)
-SYSCALL(link)
-SYSCALL(mkdir)
-SYSCALL(chdir)
-SYSCALL(dup)
-SYSCALL(getpid)
-SYSCALL(sbrk)
-SYSCALL(sleep)
-SYSCALL(uptime)
diff -ruN xv6-public/vectors.pl xv6-public_new/vectors.pl
--- xv6-public/vectors.pl	2021-09-30 23:28:57.823391400 +0530
+++ xv6-public_new/vectors.pl	1970-01-01 05:30:00.000000000 +0530
@@ -1,47 +0,0 @@
-#!/usr/bin/perl -w
-
-# Generate vectors.S, the trap/interrupt entry points.
-# There has to be one entry point per interrupt number
-# since otherwise there's no way for trap() to discover
-# the interrupt number.
-
-print "# generated by vectors.pl - do not edit\n";
-print "# handlers\n";
-print ".globl alltraps\n";
-for(my $i = 0; $i < 256; $i++){
-    print ".globl vector$i\n";
-    print "vector$i:\n";
-    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
-        print "  pushl \$0\n";
-    }
-    print "  pushl \$$i\n";
-    print "  jmp alltraps\n";
-}
-
-print "\n# vector table\n";
-print ".data\n";
-print ".globl vectors\n";
-print "vectors:\n";
-for(my $i = 0; $i < 256; $i++){
-    print "  .long vector$i\n";
-}
-
-# sample output:
-#   # handlers
-#   .globl alltraps
-#   .globl vector0
-#   vector0:
-#     pushl $0
-#     pushl $0
-#     jmp alltraps
-#   ...
-#   
-#   # vector table
-#   .data
-#   .globl vectors
-#   vectors:
-#     .long vector0
-#     .long vector1
-#     .long vector2
-#   ...
-
diff -ruN xv6-public/vm.c xv6-public_new/vm.c
--- xv6-public/vm.c	2021-09-30 23:28:57.826391200 +0530
+++ xv6-public_new/vm.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,394 +0,0 @@
-#include "param.h"
-#include "types.h"
-#include "defs.h"
-#include "x86.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "elf.h"
-
-extern char data[];  // defined by kernel.ld
-pde_t *kpgdir;  // for use in scheduler()
-
-// Set up CPU's kernel segment descriptors.
-// Run once on entry on each CPU.
-void
-seginit(void)
-{
-  struct cpu *c;
-
-  // Map "logical" addresses to virtual addresses using identity map.
-  // Cannot share a CODE descriptor for both kernel and user
-  // because it would have to have DPL_USR, but the CPU forbids
-  // an interrupt from CPL=0 to DPL=3.
-  c = &cpus[cpuid()];
-  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
-  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
-  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
-  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
-  lgdt(c->gdt, sizeof(c->gdt));
-}
-
-// Return the address of the PTE in page table pgdir
-// that corresponds to virtual address va.  If alloc!=0,
-// create any required page table pages.
-static pte_t *
-walkpgdir(pde_t *pgdir, const void *va, int alloc)
-{
-  pde_t *pde;
-  pte_t *pgtab;
-
-  pde = &pgdir[PDX(va)];
-  if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
-  } else {
-    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
-      return 0;
-    // Make sure all those PTE_P bits are zero.
-    memset(pgtab, 0, PGSIZE);
-    // The permissions here are overly generous, but they can
-    // be further restricted by the permissions in the page table
-    // entries, if necessary.
-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
-  }
-  return &pgtab[PTX(va)];
-}
-
-// Create PTEs for virtual addresses starting at va that refer to
-// physical addresses starting at pa. va and size might not
-// be page-aligned.
-static int
-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
-{
-  char *a, *last;
-  pte_t *pte;
-
-  a = (char*)PGROUNDDOWN((uint)va);
-  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
-  for(;;){
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
-      return -1;
-    if(*pte & PTE_P)
-      panic("remap");
-    *pte = pa | perm | PTE_P;
-    if(a == last)
-      break;
-    a += PGSIZE;
-    pa += PGSIZE;
-  }
-  return 0;
-}
-
-// There is one page table per process, plus one that's used when
-// a CPU is not running any process (kpgdir). The kernel uses the
-// current process's page table during system calls and interrupts;
-// page protection bits prevent user code from using the kernel's
-// mappings.
-//
-// setupkvm() and exec() set up every page table like this:
-//
-//   0..KERNBASE: user memory (text+data+stack+heap), mapped to
-//                phys memory allocated by the kernel
-//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
-//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
-//                for the kernel's instructions and r/o data
-//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
-//                                  rw data + free physical memory
-//   0xfe000000..0: mapped direct (devices such as ioapic)
-//
-// The kernel allocates physical memory for its heap and for user memory
-// between V2P(end) and the end of physical memory (PHYSTOP)
-// (directly addressable from end..P2V(PHYSTOP)).
-
-// This table defines the kernel's mappings, which are present in
-// every process's page table.
-static struct kmap {
-  void *virt;
-  uint phys_start;
-  uint phys_end;
-  int perm;
-} kmap[] = {
- { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
- { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
- { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
- { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
-};
-
-// Set up kernel part of a page table.
-pde_t*
-setupkvm(void)
-{
-  pde_t *pgdir;
-  struct kmap *k;
-
-  if((pgdir = (pde_t*)kalloc()) == 0)
-    return 0;
-  memset(pgdir, 0, PGSIZE);
-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
-    panic("PHYSTOP too high");
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
-                (uint)k->phys_start, k->perm) < 0) {
-      freevm(pgdir);
-      return 0;
-    }
-  return pgdir;
-}
-
-// Allocate one page table for the machine for the kernel address
-// space for scheduler processes.
-void
-kvmalloc(void)
-{
-  kpgdir = setupkvm();
-  switchkvm();
-}
-
-// Switch h/w page table register to the kernel-only page table,
-// for when no process is running.
-void
-switchkvm(void)
-{
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
-}
-
-// Switch TSS and h/w page table to correspond to process p.
-void
-switchuvm(struct proc *p)
-{
-  if(p == 0)
-    panic("switchuvm: no process");
-  if(p->kstack == 0)
-    panic("switchuvm: no kstack");
-  if(p->pgdir == 0)
-    panic("switchuvm: no pgdir");
-
-  pushcli();
-  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
-                                sizeof(mycpu()->ts)-1, 0);
-  mycpu()->gdt[SEG_TSS].s = 0;
-  mycpu()->ts.ss0 = SEG_KDATA << 3;
-  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
-  // forbids I/O instructions (e.g., inb and outb) from user space
-  mycpu()->ts.iomb = (ushort) 0xFFFF;
-  ltr(SEG_TSS << 3);
-  lcr3(V2P(p->pgdir));  // switch to process's address space
-  popcli();
-}
-
-// Load the initcode into address 0 of pgdir.
-// sz must be less than a page.
-void
-inituvm(pde_t *pgdir, char *init, uint sz)
-{
-  char *mem;
-
-  if(sz >= PGSIZE)
-    panic("inituvm: more than a page");
-  mem = kalloc();
-  memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
-  memmove(mem, init, sz);
-}
-
-// Load a program segment into pgdir.  addr must be page-aligned
-// and the pages from addr to addr+sz must already be mapped.
-int
-loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
-{
-  uint i, pa, n;
-  pte_t *pte;
-
-  if((uint) addr % PGSIZE != 0)
-    panic("loaduvm: addr must be page aligned");
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
-      panic("loaduvm: address should exist");
-    pa = PTE_ADDR(*pte);
-    if(sz - i < PGSIZE)
-      n = sz - i;
-    else
-      n = PGSIZE;
-    if(readi(ip, P2V(pa), offset+i, n) != n)
-      return -1;
-  }
-  return 0;
-}
-
-// Allocate page tables and physical memory to grow process from oldsz to
-// newsz, which need not be page aligned.  Returns new size or 0 on error.
-int
-allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-{
-  char *mem;
-  uint a;
-
-  if(newsz >= KERNBASE)
-    return 0;
-  if(newsz < oldsz)
-    return oldsz;
-
-  a = PGROUNDUP(oldsz);
-  for(; a < newsz; a += PGSIZE){
-    mem = kalloc();
-    if(mem == 0){
-      cprintf("allocuvm out of memory\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      return 0;
-    }
-    memset(mem, 0, PGSIZE);
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
-      cprintf("allocuvm out of memory (2)\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      kfree(mem);
-      return 0;
-    }
-  }
-  return newsz;
-}
-
-// Deallocate user pages to bring the process size from oldsz to
-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
-// need to be less than oldsz.  oldsz can be larger than the actual
-// process size.  Returns the new process size.
-int
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
-{
-  pte_t *pte;
-  uint a, pa;
-
-  if(newsz >= oldsz)
-    return oldsz;
-
-  a = PGROUNDUP(newsz);
-  for(; a  < oldsz; a += PGSIZE){
-    pte = walkpgdir(pgdir, (char*)a, 0);
-    if(!pte)
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-    else if((*pte & PTE_P) != 0){
-      pa = PTE_ADDR(*pte);
-      if(pa == 0)
-        panic("kfree");
-      char *v = P2V(pa);
-      kfree(v);
-      *pte = 0;
-    }
-  }
-  return newsz;
-}
-
-// Free a page table and all the physical memory pages
-// in the user part.
-void
-freevm(pde_t *pgdir)
-{
-  uint i;
-
-  if(pgdir == 0)
-    panic("freevm: no pgdir");
-  deallocuvm(pgdir, KERNBASE, 0);
-  for(i = 0; i < NPDENTRIES; i++){
-    if(pgdir[i] & PTE_P){
-      char * v = P2V(PTE_ADDR(pgdir[i]));
-      kfree(v);
-    }
-  }
-  kfree((char*)pgdir);
-}
-
-// Clear PTE_U on a page. Used to create an inaccessible
-// page beneath the user stack.
-void
-clearpteu(pde_t *pgdir, char *uva)
-{
-  pte_t *pte;
-
-  pte = walkpgdir(pgdir, uva, 0);
-  if(pte == 0)
-    panic("clearpteu");
-  *pte &= ~PTE_U;
-}
-
-// Given a parent process's page table, create a copy
-// of it for a child.
-pde_t*
-copyuvm(pde_t *pgdir, uint sz)
-{
-  pde_t *d;
-  pte_t *pte;
-  uint pa, i, flags;
-  char *mem;
-
-  if((d = setupkvm()) == 0)
-    return 0;
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
-      panic("copyuvm: pte should exist");
-    if(!(*pte & PTE_P))
-      panic("copyuvm: page not present");
-    pa = PTE_ADDR(*pte);
-    flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
-      kfree(mem);
-      goto bad;
-    }
-  }
-  return d;
-
-bad:
-  freevm(d);
-  return 0;
-}
-
-//PAGEBREAK!
-// Map user virtual address to kernel address.
-char*
-uva2ka(pde_t *pgdir, char *uva)
-{
-  pte_t *pte;
-
-  pte = walkpgdir(pgdir, uva, 0);
-  if((*pte & PTE_P) == 0)
-    return 0;
-  if((*pte & PTE_U) == 0)
-    return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
-}
-
-// Copy len bytes from p to user address va in page table pgdir.
-// Most useful when pgdir is not the current page table.
-// uva2ka ensures this only works for PTE_U pages.
-int
-copyout(pde_t *pgdir, uint va, void *p, uint len)
-{
-  char *buf, *pa0;
-  uint n, va0;
-
-  buf = (char*)p;
-  while(len > 0){
-    va0 = (uint)PGROUNDDOWN(va);
-    pa0 = uva2ka(pgdir, (char*)va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (va - va0);
-    if(n > len)
-      n = len;
-    memmove(pa0 + (va - va0), buf, n);
-    len -= n;
-    buf += n;
-    va = va0 + PGSIZE;
-  }
-  return 0;
-}
-
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-//PAGEBREAK!
-// Blank page.
-
diff -ruN xv6-public/wc.c xv6-public_new/wc.c
--- xv6-public/wc.c	2021-09-30 23:28:57.828391400 +0530
+++ xv6-public_new/wc.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,54 +0,0 @@
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-char buf[512];
-
-void
-wc(int fd, char *name)
-{
-  int i, n;
-  int l, w, c, inword;
-
-  l = w = c = 0;
-  inword = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i=0; i<n; i++){
-      c++;
-      if(buf[i] == '\n')
-        l++;
-      if(strchr(" \r\t\n\v", buf[i]))
-        inword = 0;
-      else if(!inword){
-        w++;
-        inword = 1;
-      }
-    }
-  }
-  if(n < 0){
-    printf(1, "wc: read error\n");
-    exit();
-  }
-  printf(1, "%d %d %d %s\n", l, w, c, name);
-}
-
-int
-main(int argc, char *argv[])
-{
-  int fd, i;
-
-  if(argc <= 1){
-    wc(0, "");
-    exit();
-  }
-
-  for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
-      printf(1, "wc: cannot open %s\n", argv[i]);
-      exit();
-    }
-    wc(fd, argv[i]);
-    close(fd);
-  }
-  exit();
-}
diff -ruN xv6-public/x86.h xv6-public_new/x86.h
--- xv6-public/x86.h	2021-09-30 23:28:57.830396000 +0530
+++ xv6-public_new/x86.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,183 +0,0 @@
-// Routines to let C code use special x86 instructions.
-
-static inline uchar
-inb(ushort port)
-{
-  uchar data;
-
-  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
-  return data;
-}
-
-static inline void
-insl(int port, void *addr, int cnt)
-{
-  asm volatile("cld; rep insl" :
-               "=D" (addr), "=c" (cnt) :
-               "d" (port), "0" (addr), "1" (cnt) :
-               "memory", "cc");
-}
-
-static inline void
-outb(ushort port, uchar data)
-{
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-}
-
-static inline void
-outw(ushort port, ushort data)
-{
-  asm volatile("out %0,%1" : : "a" (data), "d" (port));
-}
-
-static inline void
-outsl(int port, const void *addr, int cnt)
-{
-  asm volatile("cld; rep outsl" :
-               "=S" (addr), "=c" (cnt) :
-               "d" (port), "0" (addr), "1" (cnt) :
-               "cc");
-}
-
-static inline void
-stosb(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosb" :
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
-}
-
-static inline void
-stosl(void *addr, int data, int cnt)
-{
-  asm volatile("cld; rep stosl" :
-               "=D" (addr), "=c" (cnt) :
-               "0" (addr), "1" (cnt), "a" (data) :
-               "memory", "cc");
-}
-
-struct segdesc;
-
-static inline void
-lgdt(struct segdesc *p, int size)
-{
-  volatile ushort pd[3];
-
-  pd[0] = size-1;
-  pd[1] = (uint)p;
-  pd[2] = (uint)p >> 16;
-
-  asm volatile("lgdt (%0)" : : "r" (pd));
-}
-
-struct gatedesc;
-
-static inline void
-lidt(struct gatedesc *p, int size)
-{
-  volatile ushort pd[3];
-
-  pd[0] = size-1;
-  pd[1] = (uint)p;
-  pd[2] = (uint)p >> 16;
-
-  asm volatile("lidt (%0)" : : "r" (pd));
-}
-
-static inline void
-ltr(ushort sel)
-{
-  asm volatile("ltr %0" : : "r" (sel));
-}
-
-static inline uint
-readeflags(void)
-{
-  uint eflags;
-  asm volatile("pushfl; popl %0" : "=r" (eflags));
-  return eflags;
-}
-
-static inline void
-loadgs(ushort v)
-{
-  asm volatile("movw %0, %%gs" : : "r" (v));
-}
-
-static inline void
-cli(void)
-{
-  asm volatile("cli");
-}
-
-static inline void
-sti(void)
-{
-  asm volatile("sti");
-}
-
-static inline uint
-xchg(volatile uint *addr, uint newval)
-{
-  uint result;
-
-  // The + in "+m" denotes a read-modify-write operand.
-  asm volatile("lock; xchgl %0, %1" :
-               "+m" (*addr), "=a" (result) :
-               "1" (newval) :
-               "cc");
-  return result;
-}
-
-static inline uint
-rcr2(void)
-{
-  uint val;
-  asm volatile("movl %%cr2,%0" : "=r" (val));
-  return val;
-}
-
-static inline void
-lcr3(uint val)
-{
-  asm volatile("movl %0,%%cr3" : : "r" (val));
-}
-
-//PAGEBREAK: 36
-// Layout of the trap frame built on the stack by the
-// hardware and by trapasm.S, and passed to trap().
-struct trapframe {
-  // registers as pushed by pusha
-  uint edi;
-  uint esi;
-  uint ebp;
-  uint oesp;      // useless & ignored
-  uint ebx;
-  uint edx;
-  uint ecx;
-  uint eax;
-
-  // rest of trap frame
-  ushort gs;
-  ushort padding1;
-  ushort fs;
-  ushort padding2;
-  ushort es;
-  ushort padding3;
-  ushort ds;
-  ushort padding4;
-  uint trapno;
-
-  // below here defined by x86 hardware
-  uint err;
-  uint eip;
-  ushort cs;
-  ushort padding5;
-  uint eflags;
-
-  // below here only when crossing rings, such as from user to kernel
-  uint esp;
-  ushort ss;
-  ushort padding6;
-};
diff -ruN xv6-public/xv6-public/.cvsignore xv6-public_new/xv6-public/.cvsignore
--- xv6-public/xv6-public/.cvsignore	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.cvsignore	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,16 @@
+*.asm
+*.d
+*.sym
+_*
+kernel
+user1
+userfs
+usertests
+xv6.img
+vectors.S
+bochsout.txt
+bootblock
+bootother
+bootother.out
+parport.out
+fmt
diff -ruN xv6-public/xv6-public/.dir-locals.el xv6-public_new/xv6-public/.dir-locals.el
--- xv6-public/xv6-public/.dir-locals.el	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.dir-locals.el	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,4 @@
+((c-mode
+  (indent-tabs-mode . nil)
+  (c-file-style . "bsd")
+  (c-basic-offset . 2)))
diff -ruN xv6-public/xv6-public/.gdbinit.tmpl xv6-public_new/xv6-public/.gdbinit.tmpl
--- xv6-public/xv6-public/.gdbinit.tmpl	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.gdbinit.tmpl	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,27 @@
+set $lastcs = -1
+
+define hook-stop
+  # There doesn't seem to be a good way to detect if we're in 16- or
+  # 32-bit mode, but in 32-bit mode we always run with CS == 8 in the
+  # kernel and CS == 35 in user space
+  if $cs == 8 || $cs == 35
+    if $lastcs != 8 && $lastcs != 35
+      set architecture i386
+    end
+    x/i $pc
+  else
+    if $lastcs == -1 || $lastcs == 8 || $lastcs == 35
+      set architecture i8086
+    end
+    # Translate the segment:offset into a physical address
+    printf "[%4x:%4x] ", $cs, $eip
+    x/i $cs*16+$eip
+  end
+  set $lastcs = $cs
+end
+
+echo + target remote localhost:1234\n
+target remote localhost:1234
+
+echo + symbol-file kernel\n
+symbol-file kernel
diff -ruN xv6-public/xv6-public/.git/HEAD xv6-public_new/xv6-public/.git/HEAD
--- xv6-public/xv6-public/.git/HEAD	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/HEAD	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -ruN xv6-public/xv6-public/.git/config xv6-public_new/xv6-public/.git/config
--- xv6-public/xv6-public/.git/config	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/config	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,12 @@
+[core]
+	repositoryformatversion = 0
+	filemode = false
+	bare = false
+	logallrefupdates = true
+	ignorecase = true
+[remote "origin"]
+	url = git://github.com/mit-pdos/xv6-public.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -ruN xv6-public/xv6-public/.git/description xv6-public_new/xv6-public/.git/description
--- xv6-public/xv6-public/.git/description	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/description	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -ruN xv6-public/xv6-public/.git/hooks/applypatch-msg.sample xv6-public_new/xv6-public/.git/hooks/applypatch-msg.sample
--- xv6-public/xv6-public/.git/hooks/applypatch-msg.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/applypatch-msg.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff -ruN xv6-public/xv6-public/.git/hooks/commit-msg.sample xv6-public_new/xv6-public/.git/hooks/commit-msg.sample
--- xv6-public/xv6-public/.git/hooks/commit-msg.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/commit-msg.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -ruN xv6-public/xv6-public/.git/hooks/fsmonitor-watchman.sample xv6-public_new/xv6-public/.git/hooks/fsmonitor-watchman.sample
--- xv6-public/xv6-public/.git/hooks/fsmonitor-watchman.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/fsmonitor-watchman.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,109 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 1) and a time in nanoseconds
+# formatted as a string and outputs to stdout all files that have been
+# modified since the given time. Paths must be relative to the root of
+# the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $time) = @ARGV;
+
+# Check the hook interface version
+
+if ($version == 1) {
+	# convert nanoseconds to seconds
+	# subtract one second to make sure watchman will return all changes
+	$time = int ($time / 1000000000) - 1;
+} else {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree;
+if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+	$git_work_tree = Win32::GetCwd();
+	$git_work_tree =~ tr/\\/\//;
+} else {
+	require Cwd;
+	$git_work_tree = Cwd::cwd();
+}
+
+my $retry = 1;
+
+launch_watchman();
+
+sub launch_watchman {
+
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	    or die "open2() failed: $!\n" .
+	    "Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $time but were not transient (ie created after
+	# $time but no longer exist).
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only.
+
+	my $query = <<"	END";
+		["query", "$git_work_tree", {
+			"since": $time,
+			"fields": ["name"]
+		}]
+	END
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	die "Watchman: command returned no output.\n" .
+	    "Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	    "Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	my $json_pkg;
+	eval {
+		require JSON::XS;
+		$json_pkg = "JSON::XS";
+		1;
+	} or do {
+		require JSON::PP;
+		$json_pkg = "JSON::PP";
+	};
+
+	my $o = $json_pkg->new->utf8->decode($response);
+
+	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
+		$retry--;
+		qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		print "/\0";
+		eval { launch_watchman() };
+		exit 0;
+	}
+
+	die "Watchman: $o->{error}.\n" .
+	    "Falling back to scanning...\n" if $o->{error};
+
+	binmode STDOUT, ":utf8";
+	local $, = "\0";
+	print @{$o->{files}};
+}
diff -ruN xv6-public/xv6-public/.git/hooks/post-update.sample xv6-public_new/xv6-public/.git/hooks/post-update.sample
--- xv6-public/xv6-public/.git/hooks/post-update.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/post-update.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -ruN xv6-public/xv6-public/.git/hooks/pre-applypatch.sample xv6-public_new/xv6-public/.git/hooks/pre-applypatch.sample
--- xv6-public/xv6-public/.git/hooks/pre-applypatch.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/pre-applypatch.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff -ruN xv6-public/xv6-public/.git/hooks/pre-commit.sample xv6-public_new/xv6-public/.git/hooks/pre-commit.sample
--- xv6-public/xv6-public/.git/hooks/pre-commit.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/pre-commit.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=$(git hash-object -t tree /dev/null)
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -ruN xv6-public/xv6-public/.git/hooks/pre-merge-commit.sample xv6-public_new/xv6-public/.git/hooks/pre-merge-commit.sample
--- xv6-public/xv6-public/.git/hooks/pre-merge-commit.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/pre-merge-commit.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,13 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git merge" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message to
+# stderr if it wants to stop the merge commit.
+#
+# To enable this hook, rename this file to "pre-merge-commit".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+        exec "$GIT_DIR/hooks/pre-commit"
+:
diff -ruN xv6-public/xv6-public/.git/hooks/pre-push.sample xv6-public_new/xv6-public/.git/hooks/pre-push.sample
--- xv6-public/xv6-public/.git/hooks/pre-push.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/pre-push.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -ruN xv6-public/xv6-public/.git/hooks/pre-rebase.sample xv6-public_new/xv6-public/.git/hooks/pre-rebase.sample
--- xv6-public/xv6-public/.git/hooks/pre-rebase.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/pre-rebase.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff -ruN xv6-public/xv6-public/.git/hooks/pre-receive.sample xv6-public_new/xv6-public/.git/hooks/pre-receive.sample
--- xv6-public/xv6-public/.git/hooks/pre-receive.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/pre-receive.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff -ruN xv6-public/xv6-public/.git/hooks/prepare-commit-msg.sample xv6-public_new/xv6-public/.git/hooks/prepare-commit-msg.sample
--- xv6-public/xv6-public/.git/hooks/prepare-commit-msg.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/prepare-commit-msg.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff -ruN xv6-public/xv6-public/.git/hooks/update.sample xv6-public_new/xv6-public/.git/hooks/update.sample
--- xv6-public/xv6-public/.git/hooks/update.sample	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/hooks/update.sample	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --bool hooks.allowunannotated)
+allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --bool hooks.denycreatebranch)
+allowdeletetag=$(git config --bool hooks.allowdeletetag)
+allowmodifytag=$(git config --bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files xv6-public/xv6-public/.git/index and xv6-public_new/xv6-public/.git/index differ
diff -ruN xv6-public/xv6-public/.git/info/exclude xv6-public_new/xv6-public/.git/info/exclude
--- xv6-public/xv6-public/.git/info/exclude	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/info/exclude	2021-08-11 00:51:20.000000000 +0530
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -ruN xv6-public/xv6-public/.git/logs/HEAD xv6-public_new/xv6-public/.git/logs/HEAD
--- xv6-public/xv6-public/.git/logs/HEAD	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/logs/HEAD	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 hardiksuhag <hardiksuhag@outlook.com> 1628623291 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
diff -ruN xv6-public/xv6-public/.git/logs/refs/heads/master xv6-public_new/xv6-public/.git/logs/refs/heads/master
--- xv6-public/xv6-public/.git/logs/refs/heads/master	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/logs/refs/heads/master	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 hardiksuhag <hardiksuhag@outlook.com> 1628623291 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
diff -ruN xv6-public/xv6-public/.git/logs/refs/remotes/origin/HEAD xv6-public_new/xv6-public/.git/logs/refs/remotes/origin/HEAD
--- xv6-public/xv6-public/.git/logs/refs/remotes/origin/HEAD	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/logs/refs/remotes/origin/HEAD	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 hardiksuhag <hardiksuhag@outlook.com> 1628623291 +0530	clone: from git://github.com/mit-pdos/xv6-public.git
Binary files xv6-public/xv6-public/.git/objects/pack/pack-12ca327ecdd26d679901b04fa869cf247b06c9ef.idx and xv6-public_new/xv6-public/.git/objects/pack/pack-12ca327ecdd26d679901b04fa869cf247b06c9ef.idx differ
Binary files xv6-public/xv6-public/.git/objects/pack/pack-12ca327ecdd26d679901b04fa869cf247b06c9ef.pack and xv6-public_new/xv6-public/.git/objects/pack/pack-12ca327ecdd26d679901b04fa869cf247b06c9ef.pack differ
diff -ruN xv6-public/xv6-public/.git/packed-refs xv6-public_new/xv6-public/.git/packed-refs
--- xv6-public/xv6-public/.git/packed-refs	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/packed-refs	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,28 @@
+# pack-refs with: peeled fully-peeled sorted 
+eeb7b415dbcb12cc362d0783e41c3d1f44066b17 refs/remotes/origin/master
+af0e851a3a8a7d13bc2f2d596b58500594040892 refs/tags/osdi12-submit
+^8286b58087750e09bac3815219e0382a0bb2b159
+9e698c587b135db17b38a5838976805b9c01e338 refs/tags/symlinks
+05e0b1218dcebe1f40028531b51926df8ae52be0 refs/tags/xv6-2006
+^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
+42f3c3f7be9717b66ba6e133a113c0f751c53133 refs/tags/xv6-2007
+adcd16c3f7588b4a28d37495f05e94278c9e3a1e refs/tags/xv6-2008
+124fe7e457c0dc9b671c7ffccb56004eb61da4f0 refs/tags/xv6-2010
+5922cdbbcc4fdbd76eec9e0dad9f650e4c86ee99 refs/tags/xv6-rev0
+^5cc0bd5ceaf805ab44f851e6a3f1952a29e9d7b7
+81f31a773dd49b001437eaed3975438585ff9911 refs/tags/xv6-rev1
+^42f3c3f7be9717b66ba6e133a113c0f751c53133
+b818915f793cd20c5d1e24f668534a9d690f3cc8 refs/tags/xv6-rev11
+30dab73b68b816877dc8f78504ceca0808c976eb refs/tags/xv6-rev3
+^074ac7ccd43c08d01a237ce6f14cac10715a51ef
+113005d48f09a4e3939940d72a77bf6973ea8755 refs/tags/xv6-rev4
+^124fe7e457c0dc9b671c7ffccb56004eb61da4f0
+d6aa754494b37e32862b1f78d53deedc53f66a15 refs/tags/xv6-rev5
+^ae603ff5e79bb7b5eea4147425752f33d29fe558
+3e9d6413d331b4c912d55bfac253af1629d4bac9 refs/tags/xv6-rev6
+^e64c661ae8b91bd7e858bb1895bef96e6ac2b4bb
+ccc25c0fac59067d88af52ad9f3b8cee97c3810a refs/tags/xv6-rev7
+^2ae8392a5c203a7b1bc5b8bff5eabc8b5eab8972
+7d6f95e327f1c18570d5dd187e3d92e1aadae2cf refs/tags/xv6-rev8
+^9ba21267e796eb462a657392906e3cbccaedcc99
+5bf3fbee00fb27cb8cb4eca72dcd9fc4c288ed71 refs/tags/xv6-rev9
diff -ruN xv6-public/xv6-public/.git/refs/heads/master xv6-public_new/xv6-public/.git/refs/heads/master
--- xv6-public/xv6-public/.git/refs/heads/master	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/refs/heads/master	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1 @@
+eeb7b415dbcb12cc362d0783e41c3d1f44066b17
diff -ruN xv6-public/xv6-public/.git/refs/remotes/origin/HEAD xv6-public_new/xv6-public/.git/refs/remotes/origin/HEAD
--- xv6-public/xv6-public/.git/refs/remotes/origin/HEAD	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.git/refs/remotes/origin/HEAD	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -ruN xv6-public/xv6-public/.gitignore xv6-public_new/xv6-public/.gitignore
--- xv6-public/xv6-public/.gitignore	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/.gitignore	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,16 @@
+*~
+_*
+*.o
+*.d
+*.asm
+*.sym
+*.img
+vectors.S
+bootblock
+entryother
+initcode
+initcode.out
+kernel
+kernelmemfs
+mkfs
+.gdbinit
diff -ruN xv6-public/xv6-public/BUGS xv6-public_new/xv6-public/BUGS
--- xv6-public/xv6-public/BUGS	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/BUGS	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,7 @@
+formatting:
+	need to fix PAGEBREAK mechanism
+
+sh:
+	can't always runcmd in child -- breaks cd.
+	maybe should hard-code PATH=/ ?
+
diff -ruN xv6-public/xv6-public/LICENSE xv6-public_new/xv6-public/LICENSE
--- xv6-public/xv6-public/LICENSE	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/LICENSE	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,24 @@
+The xv6 software is:
+
+Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
+                        Massachusetts Institute of Technology
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
diff -ruN xv6-public/xv6-public/Makefile xv6-public_new/xv6-public/Makefile
--- xv6-public/xv6-public/Makefile	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/Makefile	2021-09-30 17:37:22.000000000 +0530
@@ -0,0 +1,300 @@
+OBJS = \
+	bio.o\
+	console.o\
+	exec.o\
+	file.o\
+	fs.o\
+	ide.o\
+	ioapic.o\
+	kalloc.o\
+	kbd.o\
+	lapic.o\
+	log.o\
+	main.o\
+	mp.o\
+	picirq.o\
+	pipe.o\
+	proc.o\
+	sleeplock.o\
+	spinlock.o\
+	string.o\
+	swtch.o\
+	syscall.o\
+	sysfile.o\
+	sysproc.o\
+	trapasm.o\
+	trap.o\
+	uart.o\
+	vectors.o\
+	vm.o\
+
+# Cross-compiling (e.g., on Mac OS X)
+# TOOLPREFIX = i386-jos-elf
+
+# Using native tools (e.g., on X86 Linux)
+#TOOLPREFIX = 
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-jos-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# If the makefile can't find QEMU, specify its path here
+# QEMU = qemu-system-i386
+
+# Try to infer the correct QEMU
+ifndef QEMU
+QEMU = $(shell if which qemu > /dev/null; \
+	then echo qemu; exit; \
+	elif which qemu-system-i386 > /dev/null; \
+	then echo qemu-system-i386; exit; \
+	elif which qemu-system-x86_64 > /dev/null; \
+	then echo qemu-system-x86_64; exit; \
+	else \
+	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
+	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "*** or have you tried setting the QEMU variable in Makefile?" 1>&2; \
+	echo "***" 1>&2; exit 1)
+endif
+
+
+ifndef SCHEDFLAG
+SCHEDFLAG := DEFAULT
+endif
+
+
+
+
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+CFLAGS += -D $(SCHEDFLAG)
+ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+# FreeBSD ld wants ``elf_i386_fbsd''
+LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+xv6.img: bootblock kernel
+	dd if=/dev/zero of=xv6.img count=10000
+	dd if=bootblock of=xv6.img conv=notrunc
+	dd if=kernel of=xv6.img seek=1 conv=notrunc
+
+xv6memfs.img: bootblock kernelmemfs
+	dd if=/dev/zero of=xv6memfs.img count=10000
+	dd if=bootblock of=xv6memfs.img conv=notrunc
+	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc
+
+bootblock: bootasm.S bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
+	$(OBJDUMP) -S bootblock.o > bootblock.asm
+	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
+	./sign.pl bootblock
+
+entryother: entryother.S
+	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
+	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
+	$(OBJDUMP) -S bootblockother.o > entryother.asm
+
+initcode: initcode.S
+	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
+	$(OBJCOPY) -S -O binary initcode.out initcode
+	$(OBJDUMP) -S initcode.o > initcode.asm
+
+kernel: $(OBJS) entry.o entryother initcode kernel.ld
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
+	$(OBJDUMP) -S kernel > kernel.asm
+	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
+
+# kernelmemfs is a copy of kernel that maintains the
+# disk image in memory instead of writing to a disk.
+# This is not so useful for testing persistent storage or
+# exploring disk buffering implementations, but it is
+# great for testing the kernel on real hardware without
+# needing a scratch disk.
+MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
+kernelmemfs: $(MEMFSOBJS) entry.o entryother initcode kernel.ld fs.img
+	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
+	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
+	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
+
+tags: $(OBJS) entryother.S _init
+	etags *.S *.c
+
+vectors.S: vectors.pl
+	./vectors.pl > vectors.S
+
+ULIB = ulib.o usys.o printf.o umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+_forktest: forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
+	$(OBJDUMP) -S _forktest > forktest.asm
+
+mkfs: mkfs.c fs.h
+	gcc -Werror -Wall -o mkfs mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=\
+	_cat\
+	_echo\
+	_forktest\
+	_grep\
+	_init\
+	_kill\
+	_ln\
+	_ls\
+	_mkdir\
+	_rm\
+	_sh\
+	_stressfs\
+	_usertests\
+	_wc\
+	_zombie\
+	_drawtest\
+	_hardik\
+	_sanity\
+	_SMLsanity\
+
+fs.img: mkfs README $(UPROGS)
+	./mkfs fs.img README $(UPROGS)
+
+-include *.d
+
+clean: 
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+	initcode initcode.out kernel xv6.img fs.img kernelmemfs \
+	xv6memfs.img mkfs .gdbinit \
+	$(UPROGS)
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
+
+# run in emulators
+
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 2
+endif
+QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+
+qemu: fs.img xv6.img
+	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+
+qemu-memfs: xv6memfs.img
+	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+
+qemu-nox: fs.img xv6.img
+	$(QEMU) -nographic $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl
+	sed "s/localhost:1234/localhost:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
+
+qemu-nox-gdb: fs.img xv6.img .gdbinit
+	@echo "*** Now run 'gdb'." 1>&2
+	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
+
+.PHONY: dist-test dist
diff -ruN xv6-public/xv6-public/Notes xv6-public_new/xv6-public/Notes
--- xv6-public/xv6-public/Notes	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/Notes	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,123 @@
+bochs 2.2.6:
+./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
+bochs CVS after 2.2.6:
+./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
+
+bootmain.c doesn't work right if the ELF sections aren't
+sector-aligned. so you can't use ld -N. and the sections may also need
+to be non-zero length, only really matters for tiny "kernels".
+
+kernel loaded at 1 megabyte. stack same place that bootasm.S left it.
+
+kinit() should find real mem size
+  and rescue useable memory below 1 meg
+
+no paging, no use of page table hardware, just segments
+
+no user area: no magic kernel stack mapping
+  so no copying of kernel stack during fork
+  though there is a kernel stack page for each process
+
+no kernel malloc(), just kalloc() for user core
+
+user pointers aren't valid in the kernel
+
+are interrupts turned on in the kernel? yes.
+
+pass curproc explicitly, or implicit from cpu #?
+  e.g. argument to newproc()?
+  hmm, you need a global curproc[cpu] for trap() &c
+
+no stack expansion
+
+test running out of memory, process slots
+
+we can't really use a separate stack segment, since stack addresses
+need to work correctly as ordinary pointers. the same may be true of
+data vs text. how can we have a gap between data and stack, so that
+both can grow, without committing 4GB of physical memory? does this
+mean we need paging?
+
+perhaps have fixed-size stack, put it in the data segment?
+
+oops, if kernel stack is in contiguous user phys mem, then moving
+users' memory (e.g. to expand it) will wreck any pointers into the
+kernel stack.
+
+do we need to set fs and gs? so user processes can't abuse them?
+
+setupsegs() may modify current segment table, is that legal?
+
+trap() ought to lgdt on return, since currently only done in swtch()
+
+protect hardware interrupt vectors from user INT instructions?
+
+test out-of-fd cases for creating pipe.
+test pipe reader closes then write
+test two readers, two writers.
+test children being inherited by grandparent &c
+
+some sleep()s should be interruptible by kill()
+
+locks
+  init_lock
+    sequences CPU startup
+  proc_table_lock
+    also protects next_pid
+  per-fd lock *just* protects count read-modify-write
+    also maybe freeness?
+  memory allocator
+  printf
+
+in general, the table locks protect both free-ness and
+  public variables of table elements
+  in many cases you can use table elements w/o a lock
+  e.g. if you are the process, or you are using an fd
+
+lock order
+  per-pipe lock
+  proc_table_lock fd_table_lock kalloc_lock
+  console_lock
+
+do you have to be holding the mutex in order to call wakeup()? yes
+
+device interrupts don't clear FL_IF
+  so a recursive timer interrupt is possible
+
+what does inode->busy mean?
+  might be held across disk reads
+  no-one is allowed to do anything to the inode
+  protected by inode_table_lock
+inode->count counts in-memory pointers to the struct
+  prevents inode[] element from being re-used
+  protected by inode_table_lock
+
+blocks and inodes have ad-hoc sleep-locks
+  provide a single mechanism?
+
+kalloc() can return 0; do callers handle this right?
+
+test: one process unlinks a file while another links to it
+test: one process opens a file while another deletes it
+test: deadlock d/.. vs ../d, two processes.
+test: dup() shared fd->off
+test: does echo foo > x truncate x?
+
+sh: ioredirection incorrect now we have pipes
+sh: chain of pipes won't work, also ugly that parent closes fdarray entries too
+sh: dynamic memory allocation?
+sh: should sh support ; () &
+sh: stop stdin on ctrl-d (for cat > y)
+
+really should have bdwrite() for file content
+  and make some inode updates async
+  so soft updates make sense
+
+disk scheduling
+echo foo > bar should truncate bar
+  so O_CREATE should not truncate
+  but O_TRUNC should
+
+make it work on a real machine
+release before acquire at end of sleep?
+check 2nd disk (i.e. if not in .bochsrc)
diff -ruN xv6-public/xv6-public/README xv6-public_new/xv6-public/README
--- xv6-public/xv6-public/README	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/README	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,51 @@
+NOTE: we have stopped maintaining the x86 version of xv6, and switched
+our efforts to the RISC-V version
+(https://github.com/mit-pdos/xv6-riscv.git)
+
+xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
+Version 6 (v6).  xv6 loosely follows the structure and style of v6,
+but is implemented for a modern x86-based multiprocessor using ANSI C.
+
+ACKNOWLEDGMENTS
+
+xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
+to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
+2000)). See also https://pdos.csail.mit.edu/6.828/, which
+provides pointers to on-line resources for v6.
+
+xv6 borrows code from the following sources:
+    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
+    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
+    FreeBSD (ioapic.c)
+    NetBSD (console.c)
+
+The following people have made contributions: Russ Cox (context switching,
+locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
+Clements.
+
+We are also grateful for the bug reports and patches contributed by Silas
+Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
+Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
+Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
+Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
+Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
+Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
+Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
+Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
+Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.
+
+The code in the files that constitute xv6 is
+Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
+
+ERROR REPORTS
+
+We don't process error reports (see note on top of this file).
+
+BUILDING AND RUNNING XV6
+
+To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
+"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
+will need to install a cross-compiler gcc suite capable of producing
+x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
+Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
+simulator and run "make qemu".
\ No newline at end of file
diff -ruN xv6-public/xv6-public/SMLsanity.asm xv6-public_new/xv6-public/SMLsanity.asm
--- xv6-public/xv6-public/SMLsanity.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/SMLsanity.asm	2021-09-30 23:29:42.000000000 +0530
@@ -0,0 +1,1568 @@
+
+_SMLsanity:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "user.h"
+
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	53                   	push   %ebx
+  12:	51                   	push   %ecx
+  13:	83 ec 60             	sub    $0x60,%esp
+  16:	89 ca                	mov    %ecx,%edx
+	if (argc != 2){
+  18:	83 3a 02             	cmpl   $0x2,(%edx)
+  1b:	74 17                	je     34 <main+0x34>
+				printf(1, "Usage: SMLsanity <n>\n");
+  1d:	83 ec 08             	sub    $0x8,%esp
+  20:	68 10 0c 00 00       	push   $0xc10
+  25:	6a 01                	push   $0x1
+  27:	e8 18 08 00 00       	call   844 <printf>
+  2c:	83 c4 10             	add    $0x10,%esp
+				exit();
+  2f:	e8 6c 06 00 00       	call   6a0 <exit>
+ 		}
+	int i;
+	int n;
+	int j = 0;
+  34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+	int k;
+	int retime;
+	int rutime;
+	int stime;
+	int sums[3][3];
+	for (i = 0; i < 3; i++)
+  3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  42:	eb 2d                	jmp    71 <main+0x71>
+		for (j = 0; j < 3; j++)
+  44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  4b:	eb 1a                	jmp    67 <main+0x67>
+			sums[i][j] = 0;
+  4d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+  50:	89 c8                	mov    %ecx,%eax
+  52:	01 c0                	add    %eax,%eax
+  54:	01 c8                	add    %ecx,%eax
+  56:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  59:	01 c8                	add    %ecx,%eax
+  5b:	c7 44 85 ac 00 00 00 	movl   $0x0,-0x54(%ebp,%eax,4)
+  62:	00 
+		for (j = 0; j < 3; j++)
+  63:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  67:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+  6b:	7e e0                	jle    4d <main+0x4d>
+	for (i = 0; i < 3; i++)
+  6d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  71:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
+  75:	7e cd                	jle    44 <main+0x44>
+	n = atoi(argv[1]);
+  77:	8b 42 04             	mov    0x4(%edx),%eax
+  7a:	83 c0 04             	add    $0x4,%eax
+  7d:	8b 00                	mov    (%eax),%eax
+  7f:	83 ec 0c             	sub    $0xc,%esp
+  82:	50                   	push   %eax
+  83:	e8 7e 05 00 00       	call   606 <atoi>
+  88:	83 c4 10             	add    $0x10,%esp
+  8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+	i = n; //unimportant
+  8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  91:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	int pid;
+
+	for (i = 0; i < 3 * n; i++) {
+  94:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  9b:	e9 10 01 00 00       	jmp    1b0 <main+0x1b0>
+		j = i % 3;
+  a0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+  a3:	ba 56 55 55 55       	mov    $0x55555556,%edx
+  a8:	89 c8                	mov    %ecx,%eax
+  aa:	f7 ea                	imul   %edx
+  ac:	89 c8                	mov    %ecx,%eax
+  ae:	c1 f8 1f             	sar    $0x1f,%eax
+  b1:	29 c2                	sub    %eax,%edx
+  b3:	89 d0                	mov    %edx,%eax
+  b5:	01 c0                	add    %eax,%eax
+  b7:	01 d0                	add    %edx,%eax
+  b9:	29 c1                	sub    %eax,%ecx
+  bb:	89 c8                	mov    %ecx,%eax
+  bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+		pid = fork();
+  c0:	e8 d3 05 00 00       	call   698 <fork>
+  c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		if (pid == 0) {//child
+  c8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  cc:	0f 85 da 00 00 00    	jne    1ac <main+0x1ac>
+			j = (getpid() - 4) % 3; // ensures independence from the first son's pid when gathering the results in the second part of the program
+  d2:	e8 49 06 00 00       	call   720 <getpid>
+  d7:	8d 48 fc             	lea    -0x4(%eax),%ecx
+  da:	ba 56 55 55 55       	mov    $0x55555556,%edx
+  df:	89 c8                	mov    %ecx,%eax
+  e1:	f7 ea                	imul   %edx
+  e3:	89 c8                	mov    %ecx,%eax
+  e5:	c1 f8 1f             	sar    $0x1f,%eax
+  e8:	29 c2                	sub    %eax,%edx
+  ea:	89 d0                	mov    %edx,%eax
+  ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  f2:	89 d0                	mov    %edx,%eax
+  f4:	01 c0                	add    %eax,%eax
+  f6:	01 d0                	add    %edx,%eax
+  f8:	29 c1                	sub    %eax,%ecx
+  fa:	89 c8                	mov    %ecx,%eax
+  fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
+			#ifdef SML
+			switch(j) {
+  ff:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+ 103:	74 32                	je     137 <main+0x137>
+ 105:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+ 109:	7f 3a                	jg     145 <main+0x145>
+ 10b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 10f:	74 08                	je     119 <main+0x119>
+ 111:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
+ 115:	74 11                	je     128 <main+0x128>
+ 117:	eb 2c                	jmp    145 <main+0x145>
+				case 0:
+          set_prio(3);
+ 119:	83 ec 0c             	sub    $0xc,%esp
+ 11c:	6a 03                	push   $0x3
+ 11e:	e8 3d 06 00 00       	call   760 <set_prio>
+ 123:	83 c4 10             	add    $0x10,%esp
+					break;
+ 126:	eb 1d                	jmp    145 <main+0x145>
+				case 1:
+          set_prio(2);
+ 128:	83 ec 0c             	sub    $0xc,%esp
+ 12b:	6a 02                	push   $0x2
+ 12d:	e8 2e 06 00 00       	call   760 <set_prio>
+ 132:	83 c4 10             	add    $0x10,%esp
+					break;
+ 135:	eb 0e                	jmp    145 <main+0x145>
+				case 2:
+          set_prio(1);
+ 137:	83 ec 0c             	sub    $0xc,%esp
+ 13a:	6a 01                	push   $0x1
+ 13c:	e8 1f 06 00 00       	call   760 <set_prio>
+ 141:	83 c4 10             	add    $0x10,%esp
+					break;
+ 144:	90                   	nop
+			}
+			#endif
+      for (k = 0; k < 100; k++){
+ 145:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+ 14c:	eb 53                	jmp    1a1 <main+0x1a1>
+        for (j = 0; j < 50000; j++){
+ 14e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 155:	eb 3d                	jmp    194 <main+0x194>
+        	int x = 2.52;
+ 157:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
+        	x += 3.15 * (k + j);
+ 15e:	db 45 dc             	fildl  -0x24(%ebp)
+ 161:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 164:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 167:	01 d0                	add    %edx,%eax
+ 169:	89 45 a0             	mov    %eax,-0x60(%ebp)
+ 16c:	db 45 a0             	fildl  -0x60(%ebp)
+ 16f:	dd 05 78 0e 00 00    	fldl   0xe78
+ 175:	de c9                	fmulp  %st,%st(1)
+ 177:	de c1                	faddp  %st,%st(1)
+ 179:	d9 7d a6             	fnstcw -0x5a(%ebp)
+ 17c:	0f b7 45 a6          	movzwl -0x5a(%ebp),%eax
+ 180:	80 cc 0c             	or     $0xc,%ah
+ 183:	66 89 45 a4          	mov    %ax,-0x5c(%ebp)
+ 187:	d9 6d a4             	fldcw  -0x5c(%ebp)
+ 18a:	db 5d dc             	fistpl -0x24(%ebp)
+ 18d:	d9 6d a6             	fldcw  -0x5a(%ebp)
+        for (j = 0; j < 50000; j++){
+ 190:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 194:	81 7d f0 4f c3 00 00 	cmpl   $0xc34f,-0x10(%ebp)
+ 19b:	7e ba                	jle    157 <main+0x157>
+      for (k = 0; k < 100; k++){
+ 19d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+ 1a1:	83 7d ec 63          	cmpl   $0x63,-0x14(%ebp)
+ 1a5:	7e a7                	jle    14e <main+0x14e>
+        }
+      }
+			exit(); // children exit here
+ 1a7:	e8 f4 04 00 00       	call   6a0 <exit>
+	for (i = 0; i < 3 * n; i++) {
+ 1ac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 1b0:	8b 55 e8             	mov    -0x18(%ebp),%edx
+ 1b3:	89 d0                	mov    %edx,%eax
+ 1b5:	01 c0                	add    %eax,%eax
+ 1b7:	01 d0                	add    %edx,%eax
+ 1b9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 1bc:	0f 8c de fe ff ff    	jl     a0 <main+0xa0>
+		}
+		continue; // father continues to spawn the next child
+	}
+	for (i = 0; i < 3 * n; i++) {
+ 1c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1c9:	e9 69 01 00 00       	jmp    337 <main+0x337>
+		pid = wait2(&retime, &rutime, &stime);
+ 1ce:	83 ec 04             	sub    $0x4,%esp
+ 1d1:	8d 45 d0             	lea    -0x30(%ebp),%eax
+ 1d4:	50                   	push   %eax
+ 1d5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+ 1d8:	50                   	push   %eax
+ 1d9:	8d 45 d8             	lea    -0x28(%ebp),%eax
+ 1dc:	50                   	push   %eax
+ 1dd:	e8 76 05 00 00       	call   758 <wait2>
+ 1e2:	83 c4 10             	add    $0x10,%esp
+ 1e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		int res = (pid - 4) % 3; // correlates to j in the dispatching loop
+ 1e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 1eb:	8d 48 fc             	lea    -0x4(%eax),%ecx
+ 1ee:	ba 56 55 55 55       	mov    $0x55555556,%edx
+ 1f3:	89 c8                	mov    %ecx,%eax
+ 1f5:	f7 ea                	imul   %edx
+ 1f7:	89 c8                	mov    %ecx,%eax
+ 1f9:	c1 f8 1f             	sar    $0x1f,%eax
+ 1fc:	29 c2                	sub    %eax,%edx
+ 1fe:	89 d0                	mov    %edx,%eax
+ 200:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ 203:	8b 55 e0             	mov    -0x20(%ebp),%edx
+ 206:	89 d0                	mov    %edx,%eax
+ 208:	01 c0                	add    %eax,%eax
+ 20a:	01 d0                	add    %edx,%eax
+ 20c:	29 c1                	sub    %eax,%ecx
+ 20e:	89 c8                	mov    %ecx,%eax
+ 210:	89 45 e0             	mov    %eax,-0x20(%ebp)
+		switch(res) {
+ 213:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
+ 217:	0f 84 c4 00 00 00    	je     2e1 <main+0x2e1>
+ 21d:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
+ 221:	0f 8f 0c 01 00 00    	jg     333 <main+0x333>
+ 227:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+ 22b:	74 0b                	je     238 <main+0x238>
+ 22d:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
+ 231:	74 5b                	je     28e <main+0x28e>
+ 233:	e9 fb 00 00 00       	jmp    333 <main+0x333>
+			case 0: // CPU bound processes
+				printf(1, "Priority 1, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+ 238:	8b 55 d8             	mov    -0x28(%ebp),%edx
+ 23b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 23e:	01 c2                	add    %eax,%edx
+ 240:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 243:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 246:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+ 249:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+ 24c:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 24f:	83 ec 04             	sub    $0x4,%esp
+ 252:	53                   	push   %ebx
+ 253:	51                   	push   %ecx
+ 254:	52                   	push   %edx
+ 255:	50                   	push   %eax
+ 256:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 259:	68 28 0c 00 00       	push   $0xc28
+ 25e:	6a 01                	push   $0x1
+ 260:	e8 df 05 00 00       	call   844 <printf>
+ 265:	83 c4 20             	add    $0x20,%esp
+				sums[0][0] += retime;
+ 268:	8b 55 ac             	mov    -0x54(%ebp),%edx
+ 26b:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 26e:	01 d0                	add    %edx,%eax
+ 270:	89 45 ac             	mov    %eax,-0x54(%ebp)
+				sums[0][1] += rutime;
+ 273:	8b 55 b0             	mov    -0x50(%ebp),%edx
+ 276:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 279:	01 d0                	add    %edx,%eax
+ 27b:	89 45 b0             	mov    %eax,-0x50(%ebp)
+				sums[0][2] += stime;
+ 27e:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+ 281:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 284:	01 d0                	add    %edx,%eax
+ 286:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+				break;
+ 289:	e9 a5 00 00 00       	jmp    333 <main+0x333>
+			case 1: // CPU bound processes, short tasks
+				printf(1, "Priority 2, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+ 28e:	8b 55 d8             	mov    -0x28(%ebp),%edx
+ 291:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 294:	01 c2                	add    %eax,%edx
+ 296:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 299:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 29c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+ 29f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+ 2a2:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 2a5:	83 ec 04             	sub    $0x4,%esp
+ 2a8:	53                   	push   %ebx
+ 2a9:	51                   	push   %ecx
+ 2aa:	52                   	push   %edx
+ 2ab:	50                   	push   %eax
+ 2ac:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 2af:	68 74 0c 00 00       	push   $0xc74
+ 2b4:	6a 01                	push   $0x1
+ 2b6:	e8 89 05 00 00       	call   844 <printf>
+ 2bb:	83 c4 20             	add    $0x20,%esp
+				sums[1][0] += retime;
+ 2be:	8b 55 b8             	mov    -0x48(%ebp),%edx
+ 2c1:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 2c4:	01 d0                	add    %edx,%eax
+ 2c6:	89 45 b8             	mov    %eax,-0x48(%ebp)
+				sums[1][1] += rutime;
+ 2c9:	8b 55 bc             	mov    -0x44(%ebp),%edx
+ 2cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 2cf:	01 d0                	add    %edx,%eax
+ 2d1:	89 45 bc             	mov    %eax,-0x44(%ebp)
+				sums[1][2] += stime;
+ 2d4:	8b 55 c0             	mov    -0x40(%ebp),%edx
+ 2d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 2da:	01 d0                	add    %edx,%eax
+ 2dc:	89 45 c0             	mov    %eax,-0x40(%ebp)
+				break;
+ 2df:	eb 52                	jmp    333 <main+0x333>
+			case 2: // simulating I/O bound processes
+				printf(1, "Priority 3, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+ 2e1:	8b 55 d8             	mov    -0x28(%ebp),%edx
+ 2e4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 2e7:	01 c2                	add    %eax,%edx
+ 2e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 2ec:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 2ef:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+ 2f2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+ 2f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 2f8:	83 ec 04             	sub    $0x4,%esp
+ 2fb:	53                   	push   %ebx
+ 2fc:	51                   	push   %ecx
+ 2fd:	52                   	push   %edx
+ 2fe:	50                   	push   %eax
+ 2ff:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 302:	68 c0 0c 00 00       	push   $0xcc0
+ 307:	6a 01                	push   $0x1
+ 309:	e8 36 05 00 00       	call   844 <printf>
+ 30e:	83 c4 20             	add    $0x20,%esp
+				sums[2][0] += retime;
+ 311:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+ 314:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 317:	01 d0                	add    %edx,%eax
+ 319:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+				sums[2][1] += rutime;
+ 31c:	8b 55 c8             	mov    -0x38(%ebp),%edx
+ 31f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 322:	01 d0                	add    %edx,%eax
+ 324:	89 45 c8             	mov    %eax,-0x38(%ebp)
+				sums[2][2] += stime;
+ 327:	8b 55 cc             	mov    -0x34(%ebp),%edx
+ 32a:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 32d:	01 d0                	add    %edx,%eax
+ 32f:	89 45 cc             	mov    %eax,-0x34(%ebp)
+				break;
+ 332:	90                   	nop
+	for (i = 0; i < 3 * n; i++) {
+ 333:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 337:	8b 55 e8             	mov    -0x18(%ebp),%edx
+ 33a:	89 d0                	mov    %edx,%eax
+ 33c:	01 c0                	add    %eax,%eax
+ 33e:	01 d0                	add    %edx,%eax
+ 340:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 343:	0f 8c 85 fe ff ff    	jl     1ce <main+0x1ce>
+		}
+	}
+	for (i = 0; i < 3; i++)
+ 349:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 350:	eb 41                	jmp    393 <main+0x393>
+		for (j = 0; j < 3; j++)
+ 352:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 359:	eb 2e                	jmp    389 <main+0x389>
+			sums[i][j] /= n;
+ 35b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 35e:	89 d0                	mov    %edx,%eax
+ 360:	01 c0                	add    %eax,%eax
+ 362:	01 d0                	add    %edx,%eax
+ 364:	8b 55 f0             	mov    -0x10(%ebp),%edx
+ 367:	01 d0                	add    %edx,%eax
+ 369:	8b 44 85 ac          	mov    -0x54(%ebp,%eax,4),%eax
+ 36d:	99                   	cltd   
+ 36e:	f7 7d e8             	idivl  -0x18(%ebp)
+ 371:	89 c1                	mov    %eax,%ecx
+ 373:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 376:	89 d0                	mov    %edx,%eax
+ 378:	01 c0                	add    %eax,%eax
+ 37a:	01 d0                	add    %edx,%eax
+ 37c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+ 37f:	01 d0                	add    %edx,%eax
+ 381:	89 4c 85 ac          	mov    %ecx,-0x54(%ebp,%eax,4)
+		for (j = 0; j < 3; j++)
+ 385:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 389:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+ 38d:	7e cc                	jle    35b <main+0x35b>
+	for (i = 0; i < 3; i++)
+ 38f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 393:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
+ 397:	7e b9                	jle    352 <main+0x352>
+  printf(1, "\n\nPriority 1:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[0][0], sums[0][1], sums[0][2], sums[0][0] + sums[0][1] + sums[0][2]);
+ 399:	8b 55 ac             	mov    -0x54(%ebp),%edx
+ 39c:	8b 45 b0             	mov    -0x50(%ebp),%eax
+ 39f:	01 c2                	add    %eax,%edx
+ 3a1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+ 3a4:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 3a7:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
+ 3aa:	8b 55 b0             	mov    -0x50(%ebp),%edx
+ 3ad:	8b 45 ac             	mov    -0x54(%ebp),%eax
+ 3b0:	83 ec 08             	sub    $0x8,%esp
+ 3b3:	53                   	push   %ebx
+ 3b4:	51                   	push   %ecx
+ 3b5:	52                   	push   %edx
+ 3b6:	50                   	push   %eax
+ 3b7:	68 0c 0d 00 00       	push   $0xd0c
+ 3bc:	6a 01                	push   $0x1
+ 3be:	e8 81 04 00 00       	call   844 <printf>
+ 3c3:	83 c4 20             	add    $0x20,%esp
+	printf(1, "Priority 2:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[1][0], sums[1][1], sums[1][2], sums[1][0] + sums[1][1] + sums[1][2]);
+ 3c6:	8b 55 b8             	mov    -0x48(%ebp),%edx
+ 3c9:	8b 45 bc             	mov    -0x44(%ebp),%eax
+ 3cc:	01 c2                	add    %eax,%edx
+ 3ce:	8b 45 c0             	mov    -0x40(%ebp),%eax
+ 3d1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 3d4:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+ 3d7:	8b 55 bc             	mov    -0x44(%ebp),%edx
+ 3da:	8b 45 b8             	mov    -0x48(%ebp),%eax
+ 3dd:	83 ec 08             	sub    $0x8,%esp
+ 3e0:	53                   	push   %ebx
+ 3e1:	51                   	push   %ecx
+ 3e2:	52                   	push   %edx
+ 3e3:	50                   	push   %eax
+ 3e4:	68 84 0d 00 00       	push   $0xd84
+ 3e9:	6a 01                	push   $0x1
+ 3eb:	e8 54 04 00 00       	call   844 <printf>
+ 3f0:	83 c4 20             	add    $0x20,%esp
+	printf(1, "Priority 3:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[2][0], sums[2][1], sums[2][2], sums[2][0] + sums[2][1] + sums[2][2]);
+ 3f3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+ 3f6:	8b 45 c8             	mov    -0x38(%ebp),%eax
+ 3f9:	01 c2                	add    %eax,%edx
+ 3fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
+ 3fe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 401:	8b 4d cc             	mov    -0x34(%ebp),%ecx
+ 404:	8b 55 c8             	mov    -0x38(%ebp),%edx
+ 407:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+ 40a:	83 ec 08             	sub    $0x8,%esp
+ 40d:	53                   	push   %ebx
+ 40e:	51                   	push   %ecx
+ 40f:	52                   	push   %edx
+ 410:	50                   	push   %eax
+ 411:	68 fc 0d 00 00       	push   $0xdfc
+ 416:	6a 01                	push   $0x1
+ 418:	e8 27 04 00 00       	call   844 <printf>
+ 41d:	83 c4 20             	add    $0x20,%esp
+	exit();
+ 420:	e8 7b 02 00 00       	call   6a0 <exit>
+
+00000425 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 425:	55                   	push   %ebp
+ 426:	89 e5                	mov    %esp,%ebp
+ 428:	57                   	push   %edi
+ 429:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 42a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 42d:	8b 55 10             	mov    0x10(%ebp),%edx
+ 430:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 433:	89 cb                	mov    %ecx,%ebx
+ 435:	89 df                	mov    %ebx,%edi
+ 437:	89 d1                	mov    %edx,%ecx
+ 439:	fc                   	cld    
+ 43a:	f3 aa                	rep stos %al,%es:(%edi)
+ 43c:	89 ca                	mov    %ecx,%edx
+ 43e:	89 fb                	mov    %edi,%ebx
+ 440:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 443:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 446:	90                   	nop
+ 447:	5b                   	pop    %ebx
+ 448:	5f                   	pop    %edi
+ 449:	5d                   	pop    %ebp
+ 44a:	c3                   	ret    
+
+0000044b <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 44b:	f3 0f 1e fb          	endbr32 
+ 44f:	55                   	push   %ebp
+ 450:	89 e5                	mov    %esp,%ebp
+ 452:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 455:	8b 45 08             	mov    0x8(%ebp),%eax
+ 458:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 45b:	90                   	nop
+ 45c:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 45f:	8d 42 01             	lea    0x1(%edx),%eax
+ 462:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 465:	8b 45 08             	mov    0x8(%ebp),%eax
+ 468:	8d 48 01             	lea    0x1(%eax),%ecx
+ 46b:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 46e:	0f b6 12             	movzbl (%edx),%edx
+ 471:	88 10                	mov    %dl,(%eax)
+ 473:	0f b6 00             	movzbl (%eax),%eax
+ 476:	84 c0                	test   %al,%al
+ 478:	75 e2                	jne    45c <strcpy+0x11>
+    ;
+  return os;
+ 47a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 47d:	c9                   	leave  
+ 47e:	c3                   	ret    
+
+0000047f <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 47f:	f3 0f 1e fb          	endbr32 
+ 483:	55                   	push   %ebp
+ 484:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 486:	eb 08                	jmp    490 <strcmp+0x11>
+    p++, q++;
+ 488:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 48c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 490:	8b 45 08             	mov    0x8(%ebp),%eax
+ 493:	0f b6 00             	movzbl (%eax),%eax
+ 496:	84 c0                	test   %al,%al
+ 498:	74 10                	je     4aa <strcmp+0x2b>
+ 49a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 49d:	0f b6 10             	movzbl (%eax),%edx
+ 4a0:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4a3:	0f b6 00             	movzbl (%eax),%eax
+ 4a6:	38 c2                	cmp    %al,%dl
+ 4a8:	74 de                	je     488 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 4aa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4ad:	0f b6 00             	movzbl (%eax),%eax
+ 4b0:	0f b6 d0             	movzbl %al,%edx
+ 4b3:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4b6:	0f b6 00             	movzbl (%eax),%eax
+ 4b9:	0f b6 c0             	movzbl %al,%eax
+ 4bc:	29 c2                	sub    %eax,%edx
+ 4be:	89 d0                	mov    %edx,%eax
+}
+ 4c0:	5d                   	pop    %ebp
+ 4c1:	c3                   	ret    
+
+000004c2 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 4c2:	f3 0f 1e fb          	endbr32 
+ 4c6:	55                   	push   %ebp
+ 4c7:	89 e5                	mov    %esp,%ebp
+ 4c9:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 4cc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 4d3:	eb 04                	jmp    4d9 <strlen+0x17>
+ 4d5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 4d9:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 4dc:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4df:	01 d0                	add    %edx,%eax
+ 4e1:	0f b6 00             	movzbl (%eax),%eax
+ 4e4:	84 c0                	test   %al,%al
+ 4e6:	75 ed                	jne    4d5 <strlen+0x13>
+    ;
+  return n;
+ 4e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 4eb:	c9                   	leave  
+ 4ec:	c3                   	ret    
+
+000004ed <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 4ed:	f3 0f 1e fb          	endbr32 
+ 4f1:	55                   	push   %ebp
+ 4f2:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 4f4:	8b 45 10             	mov    0x10(%ebp),%eax
+ 4f7:	50                   	push   %eax
+ 4f8:	ff 75 0c             	pushl  0xc(%ebp)
+ 4fb:	ff 75 08             	pushl  0x8(%ebp)
+ 4fe:	e8 22 ff ff ff       	call   425 <stosb>
+ 503:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 506:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 509:	c9                   	leave  
+ 50a:	c3                   	ret    
+
+0000050b <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 50b:	f3 0f 1e fb          	endbr32 
+ 50f:	55                   	push   %ebp
+ 510:	89 e5                	mov    %esp,%ebp
+ 512:	83 ec 04             	sub    $0x4,%esp
+ 515:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 518:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 51b:	eb 14                	jmp    531 <strchr+0x26>
+    if(*s == c)
+ 51d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 520:	0f b6 00             	movzbl (%eax),%eax
+ 523:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 526:	75 05                	jne    52d <strchr+0x22>
+      return (char*)s;
+ 528:	8b 45 08             	mov    0x8(%ebp),%eax
+ 52b:	eb 13                	jmp    540 <strchr+0x35>
+  for(; *s; s++)
+ 52d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 531:	8b 45 08             	mov    0x8(%ebp),%eax
+ 534:	0f b6 00             	movzbl (%eax),%eax
+ 537:	84 c0                	test   %al,%al
+ 539:	75 e2                	jne    51d <strchr+0x12>
+  return 0;
+ 53b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 540:	c9                   	leave  
+ 541:	c3                   	ret    
+
+00000542 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 542:	f3 0f 1e fb          	endbr32 
+ 546:	55                   	push   %ebp
+ 547:	89 e5                	mov    %esp,%ebp
+ 549:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 54c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 553:	eb 42                	jmp    597 <gets+0x55>
+    cc = read(0, &c, 1);
+ 555:	83 ec 04             	sub    $0x4,%esp
+ 558:	6a 01                	push   $0x1
+ 55a:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 55d:	50                   	push   %eax
+ 55e:	6a 00                	push   $0x0
+ 560:	e8 53 01 00 00       	call   6b8 <read>
+ 565:	83 c4 10             	add    $0x10,%esp
+ 568:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 56b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 56f:	7e 33                	jle    5a4 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 571:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 574:	8d 50 01             	lea    0x1(%eax),%edx
+ 577:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 57a:	89 c2                	mov    %eax,%edx
+ 57c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 57f:	01 c2                	add    %eax,%edx
+ 581:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 585:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 587:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 58b:	3c 0a                	cmp    $0xa,%al
+ 58d:	74 16                	je     5a5 <gets+0x63>
+ 58f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 593:	3c 0d                	cmp    $0xd,%al
+ 595:	74 0e                	je     5a5 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 597:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 59a:	83 c0 01             	add    $0x1,%eax
+ 59d:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 5a0:	7f b3                	jg     555 <gets+0x13>
+ 5a2:	eb 01                	jmp    5a5 <gets+0x63>
+      break;
+ 5a4:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 5a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 5a8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5ab:	01 d0                	add    %edx,%eax
+ 5ad:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 5b0:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 5b3:	c9                   	leave  
+ 5b4:	c3                   	ret    
+
+000005b5 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 5b5:	f3 0f 1e fb          	endbr32 
+ 5b9:	55                   	push   %ebp
+ 5ba:	89 e5                	mov    %esp,%ebp
+ 5bc:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 5bf:	83 ec 08             	sub    $0x8,%esp
+ 5c2:	6a 00                	push   $0x0
+ 5c4:	ff 75 08             	pushl  0x8(%ebp)
+ 5c7:	e8 14 01 00 00       	call   6e0 <open>
+ 5cc:	83 c4 10             	add    $0x10,%esp
+ 5cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 5d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 5d6:	79 07                	jns    5df <stat+0x2a>
+    return -1;
+ 5d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 5dd:	eb 25                	jmp    604 <stat+0x4f>
+  r = fstat(fd, st);
+ 5df:	83 ec 08             	sub    $0x8,%esp
+ 5e2:	ff 75 0c             	pushl  0xc(%ebp)
+ 5e5:	ff 75 f4             	pushl  -0xc(%ebp)
+ 5e8:	e8 0b 01 00 00       	call   6f8 <fstat>
+ 5ed:	83 c4 10             	add    $0x10,%esp
+ 5f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 5f3:	83 ec 0c             	sub    $0xc,%esp
+ 5f6:	ff 75 f4             	pushl  -0xc(%ebp)
+ 5f9:	e8 ca 00 00 00       	call   6c8 <close>
+ 5fe:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 601:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 604:	c9                   	leave  
+ 605:	c3                   	ret    
+
+00000606 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 606:	f3 0f 1e fb          	endbr32 
+ 60a:	55                   	push   %ebp
+ 60b:	89 e5                	mov    %esp,%ebp
+ 60d:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 610:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 617:	eb 25                	jmp    63e <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 619:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 61c:	89 d0                	mov    %edx,%eax
+ 61e:	c1 e0 02             	shl    $0x2,%eax
+ 621:	01 d0                	add    %edx,%eax
+ 623:	01 c0                	add    %eax,%eax
+ 625:	89 c1                	mov    %eax,%ecx
+ 627:	8b 45 08             	mov    0x8(%ebp),%eax
+ 62a:	8d 50 01             	lea    0x1(%eax),%edx
+ 62d:	89 55 08             	mov    %edx,0x8(%ebp)
+ 630:	0f b6 00             	movzbl (%eax),%eax
+ 633:	0f be c0             	movsbl %al,%eax
+ 636:	01 c8                	add    %ecx,%eax
+ 638:	83 e8 30             	sub    $0x30,%eax
+ 63b:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 63e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 641:	0f b6 00             	movzbl (%eax),%eax
+ 644:	3c 2f                	cmp    $0x2f,%al
+ 646:	7e 0a                	jle    652 <atoi+0x4c>
+ 648:	8b 45 08             	mov    0x8(%ebp),%eax
+ 64b:	0f b6 00             	movzbl (%eax),%eax
+ 64e:	3c 39                	cmp    $0x39,%al
+ 650:	7e c7                	jle    619 <atoi+0x13>
+  return n;
+ 652:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 655:	c9                   	leave  
+ 656:	c3                   	ret    
+
+00000657 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 657:	f3 0f 1e fb          	endbr32 
+ 65b:	55                   	push   %ebp
+ 65c:	89 e5                	mov    %esp,%ebp
+ 65e:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 661:	8b 45 08             	mov    0x8(%ebp),%eax
+ 664:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 667:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 66a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 66d:	eb 17                	jmp    686 <memmove+0x2f>
+    *dst++ = *src++;
+ 66f:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 672:	8d 42 01             	lea    0x1(%edx),%eax
+ 675:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 678:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 67b:	8d 48 01             	lea    0x1(%eax),%ecx
+ 67e:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 681:	0f b6 12             	movzbl (%edx),%edx
+ 684:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 686:	8b 45 10             	mov    0x10(%ebp),%eax
+ 689:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 68c:	89 55 10             	mov    %edx,0x10(%ebp)
+ 68f:	85 c0                	test   %eax,%eax
+ 691:	7f dc                	jg     66f <memmove+0x18>
+  return vdst;
+ 693:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 696:	c9                   	leave  
+ 697:	c3                   	ret    
+
+00000698 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 698:	b8 01 00 00 00       	mov    $0x1,%eax
+ 69d:	cd 40                	int    $0x40
+ 69f:	c3                   	ret    
+
+000006a0 <exit>:
+SYSCALL(exit)
+ 6a0:	b8 02 00 00 00       	mov    $0x2,%eax
+ 6a5:	cd 40                	int    $0x40
+ 6a7:	c3                   	ret    
+
+000006a8 <wait>:
+SYSCALL(wait)
+ 6a8:	b8 03 00 00 00       	mov    $0x3,%eax
+ 6ad:	cd 40                	int    $0x40
+ 6af:	c3                   	ret    
+
+000006b0 <pipe>:
+SYSCALL(pipe)
+ 6b0:	b8 04 00 00 00       	mov    $0x4,%eax
+ 6b5:	cd 40                	int    $0x40
+ 6b7:	c3                   	ret    
+
+000006b8 <read>:
+SYSCALL(read)
+ 6b8:	b8 05 00 00 00       	mov    $0x5,%eax
+ 6bd:	cd 40                	int    $0x40
+ 6bf:	c3                   	ret    
+
+000006c0 <write>:
+SYSCALL(write)
+ 6c0:	b8 10 00 00 00       	mov    $0x10,%eax
+ 6c5:	cd 40                	int    $0x40
+ 6c7:	c3                   	ret    
+
+000006c8 <close>:
+SYSCALL(close)
+ 6c8:	b8 15 00 00 00       	mov    $0x15,%eax
+ 6cd:	cd 40                	int    $0x40
+ 6cf:	c3                   	ret    
+
+000006d0 <kill>:
+SYSCALL(kill)
+ 6d0:	b8 06 00 00 00       	mov    $0x6,%eax
+ 6d5:	cd 40                	int    $0x40
+ 6d7:	c3                   	ret    
+
+000006d8 <exec>:
+SYSCALL(exec)
+ 6d8:	b8 07 00 00 00       	mov    $0x7,%eax
+ 6dd:	cd 40                	int    $0x40
+ 6df:	c3                   	ret    
+
+000006e0 <open>:
+SYSCALL(open)
+ 6e0:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 6e5:	cd 40                	int    $0x40
+ 6e7:	c3                   	ret    
+
+000006e8 <mknod>:
+SYSCALL(mknod)
+ 6e8:	b8 11 00 00 00       	mov    $0x11,%eax
+ 6ed:	cd 40                	int    $0x40
+ 6ef:	c3                   	ret    
+
+000006f0 <unlink>:
+SYSCALL(unlink)
+ 6f0:	b8 12 00 00 00       	mov    $0x12,%eax
+ 6f5:	cd 40                	int    $0x40
+ 6f7:	c3                   	ret    
+
+000006f8 <fstat>:
+SYSCALL(fstat)
+ 6f8:	b8 08 00 00 00       	mov    $0x8,%eax
+ 6fd:	cd 40                	int    $0x40
+ 6ff:	c3                   	ret    
+
+00000700 <link>:
+SYSCALL(link)
+ 700:	b8 13 00 00 00       	mov    $0x13,%eax
+ 705:	cd 40                	int    $0x40
+ 707:	c3                   	ret    
+
+00000708 <mkdir>:
+SYSCALL(mkdir)
+ 708:	b8 14 00 00 00       	mov    $0x14,%eax
+ 70d:	cd 40                	int    $0x40
+ 70f:	c3                   	ret    
+
+00000710 <chdir>:
+SYSCALL(chdir)
+ 710:	b8 09 00 00 00       	mov    $0x9,%eax
+ 715:	cd 40                	int    $0x40
+ 717:	c3                   	ret    
+
+00000718 <dup>:
+SYSCALL(dup)
+ 718:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 71d:	cd 40                	int    $0x40
+ 71f:	c3                   	ret    
+
+00000720 <getpid>:
+SYSCALL(getpid)
+ 720:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 725:	cd 40                	int    $0x40
+ 727:	c3                   	ret    
+
+00000728 <sbrk>:
+SYSCALL(sbrk)
+ 728:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 72d:	cd 40                	int    $0x40
+ 72f:	c3                   	ret    
+
+00000730 <sleep>:
+SYSCALL(sleep)
+ 730:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 735:	cd 40                	int    $0x40
+ 737:	c3                   	ret    
+
+00000738 <uptime>:
+SYSCALL(uptime)
+ 738:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 73d:	cd 40                	int    $0x40
+ 73f:	c3                   	ret    
+
+00000740 <draw>:
+SYSCALL(draw)
+ 740:	b8 16 00 00 00       	mov    $0x16,%eax
+ 745:	cd 40                	int    $0x40
+ 747:	c3                   	ret    
+
+00000748 <cps>:
+SYSCALL(cps)
+ 748:	b8 17 00 00 00       	mov    $0x17,%eax
+ 74d:	cd 40                	int    $0x40
+ 74f:	c3                   	ret    
+
+00000750 <yield>:
+SYSCALL(yield)
+ 750:	b8 18 00 00 00       	mov    $0x18,%eax
+ 755:	cd 40                	int    $0x40
+ 757:	c3                   	ret    
+
+00000758 <wait2>:
+SYSCALL(wait2)
+ 758:	b8 19 00 00 00       	mov    $0x19,%eax
+ 75d:	cd 40                	int    $0x40
+ 75f:	c3                   	ret    
+
+00000760 <set_prio>:
+SYSCALL(set_prio)
+ 760:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 765:	cd 40                	int    $0x40
+ 767:	c3                   	ret    
+
+00000768 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 768:	f3 0f 1e fb          	endbr32 
+ 76c:	55                   	push   %ebp
+ 76d:	89 e5                	mov    %esp,%ebp
+ 76f:	83 ec 18             	sub    $0x18,%esp
+ 772:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 775:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 778:	83 ec 04             	sub    $0x4,%esp
+ 77b:	6a 01                	push   $0x1
+ 77d:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 780:	50                   	push   %eax
+ 781:	ff 75 08             	pushl  0x8(%ebp)
+ 784:	e8 37 ff ff ff       	call   6c0 <write>
+ 789:	83 c4 10             	add    $0x10,%esp
+}
+ 78c:	90                   	nop
+ 78d:	c9                   	leave  
+ 78e:	c3                   	ret    
+
+0000078f <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 78f:	f3 0f 1e fb          	endbr32 
+ 793:	55                   	push   %ebp
+ 794:	89 e5                	mov    %esp,%ebp
+ 796:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 799:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 7a0:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 7a4:	74 17                	je     7bd <printint+0x2e>
+ 7a6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 7aa:	79 11                	jns    7bd <printint+0x2e>
+    neg = 1;
+ 7ac:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 7b3:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 7b6:	f7 d8                	neg    %eax
+ 7b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 7bb:	eb 06                	jmp    7c3 <printint+0x34>
+  } else {
+    x = xx;
+ 7bd:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 7c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 7c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 7ca:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 7cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 7d0:	ba 00 00 00 00       	mov    $0x0,%edx
+ 7d5:	f7 f1                	div    %ecx
+ 7d7:	89 d1                	mov    %edx,%ecx
+ 7d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7dc:	8d 50 01             	lea    0x1(%eax),%edx
+ 7df:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 7e2:	0f b6 91 d0 10 00 00 	movzbl 0x10d0(%ecx),%edx
+ 7e9:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 7ed:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 7f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 7f3:	ba 00 00 00 00       	mov    $0x0,%edx
+ 7f8:	f7 f1                	div    %ecx
+ 7fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 7fd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 801:	75 c7                	jne    7ca <printint+0x3b>
+  if(neg)
+ 803:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 807:	74 2d                	je     836 <printint+0xa7>
+    buf[i++] = '-';
+ 809:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80c:	8d 50 01             	lea    0x1(%eax),%edx
+ 80f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 812:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 817:	eb 1d                	jmp    836 <printint+0xa7>
+    putc(fd, buf[i]);
+ 819:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 81c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 81f:	01 d0                	add    %edx,%eax
+ 821:	0f b6 00             	movzbl (%eax),%eax
+ 824:	0f be c0             	movsbl %al,%eax
+ 827:	83 ec 08             	sub    $0x8,%esp
+ 82a:	50                   	push   %eax
+ 82b:	ff 75 08             	pushl  0x8(%ebp)
+ 82e:	e8 35 ff ff ff       	call   768 <putc>
+ 833:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 836:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 83a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 83e:	79 d9                	jns    819 <printint+0x8a>
+}
+ 840:	90                   	nop
+ 841:	90                   	nop
+ 842:	c9                   	leave  
+ 843:	c3                   	ret    
+
+00000844 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 844:	f3 0f 1e fb          	endbr32 
+ 848:	55                   	push   %ebp
+ 849:	89 e5                	mov    %esp,%ebp
+ 84b:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 84e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 855:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 858:	83 c0 04             	add    $0x4,%eax
+ 85b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 85e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 865:	e9 59 01 00 00       	jmp    9c3 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 86a:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 86d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 870:	01 d0                	add    %edx,%eax
+ 872:	0f b6 00             	movzbl (%eax),%eax
+ 875:	0f be c0             	movsbl %al,%eax
+ 878:	25 ff 00 00 00       	and    $0xff,%eax
+ 87d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 880:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 884:	75 2c                	jne    8b2 <printf+0x6e>
+      if(c == '%'){
+ 886:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 88a:	75 0c                	jne    898 <printf+0x54>
+        state = '%';
+ 88c:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 893:	e9 27 01 00 00       	jmp    9bf <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 898:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 89b:	0f be c0             	movsbl %al,%eax
+ 89e:	83 ec 08             	sub    $0x8,%esp
+ 8a1:	50                   	push   %eax
+ 8a2:	ff 75 08             	pushl  0x8(%ebp)
+ 8a5:	e8 be fe ff ff       	call   768 <putc>
+ 8aa:	83 c4 10             	add    $0x10,%esp
+ 8ad:	e9 0d 01 00 00       	jmp    9bf <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 8b2:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 8b6:	0f 85 03 01 00 00    	jne    9bf <printf+0x17b>
+      if(c == 'd'){
+ 8bc:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 8c0:	75 1e                	jne    8e0 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 8c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 8c5:	8b 00                	mov    (%eax),%eax
+ 8c7:	6a 01                	push   $0x1
+ 8c9:	6a 0a                	push   $0xa
+ 8cb:	50                   	push   %eax
+ 8cc:	ff 75 08             	pushl  0x8(%ebp)
+ 8cf:	e8 bb fe ff ff       	call   78f <printint>
+ 8d4:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 8d7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 8db:	e9 d8 00 00 00       	jmp    9b8 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 8e0:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 8e4:	74 06                	je     8ec <printf+0xa8>
+ 8e6:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 8ea:	75 1e                	jne    90a <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 8ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 8ef:	8b 00                	mov    (%eax),%eax
+ 8f1:	6a 00                	push   $0x0
+ 8f3:	6a 10                	push   $0x10
+ 8f5:	50                   	push   %eax
+ 8f6:	ff 75 08             	pushl  0x8(%ebp)
+ 8f9:	e8 91 fe ff ff       	call   78f <printint>
+ 8fe:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 901:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 905:	e9 ae 00 00 00       	jmp    9b8 <printf+0x174>
+      } else if(c == 's'){
+ 90a:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 90e:	75 43                	jne    953 <printf+0x10f>
+        s = (char*)*ap;
+ 910:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 913:	8b 00                	mov    (%eax),%eax
+ 915:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 918:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 91c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 920:	75 25                	jne    947 <printf+0x103>
+          s = "(null)";
+ 922:	c7 45 f4 80 0e 00 00 	movl   $0xe80,-0xc(%ebp)
+        while(*s != 0){
+ 929:	eb 1c                	jmp    947 <printf+0x103>
+          putc(fd, *s);
+ 92b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 92e:	0f b6 00             	movzbl (%eax),%eax
+ 931:	0f be c0             	movsbl %al,%eax
+ 934:	83 ec 08             	sub    $0x8,%esp
+ 937:	50                   	push   %eax
+ 938:	ff 75 08             	pushl  0x8(%ebp)
+ 93b:	e8 28 fe ff ff       	call   768 <putc>
+ 940:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 943:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 947:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 94a:	0f b6 00             	movzbl (%eax),%eax
+ 94d:	84 c0                	test   %al,%al
+ 94f:	75 da                	jne    92b <printf+0xe7>
+ 951:	eb 65                	jmp    9b8 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 953:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 957:	75 1d                	jne    976 <printf+0x132>
+        putc(fd, *ap);
+ 959:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 95c:	8b 00                	mov    (%eax),%eax
+ 95e:	0f be c0             	movsbl %al,%eax
+ 961:	83 ec 08             	sub    $0x8,%esp
+ 964:	50                   	push   %eax
+ 965:	ff 75 08             	pushl  0x8(%ebp)
+ 968:	e8 fb fd ff ff       	call   768 <putc>
+ 96d:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 970:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 974:	eb 42                	jmp    9b8 <printf+0x174>
+      } else if(c == '%'){
+ 976:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 97a:	75 17                	jne    993 <printf+0x14f>
+        putc(fd, c);
+ 97c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 97f:	0f be c0             	movsbl %al,%eax
+ 982:	83 ec 08             	sub    $0x8,%esp
+ 985:	50                   	push   %eax
+ 986:	ff 75 08             	pushl  0x8(%ebp)
+ 989:	e8 da fd ff ff       	call   768 <putc>
+ 98e:	83 c4 10             	add    $0x10,%esp
+ 991:	eb 25                	jmp    9b8 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 993:	83 ec 08             	sub    $0x8,%esp
+ 996:	6a 25                	push   $0x25
+ 998:	ff 75 08             	pushl  0x8(%ebp)
+ 99b:	e8 c8 fd ff ff       	call   768 <putc>
+ 9a0:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 9a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 9a6:	0f be c0             	movsbl %al,%eax
+ 9a9:	83 ec 08             	sub    $0x8,%esp
+ 9ac:	50                   	push   %eax
+ 9ad:	ff 75 08             	pushl  0x8(%ebp)
+ 9b0:	e8 b3 fd ff ff       	call   768 <putc>
+ 9b5:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 9b8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 9bf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 9c3:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 9c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 9c9:	01 d0                	add    %edx,%eax
+ 9cb:	0f b6 00             	movzbl (%eax),%eax
+ 9ce:	84 c0                	test   %al,%al
+ 9d0:	0f 85 94 fe ff ff    	jne    86a <printf+0x26>
+    }
+  }
+}
+ 9d6:	90                   	nop
+ 9d7:	90                   	nop
+ 9d8:	c9                   	leave  
+ 9d9:	c3                   	ret    
+
+000009da <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 9da:	f3 0f 1e fb          	endbr32 
+ 9de:	55                   	push   %ebp
+ 9df:	89 e5                	mov    %esp,%ebp
+ 9e1:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 9e4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 9e7:	83 e8 08             	sub    $0x8,%eax
+ 9ea:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 9ed:	a1 ec 10 00 00       	mov    0x10ec,%eax
+ 9f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 9f5:	eb 24                	jmp    a1b <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 9f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9fa:	8b 00                	mov    (%eax),%eax
+ 9fc:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 9ff:	72 12                	jb     a13 <free+0x39>
+ a01:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a04:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ a07:	77 24                	ja     a2d <free+0x53>
+ a09:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a0c:	8b 00                	mov    (%eax),%eax
+ a0e:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ a11:	72 1a                	jb     a2d <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ a13:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a16:	8b 00                	mov    (%eax),%eax
+ a18:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ a1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a1e:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ a21:	76 d4                	jbe    9f7 <free+0x1d>
+ a23:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a26:	8b 00                	mov    (%eax),%eax
+ a28:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ a2b:	73 ca                	jae    9f7 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ a2d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a30:	8b 40 04             	mov    0x4(%eax),%eax
+ a33:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ a3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a3d:	01 c2                	add    %eax,%edx
+ a3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a42:	8b 00                	mov    (%eax),%eax
+ a44:	39 c2                	cmp    %eax,%edx
+ a46:	75 24                	jne    a6c <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ a48:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a4b:	8b 50 04             	mov    0x4(%eax),%edx
+ a4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a51:	8b 00                	mov    (%eax),%eax
+ a53:	8b 40 04             	mov    0x4(%eax),%eax
+ a56:	01 c2                	add    %eax,%edx
+ a58:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a5b:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ a5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a61:	8b 00                	mov    (%eax),%eax
+ a63:	8b 10                	mov    (%eax),%edx
+ a65:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a68:	89 10                	mov    %edx,(%eax)
+ a6a:	eb 0a                	jmp    a76 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ a6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a6f:	8b 10                	mov    (%eax),%edx
+ a71:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a74:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ a76:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a79:	8b 40 04             	mov    0x4(%eax),%eax
+ a7c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ a83:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a86:	01 d0                	add    %edx,%eax
+ a88:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ a8b:	75 20                	jne    aad <free+0xd3>
+    p->s.size += bp->s.size;
+ a8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a90:	8b 50 04             	mov    0x4(%eax),%edx
+ a93:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a96:	8b 40 04             	mov    0x4(%eax),%eax
+ a99:	01 c2                	add    %eax,%edx
+ a9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a9e:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ aa1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ aa4:	8b 10                	mov    (%eax),%edx
+ aa6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ aa9:	89 10                	mov    %edx,(%eax)
+ aab:	eb 08                	jmp    ab5 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ aad:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ ab0:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ ab3:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ ab5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ ab8:	a3 ec 10 00 00       	mov    %eax,0x10ec
+}
+ abd:	90                   	nop
+ abe:	c9                   	leave  
+ abf:	c3                   	ret    
+
+00000ac0 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ ac0:	f3 0f 1e fb          	endbr32 
+ ac4:	55                   	push   %ebp
+ ac5:	89 e5                	mov    %esp,%ebp
+ ac7:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ aca:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ ad1:	77 07                	ja     ada <morecore+0x1a>
+    nu = 4096;
+ ad3:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ ada:	8b 45 08             	mov    0x8(%ebp),%eax
+ add:	c1 e0 03             	shl    $0x3,%eax
+ ae0:	83 ec 0c             	sub    $0xc,%esp
+ ae3:	50                   	push   %eax
+ ae4:	e8 3f fc ff ff       	call   728 <sbrk>
+ ae9:	83 c4 10             	add    $0x10,%esp
+ aec:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ aef:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ af3:	75 07                	jne    afc <morecore+0x3c>
+    return 0;
+ af5:	b8 00 00 00 00       	mov    $0x0,%eax
+ afa:	eb 26                	jmp    b22 <morecore+0x62>
+  hp = (Header*)p;
+ afc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ aff:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ b02:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b05:	8b 55 08             	mov    0x8(%ebp),%edx
+ b08:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ b0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b0e:	83 c0 08             	add    $0x8,%eax
+ b11:	83 ec 0c             	sub    $0xc,%esp
+ b14:	50                   	push   %eax
+ b15:	e8 c0 fe ff ff       	call   9da <free>
+ b1a:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ b1d:	a1 ec 10 00 00       	mov    0x10ec,%eax
+}
+ b22:	c9                   	leave  
+ b23:	c3                   	ret    
+
+00000b24 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ b24:	f3 0f 1e fb          	endbr32 
+ b28:	55                   	push   %ebp
+ b29:	89 e5                	mov    %esp,%ebp
+ b2b:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ b2e:	8b 45 08             	mov    0x8(%ebp),%eax
+ b31:	83 c0 07             	add    $0x7,%eax
+ b34:	c1 e8 03             	shr    $0x3,%eax
+ b37:	83 c0 01             	add    $0x1,%eax
+ b3a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ b3d:	a1 ec 10 00 00       	mov    0x10ec,%eax
+ b42:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ b45:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ b49:	75 23                	jne    b6e <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ b4b:	c7 45 f0 e4 10 00 00 	movl   $0x10e4,-0x10(%ebp)
+ b52:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b55:	a3 ec 10 00 00       	mov    %eax,0x10ec
+ b5a:	a1 ec 10 00 00       	mov    0x10ec,%eax
+ b5f:	a3 e4 10 00 00       	mov    %eax,0x10e4
+    base.s.size = 0;
+ b64:	c7 05 e8 10 00 00 00 	movl   $0x0,0x10e8
+ b6b:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ b6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b71:	8b 00                	mov    (%eax),%eax
+ b73:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ b76:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b79:	8b 40 04             	mov    0x4(%eax),%eax
+ b7c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ b7f:	77 4d                	ja     bce <malloc+0xaa>
+      if(p->s.size == nunits)
+ b81:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b84:	8b 40 04             	mov    0x4(%eax),%eax
+ b87:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ b8a:	75 0c                	jne    b98 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b8f:	8b 10                	mov    (%eax),%edx
+ b91:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b94:	89 10                	mov    %edx,(%eax)
+ b96:	eb 26                	jmp    bbe <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ b98:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b9b:	8b 40 04             	mov    0x4(%eax),%eax
+ b9e:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ ba1:	89 c2                	mov    %eax,%edx
+ ba3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ba6:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ bac:	8b 40 04             	mov    0x4(%eax),%eax
+ baf:	c1 e0 03             	shl    $0x3,%eax
+ bb2:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ bb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ bb8:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ bbb:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ bbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ bc1:	a3 ec 10 00 00       	mov    %eax,0x10ec
+      return (void*)(p + 1);
+ bc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ bc9:	83 c0 08             	add    $0x8,%eax
+ bcc:	eb 3b                	jmp    c09 <malloc+0xe5>
+    }
+    if(p == freep)
+ bce:	a1 ec 10 00 00       	mov    0x10ec,%eax
+ bd3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ bd6:	75 1e                	jne    bf6 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ bd8:	83 ec 0c             	sub    $0xc,%esp
+ bdb:	ff 75 ec             	pushl  -0x14(%ebp)
+ bde:	e8 dd fe ff ff       	call   ac0 <morecore>
+ be3:	83 c4 10             	add    $0x10,%esp
+ be6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ be9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ bed:	75 07                	jne    bf6 <malloc+0xd2>
+        return 0;
+ bef:	b8 00 00 00 00       	mov    $0x0,%eax
+ bf4:	eb 13                	jmp    c09 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ bf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ bf9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ bfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ bff:	8b 00                	mov    (%eax),%eax
+ c01:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ c04:	e9 6d ff ff ff       	jmp    b76 <malloc+0x52>
+  }
+}
+ c09:	c9                   	leave  
+ c0a:	c3                   	ret    
diff -ruN xv6-public/xv6-public/SMLsanity.c xv6-public_new/xv6-public/SMLsanity.c
--- xv6-public/xv6-public/SMLsanity.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/SMLsanity.c	2021-09-30 23:29:36.000000000 +0530
@@ -0,0 +1,86 @@
+#include "types.h"
+#include "user.h"
+
+
+int
+main(int argc, char *argv[])
+{
+	if (argc != 2){
+				printf(1, "Usage: SMLsanity <n>\n");
+				exit();
+ 		}
+	int i;
+	int n;
+	int j = 0;
+	int k;
+	int retime;
+	int rutime;
+	int stime;
+	int sums[3][3];
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			sums[i][j] = 0;
+	n = atoi(argv[1]);
+	i = n; //unimportant
+	int pid;
+
+	for (i = 0; i < 3 * n; i++) {
+		j = i % 3;
+		pid = fork();
+		if (pid == 0) {//child
+			j = (getpid() - 4) % 3; // ensures independence from the first son's pid when gathering the results in the second part of the program
+			#ifdef SML
+			switch(j) {
+				case 0:
+          set_prio(3);
+					break;
+				case 1:
+          set_prio(2);
+					break;
+				case 2:
+          set_prio(1);
+					break;
+			}
+			#endif
+      for (k = 0; k < 100; k++){
+        for (j = 0; j < 50000; j++){
+        	int x = 2.52;
+        	x += 3.15 * (k + j);
+        }
+      }
+			exit(); // children exit here
+		}
+		continue; // father continues to spawn the next child
+	}
+	for (i = 0; i < 3 * n; i++) {
+		pid = wait2(&retime, &rutime, &stime);
+		int res = (pid - 4) % 3; // correlates to j in the dispatching loop
+		switch(res) {
+			case 0: // CPU bound processes
+				printf(1, "Priority 1, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[0][0] += retime;
+				sums[0][1] += rutime;
+				sums[0][2] += stime;
+				break;
+			case 1: // CPU bound processes, short tasks
+				printf(1, "Priority 2, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[1][0] += retime;
+				sums[1][1] += rutime;
+				sums[1][2] += stime;
+				break;
+			case 2: // simulating I/O bound processes
+				printf(1, "Priority 3, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[2][0] += retime;
+				sums[2][1] += rutime;
+				sums[2][2] += stime;
+				break;
+		}
+	}
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			sums[i][j] /= n;
+  printf(1, "\n\nPriority 1:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[0][0], sums[0][1], sums[0][2], sums[0][0] + sums[0][1] + sums[0][2]);
+	printf(1, "Priority 2:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[1][0], sums[1][1], sums[1][2], sums[1][0] + sums[1][1] + sums[1][2]);
+	printf(1, "Priority 3:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[2][0], sums[2][1], sums[2][2], sums[2][0] + sums[2][1] + sums[2][2]);
+	exit();
+}
diff -ruN xv6-public/xv6-public/SMLsanity.d xv6-public_new/xv6-public/SMLsanity.d
--- xv6-public/xv6-public/SMLsanity.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/SMLsanity.d	2021-09-30 23:29:42.000000000 +0530
@@ -0,0 +1 @@
+SMLsanity.o: SMLsanity.c /usr/include/stdc-predef.h types.h user.h
Binary files xv6-public/xv6-public/SMLsanity.o and xv6-public_new/xv6-public/SMLsanity.o differ
diff -ruN xv6-public/xv6-public/SMLsanity.sym xv6-public_new/xv6-public/SMLsanity.sym
--- xv6-public/xv6-public/SMLsanity.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/SMLsanity.sym	2021-09-30 23:29:42.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+00000c10 .rodata
+00000e88 .eh_frame
+000010d0 .data
+000010e4 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 SMLsanity.c
+00000000 ulib.c
+00000425 stosb
+00000000 printf.c
+00000768 putc
+0000078f printint
+000010d0 digits.1098
+00000000 umalloc.c
+000010e4 base
+000010ec freep
+00000ac0 morecore
+0000044b strcpy
+00000750 yield
+00000760 set_prio
+00000844 printf
+00000657 memmove
+000006e8 mknod
+00000542 gets
+00000720 getpid
+00000b24 malloc
+00000730 sleep
+00000758 wait2
+000006b0 pipe
+000006c0 write
+000006f8 fstat
+000006d0 kill
+00000710 chdir
+000006d8 exec
+000006a8 wait
+000006b8 read
+000006f0 unlink
+00000698 fork
+00000728 sbrk
+00000738 uptime
+000010e1 __bss_start
+000004ed memset
+00000000 main
+0000047f strcmp
+00000718 dup
+000005b5 stat
+000010e1 _edata
+000010f0 _end
+00000700 link
+000006a0 exit
+00000606 atoi
+00000740 draw
+000004c2 strlen
+000006e0 open
+0000050b strchr
+00000748 cps
+00000708 mkdir
+000006c8 close
+000009da free
diff -ruN xv6-public/xv6-public/TRICKS xv6-public_new/xv6-public/TRICKS
--- xv6-public/xv6-public/TRICKS	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/TRICKS	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,140 @@
+This file lists subtle things that might not be commented 
+as well as they should be in the source code and that
+might be worth pointing out in a longer explanation or in class.
+
+---
+
+[2009/07/12: No longer relevant; forkret1 changed
+and this is now cleaner.]
+
+forkret1 in trapasm.S is called with a tf argument.
+In order to use it, forkret1 copies the tf pointer into
+%esp and then jumps to trapret, which pops the 
+register state out of the trap frame.  If an interrupt
+came in between the mov tf, %esp and the iret that
+goes back out to user space, the interrupt stack frame
+would end up scribbling over the tf and whatever memory
+lay under it.
+
+Why is this safe?  Because forkret1 is only called
+the first time a process returns to user space, and
+at that point, cp->tf is set to point to a trap frame
+constructed at the top of cp's kernel stack.  So tf 
+*is* a valid %esp that can hold interrupt state.
+
+If other tf's were used in forkret1, we could add
+a cli before the mov tf, %esp.
+
+---
+
+In pushcli, must cli() no matter what.  It is not safe to do
+
+  if(cpus[cpu()].ncli == 0)
+    cli();
+  cpus[cpu()].ncli++;
+
+because if interrupts are off then we might call cpu(), get
+rescheduled to a different cpu, look at cpus[oldcpu].ncli,
+and wrongly decide not to disable interrupts on the new cpu.
+
+Instead do 
+
+  cli();
+  cpus[cpu()].ncli++;
+
+always.
+
+---
+
+There is a (harmless) race in pushcli, which does
+
+	eflags = readeflags();
+	cli();
+	if(c->ncli++ == 0)
+		c->intena = eflags & FL_IF;
+
+Consider a bottom-level pushcli.  
+If interrupts are disabled already, then the right thing
+happens: read_eflags finds that FL_IF is not set,
+and intena = 0.  If interrupts are enabled, then
+it is less clear that the right thing happens:
+the readeflags can execute, then the process
+can get preempted and rescheduled on another cpu,
+and then once it starts running, perhaps with 
+interrupts disabled (can happen since the scheduler
+only enables interrupts once per scheduling loop,
+not every time it schedules a process), it will 
+incorrectly record that interrupts *were* enabled.
+This doesn't matter, because if it was safe to be
+running with interrupts enabled before the context
+switch, it is still safe (and arguably more correct)
+to run with them enabled after the context switch too.
+
+In fact it would be safe if scheduler always set
+	c->intena = 1;
+before calling swtch, and perhaps it should.
+
+---
+
+The x86's processor-ordering memory model 
+matches spin locks well, so no explicit memory
+synchronization instructions are required in
+acquire and release.  
+
+Consider two sequences of code on different CPUs:
+
+CPU0
+A;
+release(lk);
+
+and
+
+CPU1
+acquire(lk);
+B;
+
+We want to make sure that:
+  - all reads in B see the effects of writes in A.
+  - all reads in A do *not* see the effects of writes in B.
+ 
+The x86 guarantees that writes in A will go out
+to memory before the write of lk->locked = 0 in 
+release(lk).  It further guarantees that CPU1 
+will observe CPU0's write of lk->locked = 0 only
+after observing the earlier writes by CPU0.
+So any reads in B are guaranteed to observe the
+effects of writes in A.
+
+According to the Intel manual behavior spec, the
+second condition requires a serialization instruction
+in release, to avoid reads in A happening after giving
+up lk.  No Intel SMP processor in existence actually
+moves reads down after writes, but the language in
+the spec allows it.  There is no telling whether future
+processors will need it.
+
+---
+
+The code in fork needs to read np->pid before
+setting np->state to RUNNABLE.  The following
+is not a correct way to do this:
+
+	int
+	fork(void)
+	{
+	  ...
+	  np->state = RUNNABLE;
+	  return np->pid; // oops
+	}
+
+After setting np->state to RUNNABLE, some other CPU
+might run the process, it might exit, and then it might
+get reused for a different process (with a new pid), all
+before the return statement.  So it's not safe to just
+"return np->pid". Even saving a copy of np->pid before
+setting np->state isn't safe, since the compiler is
+allowed to re-order statements.
+
+The real code saves a copy of np->pid, then acquires a lock
+around the write to np->state. The acquire() prevents the
+compiler from re-ordering.
Binary files xv6-public/xv6-public/_SMLsanity and xv6-public_new/xv6-public/_SMLsanity differ
Binary files xv6-public/xv6-public/_cat and xv6-public_new/xv6-public/_cat differ
Binary files xv6-public/xv6-public/_drawtest and xv6-public_new/xv6-public/_drawtest differ
Binary files xv6-public/xv6-public/_echo and xv6-public_new/xv6-public/_echo differ
Binary files xv6-public/xv6-public/_forktest and xv6-public_new/xv6-public/_forktest differ
Binary files xv6-public/xv6-public/_grep and xv6-public_new/xv6-public/_grep differ
Binary files xv6-public/xv6-public/_hardik and xv6-public_new/xv6-public/_hardik differ
Binary files xv6-public/xv6-public/_init and xv6-public_new/xv6-public/_init differ
Binary files xv6-public/xv6-public/_kill and xv6-public_new/xv6-public/_kill differ
Binary files xv6-public/xv6-public/_ln and xv6-public_new/xv6-public/_ln differ
Binary files xv6-public/xv6-public/_ls and xv6-public_new/xv6-public/_ls differ
Binary files xv6-public/xv6-public/_mkdir and xv6-public_new/xv6-public/_mkdir differ
Binary files xv6-public/xv6-public/_rm and xv6-public_new/xv6-public/_rm differ
Binary files xv6-public/xv6-public/_sanity and xv6-public_new/xv6-public/_sanity differ
Binary files xv6-public/xv6-public/_sh and xv6-public_new/xv6-public/_sh differ
Binary files xv6-public/xv6-public/_stressfs and xv6-public_new/xv6-public/_stressfs differ
Binary files xv6-public/xv6-public/_usertests and xv6-public_new/xv6-public/_usertests differ
Binary files xv6-public/xv6-public/_wc and xv6-public_new/xv6-public/_wc differ
Binary files xv6-public/xv6-public/_zombie and xv6-public_new/xv6-public/_zombie differ
diff -ruN xv6-public/xv6-public/asm.h xv6-public_new/xv6-public/asm.h
--- xv6-public/xv6-public/asm.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/asm.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,18 @@
+//
+// assembler macros to create x86 segments
+//
+
+#define SEG_NULLASM                                             \
+        .word 0, 0;                                             \
+        .byte 0, 0, 0, 0
+
+// The 0xC0 means the limit is in 4096-byte units
+// and (for executable segments) 32-bit mode.
+#define SEG_ASM(type,base,lim)                                  \
+        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
+        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
+                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+
+#define STA_X     0x8       // Executable segment
+#define STA_W     0x2       // Writeable (non-executable segments)
+#define STA_R     0x2       // Readable (executable segments)
diff -ruN xv6-public/xv6-public/bio.c xv6-public_new/xv6-public/bio.c
--- xv6-public/xv6-public/bio.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/bio.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,144 @@
+// Buffer cache.
+//
+// The buffer cache is a linked list of buf structures holding
+// cached copies of disk block contents.  Caching disk blocks
+// in memory reduces the number of disk reads and also provides
+// a synchronization point for disk blocks used by multiple processes.
+//
+// Interface:
+// * To get a buffer for a particular disk block, call bread.
+// * After changing buffer data, call bwrite to write it to disk.
+// * When done with the buffer, call brelse.
+// * Do not use the buffer after calling brelse.
+// * Only one process at a time can use a buffer,
+//     so do not keep them longer than necessary.
+//
+// The implementation uses two state flags internally:
+// * B_VALID: the buffer data has been read from the disk.
+// * B_DIRTY: the buffer data has been modified
+//     and needs to be written to disk.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "buf.h"
+
+struct {
+  struct spinlock lock;
+  struct buf buf[NBUF];
+
+  // Linked list of all buffers, through prev/next.
+  // head.next is most recently used.
+  struct buf head;
+} bcache;
+
+void
+binit(void)
+{
+  struct buf *b;
+
+  initlock(&bcache.lock, "bcache");
+
+//PAGEBREAK!
+  // Create linked list of buffers
+  bcache.head.prev = &bcache.head;
+  bcache.head.next = &bcache.head;
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+    b->next = bcache.head.next;
+    b->prev = &bcache.head;
+    initsleeplock(&b->lock, "buffer");
+    bcache.head.next->prev = b;
+    bcache.head.next = b;
+  }
+}
+
+// Look through buffer cache for block on device dev.
+// If not found, allocate a buffer.
+// In either case, return locked buffer.
+static struct buf*
+bget(uint dev, uint blockno)
+{
+  struct buf *b;
+
+  acquire(&bcache.lock);
+
+  // Is the block already cached?
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+    if(b->dev == dev && b->blockno == blockno){
+      b->refcnt++;
+      release(&bcache.lock);
+      acquiresleep(&b->lock);
+      return b;
+    }
+  }
+
+  // Not cached; recycle an unused buffer.
+  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
+  // because log.c has modified it but not yet committed it.
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+      b->dev = dev;
+      b->blockno = blockno;
+      b->flags = 0;
+      b->refcnt = 1;
+      release(&bcache.lock);
+      acquiresleep(&b->lock);
+      return b;
+    }
+  }
+  panic("bget: no buffers");
+}
+
+// Return a locked buf with the contents of the indicated block.
+struct buf*
+bread(uint dev, uint blockno)
+{
+  struct buf *b;
+
+  b = bget(dev, blockno);
+  if((b->flags & B_VALID) == 0) {
+    iderw(b);
+  }
+  return b;
+}
+
+// Write b's contents to disk.  Must be locked.
+void
+bwrite(struct buf *b)
+{
+  if(!holdingsleep(&b->lock))
+    panic("bwrite");
+  b->flags |= B_DIRTY;
+  iderw(b);
+}
+
+// Release a locked buffer.
+// Move to the head of the MRU list.
+void
+brelse(struct buf *b)
+{
+  if(!holdingsleep(&b->lock))
+    panic("brelse");
+
+  releasesleep(&b->lock);
+
+  acquire(&bcache.lock);
+  b->refcnt--;
+  if (b->refcnt == 0) {
+    // no one is waiting for it.
+    b->next->prev = b->prev;
+    b->prev->next = b->next;
+    b->next = bcache.head.next;
+    b->prev = &bcache.head;
+    bcache.head.next->prev = b;
+    bcache.head.next = b;
+  }
+  
+  release(&bcache.lock);
+}
+//PAGEBREAK!
+// Blank page.
+
diff -ruN xv6-public/xv6-public/bio.d xv6-public_new/xv6-public/bio.d
--- xv6-public/xv6-public/bio.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/bio.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,2 @@
+bio.o: bio.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+ sleeplock.h fs.h buf.h
Binary files xv6-public/xv6-public/bio.o and xv6-public_new/xv6-public/bio.o differ
diff -ruN xv6-public/xv6-public/bootasm.S xv6-public_new/xv6-public/bootasm.S
--- xv6-public/xv6-public/bootasm.S	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/bootasm.S	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,88 @@
+#include "asm.h"
+#include "memlayout.h"
+#include "mmu.h"
+
+# Start the first CPU: switch to 32-bit protected mode, jump into C.
+# The BIOS loads this code from the first sector of the hard disk into
+# memory at physical address 0x7c00 and starts executing in real mode
+# with %cs=0 %ip=7c00.
+
+.code16                       # Assemble for 16-bit mode
+.globl start
+start:
+  cli                         # BIOS enabled interrupts; disable
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax             # Set %ax to zero
+  movw    %ax,%ds             # -> Data Segment
+  movw    %ax,%es             # -> Extra Segment
+  movw    %ax,%ss             # -> Stack Segment
+
+  # Physical address line A20 is tied to zero so that the first PCs 
+  # with 2 MB would run software that assumed 1 MB.  Undo that.
+seta20.1:
+  inb     $0x64,%al               # Wait for not busy
+  testb   $0x2,%al
+  jnz     seta20.1
+
+  movb    $0xd1,%al               # 0xd1 -> port 0x64
+  outb    %al,$0x64
+
+seta20.2:
+  inb     $0x64,%al               # Wait for not busy
+  testb   $0x2,%al
+  jnz     seta20.2
+
+  movb    $0xdf,%al               # 0xdf -> port 0x60
+  outb    %al,$0x60
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+  movl    %cr0, %eax
+  orl     $CR0_PE, %eax
+  movl    %eax, %cr0
+
+//PAGEBREAK!
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmp    $(SEG_KCODE<<3), $start32
+
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+  movw    %ax, %ds                # -> DS: Data Segment
+  movw    %ax, %es                # -> ES: Extra Segment
+  movw    %ax, %ss                # -> SS: Stack Segment
+  movw    $0, %ax                 # Zero segments not ready for use
+  movw    %ax, %fs                # -> FS
+  movw    %ax, %gs                # -> GS
+
+  # Set up the stack pointer and call into C.
+  movl    $start, %esp
+  call    bootmain
+
+  # If bootmain returns (it shouldn't), trigger a Bochs
+  # breakpoint if running under Bochs, then loop.
+  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+  movw    %ax, %dx
+  outw    %ax, %dx
+  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+  outw    %ax, %dx
+spin:
+  jmp     spin
+
+# Bootstrap GDT
+.p2align 2                                # force 4 byte alignment
+gdt:
+  SEG_NULLASM                             # null seg
+  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
+  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg
+
+gdtdesc:
+  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
+  .long   gdt                             # address gdt
+
diff -ruN xv6-public/xv6-public/bootasm.d xv6-public_new/xv6-public/bootasm.d
--- xv6-public/xv6-public/bootasm.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/bootasm.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1 @@
+bootasm.o: bootasm.S asm.h memlayout.h mmu.h
Binary files xv6-public/xv6-public/bootasm.o and xv6-public_new/xv6-public/bootasm.o differ
Binary files xv6-public/xv6-public/bootblock and xv6-public_new/xv6-public/bootblock differ
diff -ruN xv6-public/xv6-public/bootblock.asm xv6-public_new/xv6-public/bootblock.asm
--- xv6-public/xv6-public/bootblock.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/bootblock.asm	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,361 @@
+
+bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007c00 <start>:
+# with %cs=0 %ip=7c00.
+
+.code16                       # Assemble for 16-bit mode
+.globl start
+start:
+  cli                         # BIOS enabled interrupts; disable
+    7c00:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax             # Set %ax to zero
+    7c01:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds             # -> Data Segment
+    7c03:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es             # -> Extra Segment
+    7c05:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss             # -> Stack Segment
+    7c07:	8e d0                	mov    %eax,%ss
+
+00007c09 <seta20.1>:
+
+  # Physical address line A20 is tied to zero so that the first PCs 
+  # with 2 MB would run software that assumed 1 MB.  Undo that.
+seta20.1:
+  inb     $0x64,%al               # Wait for not busy
+    7c09:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c0b:	a8 02                	test   $0x2,%al
+  jnz     seta20.1
+    7c0d:	75 fa                	jne    7c09 <seta20.1>
+
+  movb    $0xd1,%al               # 0xd1 -> port 0x64
+    7c0f:	b0 d1                	mov    $0xd1,%al
+  outb    %al,$0x64
+    7c11:	e6 64                	out    %al,$0x64
+
+00007c13 <seta20.2>:
+
+seta20.2:
+  inb     $0x64,%al               # Wait for not busy
+    7c13:	e4 64                	in     $0x64,%al
+  testb   $0x2,%al
+    7c15:	a8 02                	test   $0x2,%al
+  jnz     seta20.2
+    7c17:	75 fa                	jne    7c13 <seta20.2>
+
+  movb    $0xdf,%al               # 0xdf -> port 0x60
+    7c19:	b0 df                	mov    $0xdf,%al
+  outb    %al,$0x60
+    7c1b:	e6 60                	out    %al,$0x60
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7c1d:	0f 01 16             	lgdtl  (%esi)
+    7c20:	78 7c                	js     7c9e <readsect+0xe>
+  movl    %cr0, %eax
+    7c22:	0f 20 c0             	mov    %cr0,%eax
+  orl     $CR0_PE, %eax
+    7c25:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7c29:	0f 22 c0             	mov    %eax,%cr0
+
+//PAGEBREAK!
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmp    $(SEG_KCODE<<3), $start32
+    7c2c:	ea                   	.byte 0xea
+    7c2d:	31 7c 08 00          	xor    %edi,0x0(%eax,%ecx,1)
+
+00007c31 <start32>:
+
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7c31:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7c35:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7c37:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7c39:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    7c3b:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    7c3f:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7c41:	8e e8                	mov    %eax,%gs
+
+  # Set up the stack pointer and call into C.
+  movl    $start, %esp
+    7c43:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+  call    bootmain
+    7c48:	e8 fc 00 00 00       	call   7d49 <bootmain>
+
+  # If bootmain returns (it shouldn't), trigger a Bochs
+  # breakpoint if running under Bochs, then loop.
+  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
+    7c4d:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    7c51:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7c54:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
+    7c56:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7c5a:	66 ef                	out    %ax,(%dx)
+
+00007c5c <spin>:
+spin:
+  jmp     spin
+    7c5c:	eb fe                	jmp    7c5c <spin>
+    7c5e:	66 90                	xchg   %ax,%ax
+
+00007c60 <gdt>:
+	...
+    7c68:	ff                   	(bad)  
+    7c69:	ff 00                	incl   (%eax)
+    7c6b:	00 00                	add    %al,(%eax)
+    7c6d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7c74:	00                   	.byte 0x0
+    7c75:	92                   	xchg   %eax,%edx
+    7c76:	cf                   	iret   
+	...
+
+00007c78 <gdtdesc>:
+    7c78:	17                   	pop    %ss
+    7c79:	00 60 7c             	add    %ah,0x7c(%eax)
+	...
+
+00007c7e <waitdisk>:
+  entry();
+}
+
+void
+waitdisk(void)
+{
+    7c7e:	f3 0f 1e fb          	endbr32 
+static inline uchar
+inb(ushort port)
+{
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+    7c82:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c87:	ec                   	in     (%dx),%al
+  // Wait for disk ready.
+  while((inb(0x1F7) & 0xC0) != 0x40)
+    7c88:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c8b:	3c 40                	cmp    $0x40,%al
+    7c8d:	75 f8                	jne    7c87 <waitdisk+0x9>
+    ;
+}
+    7c8f:	c3                   	ret    
+
+00007c90 <readsect>:
+
+// Read a single sector at offset into dst.
+void
+readsect(void *dst, uint offset)
+{
+    7c90:	f3 0f 1e fb          	endbr32 
+    7c94:	55                   	push   %ebp
+    7c95:	89 e5                	mov    %esp,%ebp
+    7c97:	57                   	push   %edi
+    7c98:	53                   	push   %ebx
+    7c99:	8b 5d 0c             	mov    0xc(%ebp),%ebx
+  // Issue command.
+  waitdisk();
+    7c9c:	e8 dd ff ff ff       	call   7c7e <waitdisk>
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+    7ca1:	b8 01 00 00 00       	mov    $0x1,%eax
+    7ca6:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7cab:	ee                   	out    %al,(%dx)
+    7cac:	ba f3 01 00 00       	mov    $0x1f3,%edx
+    7cb1:	89 d8                	mov    %ebx,%eax
+    7cb3:	ee                   	out    %al,(%dx)
+  outb(0x1F2, 1);   // count = 1
+  outb(0x1F3, offset);
+  outb(0x1F4, offset >> 8);
+    7cb4:	89 d8                	mov    %ebx,%eax
+    7cb6:	c1 e8 08             	shr    $0x8,%eax
+    7cb9:	ba f4 01 00 00       	mov    $0x1f4,%edx
+    7cbe:	ee                   	out    %al,(%dx)
+  outb(0x1F5, offset >> 16);
+    7cbf:	89 d8                	mov    %ebx,%eax
+    7cc1:	c1 e8 10             	shr    $0x10,%eax
+    7cc4:	ba f5 01 00 00       	mov    $0x1f5,%edx
+    7cc9:	ee                   	out    %al,(%dx)
+  outb(0x1F6, (offset >> 24) | 0xE0);
+    7cca:	89 d8                	mov    %ebx,%eax
+    7ccc:	c1 e8 18             	shr    $0x18,%eax
+    7ccf:	83 c8 e0             	or     $0xffffffe0,%eax
+    7cd2:	ba f6 01 00 00       	mov    $0x1f6,%edx
+    7cd7:	ee                   	out    %al,(%dx)
+    7cd8:	b8 20 00 00 00       	mov    $0x20,%eax
+    7cdd:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7ce2:	ee                   	out    %al,(%dx)
+  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+
+  // Read data.
+  waitdisk();
+    7ce3:	e8 96 ff ff ff       	call   7c7e <waitdisk>
+  asm volatile("cld; rep insl" :
+    7ce8:	8b 7d 08             	mov    0x8(%ebp),%edi
+    7ceb:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7cf0:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7cf5:	fc                   	cld    
+    7cf6:	f3 6d                	rep insl (%dx),%es:(%edi)
+  insl(0x1F0, dst, SECTSIZE/4);
+}
+    7cf8:	5b                   	pop    %ebx
+    7cf9:	5f                   	pop    %edi
+    7cfa:	5d                   	pop    %ebp
+    7cfb:	c3                   	ret    
+
+00007cfc <readseg>:
+
+// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+// Might copy more than asked.
+void
+readseg(uchar* pa, uint count, uint offset)
+{
+    7cfc:	f3 0f 1e fb          	endbr32 
+    7d00:	55                   	push   %ebp
+    7d01:	89 e5                	mov    %esp,%ebp
+    7d03:	57                   	push   %edi
+    7d04:	56                   	push   %esi
+    7d05:	53                   	push   %ebx
+    7d06:	83 ec 0c             	sub    $0xc,%esp
+    7d09:	8b 5d 08             	mov    0x8(%ebp),%ebx
+    7d0c:	8b 75 10             	mov    0x10(%ebp),%esi
+  uchar* epa;
+
+  epa = pa + count;
+    7d0f:	89 df                	mov    %ebx,%edi
+    7d11:	03 7d 0c             	add    0xc(%ebp),%edi
+
+  // Round down to sector boundary.
+  pa -= offset % SECTSIZE;
+    7d14:	89 f0                	mov    %esi,%eax
+    7d16:	25 ff 01 00 00       	and    $0x1ff,%eax
+    7d1b:	29 c3                	sub    %eax,%ebx
+
+  // Translate from bytes to sectors; kernel starts at sector 1.
+  offset = (offset / SECTSIZE) + 1;
+    7d1d:	c1 ee 09             	shr    $0x9,%esi
+    7d20:	83 c6 01             	add    $0x1,%esi
+
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d23:	39 df                	cmp    %ebx,%edi
+    7d25:	76 1a                	jbe    7d41 <readseg+0x45>
+    readsect(pa, offset);
+    7d27:	83 ec 08             	sub    $0x8,%esp
+    7d2a:	56                   	push   %esi
+    7d2b:	53                   	push   %ebx
+    7d2c:	e8 5f ff ff ff       	call   7c90 <readsect>
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    7d31:	81 c3 00 02 00 00    	add    $0x200,%ebx
+    7d37:	83 c6 01             	add    $0x1,%esi
+    7d3a:	83 c4 10             	add    $0x10,%esp
+    7d3d:	39 df                	cmp    %ebx,%edi
+    7d3f:	77 e6                	ja     7d27 <readseg+0x2b>
+}
+    7d41:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    7d44:	5b                   	pop    %ebx
+    7d45:	5e                   	pop    %esi
+    7d46:	5f                   	pop    %edi
+    7d47:	5d                   	pop    %ebp
+    7d48:	c3                   	ret    
+
+00007d49 <bootmain>:
+{
+    7d49:	f3 0f 1e fb          	endbr32 
+    7d4d:	55                   	push   %ebp
+    7d4e:	89 e5                	mov    %esp,%ebp
+    7d50:	57                   	push   %edi
+    7d51:	56                   	push   %esi
+    7d52:	53                   	push   %ebx
+    7d53:	83 ec 10             	sub    $0x10,%esp
+  readseg((uchar*)elf, 4096, 0);
+    7d56:	6a 00                	push   $0x0
+    7d58:	68 00 10 00 00       	push   $0x1000
+    7d5d:	68 00 00 01 00       	push   $0x10000
+    7d62:	e8 95 ff ff ff       	call   7cfc <readseg>
+  if(elf->magic != ELF_MAGIC)
+    7d67:	83 c4 10             	add    $0x10,%esp
+    7d6a:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d71:	45 4c 46 
+    7d74:	75 21                	jne    7d97 <bootmain+0x4e>
+  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+    7d76:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    7d7b:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+  eph = ph + elf->phnum;
+    7d81:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
+    7d88:	c1 e6 05             	shl    $0x5,%esi
+    7d8b:	01 de                	add    %ebx,%esi
+  for(; ph < eph; ph++){
+    7d8d:	39 f3                	cmp    %esi,%ebx
+    7d8f:	72 15                	jb     7da6 <bootmain+0x5d>
+  entry();
+    7d91:	ff 15 18 00 01 00    	call   *0x10018
+}
+    7d97:	8d 65 f4             	lea    -0xc(%ebp),%esp
+    7d9a:	5b                   	pop    %ebx
+    7d9b:	5e                   	pop    %esi
+    7d9c:	5f                   	pop    %edi
+    7d9d:	5d                   	pop    %ebp
+    7d9e:	c3                   	ret    
+  for(; ph < eph; ph++){
+    7d9f:	83 c3 20             	add    $0x20,%ebx
+    7da2:	39 de                	cmp    %ebx,%esi
+    7da4:	76 eb                	jbe    7d91 <bootmain+0x48>
+    pa = (uchar*)ph->paddr;
+    7da6:	8b 7b 0c             	mov    0xc(%ebx),%edi
+    readseg(pa, ph->filesz, ph->off);
+    7da9:	83 ec 04             	sub    $0x4,%esp
+    7dac:	ff 73 04             	pushl  0x4(%ebx)
+    7daf:	ff 73 10             	pushl  0x10(%ebx)
+    7db2:	57                   	push   %edi
+    7db3:	e8 44 ff ff ff       	call   7cfc <readseg>
+    if(ph->memsz > ph->filesz)
+    7db8:	8b 4b 14             	mov    0x14(%ebx),%ecx
+    7dbb:	8b 43 10             	mov    0x10(%ebx),%eax
+    7dbe:	83 c4 10             	add    $0x10,%esp
+    7dc1:	39 c1                	cmp    %eax,%ecx
+    7dc3:	76 da                	jbe    7d9f <bootmain+0x56>
+      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+    7dc5:	01 c7                	add    %eax,%edi
+    7dc7:	29 c1                	sub    %eax,%ecx
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+    7dc9:	b8 00 00 00 00       	mov    $0x0,%eax
+    7dce:	fc                   	cld    
+    7dcf:	f3 aa                	rep stos %al,%es:(%edi)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+    7dd1:	eb cc                	jmp    7d9f <bootmain+0x56>
Binary files xv6-public/xv6-public/bootblock.o and xv6-public_new/xv6-public/bootblock.o differ
Binary files xv6-public/xv6-public/bootblockother.o and xv6-public_new/xv6-public/bootblockother.o differ
diff -ruN xv6-public/xv6-public/bootmain.c xv6-public_new/xv6-public/bootmain.c
--- xv6-public/xv6-public/bootmain.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/bootmain.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,96 @@
+// Boot loader.
+//
+// Part of the boot block, along with bootasm.S, which calls bootmain().
+// bootasm.S has put the processor into protected 32-bit mode.
+// bootmain() loads an ELF kernel image from the disk starting at
+// sector 1 and then jumps to the kernel entry routine.
+
+#include "types.h"
+#include "elf.h"
+#include "x86.h"
+#include "memlayout.h"
+
+#define SECTSIZE  512
+
+void readseg(uchar*, uint, uint);
+
+void
+bootmain(void)
+{
+  struct elfhdr *elf;
+  struct proghdr *ph, *eph;
+  void (*entry)(void);
+  uchar* pa;
+
+  elf = (struct elfhdr*)0x10000;  // scratch space
+
+  // Read 1st page off disk
+  readseg((uchar*)elf, 4096, 0);
+
+  // Is this an ELF executable?
+  if(elf->magic != ELF_MAGIC)
+    return;  // let bootasm.S handle error
+
+  // Load each program segment (ignores ph flags).
+  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
+  eph = ph + elf->phnum;
+  for(; ph < eph; ph++){
+    pa = (uchar*)ph->paddr;
+    readseg(pa, ph->filesz, ph->off);
+    if(ph->memsz > ph->filesz)
+      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
+  }
+
+  // Call the entry point from the ELF header.
+  // Does not return!
+  entry = (void(*)(void))(elf->entry);
+  entry();
+}
+
+void
+waitdisk(void)
+{
+  // Wait for disk ready.
+  while((inb(0x1F7) & 0xC0) != 0x40)
+    ;
+}
+
+// Read a single sector at offset into dst.
+void
+readsect(void *dst, uint offset)
+{
+  // Issue command.
+  waitdisk();
+  outb(0x1F2, 1);   // count = 1
+  outb(0x1F3, offset);
+  outb(0x1F4, offset >> 8);
+  outb(0x1F5, offset >> 16);
+  outb(0x1F6, (offset >> 24) | 0xE0);
+  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
+
+  // Read data.
+  waitdisk();
+  insl(0x1F0, dst, SECTSIZE/4);
+}
+
+// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
+// Might copy more than asked.
+void
+readseg(uchar* pa, uint count, uint offset)
+{
+  uchar* epa;
+
+  epa = pa + count;
+
+  // Round down to sector boundary.
+  pa -= offset % SECTSIZE;
+
+  // Translate from bytes to sectors; kernel starts at sector 1.
+  offset = (offset / SECTSIZE) + 1;
+
+  // If this is too slow, we could read lots of sectors at a time.
+  // We'd write more to memory than asked, but it doesn't matter --
+  // we load in increasing order.
+  for(; pa < epa; pa += SECTSIZE, offset++)
+    readsect(pa, offset);
+}
diff -ruN xv6-public/xv6-public/bootmain.d xv6-public_new/xv6-public/bootmain.d
--- xv6-public/xv6-public/bootmain.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/bootmain.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1 @@
+bootmain.o: bootmain.c types.h elf.h x86.h memlayout.h
Binary files xv6-public/xv6-public/bootmain.o and xv6-public_new/xv6-public/bootmain.o differ
diff -ruN xv6-public/xv6-public/buf.h xv6-public_new/xv6-public/buf.h
--- xv6-public/xv6-public/buf.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/buf.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,14 @@
+struct buf {
+  int flags;
+  uint dev;
+  uint blockno;
+  struct sleeplock lock;
+  uint refcnt;
+  struct buf *prev; // LRU cache list
+  struct buf *next;
+  struct buf *qnext; // disk queue
+  uchar data[BSIZE];
+};
+#define B_VALID 0x2  // buffer has been read from disk
+#define B_DIRTY 0x4  // buffer needs to be written to disk
+
diff -ruN xv6-public/xv6-public/cat.asm xv6-public_new/xv6-public/cat.asm
--- xv6-public/xv6-public/cat.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/cat.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1256 @@
+
+_cat:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <cat>:
+
+char buf[512];
+
+void
+cat(int fd)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	55                   	push   %ebp
+   5:	89 e5                	mov    %esp,%ebp
+   7:	83 ec 18             	sub    $0x18,%esp
+  int n;
+
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+   a:	eb 31                	jmp    3d <cat+0x3d>
+    if (write(1, buf, n) != n) {
+   c:	83 ec 04             	sub    $0x4,%esp
+   f:	ff 75 f4             	pushl  -0xc(%ebp)
+  12:	68 00 0c 00 00       	push   $0xc00
+  17:	6a 01                	push   $0x1
+  19:	e8 b0 03 00 00       	call   3ce <write>
+  1e:	83 c4 10             	add    $0x10,%esp
+  21:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+  24:	74 17                	je     3d <cat+0x3d>
+      printf(1, "cat: write error\n");
+  26:	83 ec 08             	sub    $0x8,%esp
+  29:	68 19 09 00 00       	push   $0x919
+  2e:	6a 01                	push   $0x1
+  30:	e8 1d 05 00 00       	call   552 <printf>
+  35:	83 c4 10             	add    $0x10,%esp
+      exit();
+  38:	e8 71 03 00 00       	call   3ae <exit>
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+  3d:	83 ec 04             	sub    $0x4,%esp
+  40:	68 00 02 00 00       	push   $0x200
+  45:	68 00 0c 00 00       	push   $0xc00
+  4a:	ff 75 08             	pushl  0x8(%ebp)
+  4d:	e8 74 03 00 00       	call   3c6 <read>
+  52:	83 c4 10             	add    $0x10,%esp
+  55:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  58:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  5c:	7f ae                	jg     c <cat+0xc>
+    }
+  }
+  if(n < 0){
+  5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  62:	79 17                	jns    7b <cat+0x7b>
+    printf(1, "cat: read error\n");
+  64:	83 ec 08             	sub    $0x8,%esp
+  67:	68 2b 09 00 00       	push   $0x92b
+  6c:	6a 01                	push   $0x1
+  6e:	e8 df 04 00 00       	call   552 <printf>
+  73:	83 c4 10             	add    $0x10,%esp
+    exit();
+  76:	e8 33 03 00 00       	call   3ae <exit>
+  }
+}
+  7b:	90                   	nop
+  7c:	c9                   	leave  
+  7d:	c3                   	ret    
+
+0000007e <main>:
+
+int
+main(int argc, char *argv[])
+{
+  7e:	f3 0f 1e fb          	endbr32 
+  82:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  86:	83 e4 f0             	and    $0xfffffff0,%esp
+  89:	ff 71 fc             	pushl  -0x4(%ecx)
+  8c:	55                   	push   %ebp
+  8d:	89 e5                	mov    %esp,%ebp
+  8f:	53                   	push   %ebx
+  90:	51                   	push   %ecx
+  91:	83 ec 10             	sub    $0x10,%esp
+  94:	89 cb                	mov    %ecx,%ebx
+  int fd, i;
+
+  if(argc <= 1){
+  96:	83 3b 01             	cmpl   $0x1,(%ebx)
+  99:	7f 12                	jg     ad <main+0x2f>
+    cat(0);
+  9b:	83 ec 0c             	sub    $0xc,%esp
+  9e:	6a 00                	push   $0x0
+  a0:	e8 5b ff ff ff       	call   0 <cat>
+  a5:	83 c4 10             	add    $0x10,%esp
+    exit();
+  a8:	e8 01 03 00 00       	call   3ae <exit>
+  }
+
+  for(i = 1; i < argc; i++){
+  ad:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+  b4:	eb 71                	jmp    127 <main+0xa9>
+    if((fd = open(argv[i], 0)) < 0){
+  b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  c0:	8b 43 04             	mov    0x4(%ebx),%eax
+  c3:	01 d0                	add    %edx,%eax
+  c5:	8b 00                	mov    (%eax),%eax
+  c7:	83 ec 08             	sub    $0x8,%esp
+  ca:	6a 00                	push   $0x0
+  cc:	50                   	push   %eax
+  cd:	e8 1c 03 00 00       	call   3ee <open>
+  d2:	83 c4 10             	add    $0x10,%esp
+  d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  dc:	79 29                	jns    107 <main+0x89>
+      printf(1, "cat: cannot open %s\n", argv[i]);
+  de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  e1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  e8:	8b 43 04             	mov    0x4(%ebx),%eax
+  eb:	01 d0                	add    %edx,%eax
+  ed:	8b 00                	mov    (%eax),%eax
+  ef:	83 ec 04             	sub    $0x4,%esp
+  f2:	50                   	push   %eax
+  f3:	68 3c 09 00 00       	push   $0x93c
+  f8:	6a 01                	push   $0x1
+  fa:	e8 53 04 00 00       	call   552 <printf>
+  ff:	83 c4 10             	add    $0x10,%esp
+      exit();
+ 102:	e8 a7 02 00 00       	call   3ae <exit>
+    }
+    cat(fd);
+ 107:	83 ec 0c             	sub    $0xc,%esp
+ 10a:	ff 75 f0             	pushl  -0x10(%ebp)
+ 10d:	e8 ee fe ff ff       	call   0 <cat>
+ 112:	83 c4 10             	add    $0x10,%esp
+    close(fd);
+ 115:	83 ec 0c             	sub    $0xc,%esp
+ 118:	ff 75 f0             	pushl  -0x10(%ebp)
+ 11b:	e8 b6 02 00 00       	call   3d6 <close>
+ 120:	83 c4 10             	add    $0x10,%esp
+  for(i = 1; i < argc; i++){
+ 123:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 127:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 12a:	3b 03                	cmp    (%ebx),%eax
+ 12c:	7c 88                	jl     b6 <main+0x38>
+  }
+  exit();
+ 12e:	e8 7b 02 00 00       	call   3ae <exit>
+
+00000133 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 133:	55                   	push   %ebp
+ 134:	89 e5                	mov    %esp,%ebp
+ 136:	57                   	push   %edi
+ 137:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 138:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 13b:	8b 55 10             	mov    0x10(%ebp),%edx
+ 13e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 141:	89 cb                	mov    %ecx,%ebx
+ 143:	89 df                	mov    %ebx,%edi
+ 145:	89 d1                	mov    %edx,%ecx
+ 147:	fc                   	cld    
+ 148:	f3 aa                	rep stos %al,%es:(%edi)
+ 14a:	89 ca                	mov    %ecx,%edx
+ 14c:	89 fb                	mov    %edi,%ebx
+ 14e:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 151:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 154:	90                   	nop
+ 155:	5b                   	pop    %ebx
+ 156:	5f                   	pop    %edi
+ 157:	5d                   	pop    %ebp
+ 158:	c3                   	ret    
+
+00000159 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 159:	f3 0f 1e fb          	endbr32 
+ 15d:	55                   	push   %ebp
+ 15e:	89 e5                	mov    %esp,%ebp
+ 160:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 163:	8b 45 08             	mov    0x8(%ebp),%eax
+ 166:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 169:	90                   	nop
+ 16a:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 16d:	8d 42 01             	lea    0x1(%edx),%eax
+ 170:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 173:	8b 45 08             	mov    0x8(%ebp),%eax
+ 176:	8d 48 01             	lea    0x1(%eax),%ecx
+ 179:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 17c:	0f b6 12             	movzbl (%edx),%edx
+ 17f:	88 10                	mov    %dl,(%eax)
+ 181:	0f b6 00             	movzbl (%eax),%eax
+ 184:	84 c0                	test   %al,%al
+ 186:	75 e2                	jne    16a <strcpy+0x11>
+    ;
+  return os;
+ 188:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 18b:	c9                   	leave  
+ 18c:	c3                   	ret    
+
+0000018d <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 18d:	f3 0f 1e fb          	endbr32 
+ 191:	55                   	push   %ebp
+ 192:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 194:	eb 08                	jmp    19e <strcmp+0x11>
+    p++, q++;
+ 196:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 19a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 19e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1a1:	0f b6 00             	movzbl (%eax),%eax
+ 1a4:	84 c0                	test   %al,%al
+ 1a6:	74 10                	je     1b8 <strcmp+0x2b>
+ 1a8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ab:	0f b6 10             	movzbl (%eax),%edx
+ 1ae:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1b1:	0f b6 00             	movzbl (%eax),%eax
+ 1b4:	38 c2                	cmp    %al,%dl
+ 1b6:	74 de                	je     196 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 1b8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1bb:	0f b6 00             	movzbl (%eax),%eax
+ 1be:	0f b6 d0             	movzbl %al,%edx
+ 1c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1c4:	0f b6 00             	movzbl (%eax),%eax
+ 1c7:	0f b6 c0             	movzbl %al,%eax
+ 1ca:	29 c2                	sub    %eax,%edx
+ 1cc:	89 d0                	mov    %edx,%eax
+}
+ 1ce:	5d                   	pop    %ebp
+ 1cf:	c3                   	ret    
+
+000001d0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 1d0:	f3 0f 1e fb          	endbr32 
+ 1d4:	55                   	push   %ebp
+ 1d5:	89 e5                	mov    %esp,%ebp
+ 1d7:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 1e1:	eb 04                	jmp    1e7 <strlen+0x17>
+ 1e3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 1e7:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 1ea:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ed:	01 d0                	add    %edx,%eax
+ 1ef:	0f b6 00             	movzbl (%eax),%eax
+ 1f2:	84 c0                	test   %al,%al
+ 1f4:	75 ed                	jne    1e3 <strlen+0x13>
+    ;
+  return n;
+ 1f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1f9:	c9                   	leave  
+ 1fa:	c3                   	ret    
+
+000001fb <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1fb:	f3 0f 1e fb          	endbr32 
+ 1ff:	55                   	push   %ebp
+ 200:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 202:	8b 45 10             	mov    0x10(%ebp),%eax
+ 205:	50                   	push   %eax
+ 206:	ff 75 0c             	pushl  0xc(%ebp)
+ 209:	ff 75 08             	pushl  0x8(%ebp)
+ 20c:	e8 22 ff ff ff       	call   133 <stosb>
+ 211:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 214:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 217:	c9                   	leave  
+ 218:	c3                   	ret    
+
+00000219 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 219:	f3 0f 1e fb          	endbr32 
+ 21d:	55                   	push   %ebp
+ 21e:	89 e5                	mov    %esp,%ebp
+ 220:	83 ec 04             	sub    $0x4,%esp
+ 223:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 226:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 229:	eb 14                	jmp    23f <strchr+0x26>
+    if(*s == c)
+ 22b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 22e:	0f b6 00             	movzbl (%eax),%eax
+ 231:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 234:	75 05                	jne    23b <strchr+0x22>
+      return (char*)s;
+ 236:	8b 45 08             	mov    0x8(%ebp),%eax
+ 239:	eb 13                	jmp    24e <strchr+0x35>
+  for(; *s; s++)
+ 23b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 23f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 242:	0f b6 00             	movzbl (%eax),%eax
+ 245:	84 c0                	test   %al,%al
+ 247:	75 e2                	jne    22b <strchr+0x12>
+  return 0;
+ 249:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 24e:	c9                   	leave  
+ 24f:	c3                   	ret    
+
+00000250 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 250:	f3 0f 1e fb          	endbr32 
+ 254:	55                   	push   %ebp
+ 255:	89 e5                	mov    %esp,%ebp
+ 257:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 25a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 261:	eb 42                	jmp    2a5 <gets+0x55>
+    cc = read(0, &c, 1);
+ 263:	83 ec 04             	sub    $0x4,%esp
+ 266:	6a 01                	push   $0x1
+ 268:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 26b:	50                   	push   %eax
+ 26c:	6a 00                	push   $0x0
+ 26e:	e8 53 01 00 00       	call   3c6 <read>
+ 273:	83 c4 10             	add    $0x10,%esp
+ 276:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 279:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 27d:	7e 33                	jle    2b2 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 27f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 282:	8d 50 01             	lea    0x1(%eax),%edx
+ 285:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 288:	89 c2                	mov    %eax,%edx
+ 28a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 28d:	01 c2                	add    %eax,%edx
+ 28f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 293:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 295:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 299:	3c 0a                	cmp    $0xa,%al
+ 29b:	74 16                	je     2b3 <gets+0x63>
+ 29d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 2a1:	3c 0d                	cmp    $0xd,%al
+ 2a3:	74 0e                	je     2b3 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 2a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2a8:	83 c0 01             	add    $0x1,%eax
+ 2ab:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 2ae:	7f b3                	jg     263 <gets+0x13>
+ 2b0:	eb 01                	jmp    2b3 <gets+0x63>
+      break;
+ 2b2:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 2b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 2b6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b9:	01 d0                	add    %edx,%eax
+ 2bb:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 2be:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2c1:	c9                   	leave  
+ 2c2:	c3                   	ret    
+
+000002c3 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 2c3:	f3 0f 1e fb          	endbr32 
+ 2c7:	55                   	push   %ebp
+ 2c8:	89 e5                	mov    %esp,%ebp
+ 2ca:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2cd:	83 ec 08             	sub    $0x8,%esp
+ 2d0:	6a 00                	push   $0x0
+ 2d2:	ff 75 08             	pushl  0x8(%ebp)
+ 2d5:	e8 14 01 00 00       	call   3ee <open>
+ 2da:	83 c4 10             	add    $0x10,%esp
+ 2dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 2e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 2e4:	79 07                	jns    2ed <stat+0x2a>
+    return -1;
+ 2e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 2eb:	eb 25                	jmp    312 <stat+0x4f>
+  r = fstat(fd, st);
+ 2ed:	83 ec 08             	sub    $0x8,%esp
+ 2f0:	ff 75 0c             	pushl  0xc(%ebp)
+ 2f3:	ff 75 f4             	pushl  -0xc(%ebp)
+ 2f6:	e8 0b 01 00 00       	call   406 <fstat>
+ 2fb:	83 c4 10             	add    $0x10,%esp
+ 2fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 301:	83 ec 0c             	sub    $0xc,%esp
+ 304:	ff 75 f4             	pushl  -0xc(%ebp)
+ 307:	e8 ca 00 00 00       	call   3d6 <close>
+ 30c:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 30f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 312:	c9                   	leave  
+ 313:	c3                   	ret    
+
+00000314 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 314:	f3 0f 1e fb          	endbr32 
+ 318:	55                   	push   %ebp
+ 319:	89 e5                	mov    %esp,%ebp
+ 31b:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 31e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 325:	eb 25                	jmp    34c <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 327:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 32a:	89 d0                	mov    %edx,%eax
+ 32c:	c1 e0 02             	shl    $0x2,%eax
+ 32f:	01 d0                	add    %edx,%eax
+ 331:	01 c0                	add    %eax,%eax
+ 333:	89 c1                	mov    %eax,%ecx
+ 335:	8b 45 08             	mov    0x8(%ebp),%eax
+ 338:	8d 50 01             	lea    0x1(%eax),%edx
+ 33b:	89 55 08             	mov    %edx,0x8(%ebp)
+ 33e:	0f b6 00             	movzbl (%eax),%eax
+ 341:	0f be c0             	movsbl %al,%eax
+ 344:	01 c8                	add    %ecx,%eax
+ 346:	83 e8 30             	sub    $0x30,%eax
+ 349:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 34c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 34f:	0f b6 00             	movzbl (%eax),%eax
+ 352:	3c 2f                	cmp    $0x2f,%al
+ 354:	7e 0a                	jle    360 <atoi+0x4c>
+ 356:	8b 45 08             	mov    0x8(%ebp),%eax
+ 359:	0f b6 00             	movzbl (%eax),%eax
+ 35c:	3c 39                	cmp    $0x39,%al
+ 35e:	7e c7                	jle    327 <atoi+0x13>
+  return n;
+ 360:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 363:	c9                   	leave  
+ 364:	c3                   	ret    
+
+00000365 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 365:	f3 0f 1e fb          	endbr32 
+ 369:	55                   	push   %ebp
+ 36a:	89 e5                	mov    %esp,%ebp
+ 36c:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 36f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 372:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 375:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 378:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 37b:	eb 17                	jmp    394 <memmove+0x2f>
+    *dst++ = *src++;
+ 37d:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 380:	8d 42 01             	lea    0x1(%edx),%eax
+ 383:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 386:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 389:	8d 48 01             	lea    0x1(%eax),%ecx
+ 38c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 38f:	0f b6 12             	movzbl (%edx),%edx
+ 392:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 394:	8b 45 10             	mov    0x10(%ebp),%eax
+ 397:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 39a:	89 55 10             	mov    %edx,0x10(%ebp)
+ 39d:	85 c0                	test   %eax,%eax
+ 39f:	7f dc                	jg     37d <memmove+0x18>
+  return vdst;
+ 3a1:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 3a4:	c9                   	leave  
+ 3a5:	c3                   	ret    
+
+000003a6 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 3a6:	b8 01 00 00 00       	mov    $0x1,%eax
+ 3ab:	cd 40                	int    $0x40
+ 3ad:	c3                   	ret    
+
+000003ae <exit>:
+SYSCALL(exit)
+ 3ae:	b8 02 00 00 00       	mov    $0x2,%eax
+ 3b3:	cd 40                	int    $0x40
+ 3b5:	c3                   	ret    
+
+000003b6 <wait>:
+SYSCALL(wait)
+ 3b6:	b8 03 00 00 00       	mov    $0x3,%eax
+ 3bb:	cd 40                	int    $0x40
+ 3bd:	c3                   	ret    
+
+000003be <pipe>:
+SYSCALL(pipe)
+ 3be:	b8 04 00 00 00       	mov    $0x4,%eax
+ 3c3:	cd 40                	int    $0x40
+ 3c5:	c3                   	ret    
+
+000003c6 <read>:
+SYSCALL(read)
+ 3c6:	b8 05 00 00 00       	mov    $0x5,%eax
+ 3cb:	cd 40                	int    $0x40
+ 3cd:	c3                   	ret    
+
+000003ce <write>:
+SYSCALL(write)
+ 3ce:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3d3:	cd 40                	int    $0x40
+ 3d5:	c3                   	ret    
+
+000003d6 <close>:
+SYSCALL(close)
+ 3d6:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3db:	cd 40                	int    $0x40
+ 3dd:	c3                   	ret    
+
+000003de <kill>:
+SYSCALL(kill)
+ 3de:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3e3:	cd 40                	int    $0x40
+ 3e5:	c3                   	ret    
+
+000003e6 <exec>:
+SYSCALL(exec)
+ 3e6:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3eb:	cd 40                	int    $0x40
+ 3ed:	c3                   	ret    
+
+000003ee <open>:
+SYSCALL(open)
+ 3ee:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3f3:	cd 40                	int    $0x40
+ 3f5:	c3                   	ret    
+
+000003f6 <mknod>:
+SYSCALL(mknod)
+ 3f6:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3fb:	cd 40                	int    $0x40
+ 3fd:	c3                   	ret    
+
+000003fe <unlink>:
+SYSCALL(unlink)
+ 3fe:	b8 12 00 00 00       	mov    $0x12,%eax
+ 403:	cd 40                	int    $0x40
+ 405:	c3                   	ret    
+
+00000406 <fstat>:
+SYSCALL(fstat)
+ 406:	b8 08 00 00 00       	mov    $0x8,%eax
+ 40b:	cd 40                	int    $0x40
+ 40d:	c3                   	ret    
+
+0000040e <link>:
+SYSCALL(link)
+ 40e:	b8 13 00 00 00       	mov    $0x13,%eax
+ 413:	cd 40                	int    $0x40
+ 415:	c3                   	ret    
+
+00000416 <mkdir>:
+SYSCALL(mkdir)
+ 416:	b8 14 00 00 00       	mov    $0x14,%eax
+ 41b:	cd 40                	int    $0x40
+ 41d:	c3                   	ret    
+
+0000041e <chdir>:
+SYSCALL(chdir)
+ 41e:	b8 09 00 00 00       	mov    $0x9,%eax
+ 423:	cd 40                	int    $0x40
+ 425:	c3                   	ret    
+
+00000426 <dup>:
+SYSCALL(dup)
+ 426:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 42b:	cd 40                	int    $0x40
+ 42d:	c3                   	ret    
+
+0000042e <getpid>:
+SYSCALL(getpid)
+ 42e:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 433:	cd 40                	int    $0x40
+ 435:	c3                   	ret    
+
+00000436 <sbrk>:
+SYSCALL(sbrk)
+ 436:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 43b:	cd 40                	int    $0x40
+ 43d:	c3                   	ret    
+
+0000043e <sleep>:
+SYSCALL(sleep)
+ 43e:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 443:	cd 40                	int    $0x40
+ 445:	c3                   	ret    
+
+00000446 <uptime>:
+SYSCALL(uptime)
+ 446:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 44b:	cd 40                	int    $0x40
+ 44d:	c3                   	ret    
+
+0000044e <draw>:
+SYSCALL(draw)
+ 44e:	b8 16 00 00 00       	mov    $0x16,%eax
+ 453:	cd 40                	int    $0x40
+ 455:	c3                   	ret    
+
+00000456 <cps>:
+SYSCALL(cps)
+ 456:	b8 17 00 00 00       	mov    $0x17,%eax
+ 45b:	cd 40                	int    $0x40
+ 45d:	c3                   	ret    
+
+0000045e <yield>:
+SYSCALL(yield)
+ 45e:	b8 18 00 00 00       	mov    $0x18,%eax
+ 463:	cd 40                	int    $0x40
+ 465:	c3                   	ret    
+
+00000466 <wait2>:
+SYSCALL(wait2)
+ 466:	b8 19 00 00 00       	mov    $0x19,%eax
+ 46b:	cd 40                	int    $0x40
+ 46d:	c3                   	ret    
+
+0000046e <set_prio>:
+SYSCALL(set_prio)
+ 46e:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 473:	cd 40                	int    $0x40
+ 475:	c3                   	ret    
+
+00000476 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 476:	f3 0f 1e fb          	endbr32 
+ 47a:	55                   	push   %ebp
+ 47b:	89 e5                	mov    %esp,%ebp
+ 47d:	83 ec 18             	sub    $0x18,%esp
+ 480:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 483:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 486:	83 ec 04             	sub    $0x4,%esp
+ 489:	6a 01                	push   $0x1
+ 48b:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 48e:	50                   	push   %eax
+ 48f:	ff 75 08             	pushl  0x8(%ebp)
+ 492:	e8 37 ff ff ff       	call   3ce <write>
+ 497:	83 c4 10             	add    $0x10,%esp
+}
+ 49a:	90                   	nop
+ 49b:	c9                   	leave  
+ 49c:	c3                   	ret    
+
+0000049d <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 49d:	f3 0f 1e fb          	endbr32 
+ 4a1:	55                   	push   %ebp
+ 4a2:	89 e5                	mov    %esp,%ebp
+ 4a4:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 4a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 4ae:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 4b2:	74 17                	je     4cb <printint+0x2e>
+ 4b4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 4b8:	79 11                	jns    4cb <printint+0x2e>
+    neg = 1;
+ 4ba:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 4c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4c4:	f7 d8                	neg    %eax
+ 4c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 4c9:	eb 06                	jmp    4d1 <printint+0x34>
+  } else {
+    x = xx;
+ 4cb:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 4d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 4d8:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 4db:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 4de:	ba 00 00 00 00       	mov    $0x0,%edx
+ 4e3:	f7 f1                	div    %ecx
+ 4e5:	89 d1                	mov    %edx,%ecx
+ 4e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4ea:	8d 50 01             	lea    0x1(%eax),%edx
+ 4ed:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 4f0:	0f b6 91 c0 0b 00 00 	movzbl 0xbc0(%ecx),%edx
+ 4f7:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 4fb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 4fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 501:	ba 00 00 00 00       	mov    $0x0,%edx
+ 506:	f7 f1                	div    %ecx
+ 508:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 50b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 50f:	75 c7                	jne    4d8 <printint+0x3b>
+  if(neg)
+ 511:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 515:	74 2d                	je     544 <printint+0xa7>
+    buf[i++] = '-';
+ 517:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 51a:	8d 50 01             	lea    0x1(%eax),%edx
+ 51d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 520:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 525:	eb 1d                	jmp    544 <printint+0xa7>
+    putc(fd, buf[i]);
+ 527:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 52a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 52d:	01 d0                	add    %edx,%eax
+ 52f:	0f b6 00             	movzbl (%eax),%eax
+ 532:	0f be c0             	movsbl %al,%eax
+ 535:	83 ec 08             	sub    $0x8,%esp
+ 538:	50                   	push   %eax
+ 539:	ff 75 08             	pushl  0x8(%ebp)
+ 53c:	e8 35 ff ff ff       	call   476 <putc>
+ 541:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 544:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 548:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 54c:	79 d9                	jns    527 <printint+0x8a>
+}
+ 54e:	90                   	nop
+ 54f:	90                   	nop
+ 550:	c9                   	leave  
+ 551:	c3                   	ret    
+
+00000552 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 552:	f3 0f 1e fb          	endbr32 
+ 556:	55                   	push   %ebp
+ 557:	89 e5                	mov    %esp,%ebp
+ 559:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 55c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 563:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 566:	83 c0 04             	add    $0x4,%eax
+ 569:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 56c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 573:	e9 59 01 00 00       	jmp    6d1 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 578:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 57b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 57e:	01 d0                	add    %edx,%eax
+ 580:	0f b6 00             	movzbl (%eax),%eax
+ 583:	0f be c0             	movsbl %al,%eax
+ 586:	25 ff 00 00 00       	and    $0xff,%eax
+ 58b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 58e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 592:	75 2c                	jne    5c0 <printf+0x6e>
+      if(c == '%'){
+ 594:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 598:	75 0c                	jne    5a6 <printf+0x54>
+        state = '%';
+ 59a:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 5a1:	e9 27 01 00 00       	jmp    6cd <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 5a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5a9:	0f be c0             	movsbl %al,%eax
+ 5ac:	83 ec 08             	sub    $0x8,%esp
+ 5af:	50                   	push   %eax
+ 5b0:	ff 75 08             	pushl  0x8(%ebp)
+ 5b3:	e8 be fe ff ff       	call   476 <putc>
+ 5b8:	83 c4 10             	add    $0x10,%esp
+ 5bb:	e9 0d 01 00 00       	jmp    6cd <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 5c0:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 5c4:	0f 85 03 01 00 00    	jne    6cd <printf+0x17b>
+      if(c == 'd'){
+ 5ca:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 5ce:	75 1e                	jne    5ee <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 5d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5d3:	8b 00                	mov    (%eax),%eax
+ 5d5:	6a 01                	push   $0x1
+ 5d7:	6a 0a                	push   $0xa
+ 5d9:	50                   	push   %eax
+ 5da:	ff 75 08             	pushl  0x8(%ebp)
+ 5dd:	e8 bb fe ff ff       	call   49d <printint>
+ 5e2:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5e5:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5e9:	e9 d8 00 00 00       	jmp    6c6 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 5ee:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 5f2:	74 06                	je     5fa <printf+0xa8>
+ 5f4:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 5f8:	75 1e                	jne    618 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 5fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5fd:	8b 00                	mov    (%eax),%eax
+ 5ff:	6a 00                	push   $0x0
+ 601:	6a 10                	push   $0x10
+ 603:	50                   	push   %eax
+ 604:	ff 75 08             	pushl  0x8(%ebp)
+ 607:	e8 91 fe ff ff       	call   49d <printint>
+ 60c:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 60f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 613:	e9 ae 00 00 00       	jmp    6c6 <printf+0x174>
+      } else if(c == 's'){
+ 618:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 61c:	75 43                	jne    661 <printf+0x10f>
+        s = (char*)*ap;
+ 61e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 621:	8b 00                	mov    (%eax),%eax
+ 623:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 626:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 62a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 62e:	75 25                	jne    655 <printf+0x103>
+          s = "(null)";
+ 630:	c7 45 f4 51 09 00 00 	movl   $0x951,-0xc(%ebp)
+        while(*s != 0){
+ 637:	eb 1c                	jmp    655 <printf+0x103>
+          putc(fd, *s);
+ 639:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 63c:	0f b6 00             	movzbl (%eax),%eax
+ 63f:	0f be c0             	movsbl %al,%eax
+ 642:	83 ec 08             	sub    $0x8,%esp
+ 645:	50                   	push   %eax
+ 646:	ff 75 08             	pushl  0x8(%ebp)
+ 649:	e8 28 fe ff ff       	call   476 <putc>
+ 64e:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 651:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 655:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 658:	0f b6 00             	movzbl (%eax),%eax
+ 65b:	84 c0                	test   %al,%al
+ 65d:	75 da                	jne    639 <printf+0xe7>
+ 65f:	eb 65                	jmp    6c6 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 661:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 665:	75 1d                	jne    684 <printf+0x132>
+        putc(fd, *ap);
+ 667:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 66a:	8b 00                	mov    (%eax),%eax
+ 66c:	0f be c0             	movsbl %al,%eax
+ 66f:	83 ec 08             	sub    $0x8,%esp
+ 672:	50                   	push   %eax
+ 673:	ff 75 08             	pushl  0x8(%ebp)
+ 676:	e8 fb fd ff ff       	call   476 <putc>
+ 67b:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 67e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 682:	eb 42                	jmp    6c6 <printf+0x174>
+      } else if(c == '%'){
+ 684:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 688:	75 17                	jne    6a1 <printf+0x14f>
+        putc(fd, c);
+ 68a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 68d:	0f be c0             	movsbl %al,%eax
+ 690:	83 ec 08             	sub    $0x8,%esp
+ 693:	50                   	push   %eax
+ 694:	ff 75 08             	pushl  0x8(%ebp)
+ 697:	e8 da fd ff ff       	call   476 <putc>
+ 69c:	83 c4 10             	add    $0x10,%esp
+ 69f:	eb 25                	jmp    6c6 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 6a1:	83 ec 08             	sub    $0x8,%esp
+ 6a4:	6a 25                	push   $0x25
+ 6a6:	ff 75 08             	pushl  0x8(%ebp)
+ 6a9:	e8 c8 fd ff ff       	call   476 <putc>
+ 6ae:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 6b1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 6b4:	0f be c0             	movsbl %al,%eax
+ 6b7:	83 ec 08             	sub    $0x8,%esp
+ 6ba:	50                   	push   %eax
+ 6bb:	ff 75 08             	pushl  0x8(%ebp)
+ 6be:	e8 b3 fd ff ff       	call   476 <putc>
+ 6c3:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 6c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 6cd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 6d1:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 6d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 6d7:	01 d0                	add    %edx,%eax
+ 6d9:	0f b6 00             	movzbl (%eax),%eax
+ 6dc:	84 c0                	test   %al,%al
+ 6de:	0f 85 94 fe ff ff    	jne    578 <printf+0x26>
+    }
+  }
+}
+ 6e4:	90                   	nop
+ 6e5:	90                   	nop
+ 6e6:	c9                   	leave  
+ 6e7:	c3                   	ret    
+
+000006e8 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 6e8:	f3 0f 1e fb          	endbr32 
+ 6ec:	55                   	push   %ebp
+ 6ed:	89 e5                	mov    %esp,%ebp
+ 6ef:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 6f2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6f5:	83 e8 08             	sub    $0x8,%eax
+ 6f8:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6fb:	a1 e8 0b 00 00       	mov    0xbe8,%eax
+ 700:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 703:	eb 24                	jmp    729 <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 705:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 708:	8b 00                	mov    (%eax),%eax
+ 70a:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 70d:	72 12                	jb     721 <free+0x39>
+ 70f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 712:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 715:	77 24                	ja     73b <free+0x53>
+ 717:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 71a:	8b 00                	mov    (%eax),%eax
+ 71c:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 71f:	72 1a                	jb     73b <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 721:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 724:	8b 00                	mov    (%eax),%eax
+ 726:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 729:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 72c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 72f:	76 d4                	jbe    705 <free+0x1d>
+ 731:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 734:	8b 00                	mov    (%eax),%eax
+ 736:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 739:	73 ca                	jae    705 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 73b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 73e:	8b 40 04             	mov    0x4(%eax),%eax
+ 741:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 748:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 74b:	01 c2                	add    %eax,%edx
+ 74d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 750:	8b 00                	mov    (%eax),%eax
+ 752:	39 c2                	cmp    %eax,%edx
+ 754:	75 24                	jne    77a <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 756:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 759:	8b 50 04             	mov    0x4(%eax),%edx
+ 75c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 75f:	8b 00                	mov    (%eax),%eax
+ 761:	8b 40 04             	mov    0x4(%eax),%eax
+ 764:	01 c2                	add    %eax,%edx
+ 766:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 769:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 76c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 76f:	8b 00                	mov    (%eax),%eax
+ 771:	8b 10                	mov    (%eax),%edx
+ 773:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 776:	89 10                	mov    %edx,(%eax)
+ 778:	eb 0a                	jmp    784 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 77a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 77d:	8b 10                	mov    (%eax),%edx
+ 77f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 782:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 784:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 787:	8b 40 04             	mov    0x4(%eax),%eax
+ 78a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 791:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 794:	01 d0                	add    %edx,%eax
+ 796:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 799:	75 20                	jne    7bb <free+0xd3>
+    p->s.size += bp->s.size;
+ 79b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 79e:	8b 50 04             	mov    0x4(%eax),%edx
+ 7a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7a4:	8b 40 04             	mov    0x4(%eax),%eax
+ 7a7:	01 c2                	add    %eax,%edx
+ 7a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7ac:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 7af:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7b2:	8b 10                	mov    (%eax),%edx
+ 7b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7b7:	89 10                	mov    %edx,(%eax)
+ 7b9:	eb 08                	jmp    7c3 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 7bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 7c1:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 7c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7c6:	a3 e8 0b 00 00       	mov    %eax,0xbe8
+}
+ 7cb:	90                   	nop
+ 7cc:	c9                   	leave  
+ 7cd:	c3                   	ret    
+
+000007ce <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 7ce:	f3 0f 1e fb          	endbr32 
+ 7d2:	55                   	push   %ebp
+ 7d3:	89 e5                	mov    %esp,%ebp
+ 7d5:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 7d8:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 7df:	77 07                	ja     7e8 <morecore+0x1a>
+    nu = 4096;
+ 7e1:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 7e8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7eb:	c1 e0 03             	shl    $0x3,%eax
+ 7ee:	83 ec 0c             	sub    $0xc,%esp
+ 7f1:	50                   	push   %eax
+ 7f2:	e8 3f fc ff ff       	call   436 <sbrk>
+ 7f7:	83 c4 10             	add    $0x10,%esp
+ 7fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 7fd:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 801:	75 07                	jne    80a <morecore+0x3c>
+    return 0;
+ 803:	b8 00 00 00 00       	mov    $0x0,%eax
+ 808:	eb 26                	jmp    830 <morecore+0x62>
+  hp = (Header*)p;
+ 80a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 810:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 813:	8b 55 08             	mov    0x8(%ebp),%edx
+ 816:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 819:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 81c:	83 c0 08             	add    $0x8,%eax
+ 81f:	83 ec 0c             	sub    $0xc,%esp
+ 822:	50                   	push   %eax
+ 823:	e8 c0 fe ff ff       	call   6e8 <free>
+ 828:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 82b:	a1 e8 0b 00 00       	mov    0xbe8,%eax
+}
+ 830:	c9                   	leave  
+ 831:	c3                   	ret    
+
+00000832 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 832:	f3 0f 1e fb          	endbr32 
+ 836:	55                   	push   %ebp
+ 837:	89 e5                	mov    %esp,%ebp
+ 839:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 83c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 83f:	83 c0 07             	add    $0x7,%eax
+ 842:	c1 e8 03             	shr    $0x3,%eax
+ 845:	83 c0 01             	add    $0x1,%eax
+ 848:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 84b:	a1 e8 0b 00 00       	mov    0xbe8,%eax
+ 850:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 853:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 857:	75 23                	jne    87c <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 859:	c7 45 f0 e0 0b 00 00 	movl   $0xbe0,-0x10(%ebp)
+ 860:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 863:	a3 e8 0b 00 00       	mov    %eax,0xbe8
+ 868:	a1 e8 0b 00 00       	mov    0xbe8,%eax
+ 86d:	a3 e0 0b 00 00       	mov    %eax,0xbe0
+    base.s.size = 0;
+ 872:	c7 05 e4 0b 00 00 00 	movl   $0x0,0xbe4
+ 879:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 87c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 87f:	8b 00                	mov    (%eax),%eax
+ 881:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 884:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 887:	8b 40 04             	mov    0x4(%eax),%eax
+ 88a:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 88d:	77 4d                	ja     8dc <malloc+0xaa>
+      if(p->s.size == nunits)
+ 88f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 892:	8b 40 04             	mov    0x4(%eax),%eax
+ 895:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 898:	75 0c                	jne    8a6 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 89a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 89d:	8b 10                	mov    (%eax),%edx
+ 89f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8a2:	89 10                	mov    %edx,(%eax)
+ 8a4:	eb 26                	jmp    8cc <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8a9:	8b 40 04             	mov    0x4(%eax),%eax
+ 8ac:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 8af:	89 c2                	mov    %eax,%edx
+ 8b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8b4:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 8b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8ba:	8b 40 04             	mov    0x4(%eax),%eax
+ 8bd:	c1 e0 03             	shl    $0x3,%eax
+ 8c0:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 8c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 8c9:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 8cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8cf:	a3 e8 0b 00 00       	mov    %eax,0xbe8
+      return (void*)(p + 1);
+ 8d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8d7:	83 c0 08             	add    $0x8,%eax
+ 8da:	eb 3b                	jmp    917 <malloc+0xe5>
+    }
+    if(p == freep)
+ 8dc:	a1 e8 0b 00 00       	mov    0xbe8,%eax
+ 8e1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 8e4:	75 1e                	jne    904 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 8e6:	83 ec 0c             	sub    $0xc,%esp
+ 8e9:	ff 75 ec             	pushl  -0x14(%ebp)
+ 8ec:	e8 dd fe ff ff       	call   7ce <morecore>
+ 8f1:	83 c4 10             	add    $0x10,%esp
+ 8f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 8f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 8fb:	75 07                	jne    904 <malloc+0xd2>
+        return 0;
+ 8fd:	b8 00 00 00 00       	mov    $0x0,%eax
+ 902:	eb 13                	jmp    917 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 904:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 907:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 90a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 90d:	8b 00                	mov    (%eax),%eax
+ 90f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 912:	e9 6d ff ff ff       	jmp    884 <malloc+0x52>
+  }
+}
+ 917:	c9                   	leave  
+ 918:	c3                   	ret    
diff -ruN xv6-public/xv6-public/cat.c xv6-public_new/xv6-public/cat.c
--- xv6-public/xv6-public/cat.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/cat.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,43 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+char buf[512];
+
+void
+cat(int fd)
+{
+  int n;
+
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+    if (write(1, buf, n) != n) {
+      printf(1, "cat: write error\n");
+      exit();
+    }
+  }
+  if(n < 0){
+    printf(1, "cat: read error\n");
+    exit();
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+  int fd, i;
+
+  if(argc <= 1){
+    cat(0);
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+      printf(1, "cat: cannot open %s\n", argv[i]);
+      exit();
+    }
+    cat(fd);
+    close(fd);
+  }
+  exit();
+}
diff -ruN xv6-public/xv6-public/cat.d xv6-public_new/xv6-public/cat.d
--- xv6-public/xv6-public/cat.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/cat.d	2021-09-30 23:15:12.000000000 +0530
@@ -0,0 +1 @@
+cat.o: cat.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/cat.o and xv6-public_new/xv6-public/cat.o differ
diff -ruN xv6-public/xv6-public/cat.sym xv6-public_new/xv6-public/cat.sym
--- xv6-public/xv6-public/cat.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/cat.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,67 @@
+00000000 .text
+00000919 .rodata
+00000958 .eh_frame
+00000bc0 .data
+00000be0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 cat.c
+00000000 ulib.c
+00000133 stosb
+00000000 printf.c
+00000476 putc
+0000049d printint
+00000bc0 digits.1098
+00000000 umalloc.c
+00000be0 base
+00000be8 freep
+000007ce morecore
+00000159 strcpy
+0000045e yield
+0000046e set_prio
+00000552 printf
+00000365 memmove
+000003f6 mknod
+00000250 gets
+0000042e getpid
+00000000 cat
+00000832 malloc
+0000043e sleep
+00000466 wait2
+000003be pipe
+000003ce write
+00000406 fstat
+000003de kill
+0000041e chdir
+000003e6 exec
+000003b6 wait
+000003c6 read
+000003fe unlink
+000003a6 fork
+00000436 sbrk
+00000446 uptime
+00000bd1 __bss_start
+000001fb memset
+0000007e main
+0000018d strcmp
+00000426 dup
+00000c00 buf
+000002c3 stat
+00000bd1 _edata
+00000e00 _end
+0000040e link
+000003ae exit
+00000314 atoi
+0000044e draw
+000001d0 strlen
+000003ee open
+00000219 strchr
+00000456 cps
+00000416 mkdir
+000003d6 close
+000006e8 free
diff -ruN xv6-public/xv6-public/console.c xv6-public_new/xv6-public/console.c
--- xv6-public/xv6-public/console.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/console.c	2021-09-11 13:45:20.000000000 +0530
@@ -0,0 +1,299 @@
+// Console input and output.
+// Input is from the keyboard or serial port.
+// Output is written to the screen and serial port.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "traps.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "file.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+
+static void consputc(int);
+
+static int panicked = 0;
+
+static struct {
+  struct spinlock lock;
+  int locking;
+} cons;
+
+static void
+printint(int xx, int base, int sign)
+{
+  static char digits[] = "0123456789abcdef";
+  char buf[16];
+  int i;
+  uint x;
+
+  if(sign && (sign = xx < 0))
+    x = -xx;
+  else
+    x = xx;
+
+  i = 0;
+  do{
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+
+  if(sign)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+    consputc(buf[i]);
+}
+//PAGEBREAK: 50
+
+// Print to the console. only understands %d, %x, %p, %s.
+void
+cprintf(char *fmt, ...)
+{
+  int i, c, locking;
+  uint *argp;
+  char *s;
+
+  locking = cons.locking;
+  if(locking)
+    acquire(&cons.lock);
+
+  if (fmt == 0)
+    panic("null fmt");
+
+  argp = (uint*)(void*)(&fmt + 1);
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+    if(c != '%'){
+      consputc(c);
+      continue;
+    }
+    c = fmt[++i] & 0xff;
+    if(c == 0)
+      break;
+    switch(c){
+    case 'd':
+      printint(*argp++, 10, 1);
+      break;
+    case 'x':
+    case 'p':
+      printint(*argp++, 16, 0);
+      break;
+    case 's':
+      if((s = (char*)*argp++) == 0)
+        s = "(null)";
+      for(; *s; s++)
+        consputc(*s);
+      break;
+    case '%':
+      consputc('%');
+      break;
+    default:
+      // Print unknown % sequence to draw attention.
+      consputc('%');
+      consputc(c);
+      break;
+    }
+  }
+
+  if(locking)
+    release(&cons.lock);
+}
+
+void
+panic(char *s)
+{
+  int i;
+  uint pcs[10];
+
+  cli();
+  cons.locking = 0;
+  // use lapiccpunum so that we can call panic from mycpu()
+  cprintf("lapicid %d: panic: ", lapicid());
+  cprintf(s);
+  cprintf("\n");
+  getcallerpcs(&s, pcs);
+  for(i=0; i<10; i++)
+    cprintf(" %p", pcs[i]);
+  panicked = 1; // freeze other CPU
+  for(;;)
+    ;
+}
+
+//PAGEBREAK: 50
+#define BACKSPACE 0x100
+#define CRTPORT 0x3d4
+static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
+
+static void
+cgaputc(int c)
+{
+  int pos;
+
+  // Cursor position: col + 80*row.
+  outb(CRTPORT, 14);
+  pos = inb(CRTPORT+1) << 8;
+  outb(CRTPORT, 15);
+  pos |= inb(CRTPORT+1);
+
+  if(c == '\n')
+    pos += 80 - pos%80;
+  else if(c == BACKSPACE){
+    if(pos > 0) --pos;
+  } else
+    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+
+  if(pos < 0 || pos > 25*80)
+    panic("pos under/overflow");
+
+  if((pos/80) >= 24){  // Scroll up.
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+    pos -= 80;
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+  }
+
+  outb(CRTPORT, 14);
+  outb(CRTPORT+1, pos>>8);
+  outb(CRTPORT, 15);
+  outb(CRTPORT+1, pos);
+  crt[pos] = ' ' | 0x0700;
+}
+
+void
+consputc(int c)
+{
+  if(panicked){
+    cli();
+    for(;;)
+      ;
+  }
+
+  if(c == BACKSPACE){
+    uartputc('\b'); uartputc(' '); uartputc('\b');
+  } else
+    uartputc(c);
+  cgaputc(c);
+}
+
+#define INPUT_BUF 128
+struct {
+  char buf[INPUT_BUF];
+  uint r;  // Read index
+  uint w;  // Write index
+  uint e;  // Edit index
+} input;
+
+#define C(x)  ((x)-'@')  // Control-x
+
+void
+consoleintr(int (*getc)(void))
+{
+  int c, doprocdump = 0;
+
+  acquire(&cons.lock);
+  while((c = getc()) >= 0){
+    switch(c){
+    case C('P'):  // Process listing.
+      // procdump() locks cons.lock indirectly; invoke later
+      doprocdump = 1;
+      break;
+    case C('U'):  // Kill line.
+      while(input.e != input.w &&
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+        input.e--;
+        consputc(BACKSPACE);
+      }
+      break;
+    case C('H'): case '\x7f':  // Backspace
+      if(input.e != input.w){
+        input.e--;
+        consputc(BACKSPACE);
+      }
+      break;
+    default:
+      if(c != 0 && input.e-input.r < INPUT_BUF){
+        c = (c == '\r') ? '\n' : c;
+        input.buf[input.e++ % INPUT_BUF] = c;
+        consputc(c);
+        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+          input.w = input.e;
+          wakeup(&input.r);
+        }
+      }
+      break;
+    }
+  }
+  release(&cons.lock);
+  if(doprocdump) {
+    procdump();  // now call procdump() wo. cons.lock held
+  }
+}
+
+int
+consoleread(struct inode *ip, char *dst, int n)
+{
+  uint target;
+  int c;
+
+  iunlock(ip);
+  target = n;
+  acquire(&cons.lock);
+  while(n > 0){
+    while(input.r == input.w){
+      if(myproc()->killed){
+        release(&cons.lock);
+        ilock(ip);
+        return -1;
+      }
+      sleep(&input.r, &cons.lock);
+    }
+    c = input.buf[input.r++ % INPUT_BUF];
+    if(c == C('D')){  // EOF
+      if(n < target){
+        // Save ^D for next time, to make sure
+        // caller gets a 0-byte result.
+        input.r--;
+      }
+      break;
+    }
+    *dst++ = c;
+    --n;
+    if(c == '\n')
+      break;
+  }
+  release(&cons.lock);
+  ilock(ip);
+
+  return target - n;
+}
+
+int
+consolewrite(struct inode *ip, char *buf, int n)
+{
+  int i;
+
+  iunlock(ip);
+  acquire(&cons.lock);
+  for(i = 0; i < n; i++)
+    consputc(buf[i] & 0xff);
+  release(&cons.lock);
+  ilock(ip);
+
+  return n;
+}
+
+void
+consoleinit(void)
+{
+  initlock(&cons.lock, "console");
+
+  devsw[CONSOLE].write = consolewrite;
+  devsw[CONSOLE].read = consoleread;
+  cons.locking = 1;
+
+  ioapicenable(IRQ_KBD, 0);
+}
+
diff -ruN xv6-public/xv6-public/console.d xv6-public_new/xv6-public/console.d
--- xv6-public/xv6-public/console.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/console.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,3 @@
+console.o: console.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ traps.h spinlock.h sleeplock.h fs.h file.h memlayout.h mmu.h proc.h \
+ x86.h
Binary files xv6-public/xv6-public/console.o and xv6-public_new/xv6-public/console.o differ
diff -ruN xv6-public/xv6-public/cuth xv6-public_new/xv6-public/cuth
--- xv6-public/xv6-public/cuth	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/cuth	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,48 @@
+#!/usr/bin/perl
+
+$| = 1;
+
+sub writefile($@){
+	my ($file, @lines) = @_;
+	
+	sleep(1);
+	open(F, ">$file") || die "open >$file: $!";
+	print F @lines;
+	close(F);
+}
+
+# Cut out #include lines that don't contribute anything.
+for($i=0; $i<@ARGV; $i++){
+	$file = $ARGV[$i];
+	if(!open(F, $file)){
+		print STDERR "open $file: $!\n";
+		next;
+	}
+	@lines = <F>;
+	close(F);
+	
+	$obj = "$file.o";
+	$obj =~ s/\.c\.o$/.o/;
+	system("touch $file");
+
+	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+		print STDERR "make $obj failed: $rv\n";
+		next;
+	}
+
+	system("cp $file =$file");
+	for($j=@lines-1; $j>=0; $j--){
+		if($lines[$j] =~ /^#include/){
+			$old = $lines[$j];
+			$lines[$j] = "/* CUT-H */\n";
+			writefile($file, @lines);
+			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+				$lines[$j] = $old;
+			}else{
+				print STDERR "$file $old";
+			}
+		}
+	}
+	writefile($file, grep {!/CUT-H/} @lines);
+	system("rm =$file");
+}
diff -ruN xv6-public/xv6-public/date.h xv6-public_new/xv6-public/date.h
--- xv6-public/xv6-public/date.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/date.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,8 @@
+struct rtcdate {
+  uint second;
+  uint minute;
+  uint hour;
+  uint day;
+  uint month;
+  uint year;
+};
diff -ruN xv6-public/xv6-public/defs.h xv6-public_new/xv6-public/defs.h
--- xv6-public/xv6-public/defs.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/defs.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,190 @@
+struct buf;
+struct context;
+struct file;
+struct inode;
+struct pipe;
+struct proc;
+struct rtcdate;
+struct spinlock;
+struct sleeplock;
+struct stat;
+struct superblock;
+
+// bio.c
+void            binit(void);
+struct buf*     bread(uint, uint);
+void            brelse(struct buf*);
+void            bwrite(struct buf*);
+
+// console.c
+void            consoleinit(void);
+void            cprintf(char*, ...);
+void            consoleintr(int(*)(void));
+void            panic(char*) __attribute__((noreturn));
+
+// exec.c
+int             exec(char*, char**);
+
+// file.c
+struct file*    filealloc(void);
+void            fileclose(struct file*);
+struct file*    filedup(struct file*);
+void            fileinit(void);
+int             fileread(struct file*, char*, int n);
+int             filestat(struct file*, struct stat*);
+int             filewrite(struct file*, char*, int n);
+
+// fs.c
+void            readsb(int dev, struct superblock *sb);
+int             dirlink(struct inode*, char*, uint);
+struct inode*   dirlookup(struct inode*, char*, uint*);
+struct inode*   ialloc(uint, short);
+struct inode*   idup(struct inode*);
+void            iinit(int dev);
+void            ilock(struct inode*);
+void            iput(struct inode*);
+void            iunlock(struct inode*);
+void            iunlockput(struct inode*);
+void            iupdate(struct inode*);
+int             namecmp(const char*, const char*);
+struct inode*   namei(char*);
+struct inode*   nameiparent(char*, char*);
+int             readi(struct inode*, char*, uint, uint);
+void            stati(struct inode*, struct stat*);
+int             writei(struct inode*, char*, uint, uint);
+
+// ide.c
+void            ideinit(void);
+void            ideintr(void);
+void            iderw(struct buf*);
+
+// ioapic.c
+void            ioapicenable(int irq, int cpu);
+extern uchar    ioapicid;
+void            ioapicinit(void);
+
+// kalloc.c
+char*           kalloc(void);
+void            kfree(char*);
+void            kinit1(void*, void*);
+void            kinit2(void*, void*);
+
+// kbd.c
+void            kbdintr(void);
+
+// lapic.c
+void            cmostime(struct rtcdate *r);
+int             lapicid(void);
+extern volatile uint*    lapic;
+void            lapiceoi(void);
+void            lapicinit(void);
+void            lapicstartap(uchar, uint);
+void            microdelay(int);
+
+// log.c
+void            initlog(int dev);
+void            log_write(struct buf*);
+void            begin_op();
+void            end_op();
+
+// mp.c
+extern int      ismp;
+void            mpinit(void);
+
+// picirq.c
+void            picenable(int);
+void            picinit(void);
+
+// pipe.c
+int             pipealloc(struct file**, struct file**);
+void            pipeclose(struct pipe*, int);
+int             piperead(struct pipe*, char*, int);
+int             pipewrite(struct pipe*, char*, int);
+
+//PAGEBREAK: 16
+// proc.c
+int             cpuid(void);
+void            exit(void);
+int             fork(void);
+int             growproc(int);
+int             kill(int);
+struct cpu*     mycpu(void);
+struct proc*    myproc();
+void            pinit(void);
+void            procdump(void);
+void            scheduler(void) __attribute__((noreturn));
+void            sched(void);
+void            setproc(struct proc*);
+void            sleep(void*, struct spinlock*);
+void            userinit(void);
+int             wait(void);
+void            wakeup(void*);
+void            yield(void);
+
+// swtch.S
+void            swtch(struct context**, struct context*);
+
+// spinlock.c
+void            acquire(struct spinlock*);
+void            getcallerpcs(void*, uint*);
+int             holding(struct spinlock*);
+void            initlock(struct spinlock*, char*);
+void            release(struct spinlock*);
+void            pushcli(void);
+void            popcli(void);
+
+// sleeplock.c
+void            acquiresleep(struct sleeplock*);
+void            releasesleep(struct sleeplock*);
+int             holdingsleep(struct sleeplock*);
+void            initsleeplock(struct sleeplock*, char*);
+
+// string.c
+int             memcmp(const void*, const void*, uint);
+void*           memmove(void*, const void*, uint);
+void*           memset(void*, int, uint);
+char*           safestrcpy(char*, const char*, int);
+int             strlen(const char*);
+int             strncmp(const char*, const char*, uint);
+char*           strncpy(char*, const char*, int);
+
+// syscall.c
+int             argint(int, int*);
+int             argptr(int, char**, int);
+int             argstr(int, char**);
+int             fetchint(uint, int*);
+int             fetchstr(uint, char**);
+void            syscall(void);
+
+// timer.c
+void            timerinit(void);
+
+// trap.c
+void            idtinit(void);
+extern uint     ticks;
+void            tvinit(void);
+extern struct spinlock tickslock;
+
+// uart.c
+void            uartinit(void);
+void            uartintr(void);
+void            uartputc(int);
+
+// vm.c
+void            seginit(void);
+void            kvmalloc(void);
+pde_t*          setupkvm(void);
+char*           uva2ka(pde_t*, char*);
+int             allocuvm(pde_t*, uint, uint);
+int             deallocuvm(pde_t*, uint, uint);
+void            freevm(pde_t*);
+void            inituvm(pde_t*, char*, uint);
+int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
+pde_t*          copyuvm(pde_t*, uint);
+void            switchuvm(struct proc*);
+void            switchkvm(void);
+int             copyout(pde_t*, uint, void*, uint);
+void            clearpteu(pde_t *pgdir, char *uva);
+
+// number of elements in fixed-size array
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff -ruN xv6-public/xv6-public/dot-bochsrc xv6-public_new/xv6-public/dot-bochsrc
--- xv6-public/xv6-public/dot-bochsrc	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/dot-bochsrc	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,738 @@
+# You may now use double quotes around pathnames, in case
+# your pathname includes spaces.
+
+#=======================================================================
+# CONFIG_INTERFACE
+#
+# The configuration interface is a series of menus or dialog boxes that
+# allows you to change all the settings that control Bochs's behavior.
+# There are two choices of configuration interface: a text mode version
+# called "textconfig" and a graphical version called "wx".  The text
+# mode version uses stdin/stdout and is always compiled in.  The graphical
+# version is only available when you use "--with-wx" on the configure 
+# command.  If you do not write a config_interface line, Bochs will 
+# choose a default for you.
+#
+# NOTE: if you use the "wx" configuration interface, you must also use
+# the "wx" display library.
+#=======================================================================
+#config_interface: textconfig
+#config_interface: wx
+
+#=======================================================================
+# DISPLAY_LIBRARY
+#
+# The display library is the code that displays the Bochs VGA screen.  Bochs 
+# has a selection of about 10 different display library implementations for 
+# different platforms.  If you run configure with multiple --with-* options, 
+# the display_library command lets you choose which one you want to run with.
+# If you do not write a display_library line, Bochs will choose a default for
+# you.
+#
+# The choices are: 
+#   x              use X windows interface, cross platform
+#   win32          use native win32 libraries
+#   carbon         use Carbon library (for MacOS X)
+#   beos           use native BeOS libraries
+#   macintosh      use MacOS pre-10
+#   amigaos        use native AmigaOS libraries
+#   sdl            use SDL library, cross platform
+#   svga           use SVGALIB library for Linux, allows graphics without X11
+#   term           text only, uses curses/ncurses library, cross platform
+#   rfb            provides an interface to AT&T's VNC viewer, cross platform
+#   wx             use wxWidgets library, cross platform
+#   nogui          no display at all
+#
+# NOTE: if you use the "wx" configuration interface, you must also use
+# the "wx" display library.
+#
+# Specific options:
+# Some display libraries now support specific option to control their
+# behaviour. See the examples below for currently supported options.
+#=======================================================================
+#display_library: amigaos
+#display_library: beos
+#display_library: carbon
+#display_library: macintosh
+#display_library: nogui
+#display_library: rfb, options="timeout=60" # time to wait for client
+#display_library: sdl, options="fullscreen" # startup in fullscreen mode
+#display_library: term
+#display_library: win32, options="legacyF12" # use F12 to toggle mouse
+#display_library: wx
+#display_library: x
+
+#=======================================================================
+# ROMIMAGE:
+# The ROM BIOS controls what the PC does when it first powers on.
+# Normally, you can use a precompiled BIOS in the source or binary
+# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
+# starting at address 0xf0000, and it is exactly 64k long.
+# You can also use the environment variable $BXSHARE to specify the
+# location of the BIOS.
+# The usage of external large BIOS images (up to 512k) at memory top is
+# now supported, but we still recommend to use the BIOS distributed with
+# Bochs. Now the start address can be calculated from image size.
+#=======================================================================
+romimage: file=$BXSHARE/BIOS-bochs-latest
+#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top
+#romimage: file=mybios.bin # calculate start address from image size
+
+#=======================================================================
+# CPU:
+# This defines cpu-related parameters inside Bochs:
+#
+#  COUNT:
+#  Set the number of processors when Bochs is compiled for SMP emulation.
+#  Bochs currently supports up to 8 processors. If Bochs is compiled
+#  without SMP support, it won't accept values different from 1.
+#
+#  IPS:
+#  Emulated Instructions Per Second.  This is the number of IPS that bochs
+#  is capable of running on your machine. You can recompile Bochs with
+#  --enable-show-ips option enabled, to find your workstation's capability.
+#  Measured IPS value will then be logged into your log file or status bar
+#  (if supported by the gui).
+#
+#  IPS is used to calibrate many time-dependent events within the bochs 
+#  simulation.  For example, changing IPS affects the frequency of VGA
+#  updates, the duration of time before a key starts to autorepeat, and
+#  the measurement of BogoMips and other benchmarks.
+#
+#  Examples:
+#  Machine                                         Mips
+# ________________________________________________________________
+#  2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
+#  1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
+#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
+#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
+#=======================================================================
+cpu: count=2, ips=10000000
+
+#=======================================================================
+# MEGS
+# Set the number of Megabytes of physical memory you want to emulate. 
+# The default is 32MB, most OS's won't need more than that.
+# The maximum amount of memory supported is 2048Mb.
+#=======================================================================
+#megs: 256
+#megs: 128
+#megs: 64
+megs: 32
+#megs: 16
+#megs: 8
+
+#=======================================================================
+# OPTROMIMAGE[1-4]:
+# You may now load up to 4 optional ROM images. Be sure to use a 
+# read-only area, typically between C8000 and EFFFF. These optional
+# ROM images should not overwrite the rombios (located at
+# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
+# Those ROM images will be initialized by the bios if they contain 
+# the right signature (0x55AA) and a valid checksum.
+# It can also be a convenient way to upload some arbitrary code/data
+# in the simulation, that can be retrieved by the boot loader
+#=======================================================================
+#optromimage1: file=optionalrom.bin, address=0xd0000
+#optromimage2: file=optionalrom.bin, address=0xd1000
+#optromimage3: file=optionalrom.bin, address=0xd2000
+#optromimage4: file=optionalrom.bin, address=0xd3000
+
+#optramimage1: file=/path/file1.img, address=0x0010000
+#optramimage2: file=/path/file2.img, address=0x0020000
+#optramimage3: file=/path/file3.img, address=0x0030000
+#optramimage4: file=/path/file4.img, address=0x0040000
+
+#=======================================================================
+# VGAROMIMAGE
+# You now need to load a VGA ROM BIOS into C0000.
+#=======================================================================
+#vgaromimage: file=bios/VGABIOS-elpin-2.40
+vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
+#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
+
+#=======================================================================
+# VGA:
+# Here you can specify the display extension to be used. With the value
+# 'none' you can use standard VGA with no extension. Other supported
+# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
+#=======================================================================
+#vga: extension=cirrus
+#vga: extension=vbe
+vga: extension=none
+
+#=======================================================================
+# FLOPPYA:
+# Point this to pathname of floppy image file or device
+# This should be of a bootable floppy(image/device) if you're
+# booting from 'a' (or 'floppy').
+#
+# You can set the initial status of the media to 'ejected' or 'inserted'.
+#   floppya: 2_88=path, status=ejected             (2.88M 3.5" floppy)
+#   floppya: 1_44=path, status=inserted            (1.44M 3.5" floppy)
+#   floppya: 1_2=path, status=ejected              (1.2M  5.25" floppy)
+#   floppya: 720k=path, status=inserted            (720K  3.5" floppy)
+#   floppya: 360k=path, status=inserted            (360K  5.25" floppy)
+#   floppya: 320k=path, status=inserted            (320K  5.25" floppy)
+#   floppya: 180k=path, status=inserted            (180K  5.25" floppy)
+#   floppya: 160k=path, status=inserted            (160K  5.25" floppy)
+#   floppya: image=path, status=inserted           (guess type from image size)
+#
+# The path should be the name of a disk image file.  On Unix, you can use a raw
+# device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters
+# such as a: or b: as the path.  The parameter 'image' works with image files
+# only. In that case the size must match one of the supported types.
+#=======================================================================
+floppya: 1_44=/dev/fd0, status=inserted
+#floppya: image=../1.44, status=inserted
+#floppya: 1_44=/dev/fd0H1440, status=inserted
+#floppya: 1_2=../1_2, status=inserted
+#floppya: 1_44=a:, status=inserted
+#floppya: 1_44=a.img, status=inserted
+#floppya: 1_44=/dev/rfd0a, status=inserted
+
+#=======================================================================
+# FLOPPYB:
+# See FLOPPYA above for syntax
+#=======================================================================
+#floppyb: 1_44=b:, status=inserted
+floppyb: 1_44=b.img, status=inserted
+
+#=======================================================================
+# ATA0, ATA1, ATA2, ATA3
+# ATA controller for hard disks and cdroms
+#
+# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
+# 
+# These options enables up to 4 ata channels. For each channel
+# the two base io addresses and the irq must be specified.
+# 
+# ata0 and ata1 are enabled by default with the values shown below
+#
+# Examples:
+#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
+#=======================================================================
+ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
+
+#=======================================================================
+# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
+#
+# This defines the type and characteristics of all attached ata devices:
+#   type=       type of attached device [disk|cdrom] 
+#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
+#   mode=       only valid for disks [undoable|growing|volatile]
+#   path=       path of the image
+#   cylinders=  only valid for disks
+#   heads=      only valid for disks
+#   spt=        only valid for disks
+#   status=     only valid for cdroms [inserted|ejected]
+#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
+#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
+#   model=      string returned by identify device command
+#   journal=    optional filename of the redolog for undoable and volatile disks
+#   
+# Point this at a hard disk image file, cdrom iso file, or physical cdrom
+# device.  To create a hard disk image, try running bximage.  It will help you
+# choose the size and then suggest a line that works with it.
+#
+# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
+# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
+#
+# In windows, the drive letter + colon notation should be used for cdroms.
+# Depending on versions of windows and drivers, you may only be able to 
+# access the "first" cdrom in the system.  On MacOSX, use path="drive"
+# to access the physical drive.
+#
+# The path is always mandatory. For flat hard disk images created with
+# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
+# calculated using heads=16 and spt=63). For other hard disk images and modes
+# the cylinders, heads, and spt are mandatory.
+#
+# Default values are:
+#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
+#
+# The biosdetect option has currently no effect on the bios
+#
+# Examples:
+#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
+#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
+#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
+#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
+#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
+#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
+#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
+#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
+#=======================================================================
+ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
+ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
+#ata0-slave: type=cdrom, path=D:, status=inserted
+#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
+#ata0-slave: type=cdrom, path="drive", status=inserted
+#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
+
+#=======================================================================
+# BOOT:
+# This defines the boot sequence. Now you can specify up to 3 boot drives.
+# You can either boot from 'floppy', 'disk' or 'cdrom'
+# legacy 'a' and 'c' are also supported
+# Examples:
+#   boot: floppy
+#   boot: disk
+#   boot: cdrom
+#   boot: c
+#   boot: a
+#   boot: cdrom, floppy, disk
+#=======================================================================
+#boot: floppy
+boot: disk
+
+#=======================================================================
+# CLOCK:
+# This defines the parameters of the clock inside Bochs:
+#
+#  SYNC:
+#  TO BE COMPLETED (see Greg explanation in feature request #536329)
+#
+#  TIME0:
+#  Specifies the start (boot) time of the virtual machine. Use a time 
+#  value as returned by the time(2) system call. If no time0 value is 
+#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
+#  the simulation will be started at the current local host time.
+#  If time0 equal to 2 (special case) or if time0 equal 'utc',
+#  the simulation will be started at the current utc time.
+#
+# Syntax:
+#  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]
+#
+# Example:
+#   clock: sync=none,     time0=local       # Now (localtime)
+#   clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980
+#   clock: sync=none,     time0=631148400   # Mon Jan  1 00:00:00 1990
+#   clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999
+#   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
+#   clock: sync=none,     time0=1           # Now (localtime)
+#   clock: sync=none,     time0=utc         # Now (utc/gmt)
+# 
+# Default value are sync=none, time0=local
+#=======================================================================
+#clock: sync=none, time0=local
+
+
+#=======================================================================
+# FLOPPY_BOOTSIG_CHECK: disabled=[0|1]
+# Enables or disables the 0xaa55 signature check on boot floppies
+# Defaults to disabled=0
+# Examples:
+#   floppy_bootsig_check: disabled=0
+#   floppy_bootsig_check: disabled=1
+#=======================================================================
+#floppy_bootsig_check: disabled=1
+floppy_bootsig_check: disabled=0
+
+#=======================================================================
+# LOG:
+# Give the path of the log file you'd like Bochs debug and misc. verbiage
+# to be written to. If you don't use this option or set the filename to
+# '-' the output is written to the console. If you really don't want it,
+# make it "/dev/null" (Unix) or "nul" (win32). :^(
+#
+# Examples:
+#   log: ./bochs.out
+#   log: /dev/tty
+#=======================================================================
+#log: /dev/null
+log: bochsout.txt
+
+#=======================================================================
+# LOGPREFIX:
+# This handles the format of the string prepended to each log line.
+# You may use those special tokens :
+#   %t : 11 decimal digits timer tick
+#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
+#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
+#   %d : 5 characters string of the device, between brackets
+# 
+# Default : %t%e%d
+# Examples:
+#   logprefix: %t-%e-@%i-%d
+#   logprefix: %i%e%d
+#=======================================================================
+#logprefix: %t%e%d
+
+#=======================================================================
+# LOG CONTROLS
+#
+# Bochs now has four severity levels for event logging.
+#   panic: cannot proceed.  If you choose to continue after a panic, 
+#          don't be surprised if you get strange behavior or crashes.
+#   error: something went wrong, but it is probably safe to continue the
+#          simulation.
+#   info: interesting or useful messages.
+#   debug: messages useful only when debugging the code.  This may
+#          spit out thousands per second.
+#
+# For events of each level, you can choose to crash, report, or ignore.
+# TODO: allow choice based on the facility: e.g. crash on panics from
+#       everything except the cdrom, and only report those.
+#
+# If you are experiencing many panics, it can be helpful to change
+# the panic action to report instead of fatal.  However, be aware
+# that anything executed after a panic is uncharted territory and can 
+# cause bochs to become unstable.  The panic is a "graceful exit," so
+# if you disable it you may get a spectacular disaster instead.
+#=======================================================================
+panic: action=ask
+error: action=report
+info: action=report
+debug: action=ignore
+#pass: action=fatal
+
+#=======================================================================
+# DEBUGGER_LOG:
+# Give the path of the log file you'd like Bochs to log debugger output.
+# If you really don't want it, make it /dev/null or '-'. :^(
+#
+# Examples:
+#   debugger_log: ./debugger.out
+#=======================================================================
+#debugger_log: /dev/null
+#debugger_log: debugger.out
+debugger_log: -
+
+#=======================================================================
+# COM1, COM2, COM3, COM4:
+# This defines a serial port (UART type 16550A). In the 'term' you can specify
+# a device to use as com1. This can be a real serial line, or a pty.  To use
+# a pty (under X/Unix), create two windows (xterms, usually).  One of them will
+# run bochs, and the other will act as com1. Find out the tty the com1
+# window using the `tty' command, and use that as the `dev' parameter.
+# Then do `sleep 1000000' in the com1 window to keep the shell from
+# messing with things, and run bochs in the other window.  Serial I/O to
+# com1 (port 0x3f8) will all go to the other window.
+# Other serial modes are 'null' (no input/output), 'file' (output to a file
+# specified as the 'dev' parameter), 'raw' (use the real serial port - under
+# construction for win32), 'mouse' (standard serial mouse - requires
+# mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'
+# (connect a networking socket).
+#
+# Examples:
+#   com1: enabled=1, mode=null
+#   com1: enabled=1, mode=mouse
+#   com2: enabled=1, mode=file, dev=serial.out
+#   com3: enabled=1, mode=raw, dev=com1
+#   com3: enabled=1, mode=socket, dev=localhost:8888
+#=======================================================================
+#com1: enabled=1, mode=term, dev=/dev/ttyp9
+
+
+#=======================================================================
+# PARPORT1, PARPORT2:
+# This defines a parallel (printer) port. When turned on and an output file is
+# defined the emulated printer port sends characters printed by the guest OS
+# into the output file. On some platforms a device filename can be used to
+# send the data to the real parallel port (e.g. "/dev/lp0" on Linux, "lpt1" on
+# win32 platforms).
+#
+# Examples:
+#   parport1: enabled=1, file="parport.out"
+#   parport2: enabled=1, file="/dev/lp0"
+#   parport1: enabled=0
+#=======================================================================
+parport1: enabled=1, file="/dev/stdout"
+
+#=======================================================================
+# SB16:
+# This defines the SB16 sound emulation. It can have several of the
+# following properties.
+# All properties are in the format sb16: property=value
+# midi: The filename is where the midi data is sent. This can be a
+#       device or just a file if you want to record the midi data.
+# midimode:
+#      0=no data
+#      1=output to device (system dependent. midi denotes the device driver)
+#      2=SMF file output, including headers
+#      3=output the midi data stream to the file (no midi headers and no
+#        delta times, just command and data bytes)
+# wave: This is the device/file where wave output is stored
+# wavemode:
+#      0=no data
+#      1=output to device (system dependent. wave denotes the device driver)
+#      2=VOC file output, incl. headers
+#      3=output the raw wave stream to the file
+# log:  The file to write the sb16 emulator messages to.
+# loglevel:
+#      0=no log
+#      1=resource changes, midi program and bank changes
+#      2=severe errors
+#      3=all errors
+#      4=all errors plus all port accesses
+#      5=all errors and port accesses plus a lot of extra info
+# dmatimer:
+#      microseconds per second for a DMA cycle.  Make it smaller to fix
+#      non-continuous sound.  750000 is usually a good value.  This needs a
+#      reasonably correct setting for the IPS parameter of the CPU option.
+#
+# For an example look at the next line:
+#=======================================================================
+
+#sb16: midimode=1, midi=/dev/midi00, wavemode=1, wave=/dev/dsp, loglevel=2, log=sb16.log, dmatimer=600000
+
+#=======================================================================
+# VGA_UPDATE_INTERVAL:
+# Video memory is scanned for updates and screen updated every so many
+# virtual seconds.  The default is 40000, about 25Hz. Keep in mind that
+# you must tweak the 'cpu: ips=N' directive to be as close to the number
+# of emulated instructions-per-second your workstation can do, for this
+# to be accurate.
+#
+# Examples:
+#   vga_update_interval: 250000
+#=======================================================================
+vga_update_interval: 300000
+
+# using for Winstone '98 tests
+#vga_update_interval:  100000
+
+#=======================================================================
+# KEYBOARD_SERIAL_DELAY:
+# Approximate time in microseconds that it takes one character to
+# be transfered from the keyboard to controller over the serial path.
+# Examples:
+#   keyboard_serial_delay: 200
+#=======================================================================
+keyboard_serial_delay: 250
+
+#=======================================================================
+# KEYBOARD_PASTE_DELAY:
+# Approximate time in microseconds between attempts to paste
+# characters to the keyboard controller. This leaves time for the
+# guest os to deal with the flow of characters.  The ideal setting
+# depends on how your operating system processes characters.  The
+# default of 100000 usec (.1 seconds) was chosen because it works 
+# consistently in Windows.
+#
+# If your OS is losing characters during a paste, increase the paste
+# delay until it stops losing characters.
+#
+# Examples:
+#   keyboard_paste_delay: 100000
+#=======================================================================
+keyboard_paste_delay: 100000
+
+#=======================================================================
+# MOUSE: 
+# This option prevents Bochs from creating mouse "events" unless a mouse
+# is  enabled. The hardware emulation itself is not disabled by this.
+# You can turn the mouse on by setting enabled to 1, or turn it off by
+# setting enabled to 0. Unless you have a particular reason for enabling
+# the mouse by default, it is recommended that you leave it off.
+# You can also toggle the mouse usage at runtime (control key + middle
+# mouse button on X11, SDL, wxWidgets and Win32).
+# With the mouse type option you can select the type of mouse to emulate.
+# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
+# on PS/2), 'serial', 'serial_wheel' (one com port requires setting
+# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
+# connected with the 'mouse' device - requires PCI and USB support).
+#
+# Examples:
+#   mouse: enabled=1
+#   mouse: enabled=1, type=imps2
+#   mouse: enabled=1, type=serial
+#   mouse: enabled=0
+#=======================================================================
+mouse: enabled=0
+
+#=======================================================================
+# private_colormap: Request that the GUI create and use it's own
+#                   non-shared colormap.  This colormap will be used
+#                   when in the bochs window.  If not enabled, a
+#                   shared colormap scheme may be used.  Not implemented
+#                   on all GUI's.
+#
+# Examples:
+#   private_colormap: enabled=1
+#   private_colormap: enabled=0
+#=======================================================================
+private_colormap: enabled=0
+
+#=======================================================================
+# fullscreen: ONLY IMPLEMENTED ON AMIGA
+#             Request that Bochs occupy the entire screen instead of a 
+#             window.
+#
+# Examples:
+#   fullscreen: enabled=0
+#   fullscreen: enabled=1
+#=======================================================================
+#fullscreen: enabled=0
+#screenmode: name="sample"
+
+#=======================================================================
+# ne2k: NE2000 compatible ethernet adapter
+#
+# Examples:
+# ne2k: ioaddr=IOADDR, irq=IRQ, mac=MACADDR, ethmod=MODULE, ethdev=DEVICE, script=SCRIPT
+#
+# ioaddr, irq: You probably won't need to change ioaddr and irq, unless there
+# are IRQ conflicts.
+#
+# mac: The MAC address MUST NOT match the address of any machine on the net.
+# Also, the first byte must be an even number (bit 0 set means a multicast
+# address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast
+# address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may
+# be other restrictions too.  To be safe, just use the b0:c4... address.
+#
+# ethdev: The ethdev value is the name of the network interface on your host
+# platform.  On UNIX machines, you can get the name by running ifconfig.  On
+# Windows machines, you must run niclist to get the name of the ethdev.
+# Niclist source code is in misc/niclist.c and it is included in Windows 
+# binary releases.
+#
+# script: The script value is optional, and is the name of a script that 
+# is executed after bochs initialize the network interface. You can use 
+# this script to configure this network interface, or enable masquerading.
+# This is mainly useful for the tun/tap devices that only exist during
+# Bochs execution. The network interface name is supplied to the script
+# as first parameter
+#
+# If you don't want to make connections to any physical networks,
+# you can use the following 'ethmod's to simulate a virtual network.
+#   null: All packets are discarded, but logged to a few files.
+#   arpback: ARP is simulated. Disabled by default.
+#   vde:  Virtual Distributed Ethernet
+#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
+#         The virtual host uses 192.168.10.1.
+#         DHCP assigns 192.168.10.2 to the guest.
+#         TFTP uses the ethdev value for the root directory and doesn't
+#         overwrite files.
+#
+#=======================================================================
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=fbsd, ethdev=en0 #macosx
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=fbsd, ethdev=xl0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=linux, ethdev=eth0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=win32, ethdev=MYCARD
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tap, ethdev=tap0
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tuntap, ethdev=/dev/net/tun0, script=./tunconfig
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=null, ethdev=eth0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vde, ethdev="/tmp/vde.ctl"
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vnet, ethdev="c:/temp"
+
+#=======================================================================
+# KEYBOARD_MAPPING:
+# This enables a remap of a physical localized keyboard to a 
+# virtualized us keyboard, as the PC architecture expects.
+# If enabled, the keymap file must be specified.
+# 
+# Examples:
+#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
+#=======================================================================
+keyboard_mapping: enabled=0, map=
+
+#=======================================================================
+# KEYBOARD_TYPE:
+# Type of keyboard return by a "identify keyboard" command to the
+# keyboard controler. It must be one of "xt", "at" or "mf".
+# Defaults to "mf". It should be ok for almost everybody. A known
+# exception is french macs, that do have a "at"-like keyboard.
+#
+# Examples:
+#   keyboard_type: mf
+#=======================================================================
+#keyboard_type: mf
+
+#=======================================================================
+# USER_SHORTCUT:
+# This defines the keyboard shortcut to be sent when you press the "user"
+# button in the headerbar. The shortcut string is a combination of maximum
+# 3 key names (listed below) separated with a '-' character. The old-style
+# syntax (without the '-') still works for the key combinations supported
+# in Bochs 2.2.1.
+# Valid key names:
+# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
+# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
+# "plus", "right", "shift", "space", "tab", "up", and "win".
+#
+# Example:
+#   user_shortcut: keys=ctrl-alt-del
+#=======================================================================
+#user_shortcut: keys=ctrl-alt-del
+
+#=======================================================================
+# I440FXSUPPORT:
+# This option controls the presence of the i440FX PCI chipset. You can
+# also specify the devices connected to PCI slots. Up to 5 slots are
+# available now. These devices are currently supported: ne2k, pcivga,
+# pcidev and pcipnic. If Bochs is compiled with Cirrus SVGA support
+# you'll have the additional choice 'cirrus'.
+#
+# Example:
+#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
+#=======================================================================
+#i440fxsupport: enabled=1
+
+#=======================================================================
+# USB1:
+# This option controls the presence of the USB root hub which is a part
+# of the i440FX PCI chipset. With the portX option you can connect devices
+# to the hub (currently supported: 'mouse' and 'keypad'). If you connect
+# the mouse to one of the ports and use the mouse option 'type=usb' you'll
+# have a 3-button USB mouse.
+#
+# Example:
+#   usb1: enabled=1, port1=mouse, port2=keypad
+#=======================================================================
+#usb1: enabled=1
+
+#=======================================================================
+# CMOSIMAGE:
+# This defines image file that can be loaded into the CMOS RAM at startup.
+# The rtc_init parameter controls whether initialize the RTC with values stored
+# in the image. By default the time0 argument given to the clock option is used.
+# With 'rtc_init=image' the image is the source for the initial time.
+#
+# Example:
+#   cmosimage: file=cmos.img, rtc_init=image
+#=======================================================================
+#cmosimage: file=cmos.img, rtc_init=time0
+
+#=======================================================================
+# other stuff
+#=======================================================================
+#magic_break: enabled=1
+#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
+#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
+#text_snapshot_check: enable
+
+#-------------------------
+# PCI host device mapping
+#-------------------------
+#pcidev: vendor=0x1234, device=0x5678
+
+#=======================================================================
+# GDBSTUB:
+# Enable GDB stub. See user documentation for details.
+# Default value is enabled=0.
+#=======================================================================
+#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0
+
+#=======================================================================
+# IPS:
+# The IPS directive is DEPRECATED. Use the parameter IPS of the CPU
+# directive instead.
+#=======================================================================
+#ips: 10000000
+
+#=======================================================================
+# for Macintosh, use the style of pathnames in the following
+# examples.
+#
+# vgaromimage: :bios:VGABIOS-elpin-2.40
+# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
+# floppya: 1_44=[fd:], status=inserted
+#=======================================================================
diff -ruN xv6-public/xv6-public/drawtest.asm xv6-public_new/xv6-public/drawtest.asm
--- xv6-public/xv6-public/drawtest.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/drawtest.asm	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,1179 @@
+
+_drawtest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+
+//maximum size of the buffer
+const int max_size = 1578;
+
+int main(void)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	51                   	push   %ecx
+  12:	83 ec 14             	sub    $0x14,%esp
+
+    // Created a buffer with maximum size as max_size 
+    void *wolf_buffer = malloc(max_size);
+  15:	b8 2a 06 00 00       	mov    $0x62a,%eax
+  1a:	83 ec 0c             	sub    $0xc,%esp
+  1d:	50                   	push   %eax
+  1e:	e8 50 07 00 00       	call   773 <malloc>
+  23:	83 c4 10             	add    $0x10,%esp
+  26:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+    // Called the system call and stored the size of image.
+    int wolf_size = draw(wolf_buffer, max_size);
+  29:	b8 2a 06 00 00       	mov    $0x62a,%eax
+  2e:	83 ec 08             	sub    $0x8,%esp
+  31:	50                   	push   %eax
+  32:	ff 75 f4             	pushl  -0xc(%ebp)
+  35:	e8 55 03 00 00       	call   38f <draw>
+  3a:	83 c4 10             	add    $0x10,%esp
+  3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+    // If the size of image is in buffer is greater than max_size then print a error message
+    if (wolf_size == -1)
+  40:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
+  44:	75 14                	jne    5a <main+0x5a>
+    {
+        // file descriptor 1 used to print on the standard output i.e (stdout)
+        printf(1, "Buffer size is too small\n");
+  46:	83 ec 08             	sub    $0x8,%esp
+  49:	68 60 08 00 00       	push   $0x860
+  4e:	6a 01                	push   $0x1
+  50:	e8 3e 04 00 00       	call   493 <printf>
+  55:	83 c4 10             	add    $0x10,%esp
+  58:	eb 15                	jmp    6f <main+0x6f>
+    }
+    else
+    {
+         // file descriptor 1 used to print on the standard output i.e (stdout)
+        printf(1, "%s\n", (char *)wolf_buffer);
+  5a:	83 ec 04             	sub    $0x4,%esp
+  5d:	ff 75 f4             	pushl  -0xc(%ebp)
+  60:	68 7a 08 00 00       	push   $0x87a
+  65:	6a 01                	push   $0x1
+  67:	e8 27 04 00 00       	call   493 <printf>
+  6c:	83 c4 10             	add    $0x10,%esp
+    }
+
+    exit();
+  6f:	e8 7b 02 00 00       	call   2ef <exit>
+
+00000074 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  74:	55                   	push   %ebp
+  75:	89 e5                	mov    %esp,%ebp
+  77:	57                   	push   %edi
+  78:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  79:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  7c:	8b 55 10             	mov    0x10(%ebp),%edx
+  7f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  82:	89 cb                	mov    %ecx,%ebx
+  84:	89 df                	mov    %ebx,%edi
+  86:	89 d1                	mov    %edx,%ecx
+  88:	fc                   	cld    
+  89:	f3 aa                	rep stos %al,%es:(%edi)
+  8b:	89 ca                	mov    %ecx,%edx
+  8d:	89 fb                	mov    %edi,%ebx
+  8f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  92:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  95:	90                   	nop
+  96:	5b                   	pop    %ebx
+  97:	5f                   	pop    %edi
+  98:	5d                   	pop    %ebp
+  99:	c3                   	ret    
+
+0000009a <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  9a:	f3 0f 1e fb          	endbr32 
+  9e:	55                   	push   %ebp
+  9f:	89 e5                	mov    %esp,%ebp
+  a1:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  a4:	8b 45 08             	mov    0x8(%ebp),%eax
+  a7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  aa:	90                   	nop
+  ab:	8b 55 0c             	mov    0xc(%ebp),%edx
+  ae:	8d 42 01             	lea    0x1(%edx),%eax
+  b1:	89 45 0c             	mov    %eax,0xc(%ebp)
+  b4:	8b 45 08             	mov    0x8(%ebp),%eax
+  b7:	8d 48 01             	lea    0x1(%eax),%ecx
+  ba:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  bd:	0f b6 12             	movzbl (%edx),%edx
+  c0:	88 10                	mov    %dl,(%eax)
+  c2:	0f b6 00             	movzbl (%eax),%eax
+  c5:	84 c0                	test   %al,%al
+  c7:	75 e2                	jne    ab <strcpy+0x11>
+    ;
+  return os;
+  c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  cc:	c9                   	leave  
+  cd:	c3                   	ret    
+
+000000ce <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  ce:	f3 0f 1e fb          	endbr32 
+  d2:	55                   	push   %ebp
+  d3:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  d5:	eb 08                	jmp    df <strcmp+0x11>
+    p++, q++;
+  d7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  db:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+  df:	8b 45 08             	mov    0x8(%ebp),%eax
+  e2:	0f b6 00             	movzbl (%eax),%eax
+  e5:	84 c0                	test   %al,%al
+  e7:	74 10                	je     f9 <strcmp+0x2b>
+  e9:	8b 45 08             	mov    0x8(%ebp),%eax
+  ec:	0f b6 10             	movzbl (%eax),%edx
+  ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f2:	0f b6 00             	movzbl (%eax),%eax
+  f5:	38 c2                	cmp    %al,%dl
+  f7:	74 de                	je     d7 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+  f9:	8b 45 08             	mov    0x8(%ebp),%eax
+  fc:	0f b6 00             	movzbl (%eax),%eax
+  ff:	0f b6 d0             	movzbl %al,%edx
+ 102:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 105:	0f b6 00             	movzbl (%eax),%eax
+ 108:	0f b6 c0             	movzbl %al,%eax
+ 10b:	29 c2                	sub    %eax,%edx
+ 10d:	89 d0                	mov    %edx,%eax
+}
+ 10f:	5d                   	pop    %ebp
+ 110:	c3                   	ret    
+
+00000111 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 111:	f3 0f 1e fb          	endbr32 
+ 115:	55                   	push   %ebp
+ 116:	89 e5                	mov    %esp,%ebp
+ 118:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 11b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 122:	eb 04                	jmp    128 <strlen+0x17>
+ 124:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 128:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 12b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 12e:	01 d0                	add    %edx,%eax
+ 130:	0f b6 00             	movzbl (%eax),%eax
+ 133:	84 c0                	test   %al,%al
+ 135:	75 ed                	jne    124 <strlen+0x13>
+    ;
+  return n;
+ 137:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 13a:	c9                   	leave  
+ 13b:	c3                   	ret    
+
+0000013c <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 13c:	f3 0f 1e fb          	endbr32 
+ 140:	55                   	push   %ebp
+ 141:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 143:	8b 45 10             	mov    0x10(%ebp),%eax
+ 146:	50                   	push   %eax
+ 147:	ff 75 0c             	pushl  0xc(%ebp)
+ 14a:	ff 75 08             	pushl  0x8(%ebp)
+ 14d:	e8 22 ff ff ff       	call   74 <stosb>
+ 152:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 155:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 158:	c9                   	leave  
+ 159:	c3                   	ret    
+
+0000015a <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 15a:	f3 0f 1e fb          	endbr32 
+ 15e:	55                   	push   %ebp
+ 15f:	89 e5                	mov    %esp,%ebp
+ 161:	83 ec 04             	sub    $0x4,%esp
+ 164:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 167:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 16a:	eb 14                	jmp    180 <strchr+0x26>
+    if(*s == c)
+ 16c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 16f:	0f b6 00             	movzbl (%eax),%eax
+ 172:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 175:	75 05                	jne    17c <strchr+0x22>
+      return (char*)s;
+ 177:	8b 45 08             	mov    0x8(%ebp),%eax
+ 17a:	eb 13                	jmp    18f <strchr+0x35>
+  for(; *s; s++)
+ 17c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 180:	8b 45 08             	mov    0x8(%ebp),%eax
+ 183:	0f b6 00             	movzbl (%eax),%eax
+ 186:	84 c0                	test   %al,%al
+ 188:	75 e2                	jne    16c <strchr+0x12>
+  return 0;
+ 18a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 18f:	c9                   	leave  
+ 190:	c3                   	ret    
+
+00000191 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 191:	f3 0f 1e fb          	endbr32 
+ 195:	55                   	push   %ebp
+ 196:	89 e5                	mov    %esp,%ebp
+ 198:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 19b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1a2:	eb 42                	jmp    1e6 <gets+0x55>
+    cc = read(0, &c, 1);
+ 1a4:	83 ec 04             	sub    $0x4,%esp
+ 1a7:	6a 01                	push   $0x1
+ 1a9:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1ac:	50                   	push   %eax
+ 1ad:	6a 00                	push   $0x0
+ 1af:	e8 53 01 00 00       	call   307 <read>
+ 1b4:	83 c4 10             	add    $0x10,%esp
+ 1b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1ba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1be:	7e 33                	jle    1f3 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1c3:	8d 50 01             	lea    0x1(%eax),%edx
+ 1c6:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 1c9:	89 c2                	mov    %eax,%edx
+ 1cb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ce:	01 c2                	add    %eax,%edx
+ 1d0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1d4:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 1d6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1da:	3c 0a                	cmp    $0xa,%al
+ 1dc:	74 16                	je     1f4 <gets+0x63>
+ 1de:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1e2:	3c 0d                	cmp    $0xd,%al
+ 1e4:	74 0e                	je     1f4 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 1e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1e9:	83 c0 01             	add    $0x1,%eax
+ 1ec:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 1ef:	7f b3                	jg     1a4 <gets+0x13>
+ 1f1:	eb 01                	jmp    1f4 <gets+0x63>
+      break;
+ 1f3:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 1f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1f7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1fa:	01 d0                	add    %edx,%eax
+ 1fc:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 1ff:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 202:	c9                   	leave  
+ 203:	c3                   	ret    
+
+00000204 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 204:	f3 0f 1e fb          	endbr32 
+ 208:	55                   	push   %ebp
+ 209:	89 e5                	mov    %esp,%ebp
+ 20b:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 20e:	83 ec 08             	sub    $0x8,%esp
+ 211:	6a 00                	push   $0x0
+ 213:	ff 75 08             	pushl  0x8(%ebp)
+ 216:	e8 14 01 00 00       	call   32f <open>
+ 21b:	83 c4 10             	add    $0x10,%esp
+ 21e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 221:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 225:	79 07                	jns    22e <stat+0x2a>
+    return -1;
+ 227:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 22c:	eb 25                	jmp    253 <stat+0x4f>
+  r = fstat(fd, st);
+ 22e:	83 ec 08             	sub    $0x8,%esp
+ 231:	ff 75 0c             	pushl  0xc(%ebp)
+ 234:	ff 75 f4             	pushl  -0xc(%ebp)
+ 237:	e8 0b 01 00 00       	call   347 <fstat>
+ 23c:	83 c4 10             	add    $0x10,%esp
+ 23f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 242:	83 ec 0c             	sub    $0xc,%esp
+ 245:	ff 75 f4             	pushl  -0xc(%ebp)
+ 248:	e8 ca 00 00 00       	call   317 <close>
+ 24d:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 250:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 253:	c9                   	leave  
+ 254:	c3                   	ret    
+
+00000255 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 255:	f3 0f 1e fb          	endbr32 
+ 259:	55                   	push   %ebp
+ 25a:	89 e5                	mov    %esp,%ebp
+ 25c:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 25f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 266:	eb 25                	jmp    28d <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 268:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 26b:	89 d0                	mov    %edx,%eax
+ 26d:	c1 e0 02             	shl    $0x2,%eax
+ 270:	01 d0                	add    %edx,%eax
+ 272:	01 c0                	add    %eax,%eax
+ 274:	89 c1                	mov    %eax,%ecx
+ 276:	8b 45 08             	mov    0x8(%ebp),%eax
+ 279:	8d 50 01             	lea    0x1(%eax),%edx
+ 27c:	89 55 08             	mov    %edx,0x8(%ebp)
+ 27f:	0f b6 00             	movzbl (%eax),%eax
+ 282:	0f be c0             	movsbl %al,%eax
+ 285:	01 c8                	add    %ecx,%eax
+ 287:	83 e8 30             	sub    $0x30,%eax
+ 28a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 28d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 290:	0f b6 00             	movzbl (%eax),%eax
+ 293:	3c 2f                	cmp    $0x2f,%al
+ 295:	7e 0a                	jle    2a1 <atoi+0x4c>
+ 297:	8b 45 08             	mov    0x8(%ebp),%eax
+ 29a:	0f b6 00             	movzbl (%eax),%eax
+ 29d:	3c 39                	cmp    $0x39,%al
+ 29f:	7e c7                	jle    268 <atoi+0x13>
+  return n;
+ 2a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 2a4:	c9                   	leave  
+ 2a5:	c3                   	ret    
+
+000002a6 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2a6:	f3 0f 1e fb          	endbr32 
+ 2aa:	55                   	push   %ebp
+ 2ab:	89 e5                	mov    %esp,%ebp
+ 2ad:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 2b0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2b6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2bc:	eb 17                	jmp    2d5 <memmove+0x2f>
+    *dst++ = *src++;
+ 2be:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 2c1:	8d 42 01             	lea    0x1(%edx),%eax
+ 2c4:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 2c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2ca:	8d 48 01             	lea    0x1(%eax),%ecx
+ 2cd:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 2d0:	0f b6 12             	movzbl (%edx),%edx
+ 2d3:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 2d5:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2d8:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 2db:	89 55 10             	mov    %edx,0x10(%ebp)
+ 2de:	85 c0                	test   %eax,%eax
+ 2e0:	7f dc                	jg     2be <memmove+0x18>
+  return vdst;
+ 2e2:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2e5:	c9                   	leave  
+ 2e6:	c3                   	ret    
+
+000002e7 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2e7:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2ec:	cd 40                	int    $0x40
+ 2ee:	c3                   	ret    
+
+000002ef <exit>:
+SYSCALL(exit)
+ 2ef:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2f4:	cd 40                	int    $0x40
+ 2f6:	c3                   	ret    
+
+000002f7 <wait>:
+SYSCALL(wait)
+ 2f7:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2fc:	cd 40                	int    $0x40
+ 2fe:	c3                   	ret    
+
+000002ff <pipe>:
+SYSCALL(pipe)
+ 2ff:	b8 04 00 00 00       	mov    $0x4,%eax
+ 304:	cd 40                	int    $0x40
+ 306:	c3                   	ret    
+
+00000307 <read>:
+SYSCALL(read)
+ 307:	b8 05 00 00 00       	mov    $0x5,%eax
+ 30c:	cd 40                	int    $0x40
+ 30e:	c3                   	ret    
+
+0000030f <write>:
+SYSCALL(write)
+ 30f:	b8 10 00 00 00       	mov    $0x10,%eax
+ 314:	cd 40                	int    $0x40
+ 316:	c3                   	ret    
+
+00000317 <close>:
+SYSCALL(close)
+ 317:	b8 15 00 00 00       	mov    $0x15,%eax
+ 31c:	cd 40                	int    $0x40
+ 31e:	c3                   	ret    
+
+0000031f <kill>:
+SYSCALL(kill)
+ 31f:	b8 06 00 00 00       	mov    $0x6,%eax
+ 324:	cd 40                	int    $0x40
+ 326:	c3                   	ret    
+
+00000327 <exec>:
+SYSCALL(exec)
+ 327:	b8 07 00 00 00       	mov    $0x7,%eax
+ 32c:	cd 40                	int    $0x40
+ 32e:	c3                   	ret    
+
+0000032f <open>:
+SYSCALL(open)
+ 32f:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 334:	cd 40                	int    $0x40
+ 336:	c3                   	ret    
+
+00000337 <mknod>:
+SYSCALL(mknod)
+ 337:	b8 11 00 00 00       	mov    $0x11,%eax
+ 33c:	cd 40                	int    $0x40
+ 33e:	c3                   	ret    
+
+0000033f <unlink>:
+SYSCALL(unlink)
+ 33f:	b8 12 00 00 00       	mov    $0x12,%eax
+ 344:	cd 40                	int    $0x40
+ 346:	c3                   	ret    
+
+00000347 <fstat>:
+SYSCALL(fstat)
+ 347:	b8 08 00 00 00       	mov    $0x8,%eax
+ 34c:	cd 40                	int    $0x40
+ 34e:	c3                   	ret    
+
+0000034f <link>:
+SYSCALL(link)
+ 34f:	b8 13 00 00 00       	mov    $0x13,%eax
+ 354:	cd 40                	int    $0x40
+ 356:	c3                   	ret    
+
+00000357 <mkdir>:
+SYSCALL(mkdir)
+ 357:	b8 14 00 00 00       	mov    $0x14,%eax
+ 35c:	cd 40                	int    $0x40
+ 35e:	c3                   	ret    
+
+0000035f <chdir>:
+SYSCALL(chdir)
+ 35f:	b8 09 00 00 00       	mov    $0x9,%eax
+ 364:	cd 40                	int    $0x40
+ 366:	c3                   	ret    
+
+00000367 <dup>:
+SYSCALL(dup)
+ 367:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 36c:	cd 40                	int    $0x40
+ 36e:	c3                   	ret    
+
+0000036f <getpid>:
+SYSCALL(getpid)
+ 36f:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 374:	cd 40                	int    $0x40
+ 376:	c3                   	ret    
+
+00000377 <sbrk>:
+SYSCALL(sbrk)
+ 377:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 37c:	cd 40                	int    $0x40
+ 37e:	c3                   	ret    
+
+0000037f <sleep>:
+SYSCALL(sleep)
+ 37f:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 384:	cd 40                	int    $0x40
+ 386:	c3                   	ret    
+
+00000387 <uptime>:
+SYSCALL(uptime)
+ 387:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 38c:	cd 40                	int    $0x40
+ 38e:	c3                   	ret    
+
+0000038f <draw>:
+SYSCALL(draw)
+ 38f:	b8 16 00 00 00       	mov    $0x16,%eax
+ 394:	cd 40                	int    $0x40
+ 396:	c3                   	ret    
+
+00000397 <cps>:
+SYSCALL(cps)
+ 397:	b8 17 00 00 00       	mov    $0x17,%eax
+ 39c:	cd 40                	int    $0x40
+ 39e:	c3                   	ret    
+
+0000039f <yield>:
+SYSCALL(yield)
+ 39f:	b8 18 00 00 00       	mov    $0x18,%eax
+ 3a4:	cd 40                	int    $0x40
+ 3a6:	c3                   	ret    
+
+000003a7 <wait2>:
+SYSCALL(wait2)
+ 3a7:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3ac:	cd 40                	int    $0x40
+ 3ae:	c3                   	ret    
+
+000003af <set_prio>:
+SYSCALL(set_prio)
+ 3af:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3b4:	cd 40                	int    $0x40
+ 3b6:	c3                   	ret    
+
+000003b7 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3b7:	f3 0f 1e fb          	endbr32 
+ 3bb:	55                   	push   %ebp
+ 3bc:	89 e5                	mov    %esp,%ebp
+ 3be:	83 ec 18             	sub    $0x18,%esp
+ 3c1:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3c4:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3c7:	83 ec 04             	sub    $0x4,%esp
+ 3ca:	6a 01                	push   $0x1
+ 3cc:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3cf:	50                   	push   %eax
+ 3d0:	ff 75 08             	pushl  0x8(%ebp)
+ 3d3:	e8 37 ff ff ff       	call   30f <write>
+ 3d8:	83 c4 10             	add    $0x10,%esp
+}
+ 3db:	90                   	nop
+ 3dc:	c9                   	leave  
+ 3dd:	c3                   	ret    
+
+000003de <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3de:	f3 0f 1e fb          	endbr32 
+ 3e2:	55                   	push   %ebp
+ 3e3:	89 e5                	mov    %esp,%ebp
+ 3e5:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3e8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3ef:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3f3:	74 17                	je     40c <printint+0x2e>
+ 3f5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3f9:	79 11                	jns    40c <printint+0x2e>
+    neg = 1;
+ 3fb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 402:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 405:	f7 d8                	neg    %eax
+ 407:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 40a:	eb 06                	jmp    412 <printint+0x34>
+  } else {
+    x = xx;
+ 40c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 40f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 412:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 419:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 41c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 41f:	ba 00 00 00 00       	mov    $0x0,%edx
+ 424:	f7 f1                	div    %ecx
+ 426:	89 d1                	mov    %edx,%ecx
+ 428:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 42b:	8d 50 01             	lea    0x1(%eax),%edx
+ 42e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 431:	0f b6 91 cc 0a 00 00 	movzbl 0xacc(%ecx),%edx
+ 438:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 43c:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 43f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 442:	ba 00 00 00 00       	mov    $0x0,%edx
+ 447:	f7 f1                	div    %ecx
+ 449:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 44c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 450:	75 c7                	jne    419 <printint+0x3b>
+  if(neg)
+ 452:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 456:	74 2d                	je     485 <printint+0xa7>
+    buf[i++] = '-';
+ 458:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 45b:	8d 50 01             	lea    0x1(%eax),%edx
+ 45e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 461:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 466:	eb 1d                	jmp    485 <printint+0xa7>
+    putc(fd, buf[i]);
+ 468:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 46b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 46e:	01 d0                	add    %edx,%eax
+ 470:	0f b6 00             	movzbl (%eax),%eax
+ 473:	0f be c0             	movsbl %al,%eax
+ 476:	83 ec 08             	sub    $0x8,%esp
+ 479:	50                   	push   %eax
+ 47a:	ff 75 08             	pushl  0x8(%ebp)
+ 47d:	e8 35 ff ff ff       	call   3b7 <putc>
+ 482:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 485:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 489:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 48d:	79 d9                	jns    468 <printint+0x8a>
+}
+ 48f:	90                   	nop
+ 490:	90                   	nop
+ 491:	c9                   	leave  
+ 492:	c3                   	ret    
+
+00000493 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 493:	f3 0f 1e fb          	endbr32 
+ 497:	55                   	push   %ebp
+ 498:	89 e5                	mov    %esp,%ebp
+ 49a:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 49d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 4a4:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 4a7:	83 c0 04             	add    $0x4,%eax
+ 4aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 4ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4b4:	e9 59 01 00 00       	jmp    612 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 4b9:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4bf:	01 d0                	add    %edx,%eax
+ 4c1:	0f b6 00             	movzbl (%eax),%eax
+ 4c4:	0f be c0             	movsbl %al,%eax
+ 4c7:	25 ff 00 00 00       	and    $0xff,%eax
+ 4cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4cf:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4d3:	75 2c                	jne    501 <printf+0x6e>
+      if(c == '%'){
+ 4d5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4d9:	75 0c                	jne    4e7 <printf+0x54>
+        state = '%';
+ 4db:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4e2:	e9 27 01 00 00       	jmp    60e <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 4e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4ea:	0f be c0             	movsbl %al,%eax
+ 4ed:	83 ec 08             	sub    $0x8,%esp
+ 4f0:	50                   	push   %eax
+ 4f1:	ff 75 08             	pushl  0x8(%ebp)
+ 4f4:	e8 be fe ff ff       	call   3b7 <putc>
+ 4f9:	83 c4 10             	add    $0x10,%esp
+ 4fc:	e9 0d 01 00 00       	jmp    60e <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 501:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 505:	0f 85 03 01 00 00    	jne    60e <printf+0x17b>
+      if(c == 'd'){
+ 50b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 50f:	75 1e                	jne    52f <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 511:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 514:	8b 00                	mov    (%eax),%eax
+ 516:	6a 01                	push   $0x1
+ 518:	6a 0a                	push   $0xa
+ 51a:	50                   	push   %eax
+ 51b:	ff 75 08             	pushl  0x8(%ebp)
+ 51e:	e8 bb fe ff ff       	call   3de <printint>
+ 523:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 526:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 52a:	e9 d8 00 00 00       	jmp    607 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 52f:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 533:	74 06                	je     53b <printf+0xa8>
+ 535:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 539:	75 1e                	jne    559 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 53b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 53e:	8b 00                	mov    (%eax),%eax
+ 540:	6a 00                	push   $0x0
+ 542:	6a 10                	push   $0x10
+ 544:	50                   	push   %eax
+ 545:	ff 75 08             	pushl  0x8(%ebp)
+ 548:	e8 91 fe ff ff       	call   3de <printint>
+ 54d:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 550:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 554:	e9 ae 00 00 00       	jmp    607 <printf+0x174>
+      } else if(c == 's'){
+ 559:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 55d:	75 43                	jne    5a2 <printf+0x10f>
+        s = (char*)*ap;
+ 55f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 562:	8b 00                	mov    (%eax),%eax
+ 564:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 567:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 56b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 56f:	75 25                	jne    596 <printf+0x103>
+          s = "(null)";
+ 571:	c7 45 f4 7e 08 00 00 	movl   $0x87e,-0xc(%ebp)
+        while(*s != 0){
+ 578:	eb 1c                	jmp    596 <printf+0x103>
+          putc(fd, *s);
+ 57a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 57d:	0f b6 00             	movzbl (%eax),%eax
+ 580:	0f be c0             	movsbl %al,%eax
+ 583:	83 ec 08             	sub    $0x8,%esp
+ 586:	50                   	push   %eax
+ 587:	ff 75 08             	pushl  0x8(%ebp)
+ 58a:	e8 28 fe ff ff       	call   3b7 <putc>
+ 58f:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 592:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 596:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 599:	0f b6 00             	movzbl (%eax),%eax
+ 59c:	84 c0                	test   %al,%al
+ 59e:	75 da                	jne    57a <printf+0xe7>
+ 5a0:	eb 65                	jmp    607 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 5a2:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5a6:	75 1d                	jne    5c5 <printf+0x132>
+        putc(fd, *ap);
+ 5a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5ab:	8b 00                	mov    (%eax),%eax
+ 5ad:	0f be c0             	movsbl %al,%eax
+ 5b0:	83 ec 08             	sub    $0x8,%esp
+ 5b3:	50                   	push   %eax
+ 5b4:	ff 75 08             	pushl  0x8(%ebp)
+ 5b7:	e8 fb fd ff ff       	call   3b7 <putc>
+ 5bc:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5bf:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5c3:	eb 42                	jmp    607 <printf+0x174>
+      } else if(c == '%'){
+ 5c5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5c9:	75 17                	jne    5e2 <printf+0x14f>
+        putc(fd, c);
+ 5cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5ce:	0f be c0             	movsbl %al,%eax
+ 5d1:	83 ec 08             	sub    $0x8,%esp
+ 5d4:	50                   	push   %eax
+ 5d5:	ff 75 08             	pushl  0x8(%ebp)
+ 5d8:	e8 da fd ff ff       	call   3b7 <putc>
+ 5dd:	83 c4 10             	add    $0x10,%esp
+ 5e0:	eb 25                	jmp    607 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 5e2:	83 ec 08             	sub    $0x8,%esp
+ 5e5:	6a 25                	push   $0x25
+ 5e7:	ff 75 08             	pushl  0x8(%ebp)
+ 5ea:	e8 c8 fd ff ff       	call   3b7 <putc>
+ 5ef:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 5f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5f5:	0f be c0             	movsbl %al,%eax
+ 5f8:	83 ec 08             	sub    $0x8,%esp
+ 5fb:	50                   	push   %eax
+ 5fc:	ff 75 08             	pushl  0x8(%ebp)
+ 5ff:	e8 b3 fd ff ff       	call   3b7 <putc>
+ 604:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 607:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 60e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 612:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 615:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 618:	01 d0                	add    %edx,%eax
+ 61a:	0f b6 00             	movzbl (%eax),%eax
+ 61d:	84 c0                	test   %al,%al
+ 61f:	0f 85 94 fe ff ff    	jne    4b9 <printf+0x26>
+    }
+  }
+}
+ 625:	90                   	nop
+ 626:	90                   	nop
+ 627:	c9                   	leave  
+ 628:	c3                   	ret    
+
+00000629 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 629:	f3 0f 1e fb          	endbr32 
+ 62d:	55                   	push   %ebp
+ 62e:	89 e5                	mov    %esp,%ebp
+ 630:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 633:	8b 45 08             	mov    0x8(%ebp),%eax
+ 636:	83 e8 08             	sub    $0x8,%eax
+ 639:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 63c:	a1 e8 0a 00 00       	mov    0xae8,%eax
+ 641:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 644:	eb 24                	jmp    66a <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 646:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 649:	8b 00                	mov    (%eax),%eax
+ 64b:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 64e:	72 12                	jb     662 <free+0x39>
+ 650:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 653:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 656:	77 24                	ja     67c <free+0x53>
+ 658:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65b:	8b 00                	mov    (%eax),%eax
+ 65d:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 660:	72 1a                	jb     67c <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 662:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 665:	8b 00                	mov    (%eax),%eax
+ 667:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 66a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 66d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 670:	76 d4                	jbe    646 <free+0x1d>
+ 672:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 675:	8b 00                	mov    (%eax),%eax
+ 677:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 67a:	73 ca                	jae    646 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 67c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 67f:	8b 40 04             	mov    0x4(%eax),%eax
+ 682:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 689:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 68c:	01 c2                	add    %eax,%edx
+ 68e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 691:	8b 00                	mov    (%eax),%eax
+ 693:	39 c2                	cmp    %eax,%edx
+ 695:	75 24                	jne    6bb <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 697:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69a:	8b 50 04             	mov    0x4(%eax),%edx
+ 69d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a0:	8b 00                	mov    (%eax),%eax
+ 6a2:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a5:	01 c2                	add    %eax,%edx
+ 6a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6aa:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b0:	8b 00                	mov    (%eax),%eax
+ 6b2:	8b 10                	mov    (%eax),%edx
+ 6b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6b7:	89 10                	mov    %edx,(%eax)
+ 6b9:	eb 0a                	jmp    6c5 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6be:	8b 10                	mov    (%eax),%edx
+ 6c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6c3:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c8:	8b 40 04             	mov    0x4(%eax),%eax
+ 6cb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d5:	01 d0                	add    %edx,%eax
+ 6d7:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6da:	75 20                	jne    6fc <free+0xd3>
+    p->s.size += bp->s.size;
+ 6dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6df:	8b 50 04             	mov    0x4(%eax),%edx
+ 6e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e5:	8b 40 04             	mov    0x4(%eax),%eax
+ 6e8:	01 c2                	add    %eax,%edx
+ 6ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ed:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6f3:	8b 10                	mov    (%eax),%edx
+ 6f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f8:	89 10                	mov    %edx,(%eax)
+ 6fa:	eb 08                	jmp    704 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 6fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ff:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 702:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 704:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 707:	a3 e8 0a 00 00       	mov    %eax,0xae8
+}
+ 70c:	90                   	nop
+ 70d:	c9                   	leave  
+ 70e:	c3                   	ret    
+
+0000070f <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 70f:	f3 0f 1e fb          	endbr32 
+ 713:	55                   	push   %ebp
+ 714:	89 e5                	mov    %esp,%ebp
+ 716:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 719:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 720:	77 07                	ja     729 <morecore+0x1a>
+    nu = 4096;
+ 722:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 729:	8b 45 08             	mov    0x8(%ebp),%eax
+ 72c:	c1 e0 03             	shl    $0x3,%eax
+ 72f:	83 ec 0c             	sub    $0xc,%esp
+ 732:	50                   	push   %eax
+ 733:	e8 3f fc ff ff       	call   377 <sbrk>
+ 738:	83 c4 10             	add    $0x10,%esp
+ 73b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 73e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 742:	75 07                	jne    74b <morecore+0x3c>
+    return 0;
+ 744:	b8 00 00 00 00       	mov    $0x0,%eax
+ 749:	eb 26                	jmp    771 <morecore+0x62>
+  hp = (Header*)p;
+ 74b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 74e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 751:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 754:	8b 55 08             	mov    0x8(%ebp),%edx
+ 757:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 75a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 75d:	83 c0 08             	add    $0x8,%eax
+ 760:	83 ec 0c             	sub    $0xc,%esp
+ 763:	50                   	push   %eax
+ 764:	e8 c0 fe ff ff       	call   629 <free>
+ 769:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 76c:	a1 e8 0a 00 00       	mov    0xae8,%eax
+}
+ 771:	c9                   	leave  
+ 772:	c3                   	ret    
+
+00000773 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 773:	f3 0f 1e fb          	endbr32 
+ 777:	55                   	push   %ebp
+ 778:	89 e5                	mov    %esp,%ebp
+ 77a:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 77d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 780:	83 c0 07             	add    $0x7,%eax
+ 783:	c1 e8 03             	shr    $0x3,%eax
+ 786:	83 c0 01             	add    $0x1,%eax
+ 789:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 78c:	a1 e8 0a 00 00       	mov    0xae8,%eax
+ 791:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 794:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 798:	75 23                	jne    7bd <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 79a:	c7 45 f0 e0 0a 00 00 	movl   $0xae0,-0x10(%ebp)
+ 7a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7a4:	a3 e8 0a 00 00       	mov    %eax,0xae8
+ 7a9:	a1 e8 0a 00 00       	mov    0xae8,%eax
+ 7ae:	a3 e0 0a 00 00       	mov    %eax,0xae0
+    base.s.size = 0;
+ 7b3:	c7 05 e4 0a 00 00 00 	movl   $0x0,0xae4
+ 7ba:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7c0:	8b 00                	mov    (%eax),%eax
+ 7c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7c8:	8b 40 04             	mov    0x4(%eax),%eax
+ 7cb:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7ce:	77 4d                	ja     81d <malloc+0xaa>
+      if(p->s.size == nunits)
+ 7d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7d3:	8b 40 04             	mov    0x4(%eax),%eax
+ 7d6:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7d9:	75 0c                	jne    7e7 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 7db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7de:	8b 10                	mov    (%eax),%edx
+ 7e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7e3:	89 10                	mov    %edx,(%eax)
+ 7e5:	eb 26                	jmp    80d <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 7e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ea:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ed:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 7f0:	89 c2                	mov    %eax,%edx
+ 7f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f5:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7fb:	8b 40 04             	mov    0x4(%eax),%eax
+ 7fe:	c1 e0 03             	shl    $0x3,%eax
+ 801:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 804:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 807:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 80a:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 80d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 810:	a3 e8 0a 00 00       	mov    %eax,0xae8
+      return (void*)(p + 1);
+ 815:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 818:	83 c0 08             	add    $0x8,%eax
+ 81b:	eb 3b                	jmp    858 <malloc+0xe5>
+    }
+    if(p == freep)
+ 81d:	a1 e8 0a 00 00       	mov    0xae8,%eax
+ 822:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 825:	75 1e                	jne    845 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 827:	83 ec 0c             	sub    $0xc,%esp
+ 82a:	ff 75 ec             	pushl  -0x14(%ebp)
+ 82d:	e8 dd fe ff ff       	call   70f <morecore>
+ 832:	83 c4 10             	add    $0x10,%esp
+ 835:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 838:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 83c:	75 07                	jne    845 <malloc+0xd2>
+        return 0;
+ 83e:	b8 00 00 00 00       	mov    $0x0,%eax
+ 843:	eb 13                	jmp    858 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 845:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 848:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 84b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 84e:	8b 00                	mov    (%eax),%eax
+ 850:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 853:	e9 6d ff ff ff       	jmp    7c5 <malloc+0x52>
+  }
+}
+ 858:	c9                   	leave  
+ 859:	c3                   	ret    
diff -ruN xv6-public/xv6-public/drawtest.c xv6-public_new/xv6-public/drawtest.c
--- xv6-public/xv6-public/drawtest.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/drawtest.c	2021-09-29 12:56:52.000000000 +0530
@@ -0,0 +1,31 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+//maximum size of the buffer
+const int max_size = 1578;
+
+int main(void)
+{
+
+    // Created a buffer with maximum size as max_size 
+    void *wolf_buffer = malloc(max_size);
+
+    // Called the system call and stored the size of image.
+    int wolf_size = draw(wolf_buffer, max_size);
+
+    // If the size of image is in buffer is greater than max_size then print a error message
+    if (wolf_size == -1)
+    {
+        // file descriptor 1 used to print on the standard output i.e (stdout)
+        printf(1, "Buffer size is too small\n");
+    }
+    else
+    {
+         // file descriptor 1 used to print on the standard output i.e (stdout)
+        printf(1, "%s\n", (char *)wolf_buffer);
+    }
+
+    exit();
+    return 0;
+}
diff -ruN xv6-public/xv6-public/drawtest.d xv6-public_new/xv6-public/drawtest.d
--- xv6-public/xv6-public/drawtest.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/drawtest.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1 @@
+drawtest.o: drawtest.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/drawtest.o and xv6-public_new/xv6-public/drawtest.o differ
diff -ruN xv6-public/xv6-public/drawtest.sym xv6-public_new/xv6-public/drawtest.sym
--- xv6-public/xv6-public/drawtest.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/drawtest.sym	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,66 @@
+00000000 .text
+0000085c .rodata
+00000888 .eh_frame
+00000acc .data
+00000ae0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 drawtest.c
+00000000 ulib.c
+00000074 stosb
+00000000 printf.c
+000003b7 putc
+000003de printint
+00000acc digits.1098
+00000000 umalloc.c
+00000ae0 base
+00000ae8 freep
+0000070f morecore
+0000009a strcpy
+0000039f yield
+000003af set_prio
+00000493 printf
+000002a6 memmove
+00000337 mknod
+00000191 gets
+0000036f getpid
+00000773 malloc
+0000037f sleep
+000003a7 wait2
+0000085c max_size
+000002ff pipe
+0000030f write
+00000347 fstat
+0000031f kill
+0000035f chdir
+00000327 exec
+000002f7 wait
+00000307 read
+0000033f unlink
+000002e7 fork
+00000377 sbrk
+00000387 uptime
+00000add __bss_start
+0000013c memset
+00000000 main
+000000ce strcmp
+00000367 dup
+00000204 stat
+00000add _edata
+00000aec _end
+0000034f link
+000002ef exit
+00000255 atoi
+0000038f draw
+00000111 strlen
+0000032f open
+0000015a strchr
+00000397 cps
+00000357 mkdir
+00000317 close
+00000629 free
diff -ruN xv6-public/xv6-public/echo.asm xv6-public_new/xv6-public/echo.asm
--- xv6-public/xv6-public/echo.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/echo.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1164 @@
+
+_echo:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	53                   	push   %ebx
+  12:	51                   	push   %ecx
+  13:	83 ec 10             	sub    $0x10,%esp
+  16:	89 cb                	mov    %ecx,%ebx
+  int i;
+
+  for(i = 1; i < argc; i++)
+  18:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+  1f:	eb 3c                	jmp    5d <main+0x5d>
+    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+  21:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  24:	83 c0 01             	add    $0x1,%eax
+  27:	39 03                	cmp    %eax,(%ebx)
+  29:	7e 07                	jle    32 <main+0x32>
+  2b:	b9 4f 08 00 00       	mov    $0x84f,%ecx
+  30:	eb 05                	jmp    37 <main+0x37>
+  32:	b9 51 08 00 00       	mov    $0x851,%ecx
+  37:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  3a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  41:	8b 43 04             	mov    0x4(%ebx),%eax
+  44:	01 d0                	add    %edx,%eax
+  46:	8b 00                	mov    (%eax),%eax
+  48:	51                   	push   %ecx
+  49:	50                   	push   %eax
+  4a:	68 53 08 00 00       	push   $0x853
+  4f:	6a 01                	push   $0x1
+  51:	e8 32 04 00 00       	call   488 <printf>
+  56:	83 c4 10             	add    $0x10,%esp
+  for(i = 1; i < argc; i++)
+  59:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  60:	3b 03                	cmp    (%ebx),%eax
+  62:	7c bd                	jl     21 <main+0x21>
+  exit();
+  64:	e8 7b 02 00 00       	call   2e4 <exit>
+
+00000069 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  69:	55                   	push   %ebp
+  6a:	89 e5                	mov    %esp,%ebp
+  6c:	57                   	push   %edi
+  6d:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  6e:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  71:	8b 55 10             	mov    0x10(%ebp),%edx
+  74:	8b 45 0c             	mov    0xc(%ebp),%eax
+  77:	89 cb                	mov    %ecx,%ebx
+  79:	89 df                	mov    %ebx,%edi
+  7b:	89 d1                	mov    %edx,%ecx
+  7d:	fc                   	cld    
+  7e:	f3 aa                	rep stos %al,%es:(%edi)
+  80:	89 ca                	mov    %ecx,%edx
+  82:	89 fb                	mov    %edi,%ebx
+  84:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  87:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  8a:	90                   	nop
+  8b:	5b                   	pop    %ebx
+  8c:	5f                   	pop    %edi
+  8d:	5d                   	pop    %ebp
+  8e:	c3                   	ret    
+
+0000008f <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  8f:	f3 0f 1e fb          	endbr32 
+  93:	55                   	push   %ebp
+  94:	89 e5                	mov    %esp,%ebp
+  96:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  99:	8b 45 08             	mov    0x8(%ebp),%eax
+  9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  9f:	90                   	nop
+  a0:	8b 55 0c             	mov    0xc(%ebp),%edx
+  a3:	8d 42 01             	lea    0x1(%edx),%eax
+  a6:	89 45 0c             	mov    %eax,0xc(%ebp)
+  a9:	8b 45 08             	mov    0x8(%ebp),%eax
+  ac:	8d 48 01             	lea    0x1(%eax),%ecx
+  af:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  b2:	0f b6 12             	movzbl (%edx),%edx
+  b5:	88 10                	mov    %dl,(%eax)
+  b7:	0f b6 00             	movzbl (%eax),%eax
+  ba:	84 c0                	test   %al,%al
+  bc:	75 e2                	jne    a0 <strcpy+0x11>
+    ;
+  return os;
+  be:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  c1:	c9                   	leave  
+  c2:	c3                   	ret    
+
+000000c3 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  c3:	f3 0f 1e fb          	endbr32 
+  c7:	55                   	push   %ebp
+  c8:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  ca:	eb 08                	jmp    d4 <strcmp+0x11>
+    p++, q++;
+  cc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  d0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+  d4:	8b 45 08             	mov    0x8(%ebp),%eax
+  d7:	0f b6 00             	movzbl (%eax),%eax
+  da:	84 c0                	test   %al,%al
+  dc:	74 10                	je     ee <strcmp+0x2b>
+  de:	8b 45 08             	mov    0x8(%ebp),%eax
+  e1:	0f b6 10             	movzbl (%eax),%edx
+  e4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  e7:	0f b6 00             	movzbl (%eax),%eax
+  ea:	38 c2                	cmp    %al,%dl
+  ec:	74 de                	je     cc <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+  ee:	8b 45 08             	mov    0x8(%ebp),%eax
+  f1:	0f b6 00             	movzbl (%eax),%eax
+  f4:	0f b6 d0             	movzbl %al,%edx
+  f7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  fa:	0f b6 00             	movzbl (%eax),%eax
+  fd:	0f b6 c0             	movzbl %al,%eax
+ 100:	29 c2                	sub    %eax,%edx
+ 102:	89 d0                	mov    %edx,%eax
+}
+ 104:	5d                   	pop    %ebp
+ 105:	c3                   	ret    
+
+00000106 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 106:	f3 0f 1e fb          	endbr32 
+ 10a:	55                   	push   %ebp
+ 10b:	89 e5                	mov    %esp,%ebp
+ 10d:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 110:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 117:	eb 04                	jmp    11d <strlen+0x17>
+ 119:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 11d:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 120:	8b 45 08             	mov    0x8(%ebp),%eax
+ 123:	01 d0                	add    %edx,%eax
+ 125:	0f b6 00             	movzbl (%eax),%eax
+ 128:	84 c0                	test   %al,%al
+ 12a:	75 ed                	jne    119 <strlen+0x13>
+    ;
+  return n;
+ 12c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 12f:	c9                   	leave  
+ 130:	c3                   	ret    
+
+00000131 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 131:	f3 0f 1e fb          	endbr32 
+ 135:	55                   	push   %ebp
+ 136:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 138:	8b 45 10             	mov    0x10(%ebp),%eax
+ 13b:	50                   	push   %eax
+ 13c:	ff 75 0c             	pushl  0xc(%ebp)
+ 13f:	ff 75 08             	pushl  0x8(%ebp)
+ 142:	e8 22 ff ff ff       	call   69 <stosb>
+ 147:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 14a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 14d:	c9                   	leave  
+ 14e:	c3                   	ret    
+
+0000014f <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 14f:	f3 0f 1e fb          	endbr32 
+ 153:	55                   	push   %ebp
+ 154:	89 e5                	mov    %esp,%ebp
+ 156:	83 ec 04             	sub    $0x4,%esp
+ 159:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 15c:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 15f:	eb 14                	jmp    175 <strchr+0x26>
+    if(*s == c)
+ 161:	8b 45 08             	mov    0x8(%ebp),%eax
+ 164:	0f b6 00             	movzbl (%eax),%eax
+ 167:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 16a:	75 05                	jne    171 <strchr+0x22>
+      return (char*)s;
+ 16c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 16f:	eb 13                	jmp    184 <strchr+0x35>
+  for(; *s; s++)
+ 171:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 175:	8b 45 08             	mov    0x8(%ebp),%eax
+ 178:	0f b6 00             	movzbl (%eax),%eax
+ 17b:	84 c0                	test   %al,%al
+ 17d:	75 e2                	jne    161 <strchr+0x12>
+  return 0;
+ 17f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 184:	c9                   	leave  
+ 185:	c3                   	ret    
+
+00000186 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 186:	f3 0f 1e fb          	endbr32 
+ 18a:	55                   	push   %ebp
+ 18b:	89 e5                	mov    %esp,%ebp
+ 18d:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 190:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 197:	eb 42                	jmp    1db <gets+0x55>
+    cc = read(0, &c, 1);
+ 199:	83 ec 04             	sub    $0x4,%esp
+ 19c:	6a 01                	push   $0x1
+ 19e:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1a1:	50                   	push   %eax
+ 1a2:	6a 00                	push   $0x0
+ 1a4:	e8 53 01 00 00       	call   2fc <read>
+ 1a9:	83 c4 10             	add    $0x10,%esp
+ 1ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1b3:	7e 33                	jle    1e8 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1b8:	8d 50 01             	lea    0x1(%eax),%edx
+ 1bb:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 1be:	89 c2                	mov    %eax,%edx
+ 1c0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1c3:	01 c2                	add    %eax,%edx
+ 1c5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1c9:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 1cb:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1cf:	3c 0a                	cmp    $0xa,%al
+ 1d1:	74 16                	je     1e9 <gets+0x63>
+ 1d3:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1d7:	3c 0d                	cmp    $0xd,%al
+ 1d9:	74 0e                	je     1e9 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 1db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1de:	83 c0 01             	add    $0x1,%eax
+ 1e1:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 1e4:	7f b3                	jg     199 <gets+0x13>
+ 1e6:	eb 01                	jmp    1e9 <gets+0x63>
+      break;
+ 1e8:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 1e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1ec:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ef:	01 d0                	add    %edx,%eax
+ 1f1:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 1f4:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1f7:	c9                   	leave  
+ 1f8:	c3                   	ret    
+
+000001f9 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1f9:	f3 0f 1e fb          	endbr32 
+ 1fd:	55                   	push   %ebp
+ 1fe:	89 e5                	mov    %esp,%ebp
+ 200:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 203:	83 ec 08             	sub    $0x8,%esp
+ 206:	6a 00                	push   $0x0
+ 208:	ff 75 08             	pushl  0x8(%ebp)
+ 20b:	e8 14 01 00 00       	call   324 <open>
+ 210:	83 c4 10             	add    $0x10,%esp
+ 213:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 216:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 21a:	79 07                	jns    223 <stat+0x2a>
+    return -1;
+ 21c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 221:	eb 25                	jmp    248 <stat+0x4f>
+  r = fstat(fd, st);
+ 223:	83 ec 08             	sub    $0x8,%esp
+ 226:	ff 75 0c             	pushl  0xc(%ebp)
+ 229:	ff 75 f4             	pushl  -0xc(%ebp)
+ 22c:	e8 0b 01 00 00       	call   33c <fstat>
+ 231:	83 c4 10             	add    $0x10,%esp
+ 234:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 237:	83 ec 0c             	sub    $0xc,%esp
+ 23a:	ff 75 f4             	pushl  -0xc(%ebp)
+ 23d:	e8 ca 00 00 00       	call   30c <close>
+ 242:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 245:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 248:	c9                   	leave  
+ 249:	c3                   	ret    
+
+0000024a <atoi>:
+
+int
+atoi(const char *s)
+{
+ 24a:	f3 0f 1e fb          	endbr32 
+ 24e:	55                   	push   %ebp
+ 24f:	89 e5                	mov    %esp,%ebp
+ 251:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 254:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 25b:	eb 25                	jmp    282 <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 25d:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 260:	89 d0                	mov    %edx,%eax
+ 262:	c1 e0 02             	shl    $0x2,%eax
+ 265:	01 d0                	add    %edx,%eax
+ 267:	01 c0                	add    %eax,%eax
+ 269:	89 c1                	mov    %eax,%ecx
+ 26b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 26e:	8d 50 01             	lea    0x1(%eax),%edx
+ 271:	89 55 08             	mov    %edx,0x8(%ebp)
+ 274:	0f b6 00             	movzbl (%eax),%eax
+ 277:	0f be c0             	movsbl %al,%eax
+ 27a:	01 c8                	add    %ecx,%eax
+ 27c:	83 e8 30             	sub    $0x30,%eax
+ 27f:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 282:	8b 45 08             	mov    0x8(%ebp),%eax
+ 285:	0f b6 00             	movzbl (%eax),%eax
+ 288:	3c 2f                	cmp    $0x2f,%al
+ 28a:	7e 0a                	jle    296 <atoi+0x4c>
+ 28c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 28f:	0f b6 00             	movzbl (%eax),%eax
+ 292:	3c 39                	cmp    $0x39,%al
+ 294:	7e c7                	jle    25d <atoi+0x13>
+  return n;
+ 296:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 299:	c9                   	leave  
+ 29a:	c3                   	ret    
+
+0000029b <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 29b:	f3 0f 1e fb          	endbr32 
+ 29f:	55                   	push   %ebp
+ 2a0:	89 e5                	mov    %esp,%ebp
+ 2a2:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 2a5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2a8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2b1:	eb 17                	jmp    2ca <memmove+0x2f>
+    *dst++ = *src++;
+ 2b3:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 2b6:	8d 42 01             	lea    0x1(%edx),%eax
+ 2b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 2bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2bf:	8d 48 01             	lea    0x1(%eax),%ecx
+ 2c2:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 2c5:	0f b6 12             	movzbl (%edx),%edx
+ 2c8:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 2ca:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2cd:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 2d0:	89 55 10             	mov    %edx,0x10(%ebp)
+ 2d3:	85 c0                	test   %eax,%eax
+ 2d5:	7f dc                	jg     2b3 <memmove+0x18>
+  return vdst;
+ 2d7:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2da:	c9                   	leave  
+ 2db:	c3                   	ret    
+
+000002dc <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2dc:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2e1:	cd 40                	int    $0x40
+ 2e3:	c3                   	ret    
+
+000002e4 <exit>:
+SYSCALL(exit)
+ 2e4:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2e9:	cd 40                	int    $0x40
+ 2eb:	c3                   	ret    
+
+000002ec <wait>:
+SYSCALL(wait)
+ 2ec:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2f1:	cd 40                	int    $0x40
+ 2f3:	c3                   	ret    
+
+000002f4 <pipe>:
+SYSCALL(pipe)
+ 2f4:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2f9:	cd 40                	int    $0x40
+ 2fb:	c3                   	ret    
+
+000002fc <read>:
+SYSCALL(read)
+ 2fc:	b8 05 00 00 00       	mov    $0x5,%eax
+ 301:	cd 40                	int    $0x40
+ 303:	c3                   	ret    
+
+00000304 <write>:
+SYSCALL(write)
+ 304:	b8 10 00 00 00       	mov    $0x10,%eax
+ 309:	cd 40                	int    $0x40
+ 30b:	c3                   	ret    
+
+0000030c <close>:
+SYSCALL(close)
+ 30c:	b8 15 00 00 00       	mov    $0x15,%eax
+ 311:	cd 40                	int    $0x40
+ 313:	c3                   	ret    
+
+00000314 <kill>:
+SYSCALL(kill)
+ 314:	b8 06 00 00 00       	mov    $0x6,%eax
+ 319:	cd 40                	int    $0x40
+ 31b:	c3                   	ret    
+
+0000031c <exec>:
+SYSCALL(exec)
+ 31c:	b8 07 00 00 00       	mov    $0x7,%eax
+ 321:	cd 40                	int    $0x40
+ 323:	c3                   	ret    
+
+00000324 <open>:
+SYSCALL(open)
+ 324:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 329:	cd 40                	int    $0x40
+ 32b:	c3                   	ret    
+
+0000032c <mknod>:
+SYSCALL(mknod)
+ 32c:	b8 11 00 00 00       	mov    $0x11,%eax
+ 331:	cd 40                	int    $0x40
+ 333:	c3                   	ret    
+
+00000334 <unlink>:
+SYSCALL(unlink)
+ 334:	b8 12 00 00 00       	mov    $0x12,%eax
+ 339:	cd 40                	int    $0x40
+ 33b:	c3                   	ret    
+
+0000033c <fstat>:
+SYSCALL(fstat)
+ 33c:	b8 08 00 00 00       	mov    $0x8,%eax
+ 341:	cd 40                	int    $0x40
+ 343:	c3                   	ret    
+
+00000344 <link>:
+SYSCALL(link)
+ 344:	b8 13 00 00 00       	mov    $0x13,%eax
+ 349:	cd 40                	int    $0x40
+ 34b:	c3                   	ret    
+
+0000034c <mkdir>:
+SYSCALL(mkdir)
+ 34c:	b8 14 00 00 00       	mov    $0x14,%eax
+ 351:	cd 40                	int    $0x40
+ 353:	c3                   	ret    
+
+00000354 <chdir>:
+SYSCALL(chdir)
+ 354:	b8 09 00 00 00       	mov    $0x9,%eax
+ 359:	cd 40                	int    $0x40
+ 35b:	c3                   	ret    
+
+0000035c <dup>:
+SYSCALL(dup)
+ 35c:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 361:	cd 40                	int    $0x40
+ 363:	c3                   	ret    
+
+00000364 <getpid>:
+SYSCALL(getpid)
+ 364:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 369:	cd 40                	int    $0x40
+ 36b:	c3                   	ret    
+
+0000036c <sbrk>:
+SYSCALL(sbrk)
+ 36c:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 371:	cd 40                	int    $0x40
+ 373:	c3                   	ret    
+
+00000374 <sleep>:
+SYSCALL(sleep)
+ 374:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 379:	cd 40                	int    $0x40
+ 37b:	c3                   	ret    
+
+0000037c <uptime>:
+SYSCALL(uptime)
+ 37c:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 381:	cd 40                	int    $0x40
+ 383:	c3                   	ret    
+
+00000384 <draw>:
+SYSCALL(draw)
+ 384:	b8 16 00 00 00       	mov    $0x16,%eax
+ 389:	cd 40                	int    $0x40
+ 38b:	c3                   	ret    
+
+0000038c <cps>:
+SYSCALL(cps)
+ 38c:	b8 17 00 00 00       	mov    $0x17,%eax
+ 391:	cd 40                	int    $0x40
+ 393:	c3                   	ret    
+
+00000394 <yield>:
+SYSCALL(yield)
+ 394:	b8 18 00 00 00       	mov    $0x18,%eax
+ 399:	cd 40                	int    $0x40
+ 39b:	c3                   	ret    
+
+0000039c <wait2>:
+SYSCALL(wait2)
+ 39c:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3a1:	cd 40                	int    $0x40
+ 3a3:	c3                   	ret    
+
+000003a4 <set_prio>:
+SYSCALL(set_prio)
+ 3a4:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3a9:	cd 40                	int    $0x40
+ 3ab:	c3                   	ret    
+
+000003ac <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3ac:	f3 0f 1e fb          	endbr32 
+ 3b0:	55                   	push   %ebp
+ 3b1:	89 e5                	mov    %esp,%ebp
+ 3b3:	83 ec 18             	sub    $0x18,%esp
+ 3b6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3b9:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3bc:	83 ec 04             	sub    $0x4,%esp
+ 3bf:	6a 01                	push   $0x1
+ 3c1:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3c4:	50                   	push   %eax
+ 3c5:	ff 75 08             	pushl  0x8(%ebp)
+ 3c8:	e8 37 ff ff ff       	call   304 <write>
+ 3cd:	83 c4 10             	add    $0x10,%esp
+}
+ 3d0:	90                   	nop
+ 3d1:	c9                   	leave  
+ 3d2:	c3                   	ret    
+
+000003d3 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3d3:	f3 0f 1e fb          	endbr32 
+ 3d7:	55                   	push   %ebp
+ 3d8:	89 e5                	mov    %esp,%ebp
+ 3da:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3e4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3e8:	74 17                	je     401 <printint+0x2e>
+ 3ea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3ee:	79 11                	jns    401 <printint+0x2e>
+    neg = 1;
+ 3f0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 3f7:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3fa:	f7 d8                	neg    %eax
+ 3fc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 3ff:	eb 06                	jmp    407 <printint+0x34>
+  } else {
+    x = xx;
+ 401:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 404:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 407:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 40e:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 411:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 414:	ba 00 00 00 00       	mov    $0x0,%edx
+ 419:	f7 f1                	div    %ecx
+ 41b:	89 d1                	mov    %edx,%ecx
+ 41d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 420:	8d 50 01             	lea    0x1(%eax),%edx
+ 423:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 426:	0f b6 91 a8 0a 00 00 	movzbl 0xaa8(%ecx),%edx
+ 42d:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 431:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 434:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 437:	ba 00 00 00 00       	mov    $0x0,%edx
+ 43c:	f7 f1                	div    %ecx
+ 43e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 441:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 445:	75 c7                	jne    40e <printint+0x3b>
+  if(neg)
+ 447:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 44b:	74 2d                	je     47a <printint+0xa7>
+    buf[i++] = '-';
+ 44d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 450:	8d 50 01             	lea    0x1(%eax),%edx
+ 453:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 456:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 45b:	eb 1d                	jmp    47a <printint+0xa7>
+    putc(fd, buf[i]);
+ 45d:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 460:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 463:	01 d0                	add    %edx,%eax
+ 465:	0f b6 00             	movzbl (%eax),%eax
+ 468:	0f be c0             	movsbl %al,%eax
+ 46b:	83 ec 08             	sub    $0x8,%esp
+ 46e:	50                   	push   %eax
+ 46f:	ff 75 08             	pushl  0x8(%ebp)
+ 472:	e8 35 ff ff ff       	call   3ac <putc>
+ 477:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 47a:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 47e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 482:	79 d9                	jns    45d <printint+0x8a>
+}
+ 484:	90                   	nop
+ 485:	90                   	nop
+ 486:	c9                   	leave  
+ 487:	c3                   	ret    
+
+00000488 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 488:	f3 0f 1e fb          	endbr32 
+ 48c:	55                   	push   %ebp
+ 48d:	89 e5                	mov    %esp,%ebp
+ 48f:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 492:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 499:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 49c:	83 c0 04             	add    $0x4,%eax
+ 49f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 4a2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4a9:	e9 59 01 00 00       	jmp    607 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 4ae:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4b4:	01 d0                	add    %edx,%eax
+ 4b6:	0f b6 00             	movzbl (%eax),%eax
+ 4b9:	0f be c0             	movsbl %al,%eax
+ 4bc:	25 ff 00 00 00       	and    $0xff,%eax
+ 4c1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4c4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4c8:	75 2c                	jne    4f6 <printf+0x6e>
+      if(c == '%'){
+ 4ca:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4ce:	75 0c                	jne    4dc <printf+0x54>
+        state = '%';
+ 4d0:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4d7:	e9 27 01 00 00       	jmp    603 <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 4dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4df:	0f be c0             	movsbl %al,%eax
+ 4e2:	83 ec 08             	sub    $0x8,%esp
+ 4e5:	50                   	push   %eax
+ 4e6:	ff 75 08             	pushl  0x8(%ebp)
+ 4e9:	e8 be fe ff ff       	call   3ac <putc>
+ 4ee:	83 c4 10             	add    $0x10,%esp
+ 4f1:	e9 0d 01 00 00       	jmp    603 <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 4f6:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 4fa:	0f 85 03 01 00 00    	jne    603 <printf+0x17b>
+      if(c == 'd'){
+ 500:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 504:	75 1e                	jne    524 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 506:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 509:	8b 00                	mov    (%eax),%eax
+ 50b:	6a 01                	push   $0x1
+ 50d:	6a 0a                	push   $0xa
+ 50f:	50                   	push   %eax
+ 510:	ff 75 08             	pushl  0x8(%ebp)
+ 513:	e8 bb fe ff ff       	call   3d3 <printint>
+ 518:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 51b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 51f:	e9 d8 00 00 00       	jmp    5fc <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 524:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 528:	74 06                	je     530 <printf+0xa8>
+ 52a:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 52e:	75 1e                	jne    54e <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 530:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 533:	8b 00                	mov    (%eax),%eax
+ 535:	6a 00                	push   $0x0
+ 537:	6a 10                	push   $0x10
+ 539:	50                   	push   %eax
+ 53a:	ff 75 08             	pushl  0x8(%ebp)
+ 53d:	e8 91 fe ff ff       	call   3d3 <printint>
+ 542:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 545:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 549:	e9 ae 00 00 00       	jmp    5fc <printf+0x174>
+      } else if(c == 's'){
+ 54e:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 552:	75 43                	jne    597 <printf+0x10f>
+        s = (char*)*ap;
+ 554:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 557:	8b 00                	mov    (%eax),%eax
+ 559:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 55c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 560:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 564:	75 25                	jne    58b <printf+0x103>
+          s = "(null)";
+ 566:	c7 45 f4 58 08 00 00 	movl   $0x858,-0xc(%ebp)
+        while(*s != 0){
+ 56d:	eb 1c                	jmp    58b <printf+0x103>
+          putc(fd, *s);
+ 56f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 572:	0f b6 00             	movzbl (%eax),%eax
+ 575:	0f be c0             	movsbl %al,%eax
+ 578:	83 ec 08             	sub    $0x8,%esp
+ 57b:	50                   	push   %eax
+ 57c:	ff 75 08             	pushl  0x8(%ebp)
+ 57f:	e8 28 fe ff ff       	call   3ac <putc>
+ 584:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 587:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 58b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 58e:	0f b6 00             	movzbl (%eax),%eax
+ 591:	84 c0                	test   %al,%al
+ 593:	75 da                	jne    56f <printf+0xe7>
+ 595:	eb 65                	jmp    5fc <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 597:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 59b:	75 1d                	jne    5ba <printf+0x132>
+        putc(fd, *ap);
+ 59d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5a0:	8b 00                	mov    (%eax),%eax
+ 5a2:	0f be c0             	movsbl %al,%eax
+ 5a5:	83 ec 08             	sub    $0x8,%esp
+ 5a8:	50                   	push   %eax
+ 5a9:	ff 75 08             	pushl  0x8(%ebp)
+ 5ac:	e8 fb fd ff ff       	call   3ac <putc>
+ 5b1:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5b4:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5b8:	eb 42                	jmp    5fc <printf+0x174>
+      } else if(c == '%'){
+ 5ba:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5be:	75 17                	jne    5d7 <printf+0x14f>
+        putc(fd, c);
+ 5c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5c3:	0f be c0             	movsbl %al,%eax
+ 5c6:	83 ec 08             	sub    $0x8,%esp
+ 5c9:	50                   	push   %eax
+ 5ca:	ff 75 08             	pushl  0x8(%ebp)
+ 5cd:	e8 da fd ff ff       	call   3ac <putc>
+ 5d2:	83 c4 10             	add    $0x10,%esp
+ 5d5:	eb 25                	jmp    5fc <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 5d7:	83 ec 08             	sub    $0x8,%esp
+ 5da:	6a 25                	push   $0x25
+ 5dc:	ff 75 08             	pushl  0x8(%ebp)
+ 5df:	e8 c8 fd ff ff       	call   3ac <putc>
+ 5e4:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 5e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5ea:	0f be c0             	movsbl %al,%eax
+ 5ed:	83 ec 08             	sub    $0x8,%esp
+ 5f0:	50                   	push   %eax
+ 5f1:	ff 75 08             	pushl  0x8(%ebp)
+ 5f4:	e8 b3 fd ff ff       	call   3ac <putc>
+ 5f9:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 5fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 603:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 607:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 60a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 60d:	01 d0                	add    %edx,%eax
+ 60f:	0f b6 00             	movzbl (%eax),%eax
+ 612:	84 c0                	test   %al,%al
+ 614:	0f 85 94 fe ff ff    	jne    4ae <printf+0x26>
+    }
+  }
+}
+ 61a:	90                   	nop
+ 61b:	90                   	nop
+ 61c:	c9                   	leave  
+ 61d:	c3                   	ret    
+
+0000061e <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 61e:	f3 0f 1e fb          	endbr32 
+ 622:	55                   	push   %ebp
+ 623:	89 e5                	mov    %esp,%ebp
+ 625:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 628:	8b 45 08             	mov    0x8(%ebp),%eax
+ 62b:	83 e8 08             	sub    $0x8,%eax
+ 62e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 631:	a1 c4 0a 00 00       	mov    0xac4,%eax
+ 636:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 639:	eb 24                	jmp    65f <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 63b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 63e:	8b 00                	mov    (%eax),%eax
+ 640:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 643:	72 12                	jb     657 <free+0x39>
+ 645:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 648:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 64b:	77 24                	ja     671 <free+0x53>
+ 64d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 650:	8b 00                	mov    (%eax),%eax
+ 652:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 655:	72 1a                	jb     671 <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 657:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65a:	8b 00                	mov    (%eax),%eax
+ 65c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 65f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 662:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 665:	76 d4                	jbe    63b <free+0x1d>
+ 667:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 66a:	8b 00                	mov    (%eax),%eax
+ 66c:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 66f:	73 ca                	jae    63b <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 671:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 674:	8b 40 04             	mov    0x4(%eax),%eax
+ 677:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 67e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 681:	01 c2                	add    %eax,%edx
+ 683:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 686:	8b 00                	mov    (%eax),%eax
+ 688:	39 c2                	cmp    %eax,%edx
+ 68a:	75 24                	jne    6b0 <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 68c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 68f:	8b 50 04             	mov    0x4(%eax),%edx
+ 692:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 695:	8b 00                	mov    (%eax),%eax
+ 697:	8b 40 04             	mov    0x4(%eax),%eax
+ 69a:	01 c2                	add    %eax,%edx
+ 69c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69f:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a5:	8b 00                	mov    (%eax),%eax
+ 6a7:	8b 10                	mov    (%eax),%edx
+ 6a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ac:	89 10                	mov    %edx,(%eax)
+ 6ae:	eb 0a                	jmp    6ba <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b3:	8b 10                	mov    (%eax),%edx
+ 6b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6b8:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6bd:	8b 40 04             	mov    0x4(%eax),%eax
+ 6c0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ca:	01 d0                	add    %edx,%eax
+ 6cc:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6cf:	75 20                	jne    6f1 <free+0xd3>
+    p->s.size += bp->s.size;
+ 6d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d4:	8b 50 04             	mov    0x4(%eax),%edx
+ 6d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6da:	8b 40 04             	mov    0x4(%eax),%eax
+ 6dd:	01 c2                	add    %eax,%edx
+ 6df:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e2:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e8:	8b 10                	mov    (%eax),%edx
+ 6ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ed:	89 10                	mov    %edx,(%eax)
+ 6ef:	eb 08                	jmp    6f9 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 6f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f4:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 6f7:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 6f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6fc:	a3 c4 0a 00 00       	mov    %eax,0xac4
+}
+ 701:	90                   	nop
+ 702:	c9                   	leave  
+ 703:	c3                   	ret    
+
+00000704 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 704:	f3 0f 1e fb          	endbr32 
+ 708:	55                   	push   %ebp
+ 709:	89 e5                	mov    %esp,%ebp
+ 70b:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 70e:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 715:	77 07                	ja     71e <morecore+0x1a>
+    nu = 4096;
+ 717:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 71e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 721:	c1 e0 03             	shl    $0x3,%eax
+ 724:	83 ec 0c             	sub    $0xc,%esp
+ 727:	50                   	push   %eax
+ 728:	e8 3f fc ff ff       	call   36c <sbrk>
+ 72d:	83 c4 10             	add    $0x10,%esp
+ 730:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 733:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 737:	75 07                	jne    740 <morecore+0x3c>
+    return 0;
+ 739:	b8 00 00 00 00       	mov    $0x0,%eax
+ 73e:	eb 26                	jmp    766 <morecore+0x62>
+  hp = (Header*)p;
+ 740:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 743:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 746:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 749:	8b 55 08             	mov    0x8(%ebp),%edx
+ 74c:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 74f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 752:	83 c0 08             	add    $0x8,%eax
+ 755:	83 ec 0c             	sub    $0xc,%esp
+ 758:	50                   	push   %eax
+ 759:	e8 c0 fe ff ff       	call   61e <free>
+ 75e:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 761:	a1 c4 0a 00 00       	mov    0xac4,%eax
+}
+ 766:	c9                   	leave  
+ 767:	c3                   	ret    
+
+00000768 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 768:	f3 0f 1e fb          	endbr32 
+ 76c:	55                   	push   %ebp
+ 76d:	89 e5                	mov    %esp,%ebp
+ 76f:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 772:	8b 45 08             	mov    0x8(%ebp),%eax
+ 775:	83 c0 07             	add    $0x7,%eax
+ 778:	c1 e8 03             	shr    $0x3,%eax
+ 77b:	83 c0 01             	add    $0x1,%eax
+ 77e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 781:	a1 c4 0a 00 00       	mov    0xac4,%eax
+ 786:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 789:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 78d:	75 23                	jne    7b2 <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 78f:	c7 45 f0 bc 0a 00 00 	movl   $0xabc,-0x10(%ebp)
+ 796:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 799:	a3 c4 0a 00 00       	mov    %eax,0xac4
+ 79e:	a1 c4 0a 00 00       	mov    0xac4,%eax
+ 7a3:	a3 bc 0a 00 00       	mov    %eax,0xabc
+    base.s.size = 0;
+ 7a8:	c7 05 c0 0a 00 00 00 	movl   $0x0,0xac0
+ 7af:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7b5:	8b 00                	mov    (%eax),%eax
+ 7b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7bd:	8b 40 04             	mov    0x4(%eax),%eax
+ 7c0:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7c3:	77 4d                	ja     812 <malloc+0xaa>
+      if(p->s.size == nunits)
+ 7c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7c8:	8b 40 04             	mov    0x4(%eax),%eax
+ 7cb:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7ce:	75 0c                	jne    7dc <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 7d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7d3:	8b 10                	mov    (%eax),%edx
+ 7d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7d8:	89 10                	mov    %edx,(%eax)
+ 7da:	eb 26                	jmp    802 <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 7dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7df:	8b 40 04             	mov    0x4(%eax),%eax
+ 7e2:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 7e5:	89 c2                	mov    %eax,%edx
+ 7e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ea:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f0:	8b 40 04             	mov    0x4(%eax),%eax
+ 7f3:	c1 e0 03             	shl    $0x3,%eax
+ 7f6:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 7f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7fc:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 7ff:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 802:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 805:	a3 c4 0a 00 00       	mov    %eax,0xac4
+      return (void*)(p + 1);
+ 80a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80d:	83 c0 08             	add    $0x8,%eax
+ 810:	eb 3b                	jmp    84d <malloc+0xe5>
+    }
+    if(p == freep)
+ 812:	a1 c4 0a 00 00       	mov    0xac4,%eax
+ 817:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 81a:	75 1e                	jne    83a <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 81c:	83 ec 0c             	sub    $0xc,%esp
+ 81f:	ff 75 ec             	pushl  -0x14(%ebp)
+ 822:	e8 dd fe ff ff       	call   704 <morecore>
+ 827:	83 c4 10             	add    $0x10,%esp
+ 82a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 82d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 831:	75 07                	jne    83a <malloc+0xd2>
+        return 0;
+ 833:	b8 00 00 00 00       	mov    $0x0,%eax
+ 838:	eb 13                	jmp    84d <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 83a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 83d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 840:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 843:	8b 00                	mov    (%eax),%eax
+ 845:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 848:	e9 6d ff ff ff       	jmp    7ba <malloc+0x52>
+  }
+}
+ 84d:	c9                   	leave  
+ 84e:	c3                   	ret    
diff -ruN xv6-public/xv6-public/echo.c xv6-public_new/xv6-public/echo.c
--- xv6-public/xv6-public/echo.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/echo.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,13 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+
+  for(i = 1; i < argc; i++)
+    printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
+  exit();
+}
diff -ruN xv6-public/xv6-public/echo.d xv6-public_new/xv6-public/echo.d
--- xv6-public/xv6-public/echo.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/echo.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+echo.o: echo.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/echo.o and xv6-public_new/xv6-public/echo.o differ
diff -ruN xv6-public/xv6-public/echo.sym xv6-public_new/xv6-public/echo.sym
--- xv6-public/xv6-public/echo.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/echo.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+0000084f .rodata
+00000860 .eh_frame
+00000aa8 .data
+00000abc .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 echo.c
+00000000 ulib.c
+00000069 stosb
+00000000 printf.c
+000003ac putc
+000003d3 printint
+00000aa8 digits.1098
+00000000 umalloc.c
+00000abc base
+00000ac4 freep
+00000704 morecore
+0000008f strcpy
+00000394 yield
+000003a4 set_prio
+00000488 printf
+0000029b memmove
+0000032c mknod
+00000186 gets
+00000364 getpid
+00000768 malloc
+00000374 sleep
+0000039c wait2
+000002f4 pipe
+00000304 write
+0000033c fstat
+00000314 kill
+00000354 chdir
+0000031c exec
+000002ec wait
+000002fc read
+00000334 unlink
+000002dc fork
+0000036c sbrk
+0000037c uptime
+00000ab9 __bss_start
+00000131 memset
+00000000 main
+000000c3 strcmp
+0000035c dup
+000001f9 stat
+00000ab9 _edata
+00000ac8 _end
+00000344 link
+000002e4 exit
+0000024a atoi
+00000384 draw
+00000106 strlen
+00000324 open
+0000014f strchr
+0000038c cps
+0000034c mkdir
+0000030c close
+0000061e free
diff -ruN xv6-public/xv6-public/elf.h xv6-public_new/xv6-public/elf.h
--- xv6-public/xv6-public/elf.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/elf.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,42 @@
+// Format of an ELF executable file
+
+#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
+
+// File header
+struct elfhdr {
+  uint magic;  // must equal ELF_MAGIC
+  uchar elf[12];
+  ushort type;
+  ushort machine;
+  uint version;
+  uint entry;
+  uint phoff;
+  uint shoff;
+  uint flags;
+  ushort ehsize;
+  ushort phentsize;
+  ushort phnum;
+  ushort shentsize;
+  ushort shnum;
+  ushort shstrndx;
+};
+
+// Program section header
+struct proghdr {
+  uint type;
+  uint off;
+  uint vaddr;
+  uint paddr;
+  uint filesz;
+  uint memsz;
+  uint flags;
+  uint align;
+};
+
+// Values for Proghdr type
+#define ELF_PROG_LOAD           1
+
+// Flag bits for Proghdr flags
+#define ELF_PROG_FLAG_EXEC      1
+#define ELF_PROG_FLAG_WRITE     2
+#define ELF_PROG_FLAG_READ      4
diff -ruN xv6-public/xv6-public/entry.S xv6-public_new/xv6-public/entry.S
--- xv6-public/xv6-public/entry.S	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/entry.S	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,68 @@
+# The xv6 kernel starts executing in this file. This file is linked with
+# the kernel C code, so it can refer to kernel symbols such as main().
+# The boot block (bootasm.S and bootmain.c) jumps to entry below.
+        
+# Multiboot header, for multiboot boot loaders like GNU Grub.
+# http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
+#
+# Using GRUB 2, you can boot xv6 from a file stored in a
+# Linux file system by copying kernel or kernelmemfs to /boot
+# and then adding this menu entry:
+#
+# menuentry "xv6" {
+# 	insmod ext2
+# 	set root='(hd0,msdos1)'
+# 	set kernel='/boot/kernel'
+# 	echo "Loading ${kernel}..."
+# 	multiboot ${kernel} ${kernel}
+# 	boot
+# }
+
+#include "asm.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "param.h"
+
+# Multiboot header.  Data to direct multiboot loader.
+.p2align 2
+.text
+.globl multiboot_header
+multiboot_header:
+  #define magic 0x1badb002
+  #define flags 0
+  .long magic
+  .long flags
+  .long (-magic-flags)
+
+# By convention, the _start symbol specifies the ELF entry point.
+# Since we haven't set up virtual memory yet, our entry point is
+# the physical address of 'entry'.
+.globl _start
+_start = V2P_WO(entry)
+
+# Entering xv6 on boot processor, with paging off.
+.globl entry
+entry:
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+  orl     $(CR4_PSE), %eax
+  movl    %eax, %cr4
+  # Set page directory
+  movl    $(V2P_WO(entrypgdir)), %eax
+  movl    %eax, %cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+  orl     $(CR0_PG|CR0_WP), %eax
+  movl    %eax, %cr0
+
+  # Set up the stack pointer.
+  movl $(stack + KSTACKSIZE), %esp
+
+  # Jump to main(), and switch to executing at
+  # high addresses. The indirect call is needed because
+  # the assembler produces a PC-relative instruction
+  # for a direct jump.
+  mov $main, %eax
+  jmp *%eax
+
+.comm stack, KSTACKSIZE
Binary files xv6-public/xv6-public/entry.o and xv6-public_new/xv6-public/entry.o differ
Binary files xv6-public/xv6-public/entryother and xv6-public_new/xv6-public/entryother differ
diff -ruN xv6-public/xv6-public/entryother.S xv6-public_new/xv6-public/entryother.S
--- xv6-public/xv6-public/entryother.S	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/entryother.S	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,93 @@
+#include "asm.h"
+#include "memlayout.h"
+#include "mmu.h"
+	
+# Each non-boot CPU ("AP") is started up in response to a STARTUP
+# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
+# Specification says that the AP will start in real mode with CS:IP
+# set to XY00:0000, where XY is an 8-bit value sent with the
+# STARTUP. Thus this code must start at a 4096-byte boundary.
+#
+# Because this code sets DS to zero, it must sit
+# at an address in the low 2^16 bytes.
+#
+# Startothers (in main.c) sends the STARTUPs one at a time.
+# It copies this code (start) at 0x7000.  It puts the address of
+# a newly allocated per-core stack in start-4,the address of the
+# place to jump to (mpenter) in start-8, and the physical address
+# of entrypgdir in start-12.
+#
+# This code combines elements of bootasm.S and entry.S.
+
+.code16           
+.globl start
+start:
+  cli            
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax
+  movw    %ax,%ds
+  movw    %ax,%es
+  movw    %ax,%ss
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+  movl    %cr0, %eax
+  orl     $CR0_PE, %eax
+  movl    %eax, %cr0
+
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmpl    $(SEG_KCODE<<3), $(start32)
+
+//PAGEBREAK!
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+  movw    %ax, %ds                # -> DS: Data Segment
+  movw    %ax, %es                # -> ES: Extra Segment
+  movw    %ax, %ss                # -> SS: Stack Segment
+  movw    $0, %ax                 # Zero segments not ready for use
+  movw    %ax, %fs                # -> FS
+  movw    %ax, %gs                # -> GS
+
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+  orl     $(CR4_PSE), %eax
+  movl    %eax, %cr4
+  # Use entrypgdir as our initial page table
+  movl    (start-12), %eax
+  movl    %eax, %cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+  movl    %eax, %cr0
+
+  # Switch to the stack allocated by startothers()
+  movl    (start-4), %esp
+  # Call mpenter()
+  call	 *(start-8)
+
+  movw    $0x8a00, %ax
+  movw    %ax, %dx
+  outw    %ax, %dx
+  movw    $0x8ae0, %ax
+  outw    %ax, %dx
+spin:
+  jmp     spin
+
+.p2align 2
+gdt:
+  SEG_NULLASM
+  SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
+  SEG_ASM(STA_W, 0, 0xffffffff)
+
+
+gdtdesc:
+  .word   (gdtdesc - gdt - 1)
+  .long   gdt
+
diff -ruN xv6-public/xv6-public/entryother.asm xv6-public_new/xv6-public/entryother.asm
--- xv6-public/xv6-public/entryother.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/entryother.asm	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,125 @@
+
+bootblockother.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007000 <start>:
+# This code combines elements of bootasm.S and entry.S.
+
+.code16           
+.globl start
+start:
+  cli            
+    7000:	fa                   	cli    
+
+  # Zero data segment registers DS, ES, and SS.
+  xorw    %ax,%ax
+    7001:	31 c0                	xor    %eax,%eax
+  movw    %ax,%ds
+    7003:	8e d8                	mov    %eax,%ds
+  movw    %ax,%es
+    7005:	8e c0                	mov    %eax,%es
+  movw    %ax,%ss
+    7007:	8e d0                	mov    %eax,%ss
+
+  # Switch from real to protected mode.  Use a bootstrap GDT that makes
+  # virtual addresses map directly to physical addresses so that the
+  # effective memory map doesn't change during the transition.
+  lgdt    gdtdesc
+    7009:	0f 01 16             	lgdtl  (%esi)
+    700c:	84 70 0f             	test   %dh,0xf(%eax)
+  movl    %cr0, %eax
+    700f:	20 c0                	and    %al,%al
+  orl     $CR0_PE, %eax
+    7011:	66 83 c8 01          	or     $0x1,%ax
+  movl    %eax, %cr0
+    7015:	0f 22 c0             	mov    %eax,%cr0
+
+  # Complete the transition to 32-bit protected mode by using a long jmp
+  # to reload %cs and %eip.  The segment descriptors are set up with no
+  # translation, so that the mapping is still the identity mapping.
+  ljmpl    $(SEG_KCODE<<3), $(start32)
+    7018:	66 ea 20 70 00 00    	ljmpw  $0x0,$0x7020
+    701e:	08 00                	or     %al,(%eax)
+
+00007020 <start32>:
+
+//PAGEBREAK!
+.code32  # Tell assembler to generate 32-bit code now.
+start32:
+  # Set up the protected-mode data segment registers
+  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+    7020:	66 b8 10 00          	mov    $0x10,%ax
+  movw    %ax, %ds                # -> DS: Data Segment
+    7024:	8e d8                	mov    %eax,%ds
+  movw    %ax, %es                # -> ES: Extra Segment
+    7026:	8e c0                	mov    %eax,%es
+  movw    %ax, %ss                # -> SS: Stack Segment
+    7028:	8e d0                	mov    %eax,%ss
+  movw    $0, %ax                 # Zero segments not ready for use
+    702a:	66 b8 00 00          	mov    $0x0,%ax
+  movw    %ax, %fs                # -> FS
+    702e:	8e e0                	mov    %eax,%fs
+  movw    %ax, %gs                # -> GS
+    7030:	8e e8                	mov    %eax,%gs
+
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+    7032:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+    7035:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+    7038:	0f 22 e0             	mov    %eax,%cr4
+  # Use entrypgdir as our initial page table
+  movl    (start-12), %eax
+    703b:	a1 f4 6f 00 00       	mov    0x6ff4,%eax
+  movl    %eax, %cr3
+    7040:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+    7043:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
+    7046:	0d 01 00 01 80       	or     $0x80010001,%eax
+  movl    %eax, %cr0
+    704b:	0f 22 c0             	mov    %eax,%cr0
+
+  # Switch to the stack allocated by startothers()
+  movl    (start-4), %esp
+    704e:	8b 25 fc 6f 00 00    	mov    0x6ffc,%esp
+  # Call mpenter()
+  call	 *(start-8)
+    7054:	ff 15 f8 6f 00 00    	call   *0x6ff8
+
+  movw    $0x8a00, %ax
+    705a:	66 b8 00 8a          	mov    $0x8a00,%ax
+  movw    %ax, %dx
+    705e:	66 89 c2             	mov    %ax,%dx
+  outw    %ax, %dx
+    7061:	66 ef                	out    %ax,(%dx)
+  movw    $0x8ae0, %ax
+    7063:	66 b8 e0 8a          	mov    $0x8ae0,%ax
+  outw    %ax, %dx
+    7067:	66 ef                	out    %ax,(%dx)
+
+00007069 <spin>:
+spin:
+  jmp     spin
+    7069:	eb fe                	jmp    7069 <spin>
+    706b:	90                   	nop
+
+0000706c <gdt>:
+	...
+    7074:	ff                   	(bad)  
+    7075:	ff 00                	incl   (%eax)
+    7077:	00 00                	add    %al,(%eax)
+    7079:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7080:	00                   	.byte 0x0
+    7081:	92                   	xchg   %eax,%edx
+    7082:	cf                   	iret   
+	...
+
+00007084 <gdtdesc>:
+    7084:	17                   	pop    %ss
+    7085:	00 6c 70 00          	add    %ch,0x0(%eax,%esi,2)
+	...
diff -ruN xv6-public/xv6-public/entryother.d xv6-public_new/xv6-public/entryother.d
--- xv6-public/xv6-public/entryother.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/entryother.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1 @@
+entryother.o: entryother.S asm.h memlayout.h mmu.h
Binary files xv6-public/xv6-public/entryother.o and xv6-public_new/xv6-public/entryother.o differ
diff -ruN xv6-public/xv6-public/exec.c xv6-public_new/xv6-public/exec.c
--- xv6-public/xv6-public/exec.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/exec.c	2021-09-30 23:30:52.000000000 +0530
@@ -0,0 +1,119 @@
+#include "types.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "defs.h"
+#include "x86.h"
+#include "elf.h"
+
+int
+exec(char *path, char **argv)
+{
+  char *s, *last;
+  int i, off;
+  uint argc, sz, sp, ustack[3+MAXARG+1];
+  struct elfhdr elf;
+  struct inode *ip;
+  struct proghdr ph;
+  pde_t *pgdir, *oldpgdir;
+  struct proc *curproc = myproc();
+
+  begin_op();
+
+  if((ip = namei(path)) == 0){
+    end_op();
+    cprintf("exec: fail\n");
+    return -1;
+  }
+  ilock(ip);
+  pgdir = 0;
+
+  // Check ELF header
+  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+    goto bad;
+  if(elf.magic != ELF_MAGIC)
+    goto bad;
+
+  if((pgdir = setupkvm()) == 0)
+    goto bad;
+
+  // Load program into memory.
+  sz = 0;
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+      goto bad;
+    if(ph.type != ELF_PROG_LOAD)
+      continue;
+    if(ph.memsz < ph.filesz)
+      goto bad;
+    if(ph.vaddr + ph.memsz < ph.vaddr)
+      goto bad;
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+      goto bad;
+    if(ph.vaddr % PGSIZE != 0)
+      goto bad;
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+      goto bad;
+  }
+  iunlockput(ip);
+  end_op();
+  ip = 0;
+
+  // Allocate two pages at the next page boundary.
+  // Make the first inaccessible.  Use the second as the user stack.
+  sz = PGROUNDUP(sz);
+  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+    goto bad;
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+  sp = sz;
+
+  // Push argument strings, prepare rest of stack in ustack.
+  for(argc = 0; argv[argc]; argc++) {
+    if(argc >= MAXARG)
+      goto bad;
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+      goto bad;
+    ustack[3+argc] = sp;
+  }
+  ustack[3+argc] = 0;
+
+  ustack[0] = 0xffffffff;  // fake return PC
+  ustack[1] = argc;
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+
+  sp -= (3+argc+1) * 4;
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+    goto bad;
+
+  // Save program name for debugging.
+  for(last=s=path; *s; s++)
+    if(*s == '/')
+      last = s+1;
+  safestrcpy(curproc->name, last, sizeof(curproc->name));
+
+  // Commit to the user image.
+  oldpgdir = curproc->pgdir;
+  curproc->pgdir = pgdir;
+  curproc->sz = sz;
+  curproc->tf->eip = elf.entry;  // main
+  curproc->tf->esp = sp;
+  // Calling the exec system call resets
+  // the process priority to 2(default priority).  
+  #ifdef DML
+  proc->priority = 2;
+  #endif
+  switchuvm(curproc);
+  freevm(oldpgdir);
+  return 0;
+
+ bad:
+  if(pgdir)
+    freevm(pgdir);
+  if(ip){
+    iunlockput(ip);
+    end_op();
+  }
+  return -1;
+}
diff -ruN xv6-public/xv6-public/exec.d xv6-public_new/xv6-public/exec.d
--- xv6-public/xv6-public/exec.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/exec.d	2021-09-30 23:28:54.000000000 +0530
@@ -0,0 +1,2 @@
+exec.o: exec.c /usr/include/stdc-predef.h types.h param.h memlayout.h \
+ mmu.h proc.h defs.h x86.h elf.h
Binary files xv6-public/xv6-public/exec.o and xv6-public_new/xv6-public/exec.o differ
diff -ruN xv6-public/xv6-public/fcntl.h xv6-public_new/xv6-public/fcntl.h
--- xv6-public/xv6-public/fcntl.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/fcntl.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,4 @@
+#define O_RDONLY  0x000
+#define O_WRONLY  0x001
+#define O_RDWR    0x002
+#define O_CREATE  0x200
diff -ruN xv6-public/xv6-public/file.c xv6-public_new/xv6-public/file.c
--- xv6-public/xv6-public/file.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/file.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,157 @@
+//
+// File descriptors
+//
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "file.h"
+
+struct devsw devsw[NDEV];
+struct {
+  struct spinlock lock;
+  struct file file[NFILE];
+} ftable;
+
+void
+fileinit(void)
+{
+  initlock(&ftable.lock, "ftable");
+}
+
+// Allocate a file structure.
+struct file*
+filealloc(void)
+{
+  struct file *f;
+
+  acquire(&ftable.lock);
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+    if(f->ref == 0){
+      f->ref = 1;
+      release(&ftable.lock);
+      return f;
+    }
+  }
+  release(&ftable.lock);
+  return 0;
+}
+
+// Increment ref count for file f.
+struct file*
+filedup(struct file *f)
+{
+  acquire(&ftable.lock);
+  if(f->ref < 1)
+    panic("filedup");
+  f->ref++;
+  release(&ftable.lock);
+  return f;
+}
+
+// Close file f.  (Decrement ref count, close when reaches 0.)
+void
+fileclose(struct file *f)
+{
+  struct file ff;
+
+  acquire(&ftable.lock);
+  if(f->ref < 1)
+    panic("fileclose");
+  if(--f->ref > 0){
+    release(&ftable.lock);
+    return;
+  }
+  ff = *f;
+  f->ref = 0;
+  f->type = FD_NONE;
+  release(&ftable.lock);
+
+  if(ff.type == FD_PIPE)
+    pipeclose(ff.pipe, ff.writable);
+  else if(ff.type == FD_INODE){
+    begin_op();
+    iput(ff.ip);
+    end_op();
+  }
+}
+
+// Get metadata about file f.
+int
+filestat(struct file *f, struct stat *st)
+{
+  if(f->type == FD_INODE){
+    ilock(f->ip);
+    stati(f->ip, st);
+    iunlock(f->ip);
+    return 0;
+  }
+  return -1;
+}
+
+// Read from file f.
+int
+fileread(struct file *f, char *addr, int n)
+{
+  int r;
+
+  if(f->readable == 0)
+    return -1;
+  if(f->type == FD_PIPE)
+    return piperead(f->pipe, addr, n);
+  if(f->type == FD_INODE){
+    ilock(f->ip);
+    if((r = readi(f->ip, addr, f->off, n)) > 0)
+      f->off += r;
+    iunlock(f->ip);
+    return r;
+  }
+  panic("fileread");
+}
+
+//PAGEBREAK!
+// Write to file f.
+int
+filewrite(struct file *f, char *addr, int n)
+{
+  int r;
+
+  if(f->writable == 0)
+    return -1;
+  if(f->type == FD_PIPE)
+    return pipewrite(f->pipe, addr, n);
+  if(f->type == FD_INODE){
+    // write a few blocks at a time to avoid exceeding
+    // the maximum log transaction size, including
+    // i-node, indirect block, allocation blocks,
+    // and 2 blocks of slop for non-aligned writes.
+    // this really belongs lower down, since writei()
+    // might be writing a device like the console.
+    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+    int i = 0;
+    while(i < n){
+      int n1 = n - i;
+      if(n1 > max)
+        n1 = max;
+
+      begin_op();
+      ilock(f->ip);
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+        f->off += r;
+      iunlock(f->ip);
+      end_op();
+
+      if(r < 0)
+        break;
+      if(r != n1)
+        panic("short filewrite");
+      i += r;
+    }
+    return i == n ? n : -1;
+  }
+  panic("filewrite");
+}
+
diff -ruN xv6-public/xv6-public/file.d xv6-public_new/xv6-public/file.d
--- xv6-public/xv6-public/file.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/file.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,2 @@
+file.o: file.c /usr/include/stdc-predef.h types.h defs.h param.h fs.h \
+ spinlock.h sleeplock.h file.h
diff -ruN xv6-public/xv6-public/file.h xv6-public_new/xv6-public/file.h
--- xv6-public/xv6-public/file.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/file.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,37 @@
+struct file {
+  enum { FD_NONE, FD_PIPE, FD_INODE } type;
+  int ref; // reference count
+  char readable;
+  char writable;
+  struct pipe *pipe;
+  struct inode *ip;
+  uint off;
+};
+
+
+// in-memory copy of an inode
+struct inode {
+  uint dev;           // Device number
+  uint inum;          // Inode number
+  int ref;            // Reference count
+  struct sleeplock lock; // protects everything below here
+  int valid;          // inode has been read from disk?
+
+  short type;         // copy of disk inode
+  short major;
+  short minor;
+  short nlink;
+  uint size;
+  uint addrs[NDIRECT+1];
+};
+
+// table mapping major device number to
+// device functions
+struct devsw {
+  int (*read)(struct inode*, char*, int);
+  int (*write)(struct inode*, char*, int);
+};
+
+extern struct devsw devsw[];
+
+#define CONSOLE 1
Binary files xv6-public/xv6-public/file.o and xv6-public_new/xv6-public/file.o differ
diff -ruN xv6-public/xv6-public/forktest.asm xv6-public_new/xv6-public/forktest.asm
--- xv6-public/xv6-public/forktest.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/forktest.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,691 @@
+
+_forktest:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <printf>:
+
+#define N  1000
+
+void
+printf(int fd, const char *s, ...)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	55                   	push   %ebp
+   5:	89 e5                	mov    %esp,%ebp
+   7:	83 ec 08             	sub    $0x8,%esp
+  write(fd, s, strlen(s));
+   a:	83 ec 0c             	sub    $0xc,%esp
+   d:	ff 75 0c             	pushl  0xc(%ebp)
+  10:	e8 9c 01 00 00       	call   1b1 <strlen>
+  15:	83 c4 10             	add    $0x10,%esp
+  18:	83 ec 04             	sub    $0x4,%esp
+  1b:	50                   	push   %eax
+  1c:	ff 75 0c             	pushl  0xc(%ebp)
+  1f:	ff 75 08             	pushl  0x8(%ebp)
+  22:	e8 88 03 00 00       	call   3af <write>
+  27:	83 c4 10             	add    $0x10,%esp
+}
+  2a:	90                   	nop
+  2b:	c9                   	leave  
+  2c:	c3                   	ret    
+
+0000002d <forktest>:
+
+void
+forktest(void)
+{
+  2d:	f3 0f 1e fb          	endbr32 
+  31:	55                   	push   %ebp
+  32:	89 e5                	mov    %esp,%ebp
+  34:	83 ec 18             	sub    $0x18,%esp
+  int n, pid;
+
+  printf(1, "fork test\n");
+  37:	83 ec 08             	sub    $0x8,%esp
+  3a:	68 58 04 00 00       	push   $0x458
+  3f:	6a 01                	push   $0x1
+  41:	e8 ba ff ff ff       	call   0 <printf>
+  46:	83 c4 10             	add    $0x10,%esp
+
+  for(n=0; n<N; n++){
+  49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  50:	eb 1d                	jmp    6f <forktest+0x42>
+    pid = fork();
+  52:	e8 30 03 00 00       	call   387 <fork>
+  57:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(pid < 0)
+  5a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  5e:	78 1a                	js     7a <forktest+0x4d>
+      break;
+    if(pid == 0)
+  60:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  64:	75 05                	jne    6b <forktest+0x3e>
+      exit();
+  66:	e8 24 03 00 00       	call   38f <exit>
+  for(n=0; n<N; n++){
+  6b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  6f:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
+  76:	7e da                	jle    52 <forktest+0x25>
+  78:	eb 01                	jmp    7b <forktest+0x4e>
+      break;
+  7a:	90                   	nop
+  }
+
+  if(n == N){
+  7b:	81 7d f4 e8 03 00 00 	cmpl   $0x3e8,-0xc(%ebp)
+  82:	75 40                	jne    c4 <forktest+0x97>
+    printf(1, "fork claimed to work N times!\n", N);
+  84:	83 ec 04             	sub    $0x4,%esp
+  87:	68 e8 03 00 00       	push   $0x3e8
+  8c:	68 64 04 00 00       	push   $0x464
+  91:	6a 01                	push   $0x1
+  93:	e8 68 ff ff ff       	call   0 <printf>
+  98:	83 c4 10             	add    $0x10,%esp
+    exit();
+  9b:	e8 ef 02 00 00       	call   38f <exit>
+  }
+
+  for(; n > 0; n--){
+    if(wait() < 0){
+  a0:	e8 f2 02 00 00       	call   397 <wait>
+  a5:	85 c0                	test   %eax,%eax
+  a7:	79 17                	jns    c0 <forktest+0x93>
+      printf(1, "wait stopped early\n");
+  a9:	83 ec 08             	sub    $0x8,%esp
+  ac:	68 83 04 00 00       	push   $0x483
+  b1:	6a 01                	push   $0x1
+  b3:	e8 48 ff ff ff       	call   0 <printf>
+  b8:	83 c4 10             	add    $0x10,%esp
+      exit();
+  bb:	e8 cf 02 00 00       	call   38f <exit>
+  for(; n > 0; n--){
+  c0:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  c8:	7f d6                	jg     a0 <forktest+0x73>
+    }
+  }
+
+  if(wait() != -1){
+  ca:	e8 c8 02 00 00       	call   397 <wait>
+  cf:	83 f8 ff             	cmp    $0xffffffff,%eax
+  d2:	74 17                	je     eb <forktest+0xbe>
+    printf(1, "wait got too many\n");
+  d4:	83 ec 08             	sub    $0x8,%esp
+  d7:	68 97 04 00 00       	push   $0x497
+  dc:	6a 01                	push   $0x1
+  de:	e8 1d ff ff ff       	call   0 <printf>
+  e3:	83 c4 10             	add    $0x10,%esp
+    exit();
+  e6:	e8 a4 02 00 00       	call   38f <exit>
+  }
+
+  printf(1, "fork test OK\n");
+  eb:	83 ec 08             	sub    $0x8,%esp
+  ee:	68 aa 04 00 00       	push   $0x4aa
+  f3:	6a 01                	push   $0x1
+  f5:	e8 06 ff ff ff       	call   0 <printf>
+  fa:	83 c4 10             	add    $0x10,%esp
+}
+  fd:	90                   	nop
+  fe:	c9                   	leave  
+  ff:	c3                   	ret    
+
+00000100 <main>:
+
+int
+main(void)
+{
+ 100:	f3 0f 1e fb          	endbr32 
+ 104:	55                   	push   %ebp
+ 105:	89 e5                	mov    %esp,%ebp
+ 107:	83 e4 f0             	and    $0xfffffff0,%esp
+  forktest();
+ 10a:	e8 1e ff ff ff       	call   2d <forktest>
+  exit();
+ 10f:	e8 7b 02 00 00       	call   38f <exit>
+
+00000114 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 114:	55                   	push   %ebp
+ 115:	89 e5                	mov    %esp,%ebp
+ 117:	57                   	push   %edi
+ 118:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 119:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 11c:	8b 55 10             	mov    0x10(%ebp),%edx
+ 11f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 122:	89 cb                	mov    %ecx,%ebx
+ 124:	89 df                	mov    %ebx,%edi
+ 126:	89 d1                	mov    %edx,%ecx
+ 128:	fc                   	cld    
+ 129:	f3 aa                	rep stos %al,%es:(%edi)
+ 12b:	89 ca                	mov    %ecx,%edx
+ 12d:	89 fb                	mov    %edi,%ebx
+ 12f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 132:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 135:	90                   	nop
+ 136:	5b                   	pop    %ebx
+ 137:	5f                   	pop    %edi
+ 138:	5d                   	pop    %ebp
+ 139:	c3                   	ret    
+
+0000013a <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 13a:	f3 0f 1e fb          	endbr32 
+ 13e:	55                   	push   %ebp
+ 13f:	89 e5                	mov    %esp,%ebp
+ 141:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 144:	8b 45 08             	mov    0x8(%ebp),%eax
+ 147:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 14a:	90                   	nop
+ 14b:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 14e:	8d 42 01             	lea    0x1(%edx),%eax
+ 151:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 154:	8b 45 08             	mov    0x8(%ebp),%eax
+ 157:	8d 48 01             	lea    0x1(%eax),%ecx
+ 15a:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 15d:	0f b6 12             	movzbl (%edx),%edx
+ 160:	88 10                	mov    %dl,(%eax)
+ 162:	0f b6 00             	movzbl (%eax),%eax
+ 165:	84 c0                	test   %al,%al
+ 167:	75 e2                	jne    14b <strcpy+0x11>
+    ;
+  return os;
+ 169:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 16c:	c9                   	leave  
+ 16d:	c3                   	ret    
+
+0000016e <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 16e:	f3 0f 1e fb          	endbr32 
+ 172:	55                   	push   %ebp
+ 173:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 175:	eb 08                	jmp    17f <strcmp+0x11>
+    p++, q++;
+ 177:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 17b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 17f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 182:	0f b6 00             	movzbl (%eax),%eax
+ 185:	84 c0                	test   %al,%al
+ 187:	74 10                	je     199 <strcmp+0x2b>
+ 189:	8b 45 08             	mov    0x8(%ebp),%eax
+ 18c:	0f b6 10             	movzbl (%eax),%edx
+ 18f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 192:	0f b6 00             	movzbl (%eax),%eax
+ 195:	38 c2                	cmp    %al,%dl
+ 197:	74 de                	je     177 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 199:	8b 45 08             	mov    0x8(%ebp),%eax
+ 19c:	0f b6 00             	movzbl (%eax),%eax
+ 19f:	0f b6 d0             	movzbl %al,%edx
+ 1a2:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1a5:	0f b6 00             	movzbl (%eax),%eax
+ 1a8:	0f b6 c0             	movzbl %al,%eax
+ 1ab:	29 c2                	sub    %eax,%edx
+ 1ad:	89 d0                	mov    %edx,%eax
+}
+ 1af:	5d                   	pop    %ebp
+ 1b0:	c3                   	ret    
+
+000001b1 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 1b1:	f3 0f 1e fb          	endbr32 
+ 1b5:	55                   	push   %ebp
+ 1b6:	89 e5                	mov    %esp,%ebp
+ 1b8:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1bb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 1c2:	eb 04                	jmp    1c8 <strlen+0x17>
+ 1c4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 1c8:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 1cb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ce:	01 d0                	add    %edx,%eax
+ 1d0:	0f b6 00             	movzbl (%eax),%eax
+ 1d3:	84 c0                	test   %al,%al
+ 1d5:	75 ed                	jne    1c4 <strlen+0x13>
+    ;
+  return n;
+ 1d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1da:	c9                   	leave  
+ 1db:	c3                   	ret    
+
+000001dc <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1dc:	f3 0f 1e fb          	endbr32 
+ 1e0:	55                   	push   %ebp
+ 1e1:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 1e3:	8b 45 10             	mov    0x10(%ebp),%eax
+ 1e6:	50                   	push   %eax
+ 1e7:	ff 75 0c             	pushl  0xc(%ebp)
+ 1ea:	ff 75 08             	pushl  0x8(%ebp)
+ 1ed:	e8 22 ff ff ff       	call   114 <stosb>
+ 1f2:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1f8:	c9                   	leave  
+ 1f9:	c3                   	ret    
+
+000001fa <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 1fa:	f3 0f 1e fb          	endbr32 
+ 1fe:	55                   	push   %ebp
+ 1ff:	89 e5                	mov    %esp,%ebp
+ 201:	83 ec 04             	sub    $0x4,%esp
+ 204:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 207:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 20a:	eb 14                	jmp    220 <strchr+0x26>
+    if(*s == c)
+ 20c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20f:	0f b6 00             	movzbl (%eax),%eax
+ 212:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 215:	75 05                	jne    21c <strchr+0x22>
+      return (char*)s;
+ 217:	8b 45 08             	mov    0x8(%ebp),%eax
+ 21a:	eb 13                	jmp    22f <strchr+0x35>
+  for(; *s; s++)
+ 21c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 220:	8b 45 08             	mov    0x8(%ebp),%eax
+ 223:	0f b6 00             	movzbl (%eax),%eax
+ 226:	84 c0                	test   %al,%al
+ 228:	75 e2                	jne    20c <strchr+0x12>
+  return 0;
+ 22a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 22f:	c9                   	leave  
+ 230:	c3                   	ret    
+
+00000231 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 231:	f3 0f 1e fb          	endbr32 
+ 235:	55                   	push   %ebp
+ 236:	89 e5                	mov    %esp,%ebp
+ 238:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 23b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 242:	eb 42                	jmp    286 <gets+0x55>
+    cc = read(0, &c, 1);
+ 244:	83 ec 04             	sub    $0x4,%esp
+ 247:	6a 01                	push   $0x1
+ 249:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 24c:	50                   	push   %eax
+ 24d:	6a 00                	push   $0x0
+ 24f:	e8 53 01 00 00       	call   3a7 <read>
+ 254:	83 c4 10             	add    $0x10,%esp
+ 257:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 25a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 25e:	7e 33                	jle    293 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 260:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 263:	8d 50 01             	lea    0x1(%eax),%edx
+ 266:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 269:	89 c2                	mov    %eax,%edx
+ 26b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 26e:	01 c2                	add    %eax,%edx
+ 270:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 274:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 276:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 27a:	3c 0a                	cmp    $0xa,%al
+ 27c:	74 16                	je     294 <gets+0x63>
+ 27e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 282:	3c 0d                	cmp    $0xd,%al
+ 284:	74 0e                	je     294 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 286:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 289:	83 c0 01             	add    $0x1,%eax
+ 28c:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 28f:	7f b3                	jg     244 <gets+0x13>
+ 291:	eb 01                	jmp    294 <gets+0x63>
+      break;
+ 293:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 294:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 297:	8b 45 08             	mov    0x8(%ebp),%eax
+ 29a:	01 d0                	add    %edx,%eax
+ 29c:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 29f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2a2:	c9                   	leave  
+ 2a3:	c3                   	ret    
+
+000002a4 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 2a4:	f3 0f 1e fb          	endbr32 
+ 2a8:	55                   	push   %ebp
+ 2a9:	89 e5                	mov    %esp,%ebp
+ 2ab:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2ae:	83 ec 08             	sub    $0x8,%esp
+ 2b1:	6a 00                	push   $0x0
+ 2b3:	ff 75 08             	pushl  0x8(%ebp)
+ 2b6:	e8 14 01 00 00       	call   3cf <open>
+ 2bb:	83 c4 10             	add    $0x10,%esp
+ 2be:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 2c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 2c5:	79 07                	jns    2ce <stat+0x2a>
+    return -1;
+ 2c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 2cc:	eb 25                	jmp    2f3 <stat+0x4f>
+  r = fstat(fd, st);
+ 2ce:	83 ec 08             	sub    $0x8,%esp
+ 2d1:	ff 75 0c             	pushl  0xc(%ebp)
+ 2d4:	ff 75 f4             	pushl  -0xc(%ebp)
+ 2d7:	e8 0b 01 00 00       	call   3e7 <fstat>
+ 2dc:	83 c4 10             	add    $0x10,%esp
+ 2df:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 2e2:	83 ec 0c             	sub    $0xc,%esp
+ 2e5:	ff 75 f4             	pushl  -0xc(%ebp)
+ 2e8:	e8 ca 00 00 00       	call   3b7 <close>
+ 2ed:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 2f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 2f3:	c9                   	leave  
+ 2f4:	c3                   	ret    
+
+000002f5 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 2f5:	f3 0f 1e fb          	endbr32 
+ 2f9:	55                   	push   %ebp
+ 2fa:	89 e5                	mov    %esp,%ebp
+ 2fc:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 2ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 306:	eb 25                	jmp    32d <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 308:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 30b:	89 d0                	mov    %edx,%eax
+ 30d:	c1 e0 02             	shl    $0x2,%eax
+ 310:	01 d0                	add    %edx,%eax
+ 312:	01 c0                	add    %eax,%eax
+ 314:	89 c1                	mov    %eax,%ecx
+ 316:	8b 45 08             	mov    0x8(%ebp),%eax
+ 319:	8d 50 01             	lea    0x1(%eax),%edx
+ 31c:	89 55 08             	mov    %edx,0x8(%ebp)
+ 31f:	0f b6 00             	movzbl (%eax),%eax
+ 322:	0f be c0             	movsbl %al,%eax
+ 325:	01 c8                	add    %ecx,%eax
+ 327:	83 e8 30             	sub    $0x30,%eax
+ 32a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 32d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 330:	0f b6 00             	movzbl (%eax),%eax
+ 333:	3c 2f                	cmp    $0x2f,%al
+ 335:	7e 0a                	jle    341 <atoi+0x4c>
+ 337:	8b 45 08             	mov    0x8(%ebp),%eax
+ 33a:	0f b6 00             	movzbl (%eax),%eax
+ 33d:	3c 39                	cmp    $0x39,%al
+ 33f:	7e c7                	jle    308 <atoi+0x13>
+  return n;
+ 341:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 344:	c9                   	leave  
+ 345:	c3                   	ret    
+
+00000346 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 346:	f3 0f 1e fb          	endbr32 
+ 34a:	55                   	push   %ebp
+ 34b:	89 e5                	mov    %esp,%ebp
+ 34d:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 350:	8b 45 08             	mov    0x8(%ebp),%eax
+ 353:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 356:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 359:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 35c:	eb 17                	jmp    375 <memmove+0x2f>
+    *dst++ = *src++;
+ 35e:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 361:	8d 42 01             	lea    0x1(%edx),%eax
+ 364:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 367:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 36a:	8d 48 01             	lea    0x1(%eax),%ecx
+ 36d:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 370:	0f b6 12             	movzbl (%edx),%edx
+ 373:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 375:	8b 45 10             	mov    0x10(%ebp),%eax
+ 378:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 37b:	89 55 10             	mov    %edx,0x10(%ebp)
+ 37e:	85 c0                	test   %eax,%eax
+ 380:	7f dc                	jg     35e <memmove+0x18>
+  return vdst;
+ 382:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 385:	c9                   	leave  
+ 386:	c3                   	ret    
+
+00000387 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 387:	b8 01 00 00 00       	mov    $0x1,%eax
+ 38c:	cd 40                	int    $0x40
+ 38e:	c3                   	ret    
+
+0000038f <exit>:
+SYSCALL(exit)
+ 38f:	b8 02 00 00 00       	mov    $0x2,%eax
+ 394:	cd 40                	int    $0x40
+ 396:	c3                   	ret    
+
+00000397 <wait>:
+SYSCALL(wait)
+ 397:	b8 03 00 00 00       	mov    $0x3,%eax
+ 39c:	cd 40                	int    $0x40
+ 39e:	c3                   	ret    
+
+0000039f <pipe>:
+SYSCALL(pipe)
+ 39f:	b8 04 00 00 00       	mov    $0x4,%eax
+ 3a4:	cd 40                	int    $0x40
+ 3a6:	c3                   	ret    
+
+000003a7 <read>:
+SYSCALL(read)
+ 3a7:	b8 05 00 00 00       	mov    $0x5,%eax
+ 3ac:	cd 40                	int    $0x40
+ 3ae:	c3                   	ret    
+
+000003af <write>:
+SYSCALL(write)
+ 3af:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3b4:	cd 40                	int    $0x40
+ 3b6:	c3                   	ret    
+
+000003b7 <close>:
+SYSCALL(close)
+ 3b7:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3bc:	cd 40                	int    $0x40
+ 3be:	c3                   	ret    
+
+000003bf <kill>:
+SYSCALL(kill)
+ 3bf:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3c4:	cd 40                	int    $0x40
+ 3c6:	c3                   	ret    
+
+000003c7 <exec>:
+SYSCALL(exec)
+ 3c7:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3cc:	cd 40                	int    $0x40
+ 3ce:	c3                   	ret    
+
+000003cf <open>:
+SYSCALL(open)
+ 3cf:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3d4:	cd 40                	int    $0x40
+ 3d6:	c3                   	ret    
+
+000003d7 <mknod>:
+SYSCALL(mknod)
+ 3d7:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3dc:	cd 40                	int    $0x40
+ 3de:	c3                   	ret    
+
+000003df <unlink>:
+SYSCALL(unlink)
+ 3df:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3e4:	cd 40                	int    $0x40
+ 3e6:	c3                   	ret    
+
+000003e7 <fstat>:
+SYSCALL(fstat)
+ 3e7:	b8 08 00 00 00       	mov    $0x8,%eax
+ 3ec:	cd 40                	int    $0x40
+ 3ee:	c3                   	ret    
+
+000003ef <link>:
+SYSCALL(link)
+ 3ef:	b8 13 00 00 00       	mov    $0x13,%eax
+ 3f4:	cd 40                	int    $0x40
+ 3f6:	c3                   	ret    
+
+000003f7 <mkdir>:
+SYSCALL(mkdir)
+ 3f7:	b8 14 00 00 00       	mov    $0x14,%eax
+ 3fc:	cd 40                	int    $0x40
+ 3fe:	c3                   	ret    
+
+000003ff <chdir>:
+SYSCALL(chdir)
+ 3ff:	b8 09 00 00 00       	mov    $0x9,%eax
+ 404:	cd 40                	int    $0x40
+ 406:	c3                   	ret    
+
+00000407 <dup>:
+SYSCALL(dup)
+ 407:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 40c:	cd 40                	int    $0x40
+ 40e:	c3                   	ret    
+
+0000040f <getpid>:
+SYSCALL(getpid)
+ 40f:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 414:	cd 40                	int    $0x40
+ 416:	c3                   	ret    
+
+00000417 <sbrk>:
+SYSCALL(sbrk)
+ 417:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 41c:	cd 40                	int    $0x40
+ 41e:	c3                   	ret    
+
+0000041f <sleep>:
+SYSCALL(sleep)
+ 41f:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 424:	cd 40                	int    $0x40
+ 426:	c3                   	ret    
+
+00000427 <uptime>:
+SYSCALL(uptime)
+ 427:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 42c:	cd 40                	int    $0x40
+ 42e:	c3                   	ret    
+
+0000042f <draw>:
+SYSCALL(draw)
+ 42f:	b8 16 00 00 00       	mov    $0x16,%eax
+ 434:	cd 40                	int    $0x40
+ 436:	c3                   	ret    
+
+00000437 <cps>:
+SYSCALL(cps)
+ 437:	b8 17 00 00 00       	mov    $0x17,%eax
+ 43c:	cd 40                	int    $0x40
+ 43e:	c3                   	ret    
+
+0000043f <yield>:
+SYSCALL(yield)
+ 43f:	b8 18 00 00 00       	mov    $0x18,%eax
+ 444:	cd 40                	int    $0x40
+ 446:	c3                   	ret    
+
+00000447 <wait2>:
+SYSCALL(wait2)
+ 447:	b8 19 00 00 00       	mov    $0x19,%eax
+ 44c:	cd 40                	int    $0x40
+ 44e:	c3                   	ret    
+
+0000044f <set_prio>:
+SYSCALL(set_prio)
+ 44f:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 454:	cd 40                	int    $0x40
+ 456:	c3                   	ret    
diff -ruN xv6-public/xv6-public/forktest.c xv6-public_new/xv6-public/forktest.c
--- xv6-public/xv6-public/forktest.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/forktest.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,56 @@
+// Test that fork fails gracefully.
+// Tiny executable so that the limit can be filling the proc table.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define N  1000
+
+void
+printf(int fd, const char *s, ...)
+{
+  write(fd, s, strlen(s));
+}
+
+void
+forktest(void)
+{
+  int n, pid;
+
+  printf(1, "fork test\n");
+
+  for(n=0; n<N; n++){
+    pid = fork();
+    if(pid < 0)
+      break;
+    if(pid == 0)
+      exit();
+  }
+
+  if(n == N){
+    printf(1, "fork claimed to work N times!\n", N);
+    exit();
+  }
+
+  for(; n > 0; n--){
+    if(wait() < 0){
+      printf(1, "wait stopped early\n");
+      exit();
+    }
+  }
+
+  if(wait() != -1){
+    printf(1, "wait got too many\n");
+    exit();
+  }
+
+  printf(1, "fork test OK\n");
+}
+
+int
+main(void)
+{
+  forktest();
+  exit();
+}
diff -ruN xv6-public/xv6-public/forktest.d xv6-public_new/xv6-public/forktest.d
--- xv6-public/xv6-public/forktest.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/forktest.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+forktest.o: forktest.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/forktest.o and xv6-public_new/xv6-public/forktest.o differ
diff -ruN xv6-public/xv6-public/fs.c xv6-public_new/xv6-public/fs.c
--- xv6-public/xv6-public/fs.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/fs.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,670 @@
+// File system implementation.  Five layers:
+//   + Blocks: allocator for raw disk blocks.
+//   + Log: crash recovery for multi-step updates.
+//   + Files: inode allocator, reading, writing, metadata.
+//   + Directories: inode with special contents (list of other inodes!)
+//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
+//
+// This file contains the low-level file system manipulation
+// routines.  The (higher-level) system call implementations
+// are in sysfile.c.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "stat.h"
+#include "mmu.h"
+#include "proc.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "buf.h"
+#include "file.h"
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+static void itrunc(struct inode*);
+// there should be one superblock per disk device, but we run with
+// only one device
+struct superblock sb; 
+
+// Read the super block.
+void
+readsb(int dev, struct superblock *sb)
+{
+  struct buf *bp;
+
+  bp = bread(dev, 1);
+  memmove(sb, bp->data, sizeof(*sb));
+  brelse(bp);
+}
+
+// Zero a block.
+static void
+bzero(int dev, int bno)
+{
+  struct buf *bp;
+
+  bp = bread(dev, bno);
+  memset(bp->data, 0, BSIZE);
+  log_write(bp);
+  brelse(bp);
+}
+
+// Blocks.
+
+// Allocate a zeroed disk block.
+static uint
+balloc(uint dev)
+{
+  int b, bi, m;
+  struct buf *bp;
+
+  bp = 0;
+  for(b = 0; b < sb.size; b += BPB){
+    bp = bread(dev, BBLOCK(b, sb));
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+      m = 1 << (bi % 8);
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+        bp->data[bi/8] |= m;  // Mark block in use.
+        log_write(bp);
+        brelse(bp);
+        bzero(dev, b + bi);
+        return b + bi;
+      }
+    }
+    brelse(bp);
+  }
+  panic("balloc: out of blocks");
+}
+
+// Free a disk block.
+static void
+bfree(int dev, uint b)
+{
+  struct buf *bp;
+  int bi, m;
+
+  bp = bread(dev, BBLOCK(b, sb));
+  bi = b % BPB;
+  m = 1 << (bi % 8);
+  if((bp->data[bi/8] & m) == 0)
+    panic("freeing free block");
+  bp->data[bi/8] &= ~m;
+  log_write(bp);
+  brelse(bp);
+}
+
+// Inodes.
+//
+// An inode describes a single unnamed file.
+// The inode disk structure holds metadata: the file's type,
+// its size, the number of links referring to it, and the
+// list of blocks holding the file's content.
+//
+// The inodes are laid out sequentially on disk at
+// sb.startinode. Each inode has a number, indicating its
+// position on the disk.
+//
+// The kernel keeps a cache of in-use inodes in memory
+// to provide a place for synchronizing access
+// to inodes used by multiple processes. The cached
+// inodes include book-keeping information that is
+// not stored on disk: ip->ref and ip->valid.
+//
+// An inode and its in-memory representation go through a
+// sequence of states before they can be used by the
+// rest of the file system code.
+//
+// * Allocation: an inode is allocated if its type (on disk)
+//   is non-zero. ialloc() allocates, and iput() frees if
+//   the reference and link counts have fallen to zero.
+//
+// * Referencing in cache: an entry in the inode cache
+//   is free if ip->ref is zero. Otherwise ip->ref tracks
+//   the number of in-memory pointers to the entry (open
+//   files and current directories). iget() finds or
+//   creates a cache entry and increments its ref; iput()
+//   decrements ref.
+//
+// * Valid: the information (type, size, &c) in an inode
+//   cache entry is only correct when ip->valid is 1.
+//   ilock() reads the inode from
+//   the disk and sets ip->valid, while iput() clears
+//   ip->valid if ip->ref has fallen to zero.
+//
+// * Locked: file system code may only examine and modify
+//   the information in an inode and its content if it
+//   has first locked the inode.
+//
+// Thus a typical sequence is:
+//   ip = iget(dev, inum)
+//   ilock(ip)
+//   ... examine and modify ip->xxx ...
+//   iunlock(ip)
+//   iput(ip)
+//
+// ilock() is separate from iget() so that system calls can
+// get a long-term reference to an inode (as for an open file)
+// and only lock it for short periods (e.g., in read()).
+// The separation also helps avoid deadlock and races during
+// pathname lookup. iget() increments ip->ref so that the inode
+// stays cached and pointers to it remain valid.
+//
+// Many internal file system functions expect the caller to
+// have locked the inodes involved; this lets callers create
+// multi-step atomic operations.
+//
+// The icache.lock spin-lock protects the allocation of icache
+// entries. Since ip->ref indicates whether an entry is free,
+// and ip->dev and ip->inum indicate which i-node an entry
+// holds, one must hold icache.lock while using any of those fields.
+//
+// An ip->lock sleep-lock protects all ip-> fields other than ref,
+// dev, and inum.  One must hold ip->lock in order to
+// read or write that inode's ip->valid, ip->size, ip->type, &c.
+
+struct {
+  struct spinlock lock;
+  struct inode inode[NINODE];
+} icache;
+
+void
+iinit(int dev)
+{
+  int i = 0;
+  
+  initlock(&icache.lock, "icache");
+  for(i = 0; i < NINODE; i++) {
+    initsleeplock(&icache.inode[i].lock, "inode");
+  }
+
+  readsb(dev, &sb);
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+ inodestart %d bmap start %d\n", sb.size, sb.nblocks,
+          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
+          sb.bmapstart);
+}
+
+static struct inode* iget(uint dev, uint inum);
+
+//PAGEBREAK!
+// Allocate an inode on device dev.
+// Mark it as allocated by  giving it type type.
+// Returns an unlocked but allocated and referenced inode.
+struct inode*
+ialloc(uint dev, short type)
+{
+  int inum;
+  struct buf *bp;
+  struct dinode *dip;
+
+  for(inum = 1; inum < sb.ninodes; inum++){
+    bp = bread(dev, IBLOCK(inum, sb));
+    dip = (struct dinode*)bp->data + inum%IPB;
+    if(dip->type == 0){  // a free inode
+      memset(dip, 0, sizeof(*dip));
+      dip->type = type;
+      log_write(bp);   // mark it allocated on the disk
+      brelse(bp);
+      return iget(dev, inum);
+    }
+    brelse(bp);
+  }
+  panic("ialloc: no inodes");
+}
+
+// Copy a modified in-memory inode to disk.
+// Must be called after every change to an ip->xxx field
+// that lives on disk, since i-node cache is write-through.
+// Caller must hold ip->lock.
+void
+iupdate(struct inode *ip)
+{
+  struct buf *bp;
+  struct dinode *dip;
+
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+  dip->type = ip->type;
+  dip->major = ip->major;
+  dip->minor = ip->minor;
+  dip->nlink = ip->nlink;
+  dip->size = ip->size;
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+  log_write(bp);
+  brelse(bp);
+}
+
+// Find the inode with number inum on device dev
+// and return the in-memory copy. Does not lock
+// the inode and does not read it from disk.
+static struct inode*
+iget(uint dev, uint inum)
+{
+  struct inode *ip, *empty;
+
+  acquire(&icache.lock);
+
+  // Is the inode already cached?
+  empty = 0;
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+      ip->ref++;
+      release(&icache.lock);
+      return ip;
+    }
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+      empty = ip;
+  }
+
+  // Recycle an inode cache entry.
+  if(empty == 0)
+    panic("iget: no inodes");
+
+  ip = empty;
+  ip->dev = dev;
+  ip->inum = inum;
+  ip->ref = 1;
+  ip->valid = 0;
+  release(&icache.lock);
+
+  return ip;
+}
+
+// Increment reference count for ip.
+// Returns ip to enable ip = idup(ip1) idiom.
+struct inode*
+idup(struct inode *ip)
+{
+  acquire(&icache.lock);
+  ip->ref++;
+  release(&icache.lock);
+  return ip;
+}
+
+// Lock the given inode.
+// Reads the inode from disk if necessary.
+void
+ilock(struct inode *ip)
+{
+  struct buf *bp;
+  struct dinode *dip;
+
+  if(ip == 0 || ip->ref < 1)
+    panic("ilock");
+
+  acquiresleep(&ip->lock);
+
+  if(ip->valid == 0){
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+    ip->type = dip->type;
+    ip->major = dip->major;
+    ip->minor = dip->minor;
+    ip->nlink = dip->nlink;
+    ip->size = dip->size;
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+    brelse(bp);
+    ip->valid = 1;
+    if(ip->type == 0)
+      panic("ilock: no type");
+  }
+}
+
+// Unlock the given inode.
+void
+iunlock(struct inode *ip)
+{
+  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+    panic("iunlock");
+
+  releasesleep(&ip->lock);
+}
+
+// Drop a reference to an in-memory inode.
+// If that was the last reference, the inode cache entry can
+// be recycled.
+// If that was the last reference and the inode has no links
+// to it, free the inode (and its content) on disk.
+// All calls to iput() must be inside a transaction in
+// case it has to free the inode.
+void
+iput(struct inode *ip)
+{
+  acquiresleep(&ip->lock);
+  if(ip->valid && ip->nlink == 0){
+    acquire(&icache.lock);
+    int r = ip->ref;
+    release(&icache.lock);
+    if(r == 1){
+      // inode has no links and no other references: truncate and free.
+      itrunc(ip);
+      ip->type = 0;
+      iupdate(ip);
+      ip->valid = 0;
+    }
+  }
+  releasesleep(&ip->lock);
+
+  acquire(&icache.lock);
+  ip->ref--;
+  release(&icache.lock);
+}
+
+// Common idiom: unlock, then put.
+void
+iunlockput(struct inode *ip)
+{
+  iunlock(ip);
+  iput(ip);
+}
+
+//PAGEBREAK!
+// Inode content
+//
+// The content (data) associated with each inode is stored
+// in blocks on the disk. The first NDIRECT block numbers
+// are listed in ip->addrs[].  The next NINDIRECT blocks are
+// listed in block ip->addrs[NDIRECT].
+
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+    if((addr = ip->addrs[bn]) == 0)
+      ip->addrs[bn] = addr = balloc(ip->dev);
+    return addr;
+  }
+  bn -= NDIRECT;
+
+  if(bn < NINDIRECT){
+    // Load indirect block, allocating if necessary.
+    if((addr = ip->addrs[NDIRECT]) == 0)
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+    bp = bread(ip->dev, addr);
+    a = (uint*)bp->data;
+    if((addr = a[bn]) == 0){
+      a[bn] = addr = balloc(ip->dev);
+      log_write(bp);
+    }
+    brelse(bp);
+    return addr;
+  }
+
+  panic("bmap: out of range");
+}
+
+// Truncate inode (discard contents).
+// Only called when the inode has no links
+// to it (no directory entries referring to it)
+// and has no in-memory reference to it (is
+// not an open file or current directory).
+static void
+itrunc(struct inode *ip)
+{
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+    if(ip->addrs[i]){
+      bfree(ip->dev, ip->addrs[i]);
+      ip->addrs[i] = 0;
+    }
+  }
+
+  if(ip->addrs[NDIRECT]){
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+    a = (uint*)bp->data;
+    for(j = 0; j < NINDIRECT; j++){
+      if(a[j])
+        bfree(ip->dev, a[j]);
+    }
+    brelse(bp);
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    ip->addrs[NDIRECT] = 0;
+  }
+
+  ip->size = 0;
+  iupdate(ip);
+}
+
+// Copy stat information from inode.
+// Caller must hold ip->lock.
+void
+stati(struct inode *ip, struct stat *st)
+{
+  st->dev = ip->dev;
+  st->ino = ip->inum;
+  st->type = ip->type;
+  st->nlink = ip->nlink;
+  st->size = ip->size;
+}
+
+//PAGEBREAK!
+// Read data from inode.
+// Caller must hold ip->lock.
+int
+readi(struct inode *ip, char *dst, uint off, uint n)
+{
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+      return -1;
+    return devsw[ip->major].read(ip, dst, n);
+  }
+
+  if(off > ip->size || off + n < off)
+    return -1;
+  if(off + n > ip->size)
+    n = ip->size - off;
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+    m = min(n - tot, BSIZE - off%BSIZE);
+    memmove(dst, bp->data + off%BSIZE, m);
+    brelse(bp);
+  }
+  return n;
+}
+
+// PAGEBREAK!
+// Write data to inode.
+// Caller must hold ip->lock.
+int
+writei(struct inode *ip, char *src, uint off, uint n)
+{
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+      return -1;
+    return devsw[ip->major].write(ip, src, n);
+  }
+
+  if(off > ip->size || off + n < off)
+    return -1;
+  if(off + n > MAXFILE*BSIZE)
+    return -1;
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+    m = min(n - tot, BSIZE - off%BSIZE);
+    memmove(bp->data + off%BSIZE, src, m);
+    log_write(bp);
+    brelse(bp);
+  }
+
+  if(n > 0 && off > ip->size){
+    ip->size = off;
+    iupdate(ip);
+  }
+  return n;
+}
+
+//PAGEBREAK!
+// Directories
+
+int
+namecmp(const char *s, const char *t)
+{
+  return strncmp(s, t, DIRSIZ);
+}
+
+// Look for a directory entry in a directory.
+// If found, set *poff to byte offset of entry.
+struct inode*
+dirlookup(struct inode *dp, char *name, uint *poff)
+{
+  uint off, inum;
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+    panic("dirlookup not DIR");
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlookup read");
+    if(de.inum == 0)
+      continue;
+    if(namecmp(name, de.name) == 0){
+      // entry matches path element
+      if(poff)
+        *poff = off;
+      inum = de.inum;
+      return iget(dp->dev, inum);
+    }
+  }
+
+  return 0;
+}
+
+// Write a new directory entry (name, inum) into the directory dp.
+int
+dirlink(struct inode *dp, char *name, uint inum)
+{
+  int off;
+  struct dirent de;
+  struct inode *ip;
+
+  // Check that name is not present.
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    iput(ip);
+    return -1;
+  }
+
+  // Look for an empty dirent.
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlink read");
+    if(de.inum == 0)
+      break;
+  }
+
+  strncpy(de.name, name, DIRSIZ);
+  de.inum = inum;
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+    panic("dirlink");
+
+  return 0;
+}
+
+//PAGEBREAK!
+// Paths
+
+// Copy the next path element from path into name.
+// Return a pointer to the element following the copied one.
+// The returned path has no leading slashes,
+// so the caller can check *path=='\0' to see if the name is the last one.
+// If no name to remove, return 0.
+//
+// Examples:
+//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
+//   skipelem("///a//bb", name) = "bb", setting name = "a"
+//   skipelem("a", name) = "", setting name = "a"
+//   skipelem("", name) = skipelem("////", name) = 0
+//
+static char*
+skipelem(char *path, char *name)
+{
+  char *s;
+  int len;
+
+  while(*path == '/')
+    path++;
+  if(*path == 0)
+    return 0;
+  s = path;
+  while(*path != '/' && *path != 0)
+    path++;
+  len = path - s;
+  if(len >= DIRSIZ)
+    memmove(name, s, DIRSIZ);
+  else {
+    memmove(name, s, len);
+    name[len] = 0;
+  }
+  while(*path == '/')
+    path++;
+  return path;
+}
+
+// Look up and return the inode for a path name.
+// If parent != 0, return the inode for the parent and copy the final
+// path element into name, which must have room for DIRSIZ bytes.
+// Must be called inside a transaction since it calls iput().
+static struct inode*
+namex(char *path, int nameiparent, char *name)
+{
+  struct inode *ip, *next;
+
+  if(*path == '/')
+    ip = iget(ROOTDEV, ROOTINO);
+  else
+    ip = idup(myproc()->cwd);
+
+  while((path = skipelem(path, name)) != 0){
+    ilock(ip);
+    if(ip->type != T_DIR){
+      iunlockput(ip);
+      return 0;
+    }
+    if(nameiparent && *path == '\0'){
+      // Stop one level early.
+      iunlock(ip);
+      return ip;
+    }
+    if((next = dirlookup(ip, name, 0)) == 0){
+      iunlockput(ip);
+      return 0;
+    }
+    iunlockput(ip);
+    ip = next;
+  }
+  if(nameiparent){
+    iput(ip);
+    return 0;
+  }
+  return ip;
+}
+
+struct inode*
+namei(char *path)
+{
+  char name[DIRSIZ];
+  return namex(path, 0, name);
+}
+
+struct inode*
+nameiparent(char *path, char *name)
+{
+  return namex(path, 1, name);
+}
diff -ruN xv6-public/xv6-public/fs.d xv6-public_new/xv6-public/fs.d
--- xv6-public/xv6-public/fs.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/fs.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,2 @@
+fs.o: fs.c /usr/include/stdc-predef.h types.h defs.h param.h stat.h mmu.h \
+ proc.h spinlock.h sleeplock.h fs.h buf.h file.h
diff -ruN xv6-public/xv6-public/fs.h xv6-public_new/xv6-public/fs.h
--- xv6-public/xv6-public/fs.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/fs.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,57 @@
+// On-disk file system format.
+// Both the kernel and user programs use this header file.
+
+
+#define ROOTINO 1  // root i-number
+#define BSIZE 512  // block size
+
+// Disk layout:
+// [ boot block | super block | log | inode blocks |
+//                                          free bit map | data blocks]
+//
+// mkfs computes the super block and builds an initial file system. The
+// super block describes the disk layout:
+struct superblock {
+  uint size;         // Size of file system image (blocks)
+  uint nblocks;      // Number of data blocks
+  uint ninodes;      // Number of inodes.
+  uint nlog;         // Number of log blocks
+  uint logstart;     // Block number of first log block
+  uint inodestart;   // Block number of first inode block
+  uint bmapstart;    // Block number of first free map block
+};
+
+#define NDIRECT 12
+#define NINDIRECT (BSIZE / sizeof(uint))
+#define MAXFILE (NDIRECT + NINDIRECT)
+
+// On-disk inode structure
+struct dinode {
+  short type;           // File type
+  short major;          // Major device number (T_DEV only)
+  short minor;          // Minor device number (T_DEV only)
+  short nlink;          // Number of links to inode in file system
+  uint size;            // Size of file (bytes)
+  uint addrs[NDIRECT+1];   // Data block addresses
+};
+
+// Inodes per block.
+#define IPB           (BSIZE / sizeof(struct dinode))
+
+// Block containing inode i
+#define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
+
+// Bitmap bits per block
+#define BPB           (BSIZE*8)
+
+// Block of free map containing bit for block b
+#define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
+
+// Directory is a file containing a sequence of dirent structures.
+#define DIRSIZ 14
+
+struct dirent {
+  ushort inum;
+  char name[DIRSIZ];
+};
+
Binary files xv6-public/xv6-public/fs.img and xv6-public_new/xv6-public/fs.img differ
Binary files xv6-public/xv6-public/fs.o and xv6-public_new/xv6-public/fs.o differ
diff -ruN xv6-public/xv6-public/gdbutil xv6-public_new/xv6-public/gdbutil
--- xv6-public/xv6-public/gdbutil	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/gdbutil	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,291 @@
+# -*- gdb-script -*-
+
+# Utility functions to pretty-print x86 segment/interrupt descriptors.
+# To load this file, run "source gdbutil" in gdb.
+# printdesc and printdescs are the main entry points.
+
+# IA32 2007, Volume 3A, Table 3-2
+set $STS_T16A = 0x1
+set $STS_LDT  = 0x2
+set $STS_T16B = 0x3
+set $STS_CG16 = 0x4
+set $STS_TG   = 0x5
+set $STS_IG16 = 0x6
+set $STS_TG16 = 0x7
+set $STS_T32A = 0x9
+set $STS_T32B = 0xB
+set $STS_CG32 = 0xC
+set $STS_IG32 = 0xE
+set $STS_TG32 = 0xF
+
+define outputsts
+  while 1
+    if $arg0 == $STS_T16A
+      echo STS_T16A
+      loop_break
+    end
+    if $arg0 == $STS_LDT
+      echo STS_LDT\ 
+      loop_break
+    end
+    if $arg0 == $STS_T16B
+      echo STS_T16B
+      loop_break
+    end
+    if $arg0 == $STS_CG16
+      echo STS_CG16
+      loop_break
+    end
+    if $arg0 == $STS_TG
+      echo STS_TG\ \ 
+      loop_break
+    end
+    if $arg0 == $STS_IG16
+      echo STS_IG16
+      loop_break
+    end
+    if $arg0 == $STS_TG16
+      echo STS_TG16
+      loop_break
+    end
+    if $arg0 == $STS_T32A
+      echo STS_T32A
+      loop_break
+    end
+    if $arg0 == $STS_T32B
+      echo STS_T32B
+      loop_break
+    end
+    if $arg0 == $STS_CG32
+      echo STS_CG32
+      loop_break
+    end
+    if $arg0 == $STS_IG32
+      echo STS_IG32
+      loop_break
+    end
+    if $arg0 == $STS_TG32
+      echo STS_TG32
+      loop_break
+    end
+    echo Reserved
+    loop_break
+  end
+end  
+
+# IA32 2007, Volume 3A, Table 3-1
+set $STA_X = 0x8
+set $STA_E = 0x4
+set $STA_C = 0x4
+set $STA_W = 0x2
+set $STA_R = 0x2
+set $STA_A = 0x1
+
+define outputsta
+  if $arg0 & $STA_X
+    # Code segment
+    echo code
+    if $arg0 & $STA_C
+      echo |STA_C
+    end
+    if $arg0 & $STA_R
+      echo |STA_R
+    end
+  else
+    # Data segment
+    echo data
+    if $arg0 & $STA_E
+      echo |STA_E
+    end
+    if $arg0 & $STA_W
+      echo |STA_W
+    end
+  end
+  if $arg0 & $STA_A
+    echo |STA_A
+  else
+    printf "      "
+  end
+end
+
+# xv6-specific
+set $SEG_KCODE = 1
+set $SEG_KDATA = 2
+set $SEG_KCPU  = 3
+set $SEG_UCODE = 4
+set $SEG_UDATA = 5
+set $SEG_TSS   = 6
+
+define outputcs
+  if ($arg0 & 4) == 0
+    if $arg0 >> 3 == $SEG_KCODE
+      printf "SEG_KCODE<<3"
+    end
+    if $arg0 >> 3 == $SEG_KDATA
+      printf "SEG_KDATA<<3"
+    end
+    if $arg0 >> 3 == $SEG_KCPU
+      printf "SEG_KCPU<<3"
+    end
+    if $arg0 >> 3 == $SEG_UCODE
+      printf "SEG_UCODE<<3"
+    end
+    if $arg0 >> 3 == $SEG_UDATA
+      printf "SEG_UDATA<<3"
+    end
+    if $arg0 >> 3 == $SEG_TSS
+      printf "SEG_TSS<<3"
+    end
+    if ($arg0 >> 3 < 1) + ($arg0 >> 3 > 6)
+      printf "GDT[%d]", $arg0 >> 3
+    end
+  else
+    printf "LDT[%d]", $arg0 >> 3
+  end
+  if ($arg0 & 3) > 0
+    printf "|"
+    outputdpl ($arg0&3)
+  end
+end
+
+define outputdpl
+  if $arg0 == 0
+    printf "DPL_KERN"
+  else
+    if $arg0 == 3
+      printf "DPL_USER"
+    else
+      printf "DPL%d", $arg0
+    end
+  end
+end
+
+define printdesc
+  if $argc != 1
+    echo Usage: printdesc expr
+  else
+    _printdesc ((uint*)&($arg0))[0] ((uint*)&($arg0))[1]
+    printf "\n"
+  end
+end
+
+document printdesc
+Print an x86 segment or gate descriptor.
+printdesc EXPR
+EXPR must evaluate to a descriptor value.  It can be of any C type.
+end
+
+define _printdesc
+  _printdesc1 $arg0 $arg1 ($arg1>>15&1) ($arg1>>13&3) ($arg1>>12&1) ($arg1>>8&15)
+end
+
+define _printdesc1
+  # 2:P 3:DPL 4:S 5:Type
+  if $arg2 == 0
+    printf "P = 0 (Not present)"
+  else
+    printf "type = "
+    if $arg4 == 0
+      # System segment
+      outputsts $arg5
+      printf " (0x%x)    ", $arg5
+      _printsysdesc $arg0 $arg1 $arg5
+    else
+      # Code/data segment
+      outputsta $arg5
+      printf "  "
+      _printsegdesc $arg0 $arg1
+    end
+
+    printf "  DPL = "
+    outputdpl $arg3
+    printf " (%d)", $arg3
+  end
+end
+
+define _printsysdesc
+  # 2:Type
+  # GDB's || is buggy
+  if ($arg2 == $STS_TG) + (($arg2&7) == $STS_IG16) + (($arg2&7) == $STS_TG16)
+    # Gate descriptor
+    _printgate $arg2 ($arg0>>16) ($arg0&0xFFFF) ($arg1>>16)
+  else
+    # System segment descriptor
+    _printsegdesc $arg0 $arg1
+  end
+end
+
+define _printgate
+  # IA32 2007, Voume 3A, Figure 5-2
+  # 0:Type 1:CS 2:Offset 15..0 3:Offset 31..16
+  printf "CS = "
+  outputcs $arg1
+  printf " (%d)", $arg1
+
+  if (($arg0&7) == $STS_IG16) + (($arg0&7) == $STS_TG16)
+    printf "  Offset = "
+    output/a $arg3 << 16 | $arg2
+  end
+end
+
+define _printsegdesc
+  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
+  _printsegdesc1 ($arg0>>16) ($arg1&0xFF) ($arg1>>24) ($arg0&0xFFFF) ($arg1>>16&15) ($arg1>>23&1)
+  if ($arg1>>12&1) == 1
+    printf "  AVL = %d", $arg1>>20&1
+    if ($arg1>>11&1) == 0
+      # Data segment
+      if ($arg1>>22&1) == 0
+        printf "  B = small (0) "
+      else
+        printf "  B = big (1)   "
+      end
+    else
+      # Code segment
+      printf "  D = "
+      if ($arg1>>22&1) == 0
+        printf "16-bit (0)"
+      else
+        printf "32-bit (1)"
+      end
+    end
+  end
+end
+
+define _printsegdesc1
+  # 0:Base 0..15  1:Base 16..23  2:Base 24..32  3:Limit 0..15  4:Limit 16..19  5:G
+  printf "base = 0x%08x", $arg0 | ($arg1<<16) | ($arg2<<24)
+  printf "  limit = 0x"
+  if $arg5 == 0
+    printf "%08x", $arg3 | ($arg4<<16)
+  else
+    printf "%08x", (($arg3 | ($arg4<<16)) << 12) | 0xFFF
+  end
+end
+
+define printdescs
+  if $argc < 1 || $argc > 2
+    echo Usage: printdescs expr [count]
+  else
+    if $argc == 1
+      _printdescs ($arg0) (sizeof($arg0)/sizeof(($arg0)[0]))
+    else
+      _printdescs ($arg0) ($arg1)
+    end
+  end
+end
+
+document printdescs
+Print an array of x86 segment or gate descriptors.
+printdescs EXPR [COUNT]
+EXPR must evaluate to an array of descriptors.
+end
+
+define _printdescs
+  set $i = 0
+  while $i < $arg1
+    printf "[%d] ", $i
+    printdesc $arg0[$i]
+    set $i = $i + 1
+  end
+end
diff -ruN xv6-public/xv6-public/grep.asm xv6-public_new/xv6-public/grep.asm
--- xv6-public/xv6-public/grep.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/grep.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1503 @@
+
+_grep:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <grep>:
+char buf[1024];
+int match(char*, char*);
+
+void
+grep(char *pattern, int fd)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	55                   	push   %ebp
+   5:	89 e5                	mov    %esp,%ebp
+   7:	83 ec 18             	sub    $0x18,%esp
+  int n, m;
+  char *p, *q;
+
+  m = 0;
+   a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+  11:	e9 ae 00 00 00       	jmp    c4 <grep+0xc4>
+    m += n;
+  16:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  19:	01 45 f4             	add    %eax,-0xc(%ebp)
+    buf[m] = '\0';
+  1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1f:	05 80 0e 00 00       	add    $0xe80,%eax
+  24:	c6 00 00             	movb   $0x0,(%eax)
+    p = buf;
+  27:	c7 45 f0 80 0e 00 00 	movl   $0xe80,-0x10(%ebp)
+    while((q = strchr(p, '\n')) != 0){
+  2e:	eb 44                	jmp    74 <grep+0x74>
+      *q = 0;
+  30:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  33:	c6 00 00             	movb   $0x0,(%eax)
+      if(match(pattern, p)){
+  36:	83 ec 08             	sub    $0x8,%esp
+  39:	ff 75 f0             	pushl  -0x10(%ebp)
+  3c:	ff 75 08             	pushl  0x8(%ebp)
+  3f:	e8 97 01 00 00       	call   1db <match>
+  44:	83 c4 10             	add    $0x10,%esp
+  47:	85 c0                	test   %eax,%eax
+  49:	74 20                	je     6b <grep+0x6b>
+        *q = '\n';
+  4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  4e:	c6 00 0a             	movb   $0xa,(%eax)
+        write(1, p, q+1 - p);
+  51:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  54:	83 c0 01             	add    $0x1,%eax
+  57:	2b 45 f0             	sub    -0x10(%ebp),%eax
+  5a:	83 ec 04             	sub    $0x4,%esp
+  5d:	50                   	push   %eax
+  5e:	ff 75 f0             	pushl  -0x10(%ebp)
+  61:	6a 01                	push   $0x1
+  63:	e8 76 05 00 00       	call   5de <write>
+  68:	83 c4 10             	add    $0x10,%esp
+      }
+      p = q+1;
+  6b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  6e:	83 c0 01             	add    $0x1,%eax
+  71:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    while((q = strchr(p, '\n')) != 0){
+  74:	83 ec 08             	sub    $0x8,%esp
+  77:	6a 0a                	push   $0xa
+  79:	ff 75 f0             	pushl  -0x10(%ebp)
+  7c:	e8 a8 03 00 00       	call   429 <strchr>
+  81:	83 c4 10             	add    $0x10,%esp
+  84:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  87:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  8b:	75 a3                	jne    30 <grep+0x30>
+    }
+    if(p == buf)
+  8d:	81 7d f0 80 0e 00 00 	cmpl   $0xe80,-0x10(%ebp)
+  94:	75 07                	jne    9d <grep+0x9d>
+      m = 0;
+  96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if(m > 0){
+  9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  a1:	7e 21                	jle    c4 <grep+0xc4>
+      m -= p - buf;
+  a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  a6:	2d 80 0e 00 00       	sub    $0xe80,%eax
+  ab:	29 45 f4             	sub    %eax,-0xc(%ebp)
+      memmove(buf, p, m);
+  ae:	83 ec 04             	sub    $0x4,%esp
+  b1:	ff 75 f4             	pushl  -0xc(%ebp)
+  b4:	ff 75 f0             	pushl  -0x10(%ebp)
+  b7:	68 80 0e 00 00       	push   $0xe80
+  bc:	e8 b4 04 00 00       	call   575 <memmove>
+  c1:	83 c4 10             	add    $0x10,%esp
+  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+  c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  c7:	ba ff 03 00 00       	mov    $0x3ff,%edx
+  cc:	29 c2                	sub    %eax,%edx
+  ce:	89 d0                	mov    %edx,%eax
+  d0:	89 c2                	mov    %eax,%edx
+  d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  d5:	05 80 0e 00 00       	add    $0xe80,%eax
+  da:	83 ec 04             	sub    $0x4,%esp
+  dd:	52                   	push   %edx
+  de:	50                   	push   %eax
+  df:	ff 75 0c             	pushl  0xc(%ebp)
+  e2:	e8 ef 04 00 00       	call   5d6 <read>
+  e7:	83 c4 10             	add    $0x10,%esp
+  ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  ed:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+  f1:	0f 8f 1f ff ff ff    	jg     16 <grep+0x16>
+    }
+  }
+}
+  f7:	90                   	nop
+  f8:	90                   	nop
+  f9:	c9                   	leave  
+  fa:	c3                   	ret    
+
+000000fb <main>:
+
+int
+main(int argc, char *argv[])
+{
+  fb:	f3 0f 1e fb          	endbr32 
+  ff:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+ 103:	83 e4 f0             	and    $0xfffffff0,%esp
+ 106:	ff 71 fc             	pushl  -0x4(%ecx)
+ 109:	55                   	push   %ebp
+ 10a:	89 e5                	mov    %esp,%ebp
+ 10c:	53                   	push   %ebx
+ 10d:	51                   	push   %ecx
+ 10e:	83 ec 10             	sub    $0x10,%esp
+ 111:	89 cb                	mov    %ecx,%ebx
+  int fd, i;
+  char *pattern;
+
+  if(argc <= 1){
+ 113:	83 3b 01             	cmpl   $0x1,(%ebx)
+ 116:	7f 17                	jg     12f <main+0x34>
+    printf(2, "usage: grep pattern [file ...]\n");
+ 118:	83 ec 08             	sub    $0x8,%esp
+ 11b:	68 2c 0b 00 00       	push   $0xb2c
+ 120:	6a 02                	push   $0x2
+ 122:	e8 3b 06 00 00       	call   762 <printf>
+ 127:	83 c4 10             	add    $0x10,%esp
+    exit();
+ 12a:	e8 8f 04 00 00       	call   5be <exit>
+  }
+  pattern = argv[1];
+ 12f:	8b 43 04             	mov    0x4(%ebx),%eax
+ 132:	8b 40 04             	mov    0x4(%eax),%eax
+ 135:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  if(argc <= 2){
+ 138:	83 3b 02             	cmpl   $0x2,(%ebx)
+ 13b:	7f 15                	jg     152 <main+0x57>
+    grep(pattern, 0);
+ 13d:	83 ec 08             	sub    $0x8,%esp
+ 140:	6a 00                	push   $0x0
+ 142:	ff 75 f0             	pushl  -0x10(%ebp)
+ 145:	e8 b6 fe ff ff       	call   0 <grep>
+ 14a:	83 c4 10             	add    $0x10,%esp
+    exit();
+ 14d:	e8 6c 04 00 00       	call   5be <exit>
+  }
+
+  for(i = 2; i < argc; i++){
+ 152:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
+ 159:	eb 74                	jmp    1cf <main+0xd4>
+    if((fd = open(argv[i], 0)) < 0){
+ 15b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 15e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 165:	8b 43 04             	mov    0x4(%ebx),%eax
+ 168:	01 d0                	add    %edx,%eax
+ 16a:	8b 00                	mov    (%eax),%eax
+ 16c:	83 ec 08             	sub    $0x8,%esp
+ 16f:	6a 00                	push   $0x0
+ 171:	50                   	push   %eax
+ 172:	e8 87 04 00 00       	call   5fe <open>
+ 177:	83 c4 10             	add    $0x10,%esp
+ 17a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 17d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 181:	79 29                	jns    1ac <main+0xb1>
+      printf(1, "grep: cannot open %s\n", argv[i]);
+ 183:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 186:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 18d:	8b 43 04             	mov    0x4(%ebx),%eax
+ 190:	01 d0                	add    %edx,%eax
+ 192:	8b 00                	mov    (%eax),%eax
+ 194:	83 ec 04             	sub    $0x4,%esp
+ 197:	50                   	push   %eax
+ 198:	68 4c 0b 00 00       	push   $0xb4c
+ 19d:	6a 01                	push   $0x1
+ 19f:	e8 be 05 00 00       	call   762 <printf>
+ 1a4:	83 c4 10             	add    $0x10,%esp
+      exit();
+ 1a7:	e8 12 04 00 00       	call   5be <exit>
+    }
+    grep(pattern, fd);
+ 1ac:	83 ec 08             	sub    $0x8,%esp
+ 1af:	ff 75 ec             	pushl  -0x14(%ebp)
+ 1b2:	ff 75 f0             	pushl  -0x10(%ebp)
+ 1b5:	e8 46 fe ff ff       	call   0 <grep>
+ 1ba:	83 c4 10             	add    $0x10,%esp
+    close(fd);
+ 1bd:	83 ec 0c             	sub    $0xc,%esp
+ 1c0:	ff 75 ec             	pushl  -0x14(%ebp)
+ 1c3:	e8 1e 04 00 00       	call   5e6 <close>
+ 1c8:	83 c4 10             	add    $0x10,%esp
+  for(i = 2; i < argc; i++){
+ 1cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 1cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1d2:	3b 03                	cmp    (%ebx),%eax
+ 1d4:	7c 85                	jl     15b <main+0x60>
+  }
+  exit();
+ 1d6:	e8 e3 03 00 00       	call   5be <exit>
+
+000001db <match>:
+int matchhere(char*, char*);
+int matchstar(int, char*, char*);
+
+int
+match(char *re, char *text)
+{
+ 1db:	f3 0f 1e fb          	endbr32 
+ 1df:	55                   	push   %ebp
+ 1e0:	89 e5                	mov    %esp,%ebp
+ 1e2:	83 ec 08             	sub    $0x8,%esp
+  if(re[0] == '^')
+ 1e5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1e8:	0f b6 00             	movzbl (%eax),%eax
+ 1eb:	3c 5e                	cmp    $0x5e,%al
+ 1ed:	75 17                	jne    206 <match+0x2b>
+    return matchhere(re+1, text);
+ 1ef:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1f2:	83 c0 01             	add    $0x1,%eax
+ 1f5:	83 ec 08             	sub    $0x8,%esp
+ 1f8:	ff 75 0c             	pushl  0xc(%ebp)
+ 1fb:	50                   	push   %eax
+ 1fc:	e8 38 00 00 00       	call   239 <matchhere>
+ 201:	83 c4 10             	add    $0x10,%esp
+ 204:	eb 31                	jmp    237 <match+0x5c>
+  do{  // must look at empty string
+    if(matchhere(re, text))
+ 206:	83 ec 08             	sub    $0x8,%esp
+ 209:	ff 75 0c             	pushl  0xc(%ebp)
+ 20c:	ff 75 08             	pushl  0x8(%ebp)
+ 20f:	e8 25 00 00 00       	call   239 <matchhere>
+ 214:	83 c4 10             	add    $0x10,%esp
+ 217:	85 c0                	test   %eax,%eax
+ 219:	74 07                	je     222 <match+0x47>
+      return 1;
+ 21b:	b8 01 00 00 00       	mov    $0x1,%eax
+ 220:	eb 15                	jmp    237 <match+0x5c>
+  }while(*text++ != '\0');
+ 222:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 225:	8d 50 01             	lea    0x1(%eax),%edx
+ 228:	89 55 0c             	mov    %edx,0xc(%ebp)
+ 22b:	0f b6 00             	movzbl (%eax),%eax
+ 22e:	84 c0                	test   %al,%al
+ 230:	75 d4                	jne    206 <match+0x2b>
+  return 0;
+ 232:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 237:	c9                   	leave  
+ 238:	c3                   	ret    
+
+00000239 <matchhere>:
+
+// matchhere: search for re at beginning of text
+int matchhere(char *re, char *text)
+{
+ 239:	f3 0f 1e fb          	endbr32 
+ 23d:	55                   	push   %ebp
+ 23e:	89 e5                	mov    %esp,%ebp
+ 240:	83 ec 08             	sub    $0x8,%esp
+  if(re[0] == '\0')
+ 243:	8b 45 08             	mov    0x8(%ebp),%eax
+ 246:	0f b6 00             	movzbl (%eax),%eax
+ 249:	84 c0                	test   %al,%al
+ 24b:	75 0a                	jne    257 <matchhere+0x1e>
+    return 1;
+ 24d:	b8 01 00 00 00       	mov    $0x1,%eax
+ 252:	e9 99 00 00 00       	jmp    2f0 <matchhere+0xb7>
+  if(re[1] == '*')
+ 257:	8b 45 08             	mov    0x8(%ebp),%eax
+ 25a:	83 c0 01             	add    $0x1,%eax
+ 25d:	0f b6 00             	movzbl (%eax),%eax
+ 260:	3c 2a                	cmp    $0x2a,%al
+ 262:	75 21                	jne    285 <matchhere+0x4c>
+    return matchstar(re[0], re+2, text);
+ 264:	8b 45 08             	mov    0x8(%ebp),%eax
+ 267:	8d 50 02             	lea    0x2(%eax),%edx
+ 26a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 26d:	0f b6 00             	movzbl (%eax),%eax
+ 270:	0f be c0             	movsbl %al,%eax
+ 273:	83 ec 04             	sub    $0x4,%esp
+ 276:	ff 75 0c             	pushl  0xc(%ebp)
+ 279:	52                   	push   %edx
+ 27a:	50                   	push   %eax
+ 27b:	e8 72 00 00 00       	call   2f2 <matchstar>
+ 280:	83 c4 10             	add    $0x10,%esp
+ 283:	eb 6b                	jmp    2f0 <matchhere+0xb7>
+  if(re[0] == '$' && re[1] == '\0')
+ 285:	8b 45 08             	mov    0x8(%ebp),%eax
+ 288:	0f b6 00             	movzbl (%eax),%eax
+ 28b:	3c 24                	cmp    $0x24,%al
+ 28d:	75 1d                	jne    2ac <matchhere+0x73>
+ 28f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 292:	83 c0 01             	add    $0x1,%eax
+ 295:	0f b6 00             	movzbl (%eax),%eax
+ 298:	84 c0                	test   %al,%al
+ 29a:	75 10                	jne    2ac <matchhere+0x73>
+    return *text == '\0';
+ 29c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 29f:	0f b6 00             	movzbl (%eax),%eax
+ 2a2:	84 c0                	test   %al,%al
+ 2a4:	0f 94 c0             	sete   %al
+ 2a7:	0f b6 c0             	movzbl %al,%eax
+ 2aa:	eb 44                	jmp    2f0 <matchhere+0xb7>
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+ 2ac:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2af:	0f b6 00             	movzbl (%eax),%eax
+ 2b2:	84 c0                	test   %al,%al
+ 2b4:	74 35                	je     2eb <matchhere+0xb2>
+ 2b6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b9:	0f b6 00             	movzbl (%eax),%eax
+ 2bc:	3c 2e                	cmp    $0x2e,%al
+ 2be:	74 10                	je     2d0 <matchhere+0x97>
+ 2c0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2c3:	0f b6 10             	movzbl (%eax),%edx
+ 2c6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2c9:	0f b6 00             	movzbl (%eax),%eax
+ 2cc:	38 c2                	cmp    %al,%dl
+ 2ce:	75 1b                	jne    2eb <matchhere+0xb2>
+    return matchhere(re+1, text+1);
+ 2d0:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2d3:	8d 50 01             	lea    0x1(%eax),%edx
+ 2d6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2d9:	83 c0 01             	add    $0x1,%eax
+ 2dc:	83 ec 08             	sub    $0x8,%esp
+ 2df:	52                   	push   %edx
+ 2e0:	50                   	push   %eax
+ 2e1:	e8 53 ff ff ff       	call   239 <matchhere>
+ 2e6:	83 c4 10             	add    $0x10,%esp
+ 2e9:	eb 05                	jmp    2f0 <matchhere+0xb7>
+  return 0;
+ 2eb:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 2f0:	c9                   	leave  
+ 2f1:	c3                   	ret    
+
+000002f2 <matchstar>:
+
+// matchstar: search for c*re at beginning of text
+int matchstar(int c, char *re, char *text)
+{
+ 2f2:	f3 0f 1e fb          	endbr32 
+ 2f6:	55                   	push   %ebp
+ 2f7:	89 e5                	mov    %esp,%ebp
+ 2f9:	83 ec 08             	sub    $0x8,%esp
+  do{  // a * matches zero or more instances
+    if(matchhere(re, text))
+ 2fc:	83 ec 08             	sub    $0x8,%esp
+ 2ff:	ff 75 10             	pushl  0x10(%ebp)
+ 302:	ff 75 0c             	pushl  0xc(%ebp)
+ 305:	e8 2f ff ff ff       	call   239 <matchhere>
+ 30a:	83 c4 10             	add    $0x10,%esp
+ 30d:	85 c0                	test   %eax,%eax
+ 30f:	74 07                	je     318 <matchstar+0x26>
+      return 1;
+ 311:	b8 01 00 00 00       	mov    $0x1,%eax
+ 316:	eb 29                	jmp    341 <matchstar+0x4f>
+  }while(*text!='\0' && (*text++==c || c=='.'));
+ 318:	8b 45 10             	mov    0x10(%ebp),%eax
+ 31b:	0f b6 00             	movzbl (%eax),%eax
+ 31e:	84 c0                	test   %al,%al
+ 320:	74 1a                	je     33c <matchstar+0x4a>
+ 322:	8b 45 10             	mov    0x10(%ebp),%eax
+ 325:	8d 50 01             	lea    0x1(%eax),%edx
+ 328:	89 55 10             	mov    %edx,0x10(%ebp)
+ 32b:	0f b6 00             	movzbl (%eax),%eax
+ 32e:	0f be c0             	movsbl %al,%eax
+ 331:	39 45 08             	cmp    %eax,0x8(%ebp)
+ 334:	74 c6                	je     2fc <matchstar+0xa>
+ 336:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
+ 33a:	74 c0                	je     2fc <matchstar+0xa>
+  return 0;
+ 33c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 341:	c9                   	leave  
+ 342:	c3                   	ret    
+
+00000343 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 343:	55                   	push   %ebp
+ 344:	89 e5                	mov    %esp,%ebp
+ 346:	57                   	push   %edi
+ 347:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 348:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 34b:	8b 55 10             	mov    0x10(%ebp),%edx
+ 34e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 351:	89 cb                	mov    %ecx,%ebx
+ 353:	89 df                	mov    %ebx,%edi
+ 355:	89 d1                	mov    %edx,%ecx
+ 357:	fc                   	cld    
+ 358:	f3 aa                	rep stos %al,%es:(%edi)
+ 35a:	89 ca                	mov    %ecx,%edx
+ 35c:	89 fb                	mov    %edi,%ebx
+ 35e:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 361:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 364:	90                   	nop
+ 365:	5b                   	pop    %ebx
+ 366:	5f                   	pop    %edi
+ 367:	5d                   	pop    %ebp
+ 368:	c3                   	ret    
+
+00000369 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 369:	f3 0f 1e fb          	endbr32 
+ 36d:	55                   	push   %ebp
+ 36e:	89 e5                	mov    %esp,%ebp
+ 370:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 373:	8b 45 08             	mov    0x8(%ebp),%eax
+ 376:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 379:	90                   	nop
+ 37a:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 37d:	8d 42 01             	lea    0x1(%edx),%eax
+ 380:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 383:	8b 45 08             	mov    0x8(%ebp),%eax
+ 386:	8d 48 01             	lea    0x1(%eax),%ecx
+ 389:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 38c:	0f b6 12             	movzbl (%edx),%edx
+ 38f:	88 10                	mov    %dl,(%eax)
+ 391:	0f b6 00             	movzbl (%eax),%eax
+ 394:	84 c0                	test   %al,%al
+ 396:	75 e2                	jne    37a <strcpy+0x11>
+    ;
+  return os;
+ 398:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 39b:	c9                   	leave  
+ 39c:	c3                   	ret    
+
+0000039d <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 39d:	f3 0f 1e fb          	endbr32 
+ 3a1:	55                   	push   %ebp
+ 3a2:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 3a4:	eb 08                	jmp    3ae <strcmp+0x11>
+    p++, q++;
+ 3a6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 3aa:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 3ae:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3b1:	0f b6 00             	movzbl (%eax),%eax
+ 3b4:	84 c0                	test   %al,%al
+ 3b6:	74 10                	je     3c8 <strcmp+0x2b>
+ 3b8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3bb:	0f b6 10             	movzbl (%eax),%edx
+ 3be:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3c1:	0f b6 00             	movzbl (%eax),%eax
+ 3c4:	38 c2                	cmp    %al,%dl
+ 3c6:	74 de                	je     3a6 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 3c8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3cb:	0f b6 00             	movzbl (%eax),%eax
+ 3ce:	0f b6 d0             	movzbl %al,%edx
+ 3d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3d4:	0f b6 00             	movzbl (%eax),%eax
+ 3d7:	0f b6 c0             	movzbl %al,%eax
+ 3da:	29 c2                	sub    %eax,%edx
+ 3dc:	89 d0                	mov    %edx,%eax
+}
+ 3de:	5d                   	pop    %ebp
+ 3df:	c3                   	ret    
+
+000003e0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 3e0:	f3 0f 1e fb          	endbr32 
+ 3e4:	55                   	push   %ebp
+ 3e5:	89 e5                	mov    %esp,%ebp
+ 3e7:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 3ea:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 3f1:	eb 04                	jmp    3f7 <strlen+0x17>
+ 3f3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 3f7:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 3fa:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3fd:	01 d0                	add    %edx,%eax
+ 3ff:	0f b6 00             	movzbl (%eax),%eax
+ 402:	84 c0                	test   %al,%al
+ 404:	75 ed                	jne    3f3 <strlen+0x13>
+    ;
+  return n;
+ 406:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 409:	c9                   	leave  
+ 40a:	c3                   	ret    
+
+0000040b <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 40b:	f3 0f 1e fb          	endbr32 
+ 40f:	55                   	push   %ebp
+ 410:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 412:	8b 45 10             	mov    0x10(%ebp),%eax
+ 415:	50                   	push   %eax
+ 416:	ff 75 0c             	pushl  0xc(%ebp)
+ 419:	ff 75 08             	pushl  0x8(%ebp)
+ 41c:	e8 22 ff ff ff       	call   343 <stosb>
+ 421:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 424:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 427:	c9                   	leave  
+ 428:	c3                   	ret    
+
+00000429 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 429:	f3 0f 1e fb          	endbr32 
+ 42d:	55                   	push   %ebp
+ 42e:	89 e5                	mov    %esp,%ebp
+ 430:	83 ec 04             	sub    $0x4,%esp
+ 433:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 436:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 439:	eb 14                	jmp    44f <strchr+0x26>
+    if(*s == c)
+ 43b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 43e:	0f b6 00             	movzbl (%eax),%eax
+ 441:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 444:	75 05                	jne    44b <strchr+0x22>
+      return (char*)s;
+ 446:	8b 45 08             	mov    0x8(%ebp),%eax
+ 449:	eb 13                	jmp    45e <strchr+0x35>
+  for(; *s; s++)
+ 44b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 44f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 452:	0f b6 00             	movzbl (%eax),%eax
+ 455:	84 c0                	test   %al,%al
+ 457:	75 e2                	jne    43b <strchr+0x12>
+  return 0;
+ 459:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 45e:	c9                   	leave  
+ 45f:	c3                   	ret    
+
+00000460 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 460:	f3 0f 1e fb          	endbr32 
+ 464:	55                   	push   %ebp
+ 465:	89 e5                	mov    %esp,%ebp
+ 467:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 46a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 471:	eb 42                	jmp    4b5 <gets+0x55>
+    cc = read(0, &c, 1);
+ 473:	83 ec 04             	sub    $0x4,%esp
+ 476:	6a 01                	push   $0x1
+ 478:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 47b:	50                   	push   %eax
+ 47c:	6a 00                	push   $0x0
+ 47e:	e8 53 01 00 00       	call   5d6 <read>
+ 483:	83 c4 10             	add    $0x10,%esp
+ 486:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 489:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 48d:	7e 33                	jle    4c2 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 48f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 492:	8d 50 01             	lea    0x1(%eax),%edx
+ 495:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 498:	89 c2                	mov    %eax,%edx
+ 49a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 49d:	01 c2                	add    %eax,%edx
+ 49f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4a3:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 4a5:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4a9:	3c 0a                	cmp    $0xa,%al
+ 4ab:	74 16                	je     4c3 <gets+0x63>
+ 4ad:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4b1:	3c 0d                	cmp    $0xd,%al
+ 4b3:	74 0e                	je     4c3 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 4b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4b8:	83 c0 01             	add    $0x1,%eax
+ 4bb:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 4be:	7f b3                	jg     473 <gets+0x13>
+ 4c0:	eb 01                	jmp    4c3 <gets+0x63>
+      break;
+ 4c2:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 4c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 4c6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4c9:	01 d0                	add    %edx,%eax
+ 4cb:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 4ce:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 4d1:	c9                   	leave  
+ 4d2:	c3                   	ret    
+
+000004d3 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 4d3:	f3 0f 1e fb          	endbr32 
+ 4d7:	55                   	push   %ebp
+ 4d8:	89 e5                	mov    %esp,%ebp
+ 4da:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 4dd:	83 ec 08             	sub    $0x8,%esp
+ 4e0:	6a 00                	push   $0x0
+ 4e2:	ff 75 08             	pushl  0x8(%ebp)
+ 4e5:	e8 14 01 00 00       	call   5fe <open>
+ 4ea:	83 c4 10             	add    $0x10,%esp
+ 4ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 4f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 4f4:	79 07                	jns    4fd <stat+0x2a>
+    return -1;
+ 4f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 4fb:	eb 25                	jmp    522 <stat+0x4f>
+  r = fstat(fd, st);
+ 4fd:	83 ec 08             	sub    $0x8,%esp
+ 500:	ff 75 0c             	pushl  0xc(%ebp)
+ 503:	ff 75 f4             	pushl  -0xc(%ebp)
+ 506:	e8 0b 01 00 00       	call   616 <fstat>
+ 50b:	83 c4 10             	add    $0x10,%esp
+ 50e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 511:	83 ec 0c             	sub    $0xc,%esp
+ 514:	ff 75 f4             	pushl  -0xc(%ebp)
+ 517:	e8 ca 00 00 00       	call   5e6 <close>
+ 51c:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 51f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 522:	c9                   	leave  
+ 523:	c3                   	ret    
+
+00000524 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 524:	f3 0f 1e fb          	endbr32 
+ 528:	55                   	push   %ebp
+ 529:	89 e5                	mov    %esp,%ebp
+ 52b:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 52e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 535:	eb 25                	jmp    55c <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 537:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 53a:	89 d0                	mov    %edx,%eax
+ 53c:	c1 e0 02             	shl    $0x2,%eax
+ 53f:	01 d0                	add    %edx,%eax
+ 541:	01 c0                	add    %eax,%eax
+ 543:	89 c1                	mov    %eax,%ecx
+ 545:	8b 45 08             	mov    0x8(%ebp),%eax
+ 548:	8d 50 01             	lea    0x1(%eax),%edx
+ 54b:	89 55 08             	mov    %edx,0x8(%ebp)
+ 54e:	0f b6 00             	movzbl (%eax),%eax
+ 551:	0f be c0             	movsbl %al,%eax
+ 554:	01 c8                	add    %ecx,%eax
+ 556:	83 e8 30             	sub    $0x30,%eax
+ 559:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 55c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 55f:	0f b6 00             	movzbl (%eax),%eax
+ 562:	3c 2f                	cmp    $0x2f,%al
+ 564:	7e 0a                	jle    570 <atoi+0x4c>
+ 566:	8b 45 08             	mov    0x8(%ebp),%eax
+ 569:	0f b6 00             	movzbl (%eax),%eax
+ 56c:	3c 39                	cmp    $0x39,%al
+ 56e:	7e c7                	jle    537 <atoi+0x13>
+  return n;
+ 570:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 573:	c9                   	leave  
+ 574:	c3                   	ret    
+
+00000575 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 575:	f3 0f 1e fb          	endbr32 
+ 579:	55                   	push   %ebp
+ 57a:	89 e5                	mov    %esp,%ebp
+ 57c:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 57f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 582:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 585:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 588:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 58b:	eb 17                	jmp    5a4 <memmove+0x2f>
+    *dst++ = *src++;
+ 58d:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 590:	8d 42 01             	lea    0x1(%edx),%eax
+ 593:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 596:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 599:	8d 48 01             	lea    0x1(%eax),%ecx
+ 59c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 59f:	0f b6 12             	movzbl (%edx),%edx
+ 5a2:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 5a4:	8b 45 10             	mov    0x10(%ebp),%eax
+ 5a7:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 5aa:	89 55 10             	mov    %edx,0x10(%ebp)
+ 5ad:	85 c0                	test   %eax,%eax
+ 5af:	7f dc                	jg     58d <memmove+0x18>
+  return vdst;
+ 5b1:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 5b4:	c9                   	leave  
+ 5b5:	c3                   	ret    
+
+000005b6 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 5b6:	b8 01 00 00 00       	mov    $0x1,%eax
+ 5bb:	cd 40                	int    $0x40
+ 5bd:	c3                   	ret    
+
+000005be <exit>:
+SYSCALL(exit)
+ 5be:	b8 02 00 00 00       	mov    $0x2,%eax
+ 5c3:	cd 40                	int    $0x40
+ 5c5:	c3                   	ret    
+
+000005c6 <wait>:
+SYSCALL(wait)
+ 5c6:	b8 03 00 00 00       	mov    $0x3,%eax
+ 5cb:	cd 40                	int    $0x40
+ 5cd:	c3                   	ret    
+
+000005ce <pipe>:
+SYSCALL(pipe)
+ 5ce:	b8 04 00 00 00       	mov    $0x4,%eax
+ 5d3:	cd 40                	int    $0x40
+ 5d5:	c3                   	ret    
+
+000005d6 <read>:
+SYSCALL(read)
+ 5d6:	b8 05 00 00 00       	mov    $0x5,%eax
+ 5db:	cd 40                	int    $0x40
+ 5dd:	c3                   	ret    
+
+000005de <write>:
+SYSCALL(write)
+ 5de:	b8 10 00 00 00       	mov    $0x10,%eax
+ 5e3:	cd 40                	int    $0x40
+ 5e5:	c3                   	ret    
+
+000005e6 <close>:
+SYSCALL(close)
+ 5e6:	b8 15 00 00 00       	mov    $0x15,%eax
+ 5eb:	cd 40                	int    $0x40
+ 5ed:	c3                   	ret    
+
+000005ee <kill>:
+SYSCALL(kill)
+ 5ee:	b8 06 00 00 00       	mov    $0x6,%eax
+ 5f3:	cd 40                	int    $0x40
+ 5f5:	c3                   	ret    
+
+000005f6 <exec>:
+SYSCALL(exec)
+ 5f6:	b8 07 00 00 00       	mov    $0x7,%eax
+ 5fb:	cd 40                	int    $0x40
+ 5fd:	c3                   	ret    
+
+000005fe <open>:
+SYSCALL(open)
+ 5fe:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 603:	cd 40                	int    $0x40
+ 605:	c3                   	ret    
+
+00000606 <mknod>:
+SYSCALL(mknod)
+ 606:	b8 11 00 00 00       	mov    $0x11,%eax
+ 60b:	cd 40                	int    $0x40
+ 60d:	c3                   	ret    
+
+0000060e <unlink>:
+SYSCALL(unlink)
+ 60e:	b8 12 00 00 00       	mov    $0x12,%eax
+ 613:	cd 40                	int    $0x40
+ 615:	c3                   	ret    
+
+00000616 <fstat>:
+SYSCALL(fstat)
+ 616:	b8 08 00 00 00       	mov    $0x8,%eax
+ 61b:	cd 40                	int    $0x40
+ 61d:	c3                   	ret    
+
+0000061e <link>:
+SYSCALL(link)
+ 61e:	b8 13 00 00 00       	mov    $0x13,%eax
+ 623:	cd 40                	int    $0x40
+ 625:	c3                   	ret    
+
+00000626 <mkdir>:
+SYSCALL(mkdir)
+ 626:	b8 14 00 00 00       	mov    $0x14,%eax
+ 62b:	cd 40                	int    $0x40
+ 62d:	c3                   	ret    
+
+0000062e <chdir>:
+SYSCALL(chdir)
+ 62e:	b8 09 00 00 00       	mov    $0x9,%eax
+ 633:	cd 40                	int    $0x40
+ 635:	c3                   	ret    
+
+00000636 <dup>:
+SYSCALL(dup)
+ 636:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 63b:	cd 40                	int    $0x40
+ 63d:	c3                   	ret    
+
+0000063e <getpid>:
+SYSCALL(getpid)
+ 63e:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 643:	cd 40                	int    $0x40
+ 645:	c3                   	ret    
+
+00000646 <sbrk>:
+SYSCALL(sbrk)
+ 646:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 64b:	cd 40                	int    $0x40
+ 64d:	c3                   	ret    
+
+0000064e <sleep>:
+SYSCALL(sleep)
+ 64e:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 653:	cd 40                	int    $0x40
+ 655:	c3                   	ret    
+
+00000656 <uptime>:
+SYSCALL(uptime)
+ 656:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 65b:	cd 40                	int    $0x40
+ 65d:	c3                   	ret    
+
+0000065e <draw>:
+SYSCALL(draw)
+ 65e:	b8 16 00 00 00       	mov    $0x16,%eax
+ 663:	cd 40                	int    $0x40
+ 665:	c3                   	ret    
+
+00000666 <cps>:
+SYSCALL(cps)
+ 666:	b8 17 00 00 00       	mov    $0x17,%eax
+ 66b:	cd 40                	int    $0x40
+ 66d:	c3                   	ret    
+
+0000066e <yield>:
+SYSCALL(yield)
+ 66e:	b8 18 00 00 00       	mov    $0x18,%eax
+ 673:	cd 40                	int    $0x40
+ 675:	c3                   	ret    
+
+00000676 <wait2>:
+SYSCALL(wait2)
+ 676:	b8 19 00 00 00       	mov    $0x19,%eax
+ 67b:	cd 40                	int    $0x40
+ 67d:	c3                   	ret    
+
+0000067e <set_prio>:
+SYSCALL(set_prio)
+ 67e:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 683:	cd 40                	int    $0x40
+ 685:	c3                   	ret    
+
+00000686 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 686:	f3 0f 1e fb          	endbr32 
+ 68a:	55                   	push   %ebp
+ 68b:	89 e5                	mov    %esp,%ebp
+ 68d:	83 ec 18             	sub    $0x18,%esp
+ 690:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 693:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 696:	83 ec 04             	sub    $0x4,%esp
+ 699:	6a 01                	push   $0x1
+ 69b:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 69e:	50                   	push   %eax
+ 69f:	ff 75 08             	pushl  0x8(%ebp)
+ 6a2:	e8 37 ff ff ff       	call   5de <write>
+ 6a7:	83 c4 10             	add    $0x10,%esp
+}
+ 6aa:	90                   	nop
+ 6ab:	c9                   	leave  
+ 6ac:	c3                   	ret    
+
+000006ad <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 6ad:	f3 0f 1e fb          	endbr32 
+ 6b1:	55                   	push   %ebp
+ 6b2:	89 e5                	mov    %esp,%ebp
+ 6b4:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 6b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 6be:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 6c2:	74 17                	je     6db <printint+0x2e>
+ 6c4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 6c8:	79 11                	jns    6db <printint+0x2e>
+    neg = 1;
+ 6ca:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 6d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6d4:	f7 d8                	neg    %eax
+ 6d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 6d9:	eb 06                	jmp    6e1 <printint+0x34>
+  } else {
+    x = xx;
+ 6db:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6de:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 6e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 6e8:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 6eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 6ee:	ba 00 00 00 00       	mov    $0x0,%edx
+ 6f3:	f7 f1                	div    %ecx
+ 6f5:	89 d1                	mov    %edx,%ecx
+ 6f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6fa:	8d 50 01             	lea    0x1(%eax),%edx
+ 6fd:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 700:	0f b6 91 34 0e 00 00 	movzbl 0xe34(%ecx),%edx
+ 707:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 70b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 70e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 711:	ba 00 00 00 00       	mov    $0x0,%edx
+ 716:	f7 f1                	div    %ecx
+ 718:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 71b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 71f:	75 c7                	jne    6e8 <printint+0x3b>
+  if(neg)
+ 721:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 725:	74 2d                	je     754 <printint+0xa7>
+    buf[i++] = '-';
+ 727:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 72a:	8d 50 01             	lea    0x1(%eax),%edx
+ 72d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 730:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 735:	eb 1d                	jmp    754 <printint+0xa7>
+    putc(fd, buf[i]);
+ 737:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 73a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 73d:	01 d0                	add    %edx,%eax
+ 73f:	0f b6 00             	movzbl (%eax),%eax
+ 742:	0f be c0             	movsbl %al,%eax
+ 745:	83 ec 08             	sub    $0x8,%esp
+ 748:	50                   	push   %eax
+ 749:	ff 75 08             	pushl  0x8(%ebp)
+ 74c:	e8 35 ff ff ff       	call   686 <putc>
+ 751:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 754:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 758:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 75c:	79 d9                	jns    737 <printint+0x8a>
+}
+ 75e:	90                   	nop
+ 75f:	90                   	nop
+ 760:	c9                   	leave  
+ 761:	c3                   	ret    
+
+00000762 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 762:	f3 0f 1e fb          	endbr32 
+ 766:	55                   	push   %ebp
+ 767:	89 e5                	mov    %esp,%ebp
+ 769:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 76c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 773:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 776:	83 c0 04             	add    $0x4,%eax
+ 779:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 77c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 783:	e9 59 01 00 00       	jmp    8e1 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 788:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 78b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 78e:	01 d0                	add    %edx,%eax
+ 790:	0f b6 00             	movzbl (%eax),%eax
+ 793:	0f be c0             	movsbl %al,%eax
+ 796:	25 ff 00 00 00       	and    $0xff,%eax
+ 79b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 79e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 7a2:	75 2c                	jne    7d0 <printf+0x6e>
+      if(c == '%'){
+ 7a4:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 7a8:	75 0c                	jne    7b6 <printf+0x54>
+        state = '%';
+ 7aa:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 7b1:	e9 27 01 00 00       	jmp    8dd <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 7b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 7b9:	0f be c0             	movsbl %al,%eax
+ 7bc:	83 ec 08             	sub    $0x8,%esp
+ 7bf:	50                   	push   %eax
+ 7c0:	ff 75 08             	pushl  0x8(%ebp)
+ 7c3:	e8 be fe ff ff       	call   686 <putc>
+ 7c8:	83 c4 10             	add    $0x10,%esp
+ 7cb:	e9 0d 01 00 00       	jmp    8dd <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 7d0:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 7d4:	0f 85 03 01 00 00    	jne    8dd <printf+0x17b>
+      if(c == 'd'){
+ 7da:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 7de:	75 1e                	jne    7fe <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 7e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 7e3:	8b 00                	mov    (%eax),%eax
+ 7e5:	6a 01                	push   $0x1
+ 7e7:	6a 0a                	push   $0xa
+ 7e9:	50                   	push   %eax
+ 7ea:	ff 75 08             	pushl  0x8(%ebp)
+ 7ed:	e8 bb fe ff ff       	call   6ad <printint>
+ 7f2:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 7f5:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 7f9:	e9 d8 00 00 00       	jmp    8d6 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 7fe:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 802:	74 06                	je     80a <printf+0xa8>
+ 804:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 808:	75 1e                	jne    828 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 80a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 80d:	8b 00                	mov    (%eax),%eax
+ 80f:	6a 00                	push   $0x0
+ 811:	6a 10                	push   $0x10
+ 813:	50                   	push   %eax
+ 814:	ff 75 08             	pushl  0x8(%ebp)
+ 817:	e8 91 fe ff ff       	call   6ad <printint>
+ 81c:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 81f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 823:	e9 ae 00 00 00       	jmp    8d6 <printf+0x174>
+      } else if(c == 's'){
+ 828:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 82c:	75 43                	jne    871 <printf+0x10f>
+        s = (char*)*ap;
+ 82e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 831:	8b 00                	mov    (%eax),%eax
+ 833:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 836:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 83a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 83e:	75 25                	jne    865 <printf+0x103>
+          s = "(null)";
+ 840:	c7 45 f4 62 0b 00 00 	movl   $0xb62,-0xc(%ebp)
+        while(*s != 0){
+ 847:	eb 1c                	jmp    865 <printf+0x103>
+          putc(fd, *s);
+ 849:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 84c:	0f b6 00             	movzbl (%eax),%eax
+ 84f:	0f be c0             	movsbl %al,%eax
+ 852:	83 ec 08             	sub    $0x8,%esp
+ 855:	50                   	push   %eax
+ 856:	ff 75 08             	pushl  0x8(%ebp)
+ 859:	e8 28 fe ff ff       	call   686 <putc>
+ 85e:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 861:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 865:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 868:	0f b6 00             	movzbl (%eax),%eax
+ 86b:	84 c0                	test   %al,%al
+ 86d:	75 da                	jne    849 <printf+0xe7>
+ 86f:	eb 65                	jmp    8d6 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 871:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 875:	75 1d                	jne    894 <printf+0x132>
+        putc(fd, *ap);
+ 877:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 87a:	8b 00                	mov    (%eax),%eax
+ 87c:	0f be c0             	movsbl %al,%eax
+ 87f:	83 ec 08             	sub    $0x8,%esp
+ 882:	50                   	push   %eax
+ 883:	ff 75 08             	pushl  0x8(%ebp)
+ 886:	e8 fb fd ff ff       	call   686 <putc>
+ 88b:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 88e:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 892:	eb 42                	jmp    8d6 <printf+0x174>
+      } else if(c == '%'){
+ 894:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 898:	75 17                	jne    8b1 <printf+0x14f>
+        putc(fd, c);
+ 89a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 89d:	0f be c0             	movsbl %al,%eax
+ 8a0:	83 ec 08             	sub    $0x8,%esp
+ 8a3:	50                   	push   %eax
+ 8a4:	ff 75 08             	pushl  0x8(%ebp)
+ 8a7:	e8 da fd ff ff       	call   686 <putc>
+ 8ac:	83 c4 10             	add    $0x10,%esp
+ 8af:	eb 25                	jmp    8d6 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 8b1:	83 ec 08             	sub    $0x8,%esp
+ 8b4:	6a 25                	push   $0x25
+ 8b6:	ff 75 08             	pushl  0x8(%ebp)
+ 8b9:	e8 c8 fd ff ff       	call   686 <putc>
+ 8be:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 8c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 8c4:	0f be c0             	movsbl %al,%eax
+ 8c7:	83 ec 08             	sub    $0x8,%esp
+ 8ca:	50                   	push   %eax
+ 8cb:	ff 75 08             	pushl  0x8(%ebp)
+ 8ce:	e8 b3 fd ff ff       	call   686 <putc>
+ 8d3:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 8d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 8dd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 8e1:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 8e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8e7:	01 d0                	add    %edx,%eax
+ 8e9:	0f b6 00             	movzbl (%eax),%eax
+ 8ec:	84 c0                	test   %al,%al
+ 8ee:	0f 85 94 fe ff ff    	jne    788 <printf+0x26>
+    }
+  }
+}
+ 8f4:	90                   	nop
+ 8f5:	90                   	nop
+ 8f6:	c9                   	leave  
+ 8f7:	c3                   	ret    
+
+000008f8 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 8f8:	f3 0f 1e fb          	endbr32 
+ 8fc:	55                   	push   %ebp
+ 8fd:	89 e5                	mov    %esp,%ebp
+ 8ff:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 902:	8b 45 08             	mov    0x8(%ebp),%eax
+ 905:	83 e8 08             	sub    $0x8,%eax
+ 908:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 90b:	a1 68 0e 00 00       	mov    0xe68,%eax
+ 910:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 913:	eb 24                	jmp    939 <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 915:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 918:	8b 00                	mov    (%eax),%eax
+ 91a:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 91d:	72 12                	jb     931 <free+0x39>
+ 91f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 922:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 925:	77 24                	ja     94b <free+0x53>
+ 927:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 92a:	8b 00                	mov    (%eax),%eax
+ 92c:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 92f:	72 1a                	jb     94b <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 931:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 934:	8b 00                	mov    (%eax),%eax
+ 936:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 939:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 93c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 93f:	76 d4                	jbe    915 <free+0x1d>
+ 941:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 944:	8b 00                	mov    (%eax),%eax
+ 946:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 949:	73 ca                	jae    915 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 94b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 94e:	8b 40 04             	mov    0x4(%eax),%eax
+ 951:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 958:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 95b:	01 c2                	add    %eax,%edx
+ 95d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 960:	8b 00                	mov    (%eax),%eax
+ 962:	39 c2                	cmp    %eax,%edx
+ 964:	75 24                	jne    98a <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 966:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 969:	8b 50 04             	mov    0x4(%eax),%edx
+ 96c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 96f:	8b 00                	mov    (%eax),%eax
+ 971:	8b 40 04             	mov    0x4(%eax),%eax
+ 974:	01 c2                	add    %eax,%edx
+ 976:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 979:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 97c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 97f:	8b 00                	mov    (%eax),%eax
+ 981:	8b 10                	mov    (%eax),%edx
+ 983:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 986:	89 10                	mov    %edx,(%eax)
+ 988:	eb 0a                	jmp    994 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 98a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 98d:	8b 10                	mov    (%eax),%edx
+ 98f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 992:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 994:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 997:	8b 40 04             	mov    0x4(%eax),%eax
+ 99a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 9a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9a4:	01 d0                	add    %edx,%eax
+ 9a6:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 9a9:	75 20                	jne    9cb <free+0xd3>
+    p->s.size += bp->s.size;
+ 9ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9ae:	8b 50 04             	mov    0x4(%eax),%edx
+ 9b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9b4:	8b 40 04             	mov    0x4(%eax),%eax
+ 9b7:	01 c2                	add    %eax,%edx
+ 9b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9bc:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 9bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9c2:	8b 10                	mov    (%eax),%edx
+ 9c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9c7:	89 10                	mov    %edx,(%eax)
+ 9c9:	eb 08                	jmp    9d3 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 9cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9ce:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 9d1:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 9d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9d6:	a3 68 0e 00 00       	mov    %eax,0xe68
+}
+ 9db:	90                   	nop
+ 9dc:	c9                   	leave  
+ 9dd:	c3                   	ret    
+
+000009de <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 9de:	f3 0f 1e fb          	endbr32 
+ 9e2:	55                   	push   %ebp
+ 9e3:	89 e5                	mov    %esp,%ebp
+ 9e5:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 9e8:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 9ef:	77 07                	ja     9f8 <morecore+0x1a>
+    nu = 4096;
+ 9f1:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 9f8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 9fb:	c1 e0 03             	shl    $0x3,%eax
+ 9fe:	83 ec 0c             	sub    $0xc,%esp
+ a01:	50                   	push   %eax
+ a02:	e8 3f fc ff ff       	call   646 <sbrk>
+ a07:	83 c4 10             	add    $0x10,%esp
+ a0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ a0d:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ a11:	75 07                	jne    a1a <morecore+0x3c>
+    return 0;
+ a13:	b8 00 00 00 00       	mov    $0x0,%eax
+ a18:	eb 26                	jmp    a40 <morecore+0x62>
+  hp = (Header*)p;
+ a1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ a1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ a20:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a23:	8b 55 08             	mov    0x8(%ebp),%edx
+ a26:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ a29:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a2c:	83 c0 08             	add    $0x8,%eax
+ a2f:	83 ec 0c             	sub    $0xc,%esp
+ a32:	50                   	push   %eax
+ a33:	e8 c0 fe ff ff       	call   8f8 <free>
+ a38:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ a3b:	a1 68 0e 00 00       	mov    0xe68,%eax
+}
+ a40:	c9                   	leave  
+ a41:	c3                   	ret    
+
+00000a42 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ a42:	f3 0f 1e fb          	endbr32 
+ a46:	55                   	push   %ebp
+ a47:	89 e5                	mov    %esp,%ebp
+ a49:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ a4c:	8b 45 08             	mov    0x8(%ebp),%eax
+ a4f:	83 c0 07             	add    $0x7,%eax
+ a52:	c1 e8 03             	shr    $0x3,%eax
+ a55:	83 c0 01             	add    $0x1,%eax
+ a58:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ a5b:	a1 68 0e 00 00       	mov    0xe68,%eax
+ a60:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ a63:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ a67:	75 23                	jne    a8c <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ a69:	c7 45 f0 60 0e 00 00 	movl   $0xe60,-0x10(%ebp)
+ a70:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a73:	a3 68 0e 00 00       	mov    %eax,0xe68
+ a78:	a1 68 0e 00 00       	mov    0xe68,%eax
+ a7d:	a3 60 0e 00 00       	mov    %eax,0xe60
+    base.s.size = 0;
+ a82:	c7 05 64 0e 00 00 00 	movl   $0x0,0xe64
+ a89:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ a8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a8f:	8b 00                	mov    (%eax),%eax
+ a91:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ a94:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ a97:	8b 40 04             	mov    0x4(%eax),%eax
+ a9a:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ a9d:	77 4d                	ja     aec <malloc+0xaa>
+      if(p->s.size == nunits)
+ a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ aa2:	8b 40 04             	mov    0x4(%eax),%eax
+ aa5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ aa8:	75 0c                	jne    ab6 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ aaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ aad:	8b 10                	mov    (%eax),%edx
+ aaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ ab2:	89 10                	mov    %edx,(%eax)
+ ab4:	eb 26                	jmp    adc <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ ab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ab9:	8b 40 04             	mov    0x4(%eax),%eax
+ abc:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ abf:	89 c2                	mov    %eax,%edx
+ ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ac4:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ ac7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ aca:	8b 40 04             	mov    0x4(%eax),%eax
+ acd:	c1 e0 03             	shl    $0x3,%eax
+ ad0:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ ad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ad6:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ ad9:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ adc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ adf:	a3 68 0e 00 00       	mov    %eax,0xe68
+      return (void*)(p + 1);
+ ae4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ae7:	83 c0 08             	add    $0x8,%eax
+ aea:	eb 3b                	jmp    b27 <malloc+0xe5>
+    }
+    if(p == freep)
+ aec:	a1 68 0e 00 00       	mov    0xe68,%eax
+ af1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ af4:	75 1e                	jne    b14 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ af6:	83 ec 0c             	sub    $0xc,%esp
+ af9:	ff 75 ec             	pushl  -0x14(%ebp)
+ afc:	e8 dd fe ff ff       	call   9de <morecore>
+ b01:	83 c4 10             	add    $0x10,%esp
+ b04:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ b07:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ b0b:	75 07                	jne    b14 <malloc+0xd2>
+        return 0;
+ b0d:	b8 00 00 00 00       	mov    $0x0,%eax
+ b12:	eb 13                	jmp    b27 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ b14:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b17:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ b1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b1d:	8b 00                	mov    (%eax),%eax
+ b1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ b22:	e9 6d ff ff ff       	jmp    a94 <malloc+0x52>
+  }
+}
+ b27:	c9                   	leave  
+ b28:	c3                   	ret    
diff -ruN xv6-public/xv6-public/grep.c xv6-public_new/xv6-public/grep.c
--- xv6-public/xv6-public/grep.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/grep.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,107 @@
+// Simple grep.  Only supports ^ . * $ operators.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+char buf[1024];
+int match(char*, char*);
+
+void
+grep(char *pattern, int fd)
+{
+  int n, m;
+  char *p, *q;
+
+  m = 0;
+  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+    m += n;
+    buf[m] = '\0';
+    p = buf;
+    while((q = strchr(p, '\n')) != 0){
+      *q = 0;
+      if(match(pattern, p)){
+        *q = '\n';
+        write(1, p, q+1 - p);
+      }
+      p = q+1;
+    }
+    if(p == buf)
+      m = 0;
+    if(m > 0){
+      m -= p - buf;
+      memmove(buf, p, m);
+    }
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+  int fd, i;
+  char *pattern;
+
+  if(argc <= 1){
+    printf(2, "usage: grep pattern [file ...]\n");
+    exit();
+  }
+  pattern = argv[1];
+
+  if(argc <= 2){
+    grep(pattern, 0);
+    exit();
+  }
+
+  for(i = 2; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+      printf(1, "grep: cannot open %s\n", argv[i]);
+      exit();
+    }
+    grep(pattern, fd);
+    close(fd);
+  }
+  exit();
+}
+
+// Regexp matcher from Kernighan & Pike,
+// The Practice of Programming, Chapter 9.
+
+int matchhere(char*, char*);
+int matchstar(int, char*, char*);
+
+int
+match(char *re, char *text)
+{
+  if(re[0] == '^')
+    return matchhere(re+1, text);
+  do{  // must look at empty string
+    if(matchhere(re, text))
+      return 1;
+  }while(*text++ != '\0');
+  return 0;
+}
+
+// matchhere: search for re at beginning of text
+int matchhere(char *re, char *text)
+{
+  if(re[0] == '\0')
+    return 1;
+  if(re[1] == '*')
+    return matchstar(re[0], re+2, text);
+  if(re[0] == '$' && re[1] == '\0')
+    return *text == '\0';
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+    return matchhere(re+1, text+1);
+  return 0;
+}
+
+// matchstar: search for c*re at beginning of text
+int matchstar(int c, char *re, char *text)
+{
+  do{  // a * matches zero or more instances
+    if(matchhere(re, text))
+      return 1;
+  }while(*text!='\0' && (*text++==c || c=='.'));
+  return 0;
+}
+
diff -ruN xv6-public/xv6-public/grep.d xv6-public_new/xv6-public/grep.d
--- xv6-public/xv6-public/grep.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/grep.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+grep.o: grep.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/grep.o and xv6-public_new/xv6-public/grep.o differ
diff -ruN xv6-public/xv6-public/grep.sym xv6-public_new/xv6-public/grep.sym
--- xv6-public/xv6-public/grep.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/grep.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,70 @@
+00000000 .text
+00000b2c .rodata
+00000b6c .eh_frame
+00000e34 .data
+00000e60 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 grep.c
+00000000 ulib.c
+00000343 stosb
+00000000 printf.c
+00000686 putc
+000006ad printint
+00000e34 digits.1098
+00000000 umalloc.c
+00000e60 base
+00000e68 freep
+000009de morecore
+00000369 strcpy
+0000066e yield
+0000067e set_prio
+00000762 printf
+00000575 memmove
+00000239 matchhere
+00000606 mknod
+00000460 gets
+0000063e getpid
+00000000 grep
+00000a42 malloc
+0000064e sleep
+00000676 wait2
+000005ce pipe
+000005de write
+00000616 fstat
+000005ee kill
+0000062e chdir
+000005f6 exec
+000005c6 wait
+000005d6 read
+0000060e unlink
+000005b6 fork
+00000646 sbrk
+00000656 uptime
+00000e45 __bss_start
+0000040b memset
+000000fb main
+000002f2 matchstar
+0000039d strcmp
+00000636 dup
+00000e80 buf
+000004d3 stat
+00000e45 _edata
+00001280 _end
+000001db match
+0000061e link
+000005be exit
+00000524 atoi
+0000065e draw
+000003e0 strlen
+000005fe open
+00000429 strchr
+00000666 cps
+00000626 mkdir
+000005e6 close
+000008f8 free
diff -ruN xv6-public/xv6-public/hardik.asm xv6-public_new/xv6-public/hardik.asm
--- xv6-public/xv6-public/hardik.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/hardik.asm	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,1218 @@
+
+_hardik:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+# include "types.h"
+# include "stat.h"
+# include "user.h"
+# include "fcntl.h"
+int main(int argc, char** argv){
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	51                   	push   %ecx
+  12:	83 ec 34             	sub    $0x34,%esp
+	// int val = wait2(&x1, &x2, &x3);
+	// printf(1, "Child which we waited for: %d \n", val);
+	// exit();
+
+	// now only the parent process is running
+	cps();
+  15:	e8 e4 03 00 00       	call   3fe <cps>
+
+	for(int i = 0; i<3 ; i++){
+  1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  21:	e9 8e 00 00 00       	jmp    b4 <main+0xb4>
+		// if it's here it must be the parent only
+		int pid = fork();
+  26:	e8 23 03 00 00       	call   34e <fork>
+  2b:	89 45 d8             	mov    %eax,-0x28(%ebp)
+		if(pid<0){
+  2e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+  32:	79 17                	jns    4b <main+0x4b>
+			printf(1, "@");
+  34:	83 ec 08             	sub    $0x8,%esp
+  37:	68 c8 08 00 00       	push   $0x8c8
+  3c:	6a 01                	push   $0x1
+  3e:	e8 b7 04 00 00       	call   4fa <printf>
+  43:	83 c4 10             	add    $0x10,%esp
+			exit();
+  46:	e8 0b 03 00 00       	call   356 <exit>
+		}else if(pid>0){
+  4b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+  4f:	7e 06                	jle    57 <main+0x57>
+	for(int i = 0; i<3 ; i++){
+  51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  55:	eb 5d                	jmp    b4 <main+0xb4>
+			// still in the parent
+			continue;
+		}else{
+			// in the child now
+			double x = 0.0;
+  57:	d9 ee                	fldz   
+  59:	dd 5d e8             	fstpl  -0x18(%ebp)
+			double y = 1.2;
+  5c:	dd 05 d0 08 00 00    	fldl   0x8d0
+  62:	dd 5d d0             	fstpl  -0x30(%ebp)
+			for(double z = 0.0; z<80.0 ; z++) x+= 3.14 * y;
+  65:	d9 ee                	fldz   
+  67:	dd 5d e0             	fstpl  -0x20(%ebp)
+  6a:	eb 1d                	jmp    89 <main+0x89>
+  6c:	dd 45 d0             	fldl   -0x30(%ebp)
+  6f:	dd 05 d8 08 00 00    	fldl   0x8d8
+  75:	de c9                	fmulp  %st,%st(1)
+  77:	dd 45 e8             	fldl   -0x18(%ebp)
+  7a:	de c1                	faddp  %st,%st(1)
+  7c:	dd 5d e8             	fstpl  -0x18(%ebp)
+  7f:	dd 45 e0             	fldl   -0x20(%ebp)
+  82:	d9 e8                	fld1   
+  84:	de c1                	faddp  %st,%st(1)
+  86:	dd 5d e0             	fstpl  -0x20(%ebp)
+  89:	dd 45 e0             	fldl   -0x20(%ebp)
+  8c:	dd 05 e0 08 00 00    	fldl   0x8e0
+  92:	df f1                	fcomip %st(1),%st
+  94:	dd d8                	fstp   %st(0)
+  96:	77 d4                	ja     6c <main+0x6c>
+			printf(1, "(");
+  98:	83 ec 08             	sub    $0x8,%esp
+  9b:	68 ca 08 00 00       	push   $0x8ca
+  a0:	6a 01                	push   $0x1
+  a2:	e8 53 04 00 00       	call   4fa <printf>
+  a7:	83 c4 10             	add    $0x10,%esp
+			yield();
+  aa:	e8 57 03 00 00       	call   406 <yield>
+			exit();
+  af:	e8 a2 02 00 00       	call   356 <exit>
+	for(int i = 0; i<3 ; i++){
+  b4:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
+  b8:	0f 8e 68 ff ff ff    	jle    26 <main+0x26>
+		}
+	}
+	// if it's here it must be parent, and done with creating all the three children 
+	// now would be a good time to look at the state
+	// cps();
+	for(int i = 0; i<3 ; i++) wait();
+  be:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  c5:	eb 09                	jmp    d0 <main+0xd0>
+  c7:	e8 92 02 00 00       	call   35e <wait>
+  cc:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
+  d0:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
+  d4:	7e f1                	jle    c7 <main+0xc7>
+	exit(); // exits the parent
+  d6:	e8 7b 02 00 00       	call   356 <exit>
+
+000000db <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  db:	55                   	push   %ebp
+  dc:	89 e5                	mov    %esp,%ebp
+  de:	57                   	push   %edi
+  df:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  e0:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  e3:	8b 55 10             	mov    0x10(%ebp),%edx
+  e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  e9:	89 cb                	mov    %ecx,%ebx
+  eb:	89 df                	mov    %ebx,%edi
+  ed:	89 d1                	mov    %edx,%ecx
+  ef:	fc                   	cld    
+  f0:	f3 aa                	rep stos %al,%es:(%edi)
+  f2:	89 ca                	mov    %ecx,%edx
+  f4:	89 fb                	mov    %edi,%ebx
+  f6:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  f9:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  fc:	90                   	nop
+  fd:	5b                   	pop    %ebx
+  fe:	5f                   	pop    %edi
+  ff:	5d                   	pop    %ebp
+ 100:	c3                   	ret    
+
+00000101 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 101:	f3 0f 1e fb          	endbr32 
+ 105:	55                   	push   %ebp
+ 106:	89 e5                	mov    %esp,%ebp
+ 108:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 10b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 10e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 111:	90                   	nop
+ 112:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 115:	8d 42 01             	lea    0x1(%edx),%eax
+ 118:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 11b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 11e:	8d 48 01             	lea    0x1(%eax),%ecx
+ 121:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 124:	0f b6 12             	movzbl (%edx),%edx
+ 127:	88 10                	mov    %dl,(%eax)
+ 129:	0f b6 00             	movzbl (%eax),%eax
+ 12c:	84 c0                	test   %al,%al
+ 12e:	75 e2                	jne    112 <strcpy+0x11>
+    ;
+  return os;
+ 130:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 133:	c9                   	leave  
+ 134:	c3                   	ret    
+
+00000135 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 135:	f3 0f 1e fb          	endbr32 
+ 139:	55                   	push   %ebp
+ 13a:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 13c:	eb 08                	jmp    146 <strcmp+0x11>
+    p++, q++;
+ 13e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 142:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 146:	8b 45 08             	mov    0x8(%ebp),%eax
+ 149:	0f b6 00             	movzbl (%eax),%eax
+ 14c:	84 c0                	test   %al,%al
+ 14e:	74 10                	je     160 <strcmp+0x2b>
+ 150:	8b 45 08             	mov    0x8(%ebp),%eax
+ 153:	0f b6 10             	movzbl (%eax),%edx
+ 156:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 159:	0f b6 00             	movzbl (%eax),%eax
+ 15c:	38 c2                	cmp    %al,%dl
+ 15e:	74 de                	je     13e <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 160:	8b 45 08             	mov    0x8(%ebp),%eax
+ 163:	0f b6 00             	movzbl (%eax),%eax
+ 166:	0f b6 d0             	movzbl %al,%edx
+ 169:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 16c:	0f b6 00             	movzbl (%eax),%eax
+ 16f:	0f b6 c0             	movzbl %al,%eax
+ 172:	29 c2                	sub    %eax,%edx
+ 174:	89 d0                	mov    %edx,%eax
+}
+ 176:	5d                   	pop    %ebp
+ 177:	c3                   	ret    
+
+00000178 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 178:	f3 0f 1e fb          	endbr32 
+ 17c:	55                   	push   %ebp
+ 17d:	89 e5                	mov    %esp,%ebp
+ 17f:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 182:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 189:	eb 04                	jmp    18f <strlen+0x17>
+ 18b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 18f:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 192:	8b 45 08             	mov    0x8(%ebp),%eax
+ 195:	01 d0                	add    %edx,%eax
+ 197:	0f b6 00             	movzbl (%eax),%eax
+ 19a:	84 c0                	test   %al,%al
+ 19c:	75 ed                	jne    18b <strlen+0x13>
+    ;
+  return n;
+ 19e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1a1:	c9                   	leave  
+ 1a2:	c3                   	ret    
+
+000001a3 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1a3:	f3 0f 1e fb          	endbr32 
+ 1a7:	55                   	push   %ebp
+ 1a8:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 1aa:	8b 45 10             	mov    0x10(%ebp),%eax
+ 1ad:	50                   	push   %eax
+ 1ae:	ff 75 0c             	pushl  0xc(%ebp)
+ 1b1:	ff 75 08             	pushl  0x8(%ebp)
+ 1b4:	e8 22 ff ff ff       	call   db <stosb>
+ 1b9:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 1bc:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1bf:	c9                   	leave  
+ 1c0:	c3                   	ret    
+
+000001c1 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 1c1:	f3 0f 1e fb          	endbr32 
+ 1c5:	55                   	push   %ebp
+ 1c6:	89 e5                	mov    %esp,%ebp
+ 1c8:	83 ec 04             	sub    $0x4,%esp
+ 1cb:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1ce:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 1d1:	eb 14                	jmp    1e7 <strchr+0x26>
+    if(*s == c)
+ 1d3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1d6:	0f b6 00             	movzbl (%eax),%eax
+ 1d9:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 1dc:	75 05                	jne    1e3 <strchr+0x22>
+      return (char*)s;
+ 1de:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1e1:	eb 13                	jmp    1f6 <strchr+0x35>
+  for(; *s; s++)
+ 1e3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 1e7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ea:	0f b6 00             	movzbl (%eax),%eax
+ 1ed:	84 c0                	test   %al,%al
+ 1ef:	75 e2                	jne    1d3 <strchr+0x12>
+  return 0;
+ 1f1:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 1f6:	c9                   	leave  
+ 1f7:	c3                   	ret    
+
+000001f8 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1f8:	f3 0f 1e fb          	endbr32 
+ 1fc:	55                   	push   %ebp
+ 1fd:	89 e5                	mov    %esp,%ebp
+ 1ff:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 202:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 209:	eb 42                	jmp    24d <gets+0x55>
+    cc = read(0, &c, 1);
+ 20b:	83 ec 04             	sub    $0x4,%esp
+ 20e:	6a 01                	push   $0x1
+ 210:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 213:	50                   	push   %eax
+ 214:	6a 00                	push   $0x0
+ 216:	e8 53 01 00 00       	call   36e <read>
+ 21b:	83 c4 10             	add    $0x10,%esp
+ 21e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 221:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 225:	7e 33                	jle    25a <gets+0x62>
+      break;
+    buf[i++] = c;
+ 227:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 22a:	8d 50 01             	lea    0x1(%eax),%edx
+ 22d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 230:	89 c2                	mov    %eax,%edx
+ 232:	8b 45 08             	mov    0x8(%ebp),%eax
+ 235:	01 c2                	add    %eax,%edx
+ 237:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 23b:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 23d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 241:	3c 0a                	cmp    $0xa,%al
+ 243:	74 16                	je     25b <gets+0x63>
+ 245:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 249:	3c 0d                	cmp    $0xd,%al
+ 24b:	74 0e                	je     25b <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 24d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 250:	83 c0 01             	add    $0x1,%eax
+ 253:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 256:	7f b3                	jg     20b <gets+0x13>
+ 258:	eb 01                	jmp    25b <gets+0x63>
+      break;
+ 25a:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 25b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 25e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 261:	01 d0                	add    %edx,%eax
+ 263:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 266:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 269:	c9                   	leave  
+ 26a:	c3                   	ret    
+
+0000026b <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 26b:	f3 0f 1e fb          	endbr32 
+ 26f:	55                   	push   %ebp
+ 270:	89 e5                	mov    %esp,%ebp
+ 272:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 275:	83 ec 08             	sub    $0x8,%esp
+ 278:	6a 00                	push   $0x0
+ 27a:	ff 75 08             	pushl  0x8(%ebp)
+ 27d:	e8 14 01 00 00       	call   396 <open>
+ 282:	83 c4 10             	add    $0x10,%esp
+ 285:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 288:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 28c:	79 07                	jns    295 <stat+0x2a>
+    return -1;
+ 28e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 293:	eb 25                	jmp    2ba <stat+0x4f>
+  r = fstat(fd, st);
+ 295:	83 ec 08             	sub    $0x8,%esp
+ 298:	ff 75 0c             	pushl  0xc(%ebp)
+ 29b:	ff 75 f4             	pushl  -0xc(%ebp)
+ 29e:	e8 0b 01 00 00       	call   3ae <fstat>
+ 2a3:	83 c4 10             	add    $0x10,%esp
+ 2a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 2a9:	83 ec 0c             	sub    $0xc,%esp
+ 2ac:	ff 75 f4             	pushl  -0xc(%ebp)
+ 2af:	e8 ca 00 00 00       	call   37e <close>
+ 2b4:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 2b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 2ba:	c9                   	leave  
+ 2bb:	c3                   	ret    
+
+000002bc <atoi>:
+
+int
+atoi(const char *s)
+{
+ 2bc:	f3 0f 1e fb          	endbr32 
+ 2c0:	55                   	push   %ebp
+ 2c1:	89 e5                	mov    %esp,%ebp
+ 2c3:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 2c6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 2cd:	eb 25                	jmp    2f4 <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 2cf:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 2d2:	89 d0                	mov    %edx,%eax
+ 2d4:	c1 e0 02             	shl    $0x2,%eax
+ 2d7:	01 d0                	add    %edx,%eax
+ 2d9:	01 c0                	add    %eax,%eax
+ 2db:	89 c1                	mov    %eax,%ecx
+ 2dd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2e0:	8d 50 01             	lea    0x1(%eax),%edx
+ 2e3:	89 55 08             	mov    %edx,0x8(%ebp)
+ 2e6:	0f b6 00             	movzbl (%eax),%eax
+ 2e9:	0f be c0             	movsbl %al,%eax
+ 2ec:	01 c8                	add    %ecx,%eax
+ 2ee:	83 e8 30             	sub    $0x30,%eax
+ 2f1:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 2f4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2f7:	0f b6 00             	movzbl (%eax),%eax
+ 2fa:	3c 2f                	cmp    $0x2f,%al
+ 2fc:	7e 0a                	jle    308 <atoi+0x4c>
+ 2fe:	8b 45 08             	mov    0x8(%ebp),%eax
+ 301:	0f b6 00             	movzbl (%eax),%eax
+ 304:	3c 39                	cmp    $0x39,%al
+ 306:	7e c7                	jle    2cf <atoi+0x13>
+  return n;
+ 308:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 30b:	c9                   	leave  
+ 30c:	c3                   	ret    
+
+0000030d <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 30d:	f3 0f 1e fb          	endbr32 
+ 311:	55                   	push   %ebp
+ 312:	89 e5                	mov    %esp,%ebp
+ 314:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 317:	8b 45 08             	mov    0x8(%ebp),%eax
+ 31a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 31d:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 320:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 323:	eb 17                	jmp    33c <memmove+0x2f>
+    *dst++ = *src++;
+ 325:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 328:	8d 42 01             	lea    0x1(%edx),%eax
+ 32b:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 32e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 331:	8d 48 01             	lea    0x1(%eax),%ecx
+ 334:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 337:	0f b6 12             	movzbl (%edx),%edx
+ 33a:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 33c:	8b 45 10             	mov    0x10(%ebp),%eax
+ 33f:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 342:	89 55 10             	mov    %edx,0x10(%ebp)
+ 345:	85 c0                	test   %eax,%eax
+ 347:	7f dc                	jg     325 <memmove+0x18>
+  return vdst;
+ 349:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 34c:	c9                   	leave  
+ 34d:	c3                   	ret    
+
+0000034e <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 34e:	b8 01 00 00 00       	mov    $0x1,%eax
+ 353:	cd 40                	int    $0x40
+ 355:	c3                   	ret    
+
+00000356 <exit>:
+SYSCALL(exit)
+ 356:	b8 02 00 00 00       	mov    $0x2,%eax
+ 35b:	cd 40                	int    $0x40
+ 35d:	c3                   	ret    
+
+0000035e <wait>:
+SYSCALL(wait)
+ 35e:	b8 03 00 00 00       	mov    $0x3,%eax
+ 363:	cd 40                	int    $0x40
+ 365:	c3                   	ret    
+
+00000366 <pipe>:
+SYSCALL(pipe)
+ 366:	b8 04 00 00 00       	mov    $0x4,%eax
+ 36b:	cd 40                	int    $0x40
+ 36d:	c3                   	ret    
+
+0000036e <read>:
+SYSCALL(read)
+ 36e:	b8 05 00 00 00       	mov    $0x5,%eax
+ 373:	cd 40                	int    $0x40
+ 375:	c3                   	ret    
+
+00000376 <write>:
+SYSCALL(write)
+ 376:	b8 10 00 00 00       	mov    $0x10,%eax
+ 37b:	cd 40                	int    $0x40
+ 37d:	c3                   	ret    
+
+0000037e <close>:
+SYSCALL(close)
+ 37e:	b8 15 00 00 00       	mov    $0x15,%eax
+ 383:	cd 40                	int    $0x40
+ 385:	c3                   	ret    
+
+00000386 <kill>:
+SYSCALL(kill)
+ 386:	b8 06 00 00 00       	mov    $0x6,%eax
+ 38b:	cd 40                	int    $0x40
+ 38d:	c3                   	ret    
+
+0000038e <exec>:
+SYSCALL(exec)
+ 38e:	b8 07 00 00 00       	mov    $0x7,%eax
+ 393:	cd 40                	int    $0x40
+ 395:	c3                   	ret    
+
+00000396 <open>:
+SYSCALL(open)
+ 396:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 39b:	cd 40                	int    $0x40
+ 39d:	c3                   	ret    
+
+0000039e <mknod>:
+SYSCALL(mknod)
+ 39e:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3a3:	cd 40                	int    $0x40
+ 3a5:	c3                   	ret    
+
+000003a6 <unlink>:
+SYSCALL(unlink)
+ 3a6:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3ab:	cd 40                	int    $0x40
+ 3ad:	c3                   	ret    
+
+000003ae <fstat>:
+SYSCALL(fstat)
+ 3ae:	b8 08 00 00 00       	mov    $0x8,%eax
+ 3b3:	cd 40                	int    $0x40
+ 3b5:	c3                   	ret    
+
+000003b6 <link>:
+SYSCALL(link)
+ 3b6:	b8 13 00 00 00       	mov    $0x13,%eax
+ 3bb:	cd 40                	int    $0x40
+ 3bd:	c3                   	ret    
+
+000003be <mkdir>:
+SYSCALL(mkdir)
+ 3be:	b8 14 00 00 00       	mov    $0x14,%eax
+ 3c3:	cd 40                	int    $0x40
+ 3c5:	c3                   	ret    
+
+000003c6 <chdir>:
+SYSCALL(chdir)
+ 3c6:	b8 09 00 00 00       	mov    $0x9,%eax
+ 3cb:	cd 40                	int    $0x40
+ 3cd:	c3                   	ret    
+
+000003ce <dup>:
+SYSCALL(dup)
+ 3ce:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 3d3:	cd 40                	int    $0x40
+ 3d5:	c3                   	ret    
+
+000003d6 <getpid>:
+SYSCALL(getpid)
+ 3d6:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 3db:	cd 40                	int    $0x40
+ 3dd:	c3                   	ret    
+
+000003de <sbrk>:
+SYSCALL(sbrk)
+ 3de:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 3e3:	cd 40                	int    $0x40
+ 3e5:	c3                   	ret    
+
+000003e6 <sleep>:
+SYSCALL(sleep)
+ 3e6:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 3eb:	cd 40                	int    $0x40
+ 3ed:	c3                   	ret    
+
+000003ee <uptime>:
+SYSCALL(uptime)
+ 3ee:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 3f3:	cd 40                	int    $0x40
+ 3f5:	c3                   	ret    
+
+000003f6 <draw>:
+SYSCALL(draw)
+ 3f6:	b8 16 00 00 00       	mov    $0x16,%eax
+ 3fb:	cd 40                	int    $0x40
+ 3fd:	c3                   	ret    
+
+000003fe <cps>:
+SYSCALL(cps)
+ 3fe:	b8 17 00 00 00       	mov    $0x17,%eax
+ 403:	cd 40                	int    $0x40
+ 405:	c3                   	ret    
+
+00000406 <yield>:
+SYSCALL(yield)
+ 406:	b8 18 00 00 00       	mov    $0x18,%eax
+ 40b:	cd 40                	int    $0x40
+ 40d:	c3                   	ret    
+
+0000040e <wait2>:
+SYSCALL(wait2)
+ 40e:	b8 19 00 00 00       	mov    $0x19,%eax
+ 413:	cd 40                	int    $0x40
+ 415:	c3                   	ret    
+
+00000416 <set_prio>:
+SYSCALL(set_prio)
+ 416:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 41b:	cd 40                	int    $0x40
+ 41d:	c3                   	ret    
+
+0000041e <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 41e:	f3 0f 1e fb          	endbr32 
+ 422:	55                   	push   %ebp
+ 423:	89 e5                	mov    %esp,%ebp
+ 425:	83 ec 18             	sub    $0x18,%esp
+ 428:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 42b:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 42e:	83 ec 04             	sub    $0x4,%esp
+ 431:	6a 01                	push   $0x1
+ 433:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 436:	50                   	push   %eax
+ 437:	ff 75 08             	pushl  0x8(%ebp)
+ 43a:	e8 37 ff ff ff       	call   376 <write>
+ 43f:	83 c4 10             	add    $0x10,%esp
+}
+ 442:	90                   	nop
+ 443:	c9                   	leave  
+ 444:	c3                   	ret    
+
+00000445 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 445:	f3 0f 1e fb          	endbr32 
+ 449:	55                   	push   %ebp
+ 44a:	89 e5                	mov    %esp,%ebp
+ 44c:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 44f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 456:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 45a:	74 17                	je     473 <printint+0x2e>
+ 45c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 460:	79 11                	jns    473 <printint+0x2e>
+    neg = 1;
+ 462:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 469:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 46c:	f7 d8                	neg    %eax
+ 46e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 471:	eb 06                	jmp    479 <printint+0x34>
+  } else {
+    x = xx;
+ 473:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 476:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 479:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 480:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 483:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 486:	ba 00 00 00 00       	mov    $0x0,%edx
+ 48b:	f7 f1                	div    %ecx
+ 48d:	89 d1                	mov    %edx,%ecx
+ 48f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 492:	8d 50 01             	lea    0x1(%eax),%edx
+ 495:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 498:	0f b6 91 34 0b 00 00 	movzbl 0xb34(%ecx),%edx
+ 49f:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 4a3:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 4a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 4a9:	ba 00 00 00 00       	mov    $0x0,%edx
+ 4ae:	f7 f1                	div    %ecx
+ 4b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 4b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4b7:	75 c7                	jne    480 <printint+0x3b>
+  if(neg)
+ 4b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 4bd:	74 2d                	je     4ec <printint+0xa7>
+    buf[i++] = '-';
+ 4bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4c2:	8d 50 01             	lea    0x1(%eax),%edx
+ 4c5:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 4c8:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 4cd:	eb 1d                	jmp    4ec <printint+0xa7>
+    putc(fd, buf[i]);
+ 4cf:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 4d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4d5:	01 d0                	add    %edx,%eax
+ 4d7:	0f b6 00             	movzbl (%eax),%eax
+ 4da:	0f be c0             	movsbl %al,%eax
+ 4dd:	83 ec 08             	sub    $0x8,%esp
+ 4e0:	50                   	push   %eax
+ 4e1:	ff 75 08             	pushl  0x8(%ebp)
+ 4e4:	e8 35 ff ff ff       	call   41e <putc>
+ 4e9:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 4ec:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 4f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 4f4:	79 d9                	jns    4cf <printint+0x8a>
+}
+ 4f6:	90                   	nop
+ 4f7:	90                   	nop
+ 4f8:	c9                   	leave  
+ 4f9:	c3                   	ret    
+
+000004fa <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 4fa:	f3 0f 1e fb          	endbr32 
+ 4fe:	55                   	push   %ebp
+ 4ff:	89 e5                	mov    %esp,%ebp
+ 501:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 504:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 50b:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 50e:	83 c0 04             	add    $0x4,%eax
+ 511:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 514:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 51b:	e9 59 01 00 00       	jmp    679 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 520:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 523:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 526:	01 d0                	add    %edx,%eax
+ 528:	0f b6 00             	movzbl (%eax),%eax
+ 52b:	0f be c0             	movsbl %al,%eax
+ 52e:	25 ff 00 00 00       	and    $0xff,%eax
+ 533:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 536:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 53a:	75 2c                	jne    568 <printf+0x6e>
+      if(c == '%'){
+ 53c:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 540:	75 0c                	jne    54e <printf+0x54>
+        state = '%';
+ 542:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 549:	e9 27 01 00 00       	jmp    675 <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 54e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 551:	0f be c0             	movsbl %al,%eax
+ 554:	83 ec 08             	sub    $0x8,%esp
+ 557:	50                   	push   %eax
+ 558:	ff 75 08             	pushl  0x8(%ebp)
+ 55b:	e8 be fe ff ff       	call   41e <putc>
+ 560:	83 c4 10             	add    $0x10,%esp
+ 563:	e9 0d 01 00 00       	jmp    675 <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 568:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 56c:	0f 85 03 01 00 00    	jne    675 <printf+0x17b>
+      if(c == 'd'){
+ 572:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 576:	75 1e                	jne    596 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 578:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 57b:	8b 00                	mov    (%eax),%eax
+ 57d:	6a 01                	push   $0x1
+ 57f:	6a 0a                	push   $0xa
+ 581:	50                   	push   %eax
+ 582:	ff 75 08             	pushl  0x8(%ebp)
+ 585:	e8 bb fe ff ff       	call   445 <printint>
+ 58a:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 58d:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 591:	e9 d8 00 00 00       	jmp    66e <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 596:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 59a:	74 06                	je     5a2 <printf+0xa8>
+ 59c:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 5a0:	75 1e                	jne    5c0 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 5a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5a5:	8b 00                	mov    (%eax),%eax
+ 5a7:	6a 00                	push   $0x0
+ 5a9:	6a 10                	push   $0x10
+ 5ab:	50                   	push   %eax
+ 5ac:	ff 75 08             	pushl  0x8(%ebp)
+ 5af:	e8 91 fe ff ff       	call   445 <printint>
+ 5b4:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5b7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5bb:	e9 ae 00 00 00       	jmp    66e <printf+0x174>
+      } else if(c == 's'){
+ 5c0:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 5c4:	75 43                	jne    609 <printf+0x10f>
+        s = (char*)*ap;
+ 5c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5c9:	8b 00                	mov    (%eax),%eax
+ 5cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 5ce:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 5d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 5d6:	75 25                	jne    5fd <printf+0x103>
+          s = "(null)";
+ 5d8:	c7 45 f4 e8 08 00 00 	movl   $0x8e8,-0xc(%ebp)
+        while(*s != 0){
+ 5df:	eb 1c                	jmp    5fd <printf+0x103>
+          putc(fd, *s);
+ 5e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5e4:	0f b6 00             	movzbl (%eax),%eax
+ 5e7:	0f be c0             	movsbl %al,%eax
+ 5ea:	83 ec 08             	sub    $0x8,%esp
+ 5ed:	50                   	push   %eax
+ 5ee:	ff 75 08             	pushl  0x8(%ebp)
+ 5f1:	e8 28 fe ff ff       	call   41e <putc>
+ 5f6:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 5f9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 5fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 600:	0f b6 00             	movzbl (%eax),%eax
+ 603:	84 c0                	test   %al,%al
+ 605:	75 da                	jne    5e1 <printf+0xe7>
+ 607:	eb 65                	jmp    66e <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 609:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 60d:	75 1d                	jne    62c <printf+0x132>
+        putc(fd, *ap);
+ 60f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 612:	8b 00                	mov    (%eax),%eax
+ 614:	0f be c0             	movsbl %al,%eax
+ 617:	83 ec 08             	sub    $0x8,%esp
+ 61a:	50                   	push   %eax
+ 61b:	ff 75 08             	pushl  0x8(%ebp)
+ 61e:	e8 fb fd ff ff       	call   41e <putc>
+ 623:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 626:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 62a:	eb 42                	jmp    66e <printf+0x174>
+      } else if(c == '%'){
+ 62c:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 630:	75 17                	jne    649 <printf+0x14f>
+        putc(fd, c);
+ 632:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 635:	0f be c0             	movsbl %al,%eax
+ 638:	83 ec 08             	sub    $0x8,%esp
+ 63b:	50                   	push   %eax
+ 63c:	ff 75 08             	pushl  0x8(%ebp)
+ 63f:	e8 da fd ff ff       	call   41e <putc>
+ 644:	83 c4 10             	add    $0x10,%esp
+ 647:	eb 25                	jmp    66e <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 649:	83 ec 08             	sub    $0x8,%esp
+ 64c:	6a 25                	push   $0x25
+ 64e:	ff 75 08             	pushl  0x8(%ebp)
+ 651:	e8 c8 fd ff ff       	call   41e <putc>
+ 656:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 659:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 65c:	0f be c0             	movsbl %al,%eax
+ 65f:	83 ec 08             	sub    $0x8,%esp
+ 662:	50                   	push   %eax
+ 663:	ff 75 08             	pushl  0x8(%ebp)
+ 666:	e8 b3 fd ff ff       	call   41e <putc>
+ 66b:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 66e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 675:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 679:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 67c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 67f:	01 d0                	add    %edx,%eax
+ 681:	0f b6 00             	movzbl (%eax),%eax
+ 684:	84 c0                	test   %al,%al
+ 686:	0f 85 94 fe ff ff    	jne    520 <printf+0x26>
+    }
+  }
+}
+ 68c:	90                   	nop
+ 68d:	90                   	nop
+ 68e:	c9                   	leave  
+ 68f:	c3                   	ret    
+
+00000690 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 690:	f3 0f 1e fb          	endbr32 
+ 694:	55                   	push   %ebp
+ 695:	89 e5                	mov    %esp,%ebp
+ 697:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 69a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 69d:	83 e8 08             	sub    $0x8,%eax
+ 6a0:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6a3:	a1 50 0b 00 00       	mov    0xb50,%eax
+ 6a8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 6ab:	eb 24                	jmp    6d1 <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 6ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b0:	8b 00                	mov    (%eax),%eax
+ 6b2:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 6b5:	72 12                	jb     6c9 <free+0x39>
+ 6b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ba:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 6bd:	77 24                	ja     6e3 <free+0x53>
+ 6bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c2:	8b 00                	mov    (%eax),%eax
+ 6c4:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6c7:	72 1a                	jb     6e3 <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6cc:	8b 00                	mov    (%eax),%eax
+ 6ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 6d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6d4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 6d7:	76 d4                	jbe    6ad <free+0x1d>
+ 6d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6dc:	8b 00                	mov    (%eax),%eax
+ 6de:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6e1:	73 ca                	jae    6ad <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 6e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e6:	8b 40 04             	mov    0x4(%eax),%eax
+ 6e9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6f3:	01 c2                	add    %eax,%edx
+ 6f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f8:	8b 00                	mov    (%eax),%eax
+ 6fa:	39 c2                	cmp    %eax,%edx
+ 6fc:	75 24                	jne    722 <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 6fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 701:	8b 50 04             	mov    0x4(%eax),%edx
+ 704:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 707:	8b 00                	mov    (%eax),%eax
+ 709:	8b 40 04             	mov    0x4(%eax),%eax
+ 70c:	01 c2                	add    %eax,%edx
+ 70e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 711:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 714:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 717:	8b 00                	mov    (%eax),%eax
+ 719:	8b 10                	mov    (%eax),%edx
+ 71b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 71e:	89 10                	mov    %edx,(%eax)
+ 720:	eb 0a                	jmp    72c <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 722:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 725:	8b 10                	mov    (%eax),%edx
+ 727:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 72a:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 72c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 72f:	8b 40 04             	mov    0x4(%eax),%eax
+ 732:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 739:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 73c:	01 d0                	add    %edx,%eax
+ 73e:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 741:	75 20                	jne    763 <free+0xd3>
+    p->s.size += bp->s.size;
+ 743:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 746:	8b 50 04             	mov    0x4(%eax),%edx
+ 749:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 74c:	8b 40 04             	mov    0x4(%eax),%eax
+ 74f:	01 c2                	add    %eax,%edx
+ 751:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 754:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 757:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 75a:	8b 10                	mov    (%eax),%edx
+ 75c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 75f:	89 10                	mov    %edx,(%eax)
+ 761:	eb 08                	jmp    76b <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 763:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 766:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 769:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 76b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 76e:	a3 50 0b 00 00       	mov    %eax,0xb50
+}
+ 773:	90                   	nop
+ 774:	c9                   	leave  
+ 775:	c3                   	ret    
+
+00000776 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 776:	f3 0f 1e fb          	endbr32 
+ 77a:	55                   	push   %ebp
+ 77b:	89 e5                	mov    %esp,%ebp
+ 77d:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 780:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 787:	77 07                	ja     790 <morecore+0x1a>
+    nu = 4096;
+ 789:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 790:	8b 45 08             	mov    0x8(%ebp),%eax
+ 793:	c1 e0 03             	shl    $0x3,%eax
+ 796:	83 ec 0c             	sub    $0xc,%esp
+ 799:	50                   	push   %eax
+ 79a:	e8 3f fc ff ff       	call   3de <sbrk>
+ 79f:	83 c4 10             	add    $0x10,%esp
+ 7a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 7a5:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 7a9:	75 07                	jne    7b2 <morecore+0x3c>
+    return 0;
+ 7ab:	b8 00 00 00 00       	mov    $0x0,%eax
+ 7b0:	eb 26                	jmp    7d8 <morecore+0x62>
+  hp = (Header*)p;
+ 7b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 7b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7bb:	8b 55 08             	mov    0x8(%ebp),%edx
+ 7be:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 7c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7c4:	83 c0 08             	add    $0x8,%eax
+ 7c7:	83 ec 0c             	sub    $0xc,%esp
+ 7ca:	50                   	push   %eax
+ 7cb:	e8 c0 fe ff ff       	call   690 <free>
+ 7d0:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 7d3:	a1 50 0b 00 00       	mov    0xb50,%eax
+}
+ 7d8:	c9                   	leave  
+ 7d9:	c3                   	ret    
+
+000007da <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 7da:	f3 0f 1e fb          	endbr32 
+ 7de:	55                   	push   %ebp
+ 7df:	89 e5                	mov    %esp,%ebp
+ 7e1:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7e4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7e7:	83 c0 07             	add    $0x7,%eax
+ 7ea:	c1 e8 03             	shr    $0x3,%eax
+ 7ed:	83 c0 01             	add    $0x1,%eax
+ 7f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 7f3:	a1 50 0b 00 00       	mov    0xb50,%eax
+ 7f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 7fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 7ff:	75 23                	jne    824 <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 801:	c7 45 f0 48 0b 00 00 	movl   $0xb48,-0x10(%ebp)
+ 808:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 80b:	a3 50 0b 00 00       	mov    %eax,0xb50
+ 810:	a1 50 0b 00 00       	mov    0xb50,%eax
+ 815:	a3 48 0b 00 00       	mov    %eax,0xb48
+    base.s.size = 0;
+ 81a:	c7 05 4c 0b 00 00 00 	movl   $0x0,0xb4c
+ 821:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 824:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 827:	8b 00                	mov    (%eax),%eax
+ 829:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 82c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 82f:	8b 40 04             	mov    0x4(%eax),%eax
+ 832:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 835:	77 4d                	ja     884 <malloc+0xaa>
+      if(p->s.size == nunits)
+ 837:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 83a:	8b 40 04             	mov    0x4(%eax),%eax
+ 83d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 840:	75 0c                	jne    84e <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 842:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 845:	8b 10                	mov    (%eax),%edx
+ 847:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 84a:	89 10                	mov    %edx,(%eax)
+ 84c:	eb 26                	jmp    874 <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 84e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 851:	8b 40 04             	mov    0x4(%eax),%eax
+ 854:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 857:	89 c2                	mov    %eax,%edx
+ 859:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 85c:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 85f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 862:	8b 40 04             	mov    0x4(%eax),%eax
+ 865:	c1 e0 03             	shl    $0x3,%eax
+ 868:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 86b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 86e:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 871:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 874:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 877:	a3 50 0b 00 00       	mov    %eax,0xb50
+      return (void*)(p + 1);
+ 87c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 87f:	83 c0 08             	add    $0x8,%eax
+ 882:	eb 3b                	jmp    8bf <malloc+0xe5>
+    }
+    if(p == freep)
+ 884:	a1 50 0b 00 00       	mov    0xb50,%eax
+ 889:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 88c:	75 1e                	jne    8ac <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 88e:	83 ec 0c             	sub    $0xc,%esp
+ 891:	ff 75 ec             	pushl  -0x14(%ebp)
+ 894:	e8 dd fe ff ff       	call   776 <morecore>
+ 899:	83 c4 10             	add    $0x10,%esp
+ 89c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 89f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 8a3:	75 07                	jne    8ac <malloc+0xd2>
+        return 0;
+ 8a5:	b8 00 00 00 00       	mov    $0x0,%eax
+ 8aa:	eb 13                	jmp    8bf <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8af:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 8b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8b5:	8b 00                	mov    (%eax),%eax
+ 8b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 8ba:	e9 6d ff ff ff       	jmp    82c <malloc+0x52>
+  }
+}
+ 8bf:	c9                   	leave  
+ 8c0:	c3                   	ret    
diff -ruN xv6-public/xv6-public/hardik.c xv6-public_new/xv6-public/hardik.c
--- xv6-public/xv6-public/hardik.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/hardik.c	2021-09-30 18:05:38.000000000 +0530
@@ -0,0 +1,42 @@
+# include "types.h"
+# include "stat.h"
+# include "user.h"
+# include "fcntl.h"
+int main(int argc, char** argv){
+
+	// int x1 = 74;
+	// int x2 = 90;
+	// int x3 = 11;
+	// fork();
+	// int val = wait2(&x1, &x2, &x3);
+	// printf(1, "Child which we waited for: %d \n", val);
+	// exit();
+
+	// now only the parent process is running
+	cps();
+
+	for(int i = 0; i<3 ; i++){
+		// if it's here it must be the parent only
+		int pid = fork();
+		if(pid<0){
+			printf(1, "@");
+			exit();
+		}else if(pid>0){
+			// still in the parent
+			continue;
+		}else{
+			// in the child now
+			double x = 0.0;
+			double y = 1.2;
+			for(double z = 0.0; z<80.0 ; z++) x+= 3.14 * y;
+			printf(1, "(");
+			yield();
+			exit();
+		}
+	}
+	// if it's here it must be parent, and done with creating all the three children 
+	// now would be a good time to look at the state
+	// cps();
+	for(int i = 0; i<3 ; i++) wait();
+	exit(); // exits the parent
+}
diff -ruN xv6-public/xv6-public/hardik.d xv6-public_new/xv6-public/hardik.d
--- xv6-public/xv6-public/hardik.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/hardik.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,2 @@
+hardik.o: hardik.c /usr/include/stdc-predef.h types.h stat.h user.h \
+ fcntl.h
Binary files xv6-public/xv6-public/hardik.o and xv6-public_new/xv6-public/hardik.o differ
diff -ruN xv6-public/xv6-public/hardik.sym xv6-public_new/xv6-public/hardik.sym
--- xv6-public/xv6-public/hardik.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/hardik.sym	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,66 @@
+00000000 .text
+000008c8 .rodata
+000008f0 .eh_frame
+00000b34 .data
+00000b48 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 hardik.c
+00000000 ulib.c
+000000db stosb
+00000000 printf.c
+0000041e putc
+00000445 printint
+00000b34 digits.1098
+00000000 umalloc.c
+00000b48 base
+00000b50 freep
+00000776 morecore
+00000101 strcpy
+00000406 yield
+00000416 set_prio
+000004fa printf
+0000030d memmove
+0000039e mknod
+000001f8 gets
+000003d6 getpid
+000007da malloc
+000003e6 sleep
+0000040e wait2
+00000366 pipe
+00000376 write
+000003ae fstat
+00000386 kill
+000003c6 chdir
+0000038e exec
+0000035e wait
+0000036e read
+000003a6 unlink
+0000034e fork
+000003de sbrk
+000003ee uptime
+00000b45 __bss_start
+000001a3 memset
+00000000 main
+00000135 strcmp
+000003ce dup
+0000026b stat
+00000b45 _edata
+00000b54 _end
+000003b6 link
+00000356 exit
+000002bc atoi
+000003f6 draw
+00000178 strlen
+00000396 open
+000001c1 strchr
+000003fe cps
+000003be mkdir
+0000037e close
+00000690 free
diff -ruN xv6-public/xv6-public/ide.c xv6-public_new/xv6-public/ide.c
--- xv6-public/xv6-public/ide.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ide.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,168 @@
+// Simple PIO-based (non-DMA) IDE driver code.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+#include "traps.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "buf.h"
+
+#define SECTOR_SIZE   512
+#define IDE_BSY       0x80
+#define IDE_DRDY      0x40
+#define IDE_DF        0x20
+#define IDE_ERR       0x01
+
+#define IDE_CMD_READ  0x20
+#define IDE_CMD_WRITE 0x30
+#define IDE_CMD_RDMUL 0xc4
+#define IDE_CMD_WRMUL 0xc5
+
+// idequeue points to the buf now being read/written to the disk.
+// idequeue->qnext points to the next buf to be processed.
+// You must hold idelock while manipulating queue.
+
+static struct spinlock idelock;
+static struct buf *idequeue;
+
+static int havedisk1;
+static void idestart(struct buf*);
+
+// Wait for IDE disk to become ready.
+static int
+idewait(int checkerr)
+{
+  int r;
+
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+    ;
+  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+    return -1;
+  return 0;
+}
+
+void
+ideinit(void)
+{
+  int i;
+
+  initlock(&idelock, "ide");
+  ioapicenable(IRQ_IDE, ncpu - 1);
+  idewait(0);
+
+  // Check if disk 1 is present
+  outb(0x1f6, 0xe0 | (1<<4));
+  for(i=0; i<1000; i++){
+    if(inb(0x1f7) != 0){
+      havedisk1 = 1;
+      break;
+    }
+  }
+
+  // Switch back to disk 0.
+  outb(0x1f6, 0xe0 | (0<<4));
+}
+
+// Start the request for b.  Caller must hold idelock.
+static void
+idestart(struct buf *b)
+{
+  if(b == 0)
+    panic("idestart");
+  if(b->blockno >= FSSIZE)
+    panic("incorrect blockno");
+  int sector_per_block =  BSIZE/SECTOR_SIZE;
+  int sector = b->blockno * sector_per_block;
+  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
+  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
+
+  if (sector_per_block > 7) panic("idestart");
+
+  idewait(0);
+  outb(0x3f6, 0);  // generate interrupt
+  outb(0x1f2, sector_per_block);  // number of sectors
+  outb(0x1f3, sector & 0xff);
+  outb(0x1f4, (sector >> 8) & 0xff);
+  outb(0x1f5, (sector >> 16) & 0xff);
+  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+  if(b->flags & B_DIRTY){
+    outb(0x1f7, write_cmd);
+    outsl(0x1f0, b->data, BSIZE/4);
+  } else {
+    outb(0x1f7, read_cmd);
+  }
+}
+
+// Interrupt handler.
+void
+ideintr(void)
+{
+  struct buf *b;
+
+  // First queued buffer is the active request.
+  acquire(&idelock);
+
+  if((b = idequeue) == 0){
+    release(&idelock);
+    return;
+  }
+  idequeue = b->qnext;
+
+  // Read data if needed.
+  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+    insl(0x1f0, b->data, BSIZE/4);
+
+  // Wake process waiting for this buf.
+  b->flags |= B_VALID;
+  b->flags &= ~B_DIRTY;
+  wakeup(b);
+
+  // Start disk on next buf in queue.
+  if(idequeue != 0)
+    idestart(idequeue);
+
+  release(&idelock);
+}
+
+//PAGEBREAK!
+// Sync buf with disk.
+// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+// Else if B_VALID is not set, read buf from disk, set B_VALID.
+void
+iderw(struct buf *b)
+{
+  struct buf **pp;
+
+  if(!holdingsleep(&b->lock))
+    panic("iderw: buf not locked");
+  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+    panic("iderw: nothing to do");
+  if(b->dev != 0 && !havedisk1)
+    panic("iderw: ide disk 1 not present");
+
+  acquire(&idelock);  //DOC:acquire-lock
+
+  // Append b to idequeue.
+  b->qnext = 0;
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+    ;
+  *pp = b;
+
+  // Start disk if necessary.
+  if(idequeue == b)
+    idestart(b);
+
+  // Wait for request to finish.
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+    sleep(b, &idelock);
+  }
+
+
+  release(&idelock);
+}
diff -ruN xv6-public/xv6-public/ide.d xv6-public_new/xv6-public/ide.d
--- xv6-public/xv6-public/ide.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ide.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+ide.o: ide.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h traps.h spinlock.h sleeplock.h fs.h buf.h
Binary files xv6-public/xv6-public/ide.o and xv6-public_new/xv6-public/ide.o differ
diff -ruN xv6-public/xv6-public/init.asm xv6-public_new/xv6-public/init.asm
--- xv6-public/xv6-public/init.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/init.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1223 @@
+
+_init:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+
+char *argv[] = { "sh", 0 };
+
+int
+main(void)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	51                   	push   %ecx
+  12:	83 ec 14             	sub    $0x14,%esp
+  int pid, wpid;
+
+  if(open("console", O_RDWR) < 0){
+  15:	83 ec 08             	sub    $0x8,%esp
+  18:	6a 02                	push   $0x2
+  1a:	68 ee 08 00 00       	push   $0x8ee
+  1f:	e8 9c 03 00 00       	call   3c0 <open>
+  24:	83 c4 10             	add    $0x10,%esp
+  27:	85 c0                	test   %eax,%eax
+  29:	79 26                	jns    51 <main+0x51>
+    mknod("console", 1, 1);
+  2b:	83 ec 04             	sub    $0x4,%esp
+  2e:	6a 01                	push   $0x1
+  30:	6a 01                	push   $0x1
+  32:	68 ee 08 00 00       	push   $0x8ee
+  37:	e8 8c 03 00 00       	call   3c8 <mknod>
+  3c:	83 c4 10             	add    $0x10,%esp
+    open("console", O_RDWR);
+  3f:	83 ec 08             	sub    $0x8,%esp
+  42:	6a 02                	push   $0x2
+  44:	68 ee 08 00 00       	push   $0x8ee
+  49:	e8 72 03 00 00       	call   3c0 <open>
+  4e:	83 c4 10             	add    $0x10,%esp
+  }
+  dup(0);  // stdout
+  51:	83 ec 0c             	sub    $0xc,%esp
+  54:	6a 00                	push   $0x0
+  56:	e8 9d 03 00 00       	call   3f8 <dup>
+  5b:	83 c4 10             	add    $0x10,%esp
+  dup(0);  // stderr
+  5e:	83 ec 0c             	sub    $0xc,%esp
+  61:	6a 00                	push   $0x0
+  63:	e8 90 03 00 00       	call   3f8 <dup>
+  68:	83 c4 10             	add    $0x10,%esp
+
+  for(;;){
+    printf(1, "init: starting sh\n");
+  6b:	83 ec 08             	sub    $0x8,%esp
+  6e:	68 f6 08 00 00       	push   $0x8f6
+  73:	6a 01                	push   $0x1
+  75:	e8 aa 04 00 00       	call   524 <printf>
+  7a:	83 c4 10             	add    $0x10,%esp
+    pid = fork();
+  7d:	e8 f6 02 00 00       	call   378 <fork>
+  82:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(pid < 0){
+  85:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  89:	79 17                	jns    a2 <main+0xa2>
+      printf(1, "init: fork failed\n");
+  8b:	83 ec 08             	sub    $0x8,%esp
+  8e:	68 09 09 00 00       	push   $0x909
+  93:	6a 01                	push   $0x1
+  95:	e8 8a 04 00 00       	call   524 <printf>
+  9a:	83 c4 10             	add    $0x10,%esp
+      exit();
+  9d:	e8 de 02 00 00       	call   380 <exit>
+    }
+    if(pid == 0){
+  a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  a6:	75 3e                	jne    e6 <main+0xe6>
+      exec("sh", argv);
+  a8:	83 ec 08             	sub    $0x8,%esp
+  ab:	68 88 0b 00 00       	push   $0xb88
+  b0:	68 eb 08 00 00       	push   $0x8eb
+  b5:	e8 fe 02 00 00       	call   3b8 <exec>
+  ba:	83 c4 10             	add    $0x10,%esp
+      printf(1, "init: exec sh failed\n");
+  bd:	83 ec 08             	sub    $0x8,%esp
+  c0:	68 1c 09 00 00       	push   $0x91c
+  c5:	6a 01                	push   $0x1
+  c7:	e8 58 04 00 00       	call   524 <printf>
+  cc:	83 c4 10             	add    $0x10,%esp
+      exit();
+  cf:	e8 ac 02 00 00       	call   380 <exit>
+    }
+    while((wpid=wait()) >= 0 && wpid != pid)
+      printf(1, "zombie!\n");
+  d4:	83 ec 08             	sub    $0x8,%esp
+  d7:	68 32 09 00 00       	push   $0x932
+  dc:	6a 01                	push   $0x1
+  de:	e8 41 04 00 00       	call   524 <printf>
+  e3:	83 c4 10             	add    $0x10,%esp
+    while((wpid=wait()) >= 0 && wpid != pid)
+  e6:	e8 9d 02 00 00       	call   388 <wait>
+  eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  ee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  f2:	0f 88 73 ff ff ff    	js     6b <main+0x6b>
+  f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  fb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  fe:	75 d4                	jne    d4 <main+0xd4>
+    printf(1, "init: starting sh\n");
+ 100:	e9 66 ff ff ff       	jmp    6b <main+0x6b>
+
+00000105 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 105:	55                   	push   %ebp
+ 106:	89 e5                	mov    %esp,%ebp
+ 108:	57                   	push   %edi
+ 109:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 10a:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 10d:	8b 55 10             	mov    0x10(%ebp),%edx
+ 110:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 113:	89 cb                	mov    %ecx,%ebx
+ 115:	89 df                	mov    %ebx,%edi
+ 117:	89 d1                	mov    %edx,%ecx
+ 119:	fc                   	cld    
+ 11a:	f3 aa                	rep stos %al,%es:(%edi)
+ 11c:	89 ca                	mov    %ecx,%edx
+ 11e:	89 fb                	mov    %edi,%ebx
+ 120:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 123:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 126:	90                   	nop
+ 127:	5b                   	pop    %ebx
+ 128:	5f                   	pop    %edi
+ 129:	5d                   	pop    %ebp
+ 12a:	c3                   	ret    
+
+0000012b <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 12b:	f3 0f 1e fb          	endbr32 
+ 12f:	55                   	push   %ebp
+ 130:	89 e5                	mov    %esp,%ebp
+ 132:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 135:	8b 45 08             	mov    0x8(%ebp),%eax
+ 138:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 13b:	90                   	nop
+ 13c:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 13f:	8d 42 01             	lea    0x1(%edx),%eax
+ 142:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 145:	8b 45 08             	mov    0x8(%ebp),%eax
+ 148:	8d 48 01             	lea    0x1(%eax),%ecx
+ 14b:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 14e:	0f b6 12             	movzbl (%edx),%edx
+ 151:	88 10                	mov    %dl,(%eax)
+ 153:	0f b6 00             	movzbl (%eax),%eax
+ 156:	84 c0                	test   %al,%al
+ 158:	75 e2                	jne    13c <strcpy+0x11>
+    ;
+  return os;
+ 15a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 15d:	c9                   	leave  
+ 15e:	c3                   	ret    
+
+0000015f <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 15f:	f3 0f 1e fb          	endbr32 
+ 163:	55                   	push   %ebp
+ 164:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 166:	eb 08                	jmp    170 <strcmp+0x11>
+    p++, q++;
+ 168:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 16c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 170:	8b 45 08             	mov    0x8(%ebp),%eax
+ 173:	0f b6 00             	movzbl (%eax),%eax
+ 176:	84 c0                	test   %al,%al
+ 178:	74 10                	je     18a <strcmp+0x2b>
+ 17a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 17d:	0f b6 10             	movzbl (%eax),%edx
+ 180:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 183:	0f b6 00             	movzbl (%eax),%eax
+ 186:	38 c2                	cmp    %al,%dl
+ 188:	74 de                	je     168 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 18a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 18d:	0f b6 00             	movzbl (%eax),%eax
+ 190:	0f b6 d0             	movzbl %al,%edx
+ 193:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 196:	0f b6 00             	movzbl (%eax),%eax
+ 199:	0f b6 c0             	movzbl %al,%eax
+ 19c:	29 c2                	sub    %eax,%edx
+ 19e:	89 d0                	mov    %edx,%eax
+}
+ 1a0:	5d                   	pop    %ebp
+ 1a1:	c3                   	ret    
+
+000001a2 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 1a2:	f3 0f 1e fb          	endbr32 
+ 1a6:	55                   	push   %ebp
+ 1a7:	89 e5                	mov    %esp,%ebp
+ 1a9:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 1b3:	eb 04                	jmp    1b9 <strlen+0x17>
+ 1b5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 1b9:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 1bc:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1bf:	01 d0                	add    %edx,%eax
+ 1c1:	0f b6 00             	movzbl (%eax),%eax
+ 1c4:	84 c0                	test   %al,%al
+ 1c6:	75 ed                	jne    1b5 <strlen+0x13>
+    ;
+  return n;
+ 1c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1cb:	c9                   	leave  
+ 1cc:	c3                   	ret    
+
+000001cd <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1cd:	f3 0f 1e fb          	endbr32 
+ 1d1:	55                   	push   %ebp
+ 1d2:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 1d4:	8b 45 10             	mov    0x10(%ebp),%eax
+ 1d7:	50                   	push   %eax
+ 1d8:	ff 75 0c             	pushl  0xc(%ebp)
+ 1db:	ff 75 08             	pushl  0x8(%ebp)
+ 1de:	e8 22 ff ff ff       	call   105 <stosb>
+ 1e3:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 1e6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1e9:	c9                   	leave  
+ 1ea:	c3                   	ret    
+
+000001eb <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 1eb:	f3 0f 1e fb          	endbr32 
+ 1ef:	55                   	push   %ebp
+ 1f0:	89 e5                	mov    %esp,%ebp
+ 1f2:	83 ec 04             	sub    $0x4,%esp
+ 1f5:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1f8:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 1fb:	eb 14                	jmp    211 <strchr+0x26>
+    if(*s == c)
+ 1fd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 200:	0f b6 00             	movzbl (%eax),%eax
+ 203:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 206:	75 05                	jne    20d <strchr+0x22>
+      return (char*)s;
+ 208:	8b 45 08             	mov    0x8(%ebp),%eax
+ 20b:	eb 13                	jmp    220 <strchr+0x35>
+  for(; *s; s++)
+ 20d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 211:	8b 45 08             	mov    0x8(%ebp),%eax
+ 214:	0f b6 00             	movzbl (%eax),%eax
+ 217:	84 c0                	test   %al,%al
+ 219:	75 e2                	jne    1fd <strchr+0x12>
+  return 0;
+ 21b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 220:	c9                   	leave  
+ 221:	c3                   	ret    
+
+00000222 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 222:	f3 0f 1e fb          	endbr32 
+ 226:	55                   	push   %ebp
+ 227:	89 e5                	mov    %esp,%ebp
+ 229:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 22c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 233:	eb 42                	jmp    277 <gets+0x55>
+    cc = read(0, &c, 1);
+ 235:	83 ec 04             	sub    $0x4,%esp
+ 238:	6a 01                	push   $0x1
+ 23a:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 23d:	50                   	push   %eax
+ 23e:	6a 00                	push   $0x0
+ 240:	e8 53 01 00 00       	call   398 <read>
+ 245:	83 c4 10             	add    $0x10,%esp
+ 248:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 24b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 24f:	7e 33                	jle    284 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 251:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 254:	8d 50 01             	lea    0x1(%eax),%edx
+ 257:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 25a:	89 c2                	mov    %eax,%edx
+ 25c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 25f:	01 c2                	add    %eax,%edx
+ 261:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 265:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 267:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 26b:	3c 0a                	cmp    $0xa,%al
+ 26d:	74 16                	je     285 <gets+0x63>
+ 26f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 273:	3c 0d                	cmp    $0xd,%al
+ 275:	74 0e                	je     285 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 277:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 27a:	83 c0 01             	add    $0x1,%eax
+ 27d:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 280:	7f b3                	jg     235 <gets+0x13>
+ 282:	eb 01                	jmp    285 <gets+0x63>
+      break;
+ 284:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 285:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 288:	8b 45 08             	mov    0x8(%ebp),%eax
+ 28b:	01 d0                	add    %edx,%eax
+ 28d:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 290:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 293:	c9                   	leave  
+ 294:	c3                   	ret    
+
+00000295 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 295:	f3 0f 1e fb          	endbr32 
+ 299:	55                   	push   %ebp
+ 29a:	89 e5                	mov    %esp,%ebp
+ 29c:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 29f:	83 ec 08             	sub    $0x8,%esp
+ 2a2:	6a 00                	push   $0x0
+ 2a4:	ff 75 08             	pushl  0x8(%ebp)
+ 2a7:	e8 14 01 00 00       	call   3c0 <open>
+ 2ac:	83 c4 10             	add    $0x10,%esp
+ 2af:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 2b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 2b6:	79 07                	jns    2bf <stat+0x2a>
+    return -1;
+ 2b8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 2bd:	eb 25                	jmp    2e4 <stat+0x4f>
+  r = fstat(fd, st);
+ 2bf:	83 ec 08             	sub    $0x8,%esp
+ 2c2:	ff 75 0c             	pushl  0xc(%ebp)
+ 2c5:	ff 75 f4             	pushl  -0xc(%ebp)
+ 2c8:	e8 0b 01 00 00       	call   3d8 <fstat>
+ 2cd:	83 c4 10             	add    $0x10,%esp
+ 2d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 2d3:	83 ec 0c             	sub    $0xc,%esp
+ 2d6:	ff 75 f4             	pushl  -0xc(%ebp)
+ 2d9:	e8 ca 00 00 00       	call   3a8 <close>
+ 2de:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 2e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 2e4:	c9                   	leave  
+ 2e5:	c3                   	ret    
+
+000002e6 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 2e6:	f3 0f 1e fb          	endbr32 
+ 2ea:	55                   	push   %ebp
+ 2eb:	89 e5                	mov    %esp,%ebp
+ 2ed:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 2f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 2f7:	eb 25                	jmp    31e <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 2f9:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 2fc:	89 d0                	mov    %edx,%eax
+ 2fe:	c1 e0 02             	shl    $0x2,%eax
+ 301:	01 d0                	add    %edx,%eax
+ 303:	01 c0                	add    %eax,%eax
+ 305:	89 c1                	mov    %eax,%ecx
+ 307:	8b 45 08             	mov    0x8(%ebp),%eax
+ 30a:	8d 50 01             	lea    0x1(%eax),%edx
+ 30d:	89 55 08             	mov    %edx,0x8(%ebp)
+ 310:	0f b6 00             	movzbl (%eax),%eax
+ 313:	0f be c0             	movsbl %al,%eax
+ 316:	01 c8                	add    %ecx,%eax
+ 318:	83 e8 30             	sub    $0x30,%eax
+ 31b:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 31e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 321:	0f b6 00             	movzbl (%eax),%eax
+ 324:	3c 2f                	cmp    $0x2f,%al
+ 326:	7e 0a                	jle    332 <atoi+0x4c>
+ 328:	8b 45 08             	mov    0x8(%ebp),%eax
+ 32b:	0f b6 00             	movzbl (%eax),%eax
+ 32e:	3c 39                	cmp    $0x39,%al
+ 330:	7e c7                	jle    2f9 <atoi+0x13>
+  return n;
+ 332:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 335:	c9                   	leave  
+ 336:	c3                   	ret    
+
+00000337 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 337:	f3 0f 1e fb          	endbr32 
+ 33b:	55                   	push   %ebp
+ 33c:	89 e5                	mov    %esp,%ebp
+ 33e:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 341:	8b 45 08             	mov    0x8(%ebp),%eax
+ 344:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 347:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 34a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 34d:	eb 17                	jmp    366 <memmove+0x2f>
+    *dst++ = *src++;
+ 34f:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 352:	8d 42 01             	lea    0x1(%edx),%eax
+ 355:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 358:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 35b:	8d 48 01             	lea    0x1(%eax),%ecx
+ 35e:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 361:	0f b6 12             	movzbl (%edx),%edx
+ 364:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 366:	8b 45 10             	mov    0x10(%ebp),%eax
+ 369:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 36c:	89 55 10             	mov    %edx,0x10(%ebp)
+ 36f:	85 c0                	test   %eax,%eax
+ 371:	7f dc                	jg     34f <memmove+0x18>
+  return vdst;
+ 373:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 376:	c9                   	leave  
+ 377:	c3                   	ret    
+
+00000378 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 378:	b8 01 00 00 00       	mov    $0x1,%eax
+ 37d:	cd 40                	int    $0x40
+ 37f:	c3                   	ret    
+
+00000380 <exit>:
+SYSCALL(exit)
+ 380:	b8 02 00 00 00       	mov    $0x2,%eax
+ 385:	cd 40                	int    $0x40
+ 387:	c3                   	ret    
+
+00000388 <wait>:
+SYSCALL(wait)
+ 388:	b8 03 00 00 00       	mov    $0x3,%eax
+ 38d:	cd 40                	int    $0x40
+ 38f:	c3                   	ret    
+
+00000390 <pipe>:
+SYSCALL(pipe)
+ 390:	b8 04 00 00 00       	mov    $0x4,%eax
+ 395:	cd 40                	int    $0x40
+ 397:	c3                   	ret    
+
+00000398 <read>:
+SYSCALL(read)
+ 398:	b8 05 00 00 00       	mov    $0x5,%eax
+ 39d:	cd 40                	int    $0x40
+ 39f:	c3                   	ret    
+
+000003a0 <write>:
+SYSCALL(write)
+ 3a0:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3a5:	cd 40                	int    $0x40
+ 3a7:	c3                   	ret    
+
+000003a8 <close>:
+SYSCALL(close)
+ 3a8:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3ad:	cd 40                	int    $0x40
+ 3af:	c3                   	ret    
+
+000003b0 <kill>:
+SYSCALL(kill)
+ 3b0:	b8 06 00 00 00       	mov    $0x6,%eax
+ 3b5:	cd 40                	int    $0x40
+ 3b7:	c3                   	ret    
+
+000003b8 <exec>:
+SYSCALL(exec)
+ 3b8:	b8 07 00 00 00       	mov    $0x7,%eax
+ 3bd:	cd 40                	int    $0x40
+ 3bf:	c3                   	ret    
+
+000003c0 <open>:
+SYSCALL(open)
+ 3c0:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 3c5:	cd 40                	int    $0x40
+ 3c7:	c3                   	ret    
+
+000003c8 <mknod>:
+SYSCALL(mknod)
+ 3c8:	b8 11 00 00 00       	mov    $0x11,%eax
+ 3cd:	cd 40                	int    $0x40
+ 3cf:	c3                   	ret    
+
+000003d0 <unlink>:
+SYSCALL(unlink)
+ 3d0:	b8 12 00 00 00       	mov    $0x12,%eax
+ 3d5:	cd 40                	int    $0x40
+ 3d7:	c3                   	ret    
+
+000003d8 <fstat>:
+SYSCALL(fstat)
+ 3d8:	b8 08 00 00 00       	mov    $0x8,%eax
+ 3dd:	cd 40                	int    $0x40
+ 3df:	c3                   	ret    
+
+000003e0 <link>:
+SYSCALL(link)
+ 3e0:	b8 13 00 00 00       	mov    $0x13,%eax
+ 3e5:	cd 40                	int    $0x40
+ 3e7:	c3                   	ret    
+
+000003e8 <mkdir>:
+SYSCALL(mkdir)
+ 3e8:	b8 14 00 00 00       	mov    $0x14,%eax
+ 3ed:	cd 40                	int    $0x40
+ 3ef:	c3                   	ret    
+
+000003f0 <chdir>:
+SYSCALL(chdir)
+ 3f0:	b8 09 00 00 00       	mov    $0x9,%eax
+ 3f5:	cd 40                	int    $0x40
+ 3f7:	c3                   	ret    
+
+000003f8 <dup>:
+SYSCALL(dup)
+ 3f8:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 3fd:	cd 40                	int    $0x40
+ 3ff:	c3                   	ret    
+
+00000400 <getpid>:
+SYSCALL(getpid)
+ 400:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 405:	cd 40                	int    $0x40
+ 407:	c3                   	ret    
+
+00000408 <sbrk>:
+SYSCALL(sbrk)
+ 408:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 40d:	cd 40                	int    $0x40
+ 40f:	c3                   	ret    
+
+00000410 <sleep>:
+SYSCALL(sleep)
+ 410:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 415:	cd 40                	int    $0x40
+ 417:	c3                   	ret    
+
+00000418 <uptime>:
+SYSCALL(uptime)
+ 418:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 41d:	cd 40                	int    $0x40
+ 41f:	c3                   	ret    
+
+00000420 <draw>:
+SYSCALL(draw)
+ 420:	b8 16 00 00 00       	mov    $0x16,%eax
+ 425:	cd 40                	int    $0x40
+ 427:	c3                   	ret    
+
+00000428 <cps>:
+SYSCALL(cps)
+ 428:	b8 17 00 00 00       	mov    $0x17,%eax
+ 42d:	cd 40                	int    $0x40
+ 42f:	c3                   	ret    
+
+00000430 <yield>:
+SYSCALL(yield)
+ 430:	b8 18 00 00 00       	mov    $0x18,%eax
+ 435:	cd 40                	int    $0x40
+ 437:	c3                   	ret    
+
+00000438 <wait2>:
+SYSCALL(wait2)
+ 438:	b8 19 00 00 00       	mov    $0x19,%eax
+ 43d:	cd 40                	int    $0x40
+ 43f:	c3                   	ret    
+
+00000440 <set_prio>:
+SYSCALL(set_prio)
+ 440:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 445:	cd 40                	int    $0x40
+ 447:	c3                   	ret    
+
+00000448 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 448:	f3 0f 1e fb          	endbr32 
+ 44c:	55                   	push   %ebp
+ 44d:	89 e5                	mov    %esp,%ebp
+ 44f:	83 ec 18             	sub    $0x18,%esp
+ 452:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 455:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 458:	83 ec 04             	sub    $0x4,%esp
+ 45b:	6a 01                	push   $0x1
+ 45d:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 460:	50                   	push   %eax
+ 461:	ff 75 08             	pushl  0x8(%ebp)
+ 464:	e8 37 ff ff ff       	call   3a0 <write>
+ 469:	83 c4 10             	add    $0x10,%esp
+}
+ 46c:	90                   	nop
+ 46d:	c9                   	leave  
+ 46e:	c3                   	ret    
+
+0000046f <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 46f:	f3 0f 1e fb          	endbr32 
+ 473:	55                   	push   %ebp
+ 474:	89 e5                	mov    %esp,%ebp
+ 476:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 479:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 480:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 484:	74 17                	je     49d <printint+0x2e>
+ 486:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 48a:	79 11                	jns    49d <printint+0x2e>
+    neg = 1;
+ 48c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 493:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 496:	f7 d8                	neg    %eax
+ 498:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 49b:	eb 06                	jmp    4a3 <printint+0x34>
+  } else {
+    x = xx;
+ 49d:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 4a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 4aa:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 4ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 4b0:	ba 00 00 00 00       	mov    $0x0,%edx
+ 4b5:	f7 f1                	div    %ecx
+ 4b7:	89 d1                	mov    %edx,%ecx
+ 4b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4bc:	8d 50 01             	lea    0x1(%eax),%edx
+ 4bf:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 4c2:	0f b6 91 90 0b 00 00 	movzbl 0xb90(%ecx),%edx
+ 4c9:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 4cd:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 4d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 4d3:	ba 00 00 00 00       	mov    $0x0,%edx
+ 4d8:	f7 f1                	div    %ecx
+ 4da:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 4dd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4e1:	75 c7                	jne    4aa <printint+0x3b>
+  if(neg)
+ 4e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 4e7:	74 2d                	je     516 <printint+0xa7>
+    buf[i++] = '-';
+ 4e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4ec:	8d 50 01             	lea    0x1(%eax),%edx
+ 4ef:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 4f2:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 4f7:	eb 1d                	jmp    516 <printint+0xa7>
+    putc(fd, buf[i]);
+ 4f9:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 4fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4ff:	01 d0                	add    %edx,%eax
+ 501:	0f b6 00             	movzbl (%eax),%eax
+ 504:	0f be c0             	movsbl %al,%eax
+ 507:	83 ec 08             	sub    $0x8,%esp
+ 50a:	50                   	push   %eax
+ 50b:	ff 75 08             	pushl  0x8(%ebp)
+ 50e:	e8 35 ff ff ff       	call   448 <putc>
+ 513:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 516:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 51a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 51e:	79 d9                	jns    4f9 <printint+0x8a>
+}
+ 520:	90                   	nop
+ 521:	90                   	nop
+ 522:	c9                   	leave  
+ 523:	c3                   	ret    
+
+00000524 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 524:	f3 0f 1e fb          	endbr32 
+ 528:	55                   	push   %ebp
+ 529:	89 e5                	mov    %esp,%ebp
+ 52b:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 52e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 535:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 538:	83 c0 04             	add    $0x4,%eax
+ 53b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 53e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 545:	e9 59 01 00 00       	jmp    6a3 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 54a:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 54d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 550:	01 d0                	add    %edx,%eax
+ 552:	0f b6 00             	movzbl (%eax),%eax
+ 555:	0f be c0             	movsbl %al,%eax
+ 558:	25 ff 00 00 00       	and    $0xff,%eax
+ 55d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 560:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 564:	75 2c                	jne    592 <printf+0x6e>
+      if(c == '%'){
+ 566:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 56a:	75 0c                	jne    578 <printf+0x54>
+        state = '%';
+ 56c:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 573:	e9 27 01 00 00       	jmp    69f <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 578:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 57b:	0f be c0             	movsbl %al,%eax
+ 57e:	83 ec 08             	sub    $0x8,%esp
+ 581:	50                   	push   %eax
+ 582:	ff 75 08             	pushl  0x8(%ebp)
+ 585:	e8 be fe ff ff       	call   448 <putc>
+ 58a:	83 c4 10             	add    $0x10,%esp
+ 58d:	e9 0d 01 00 00       	jmp    69f <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 592:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 596:	0f 85 03 01 00 00    	jne    69f <printf+0x17b>
+      if(c == 'd'){
+ 59c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 5a0:	75 1e                	jne    5c0 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 5a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5a5:	8b 00                	mov    (%eax),%eax
+ 5a7:	6a 01                	push   $0x1
+ 5a9:	6a 0a                	push   $0xa
+ 5ab:	50                   	push   %eax
+ 5ac:	ff 75 08             	pushl  0x8(%ebp)
+ 5af:	e8 bb fe ff ff       	call   46f <printint>
+ 5b4:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5b7:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5bb:	e9 d8 00 00 00       	jmp    698 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 5c0:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 5c4:	74 06                	je     5cc <printf+0xa8>
+ 5c6:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 5ca:	75 1e                	jne    5ea <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 5cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5cf:	8b 00                	mov    (%eax),%eax
+ 5d1:	6a 00                	push   $0x0
+ 5d3:	6a 10                	push   $0x10
+ 5d5:	50                   	push   %eax
+ 5d6:	ff 75 08             	pushl  0x8(%ebp)
+ 5d9:	e8 91 fe ff ff       	call   46f <printint>
+ 5de:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5e1:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5e5:	e9 ae 00 00 00       	jmp    698 <printf+0x174>
+      } else if(c == 's'){
+ 5ea:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 5ee:	75 43                	jne    633 <printf+0x10f>
+        s = (char*)*ap;
+ 5f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5f3:	8b 00                	mov    (%eax),%eax
+ 5f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 5f8:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 5fc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 600:	75 25                	jne    627 <printf+0x103>
+          s = "(null)";
+ 602:	c7 45 f4 3b 09 00 00 	movl   $0x93b,-0xc(%ebp)
+        while(*s != 0){
+ 609:	eb 1c                	jmp    627 <printf+0x103>
+          putc(fd, *s);
+ 60b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 60e:	0f b6 00             	movzbl (%eax),%eax
+ 611:	0f be c0             	movsbl %al,%eax
+ 614:	83 ec 08             	sub    $0x8,%esp
+ 617:	50                   	push   %eax
+ 618:	ff 75 08             	pushl  0x8(%ebp)
+ 61b:	e8 28 fe ff ff       	call   448 <putc>
+ 620:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 623:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 627:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 62a:	0f b6 00             	movzbl (%eax),%eax
+ 62d:	84 c0                	test   %al,%al
+ 62f:	75 da                	jne    60b <printf+0xe7>
+ 631:	eb 65                	jmp    698 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 633:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 637:	75 1d                	jne    656 <printf+0x132>
+        putc(fd, *ap);
+ 639:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 63c:	8b 00                	mov    (%eax),%eax
+ 63e:	0f be c0             	movsbl %al,%eax
+ 641:	83 ec 08             	sub    $0x8,%esp
+ 644:	50                   	push   %eax
+ 645:	ff 75 08             	pushl  0x8(%ebp)
+ 648:	e8 fb fd ff ff       	call   448 <putc>
+ 64d:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 650:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 654:	eb 42                	jmp    698 <printf+0x174>
+      } else if(c == '%'){
+ 656:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 65a:	75 17                	jne    673 <printf+0x14f>
+        putc(fd, c);
+ 65c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 65f:	0f be c0             	movsbl %al,%eax
+ 662:	83 ec 08             	sub    $0x8,%esp
+ 665:	50                   	push   %eax
+ 666:	ff 75 08             	pushl  0x8(%ebp)
+ 669:	e8 da fd ff ff       	call   448 <putc>
+ 66e:	83 c4 10             	add    $0x10,%esp
+ 671:	eb 25                	jmp    698 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 673:	83 ec 08             	sub    $0x8,%esp
+ 676:	6a 25                	push   $0x25
+ 678:	ff 75 08             	pushl  0x8(%ebp)
+ 67b:	e8 c8 fd ff ff       	call   448 <putc>
+ 680:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 683:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 686:	0f be c0             	movsbl %al,%eax
+ 689:	83 ec 08             	sub    $0x8,%esp
+ 68c:	50                   	push   %eax
+ 68d:	ff 75 08             	pushl  0x8(%ebp)
+ 690:	e8 b3 fd ff ff       	call   448 <putc>
+ 695:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 698:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 69f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 6a3:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 6a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 6a9:	01 d0                	add    %edx,%eax
+ 6ab:	0f b6 00             	movzbl (%eax),%eax
+ 6ae:	84 c0                	test   %al,%al
+ 6b0:	0f 85 94 fe ff ff    	jne    54a <printf+0x26>
+    }
+  }
+}
+ 6b6:	90                   	nop
+ 6b7:	90                   	nop
+ 6b8:	c9                   	leave  
+ 6b9:	c3                   	ret    
+
+000006ba <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 6ba:	f3 0f 1e fb          	endbr32 
+ 6be:	55                   	push   %ebp
+ 6bf:	89 e5                	mov    %esp,%ebp
+ 6c1:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 6c4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6c7:	83 e8 08             	sub    $0x8,%eax
+ 6ca:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6cd:	a1 ac 0b 00 00       	mov    0xbac,%eax
+ 6d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 6d5:	eb 24                	jmp    6fb <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 6d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6da:	8b 00                	mov    (%eax),%eax
+ 6dc:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 6df:	72 12                	jb     6f3 <free+0x39>
+ 6e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 6e7:	77 24                	ja     70d <free+0x53>
+ 6e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ec:	8b 00                	mov    (%eax),%eax
+ 6ee:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6f1:	72 1a                	jb     70d <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 6f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f6:	8b 00                	mov    (%eax),%eax
+ 6f8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 6fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6fe:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 701:	76 d4                	jbe    6d7 <free+0x1d>
+ 703:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 706:	8b 00                	mov    (%eax),%eax
+ 708:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 70b:	73 ca                	jae    6d7 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 70d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 710:	8b 40 04             	mov    0x4(%eax),%eax
+ 713:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 71a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 71d:	01 c2                	add    %eax,%edx
+ 71f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 722:	8b 00                	mov    (%eax),%eax
+ 724:	39 c2                	cmp    %eax,%edx
+ 726:	75 24                	jne    74c <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 728:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 72b:	8b 50 04             	mov    0x4(%eax),%edx
+ 72e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 731:	8b 00                	mov    (%eax),%eax
+ 733:	8b 40 04             	mov    0x4(%eax),%eax
+ 736:	01 c2                	add    %eax,%edx
+ 738:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 73b:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 73e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 741:	8b 00                	mov    (%eax),%eax
+ 743:	8b 10                	mov    (%eax),%edx
+ 745:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 748:	89 10                	mov    %edx,(%eax)
+ 74a:	eb 0a                	jmp    756 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 74c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 74f:	8b 10                	mov    (%eax),%edx
+ 751:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 754:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 756:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 759:	8b 40 04             	mov    0x4(%eax),%eax
+ 75c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 763:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 766:	01 d0                	add    %edx,%eax
+ 768:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 76b:	75 20                	jne    78d <free+0xd3>
+    p->s.size += bp->s.size;
+ 76d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 770:	8b 50 04             	mov    0x4(%eax),%edx
+ 773:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 776:	8b 40 04             	mov    0x4(%eax),%eax
+ 779:	01 c2                	add    %eax,%edx
+ 77b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 77e:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 781:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 784:	8b 10                	mov    (%eax),%edx
+ 786:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 789:	89 10                	mov    %edx,(%eax)
+ 78b:	eb 08                	jmp    795 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 78d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 790:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 793:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 795:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 798:	a3 ac 0b 00 00       	mov    %eax,0xbac
+}
+ 79d:	90                   	nop
+ 79e:	c9                   	leave  
+ 79f:	c3                   	ret    
+
+000007a0 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 7a0:	f3 0f 1e fb          	endbr32 
+ 7a4:	55                   	push   %ebp
+ 7a5:	89 e5                	mov    %esp,%ebp
+ 7a7:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 7aa:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 7b1:	77 07                	ja     7ba <morecore+0x1a>
+    nu = 4096;
+ 7b3:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 7ba:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7bd:	c1 e0 03             	shl    $0x3,%eax
+ 7c0:	83 ec 0c             	sub    $0xc,%esp
+ 7c3:	50                   	push   %eax
+ 7c4:	e8 3f fc ff ff       	call   408 <sbrk>
+ 7c9:	83 c4 10             	add    $0x10,%esp
+ 7cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 7cf:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 7d3:	75 07                	jne    7dc <morecore+0x3c>
+    return 0;
+ 7d5:	b8 00 00 00 00       	mov    $0x0,%eax
+ 7da:	eb 26                	jmp    802 <morecore+0x62>
+  hp = (Header*)p;
+ 7dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7df:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 7e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7e5:	8b 55 08             	mov    0x8(%ebp),%edx
+ 7e8:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 7eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7ee:	83 c0 08             	add    $0x8,%eax
+ 7f1:	83 ec 0c             	sub    $0xc,%esp
+ 7f4:	50                   	push   %eax
+ 7f5:	e8 c0 fe ff ff       	call   6ba <free>
+ 7fa:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 7fd:	a1 ac 0b 00 00       	mov    0xbac,%eax
+}
+ 802:	c9                   	leave  
+ 803:	c3                   	ret    
+
+00000804 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 804:	f3 0f 1e fb          	endbr32 
+ 808:	55                   	push   %ebp
+ 809:	89 e5                	mov    %esp,%ebp
+ 80b:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 80e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 811:	83 c0 07             	add    $0x7,%eax
+ 814:	c1 e8 03             	shr    $0x3,%eax
+ 817:	83 c0 01             	add    $0x1,%eax
+ 81a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 81d:	a1 ac 0b 00 00       	mov    0xbac,%eax
+ 822:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 825:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 829:	75 23                	jne    84e <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 82b:	c7 45 f0 a4 0b 00 00 	movl   $0xba4,-0x10(%ebp)
+ 832:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 835:	a3 ac 0b 00 00       	mov    %eax,0xbac
+ 83a:	a1 ac 0b 00 00       	mov    0xbac,%eax
+ 83f:	a3 a4 0b 00 00       	mov    %eax,0xba4
+    base.s.size = 0;
+ 844:	c7 05 a8 0b 00 00 00 	movl   $0x0,0xba8
+ 84b:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 84e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 851:	8b 00                	mov    (%eax),%eax
+ 853:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 856:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 859:	8b 40 04             	mov    0x4(%eax),%eax
+ 85c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 85f:	77 4d                	ja     8ae <malloc+0xaa>
+      if(p->s.size == nunits)
+ 861:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 864:	8b 40 04             	mov    0x4(%eax),%eax
+ 867:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 86a:	75 0c                	jne    878 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 86c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 86f:	8b 10                	mov    (%eax),%edx
+ 871:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 874:	89 10                	mov    %edx,(%eax)
+ 876:	eb 26                	jmp    89e <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 878:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 87b:	8b 40 04             	mov    0x4(%eax),%eax
+ 87e:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 881:	89 c2                	mov    %eax,%edx
+ 883:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 886:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 889:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 88c:	8b 40 04             	mov    0x4(%eax),%eax
+ 88f:	c1 e0 03             	shl    $0x3,%eax
+ 892:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 895:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 898:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 89b:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 89e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8a1:	a3 ac 0b 00 00       	mov    %eax,0xbac
+      return (void*)(p + 1);
+ 8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8a9:	83 c0 08             	add    $0x8,%eax
+ 8ac:	eb 3b                	jmp    8e9 <malloc+0xe5>
+    }
+    if(p == freep)
+ 8ae:	a1 ac 0b 00 00       	mov    0xbac,%eax
+ 8b3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 8b6:	75 1e                	jne    8d6 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 8b8:	83 ec 0c             	sub    $0xc,%esp
+ 8bb:	ff 75 ec             	pushl  -0x14(%ebp)
+ 8be:	e8 dd fe ff ff       	call   7a0 <morecore>
+ 8c3:	83 c4 10             	add    $0x10,%esp
+ 8c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 8c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 8cd:	75 07                	jne    8d6 <malloc+0xd2>
+        return 0;
+ 8cf:	b8 00 00 00 00       	mov    $0x0,%eax
+ 8d4:	eb 13                	jmp    8e9 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 8dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8df:	8b 00                	mov    (%eax),%eax
+ 8e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 8e4:	e9 6d ff ff ff       	jmp    856 <malloc+0x52>
+  }
+}
+ 8e9:	c9                   	leave  
+ 8ea:	c3                   	ret    
diff -ruN xv6-public/xv6-public/init.c xv6-public_new/xv6-public/init.c
--- xv6-public/xv6-public/init.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/init.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,37 @@
+// init: The initial user-level program
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fcntl.h"
+
+char *argv[] = { "sh", 0 };
+
+int
+main(void)
+{
+  int pid, wpid;
+
+  if(open("console", O_RDWR) < 0){
+    mknod("console", 1, 1);
+    open("console", O_RDWR);
+  }
+  dup(0);  // stdout
+  dup(0);  // stderr
+
+  for(;;){
+    printf(1, "init: starting sh\n");
+    pid = fork();
+    if(pid < 0){
+      printf(1, "init: fork failed\n");
+      exit();
+    }
+    if(pid == 0){
+      exec("sh", argv);
+      printf(1, "init: exec sh failed\n");
+      exit();
+    }
+    while((wpid=wait()) >= 0 && wpid != pid)
+      printf(1, "zombie!\n");
+  }
+}
diff -ruN xv6-public/xv6-public/init.d xv6-public_new/xv6-public/init.d
--- xv6-public/xv6-public/init.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/init.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+init.o: init.c /usr/include/stdc-predef.h types.h stat.h user.h fcntl.h
Binary files xv6-public/xv6-public/init.o and xv6-public_new/xv6-public/init.o differ
diff -ruN xv6-public/xv6-public/init.sym xv6-public_new/xv6-public/init.sym
--- xv6-public/xv6-public/init.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/init.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,66 @@
+00000000 .text
+000008eb .rodata
+00000944 .eh_frame
+00000b88 .data
+00000ba4 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 init.c
+00000000 ulib.c
+00000105 stosb
+00000000 printf.c
+00000448 putc
+0000046f printint
+00000b90 digits.1098
+00000000 umalloc.c
+00000ba4 base
+00000bac freep
+000007a0 morecore
+0000012b strcpy
+00000430 yield
+00000440 set_prio
+00000524 printf
+00000b88 argv
+00000337 memmove
+000003c8 mknod
+00000222 gets
+00000400 getpid
+00000804 malloc
+00000410 sleep
+00000438 wait2
+00000390 pipe
+000003a0 write
+000003d8 fstat
+000003b0 kill
+000003f0 chdir
+000003b8 exec
+00000388 wait
+00000398 read
+000003d0 unlink
+00000378 fork
+00000408 sbrk
+00000418 uptime
+00000ba1 __bss_start
+000001cd memset
+00000000 main
+0000015f strcmp
+000003f8 dup
+00000295 stat
+00000ba1 _edata
+00000bb0 _end
+000003e0 link
+00000380 exit
+000002e6 atoi
+00000420 draw
+000001a2 strlen
+000003c0 open
+000001eb strchr
+00000428 cps
+000003e8 mkdir
+000003a8 close
+000006ba free
Binary files xv6-public/xv6-public/initcode and xv6-public_new/xv6-public/initcode differ
diff -ruN xv6-public/xv6-public/initcode.S xv6-public_new/xv6-public/initcode.S
--- xv6-public/xv6-public/initcode.S	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/initcode.S	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,32 @@
+# Initial process execs /init.
+# This code runs in user space.
+
+#include "syscall.h"
+#include "traps.h"
+
+
+# exec(init, argv)
+.globl start
+start:
+  pushl $argv
+  pushl $init
+  pushl $0  // where caller pc would be
+  movl $SYS_exec, %eax
+  int $T_SYSCALL
+
+# for(;;) exit();
+exit:
+  movl $SYS_exit, %eax
+  int $T_SYSCALL
+  jmp exit
+
+# char init[] = "/init\0";
+init:
+  .string "/init\0"
+
+# char *argv[] = { init, 0 };
+.p2align 2
+argv:
+  .long init
+  .long 0
+
diff -ruN xv6-public/xv6-public/initcode.asm xv6-public_new/xv6-public/initcode.asm
--- xv6-public/xv6-public/initcode.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/initcode.asm	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,43 @@
+
+initcode.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <start>:
+
+
+# exec(init, argv)
+.globl start
+start:
+  pushl $argv
+   0:	68 24 00 00 00       	push   $0x24
+  pushl $init
+   5:	68 1c 00 00 00       	push   $0x1c
+  pushl $0  // where caller pc would be
+   a:	6a 00                	push   $0x0
+  movl $SYS_exec, %eax
+   c:	b8 07 00 00 00       	mov    $0x7,%eax
+  int $T_SYSCALL
+  11:	cd 40                	int    $0x40
+
+00000013 <exit>:
+
+# for(;;) exit();
+exit:
+  movl $SYS_exit, %eax
+  13:	b8 02 00 00 00       	mov    $0x2,%eax
+  int $T_SYSCALL
+  18:	cd 40                	int    $0x40
+  jmp exit
+  1a:	eb f7                	jmp    13 <exit>
+
+0000001c <init>:
+  1c:	2f                   	das    
+  1d:	69 6e 69 74 00 00 90 	imul   $0x90000074,0x69(%esi),%ebp
+
+00000024 <argv>:
+  24:	1c 00                	sbb    $0x0,%al
+  26:	00 00                	add    %al,(%eax)
+  28:	00 00                	add    %al,(%eax)
+	...
diff -ruN xv6-public/xv6-public/initcode.d xv6-public_new/xv6-public/initcode.d
--- xv6-public/xv6-public/initcode.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/initcode.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1 @@
+initcode.o: initcode.S syscall.h traps.h
Binary files xv6-public/xv6-public/initcode.o and xv6-public_new/xv6-public/initcode.o differ
Binary files xv6-public/xv6-public/initcode.out and xv6-public_new/xv6-public/initcode.out differ
diff -ruN xv6-public/xv6-public/ioapic.c xv6-public_new/xv6-public/ioapic.c
--- xv6-public/xv6-public/ioapic.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ioapic.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,75 @@
+// The I/O APIC manages hardware interrupts for an SMP system.
+// http://www.intel.com/design/chipsets/datashts/29056601.pdf
+// See also picirq.c.
+
+#include "types.h"
+#include "defs.h"
+#include "traps.h"
+
+#define IOAPIC  0xFEC00000   // Default physical address of IO APIC
+
+#define REG_ID     0x00  // Register index: ID
+#define REG_VER    0x01  // Register index: version
+#define REG_TABLE  0x10  // Redirection table base
+
+// The redirection table starts at REG_TABLE and uses
+// two registers to configure each interrupt.
+// The first (low) register in a pair contains configuration bits.
+// The second (high) register contains a bitmask telling which
+// CPUs can serve that interrupt.
+#define INT_DISABLED   0x00010000  // Interrupt disabled
+#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
+#define INT_ACTIVELOW  0x00002000  // Active low (vs high)
+#define INT_LOGICAL    0x00000800  // Destination is CPU id (vs APIC ID)
+
+volatile struct ioapic *ioapic;
+
+// IO APIC MMIO structure: write reg, then read or write data.
+struct ioapic {
+  uint reg;
+  uint pad[3];
+  uint data;
+};
+
+static uint
+ioapicread(int reg)
+{
+  ioapic->reg = reg;
+  return ioapic->data;
+}
+
+static void
+ioapicwrite(int reg, uint data)
+{
+  ioapic->reg = reg;
+  ioapic->data = data;
+}
+
+void
+ioapicinit(void)
+{
+  int i, id, maxintr;
+
+  ioapic = (volatile struct ioapic*)IOAPIC;
+  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+  id = ioapicread(REG_ID) >> 24;
+  if(id != ioapicid)
+    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
+
+  // Mark all interrupts edge-triggered, active high, disabled,
+  // and not routed to any CPUs.
+  for(i = 0; i <= maxintr; i++){
+    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+    ioapicwrite(REG_TABLE+2*i+1, 0);
+  }
+}
+
+void
+ioapicenable(int irq, int cpunum)
+{
+  // Mark interrupt edge-triggered, active high,
+  // enabled, and routed to the given cpunum,
+  // which happens to be that cpu's APIC ID.
+  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+}
diff -ruN xv6-public/xv6-public/ioapic.d xv6-public_new/xv6-public/ioapic.d
--- xv6-public/xv6-public/ioapic.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ioapic.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1 @@
+ioapic.o: ioapic.c /usr/include/stdc-predef.h types.h defs.h traps.h
Binary files xv6-public/xv6-public/ioapic.o and xv6-public_new/xv6-public/ioapic.o differ
diff -ruN xv6-public/xv6-public/kalloc.c xv6-public_new/xv6-public/kalloc.c
--- xv6-public/xv6-public/kalloc.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kalloc.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,96 @@
+// Physical memory allocator, intended to allocate
+// memory for user processes, kernel stacks, page table pages,
+// and pipe buffers. Allocates 4096-byte pages.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "spinlock.h"
+
+void freerange(void *vstart, void *vend);
+extern char end[]; // first address after kernel loaded from ELF file
+                   // defined by the kernel linker script in kernel.ld
+
+struct run {
+  struct run *next;
+};
+
+struct {
+  struct spinlock lock;
+  int use_lock;
+  struct run *freelist;
+} kmem;
+
+// Initialization happens in two phases.
+// 1. main() calls kinit1() while still using entrypgdir to place just
+// the pages mapped by entrypgdir on free list.
+// 2. main() calls kinit2() with the rest of the physical pages
+// after installing a full page table that maps them on all cores.
+void
+kinit1(void *vstart, void *vend)
+{
+  initlock(&kmem.lock, "kmem");
+  kmem.use_lock = 0;
+  freerange(vstart, vend);
+}
+
+void
+kinit2(void *vstart, void *vend)
+{
+  freerange(vstart, vend);
+  kmem.use_lock = 1;
+}
+
+void
+freerange(void *vstart, void *vend)
+{
+  char *p;
+  p = (char*)PGROUNDUP((uint)vstart);
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+    kfree(p);
+}
+//PAGEBREAK: 21
+// Free the page of physical memory pointed at by v,
+// which normally should have been returned by a
+// call to kalloc().  (The exception is when
+// initializing the allocator; see kinit above.)
+void
+kfree(char *v)
+{
+  struct run *r;
+
+  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+    panic("kfree");
+
+  // Fill with junk to catch dangling refs.
+  memset(v, 1, PGSIZE);
+
+  if(kmem.use_lock)
+    acquire(&kmem.lock);
+  r = (struct run*)v;
+  r->next = kmem.freelist;
+  kmem.freelist = r;
+  if(kmem.use_lock)
+    release(&kmem.lock);
+}
+
+// Allocate one 4096-byte page of physical memory.
+// Returns a pointer that the kernel can use.
+// Returns 0 if the memory cannot be allocated.
+char*
+kalloc(void)
+{
+  struct run *r;
+
+  if(kmem.use_lock)
+    acquire(&kmem.lock);
+  r = kmem.freelist;
+  if(r)
+    kmem.freelist = r->next;
+  if(kmem.use_lock)
+    release(&kmem.lock);
+  return (char*)r;
+}
+
diff -ruN xv6-public/xv6-public/kalloc.d xv6-public_new/xv6-public/kalloc.d
--- xv6-public/xv6-public/kalloc.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kalloc.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+kalloc.o: kalloc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h spinlock.h
Binary files xv6-public/xv6-public/kalloc.o and xv6-public_new/xv6-public/kalloc.o differ
diff -ruN xv6-public/xv6-public/kbd.c xv6-public_new/xv6-public/kbd.c
--- xv6-public/xv6-public/kbd.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kbd.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,50 @@
+#include "types.h"
+#include "x86.h"
+#include "defs.h"
+#include "kbd.h"
+
+int
+kbdgetc(void)
+{
+  static uint shift;
+  static uchar *charcode[4] = {
+    normalmap, shiftmap, ctlmap, ctlmap
+  };
+  uint st, data, c;
+
+  st = inb(KBSTATP);
+  if((st & KBS_DIB) == 0)
+    return -1;
+  data = inb(KBDATAP);
+
+  if(data == 0xE0){
+    shift |= E0ESC;
+    return 0;
+  } else if(data & 0x80){
+    // Key released
+    data = (shift & E0ESC ? data : data & 0x7F);
+    shift &= ~(shiftcode[data] | E0ESC);
+    return 0;
+  } else if(shift & E0ESC){
+    // Last character was an E0 escape; or with 0x80
+    data |= 0x80;
+    shift &= ~E0ESC;
+  }
+
+  shift |= shiftcode[data];
+  shift ^= togglecode[data];
+  c = charcode[shift & (CTL | SHIFT)][data];
+  if(shift & CAPSLOCK){
+    if('a' <= c && c <= 'z')
+      c += 'A' - 'a';
+    else if('A' <= c && c <= 'Z')
+      c += 'a' - 'A';
+  }
+  return c;
+}
+
+void
+kbdintr(void)
+{
+  consoleintr(kbdgetc);
+}
diff -ruN xv6-public/xv6-public/kbd.d xv6-public_new/xv6-public/kbd.d
--- xv6-public/xv6-public/kbd.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kbd.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1 @@
+kbd.o: kbd.c /usr/include/stdc-predef.h types.h x86.h defs.h kbd.h
diff -ruN xv6-public/xv6-public/kbd.h xv6-public_new/xv6-public/kbd.h
--- xv6-public/xv6-public/kbd.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kbd.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,112 @@
+// PC keyboard interface constants
+
+#define KBSTATP         0x64    // kbd controller status port(I)
+#define KBS_DIB         0x01    // kbd data in buffer
+#define KBDATAP         0x60    // kbd data port(I)
+
+#define NO              0
+
+#define SHIFT           (1<<0)
+#define CTL             (1<<1)
+#define ALT             (1<<2)
+
+#define CAPSLOCK        (1<<3)
+#define NUMLOCK         (1<<4)
+#define SCROLLLOCK      (1<<5)
+
+#define E0ESC           (1<<6)
+
+// Special keycodes
+#define KEY_HOME        0xE0
+#define KEY_END         0xE1
+#define KEY_UP          0xE2
+#define KEY_DN          0xE3
+#define KEY_LF          0xE4
+#define KEY_RT          0xE5
+#define KEY_PGUP        0xE6
+#define KEY_PGDN        0xE7
+#define KEY_INS         0xE8
+#define KEY_DEL         0xE9
+
+// C('A') == Control-A
+#define C(x) (x - '@')
+
+static uchar shiftcode[256] =
+{
+  [0x1D] CTL,
+  [0x2A] SHIFT,
+  [0x36] SHIFT,
+  [0x38] ALT,
+  [0x9D] CTL,
+  [0xB8] ALT
+};
+
+static uchar togglecode[256] =
+{
+  [0x3A] CAPSLOCK,
+  [0x45] NUMLOCK,
+  [0x46] SCROLLLOCK
+};
+
+static uchar normalmap[256] =
+{
+  NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
+  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
+  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
+  'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
+  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
+  '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
+  'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
+  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+  [0x9C] '\n',      // KP_Enter
+  [0xB5] '/',       // KP_Div
+  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+  [0x97] KEY_HOME,  [0xCF] KEY_END,
+  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+};
+
+static uchar shiftmap[256] =
+{
+  NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
+  '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
+  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
+  'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
+  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
+  '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
+  'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
+  NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+  NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+  '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+  [0x9C] '\n',      // KP_Enter
+  [0xB5] '/',       // KP_Div
+  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+  [0x97] KEY_HOME,  [0xCF] KEY_END,
+  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+};
+
+static uchar ctlmap[256] =
+{
+  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+  NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+  C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
+  C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
+  C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
+  NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
+  C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
+  [0x9C] '\r',      // KP_Enter
+  [0xB5] C('/'),    // KP_Div
+  [0xC8] KEY_UP,    [0xD0] KEY_DN,
+  [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+  [0xCB] KEY_LF,    [0xCD] KEY_RT,
+  [0x97] KEY_HOME,  [0xCF] KEY_END,
+  [0xD2] KEY_INS,   [0xD3] KEY_DEL
+};
+
Binary files xv6-public/xv6-public/kbd.o and xv6-public_new/xv6-public/kbd.o differ
Binary files xv6-public/xv6-public/kernel and xv6-public_new/xv6-public/kernel differ
diff -ruN xv6-public/xv6-public/kernel.asm xv6-public_new/xv6-public/kernel.asm
--- xv6-public/xv6-public/kernel.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kernel.asm	2021-09-30 23:28:54.000000000 +0530
@@ -0,0 +1,18066 @@
+
+kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+80100000 <multiboot_header>:
+80100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
+80100006:	00 00                	add    %al,(%eax)
+80100008:	fe 4f 52             	decb   0x52(%edi)
+8010000b:	e4                   	.byte 0xe4
+
+8010000c <entry>:
+
+# Entering xv6 on boot processor, with paging off.
+.globl entry
+entry:
+  # Turn on page size extension for 4Mbyte pages
+  movl    %cr4, %eax
+8010000c:	0f 20 e0             	mov    %cr4,%eax
+  orl     $(CR4_PSE), %eax
+8010000f:	83 c8 10             	or     $0x10,%eax
+  movl    %eax, %cr4
+80100012:	0f 22 e0             	mov    %eax,%cr4
+  # Set page directory
+  movl    $(V2P_WO(entrypgdir)), %eax
+80100015:	b8 00 b0 10 00       	mov    $0x10b000,%eax
+  movl    %eax, %cr3
+8010001a:	0f 22 d8             	mov    %eax,%cr3
+  # Turn on paging.
+  movl    %cr0, %eax
+8010001d:	0f 20 c0             	mov    %cr0,%eax
+  orl     $(CR0_PG|CR0_WP), %eax
+80100020:	0d 00 00 01 80       	or     $0x80010000,%eax
+  movl    %eax, %cr0
+80100025:	0f 22 c0             	mov    %eax,%cr0
+
+  # Set up the stack pointer.
+  movl $(stack + KSTACKSIZE), %esp
+80100028:	bc 50 d6 10 80       	mov    $0x8010d650,%esp
+
+  # Jump to main(), and switch to executing at
+  # high addresses. The indirect call is needed because
+  # the assembler produces a PC-relative instruction
+  # for a direct jump.
+  mov $main, %eax
+8010002d:	b8 ae 39 10 80       	mov    $0x801039ae,%eax
+  jmp *%eax
+80100032:	ff e0                	jmp    *%eax
+
+80100034 <binit>:
+  struct buf head;
+} bcache;
+
+void
+binit(void)
+{
+80100034:	f3 0f 1e fb          	endbr32 
+80100038:	55                   	push   %ebp
+80100039:	89 e5                	mov    %esp,%ebp
+8010003b:	83 ec 18             	sub    $0x18,%esp
+  struct buf *b;
+
+  initlock(&bcache.lock, "bcache");
+8010003e:	83 ec 08             	sub    $0x8,%esp
+80100041:	68 00 8d 10 80       	push   $0x80108d00
+80100046:	68 60 d6 10 80       	push   $0x8010d660
+8010004b:	e8 06 57 00 00       	call   80105756 <initlock>
+80100050:	83 c4 10             	add    $0x10,%esp
+
+//PAGEBREAK!
+  // Create linked list of buffers
+  bcache.head.prev = &bcache.head;
+80100053:	c7 05 ac 1d 11 80 5c 	movl   $0x80111d5c,0x80111dac
+8010005a:	1d 11 80 
+  bcache.head.next = &bcache.head;
+8010005d:	c7 05 b0 1d 11 80 5c 	movl   $0x80111d5c,0x80111db0
+80100064:	1d 11 80 
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+80100067:	c7 45 f4 94 d6 10 80 	movl   $0x8010d694,-0xc(%ebp)
+8010006e:	eb 47                	jmp    801000b7 <binit+0x83>
+    b->next = bcache.head.next;
+80100070:	8b 15 b0 1d 11 80    	mov    0x80111db0,%edx
+80100076:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100079:	89 50 54             	mov    %edx,0x54(%eax)
+    b->prev = &bcache.head;
+8010007c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010007f:	c7 40 50 5c 1d 11 80 	movl   $0x80111d5c,0x50(%eax)
+    initsleeplock(&b->lock, "buffer");
+80100086:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100089:	83 c0 0c             	add    $0xc,%eax
+8010008c:	83 ec 08             	sub    $0x8,%esp
+8010008f:	68 07 8d 10 80       	push   $0x80108d07
+80100094:	50                   	push   %eax
+80100095:	e8 29 55 00 00       	call   801055c3 <initsleeplock>
+8010009a:	83 c4 10             	add    $0x10,%esp
+    bcache.head.next->prev = b;
+8010009d:	a1 b0 1d 11 80       	mov    0x80111db0,%eax
+801000a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801000a5:	89 50 50             	mov    %edx,0x50(%eax)
+    bcache.head.next = b;
+801000a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801000ab:	a3 b0 1d 11 80       	mov    %eax,0x80111db0
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+801000b0:	81 45 f4 5c 02 00 00 	addl   $0x25c,-0xc(%ebp)
+801000b7:	b8 5c 1d 11 80       	mov    $0x80111d5c,%eax
+801000bc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+801000bf:	72 af                	jb     80100070 <binit+0x3c>
+  }
+}
+801000c1:	90                   	nop
+801000c2:	90                   	nop
+801000c3:	c9                   	leave  
+801000c4:	c3                   	ret    
+
+801000c5 <bget>:
+// Look through buffer cache for block on device dev.
+// If not found, allocate a buffer.
+// In either case, return locked buffer.
+static struct buf*
+bget(uint dev, uint blockno)
+{
+801000c5:	f3 0f 1e fb          	endbr32 
+801000c9:	55                   	push   %ebp
+801000ca:	89 e5                	mov    %esp,%ebp
+801000cc:	83 ec 18             	sub    $0x18,%esp
+  struct buf *b;
+
+  acquire(&bcache.lock);
+801000cf:	83 ec 0c             	sub    $0xc,%esp
+801000d2:	68 60 d6 10 80       	push   $0x8010d660
+801000d7:	e8 a0 56 00 00       	call   8010577c <acquire>
+801000dc:	83 c4 10             	add    $0x10,%esp
+
+  // Is the block already cached?
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+801000df:	a1 b0 1d 11 80       	mov    0x80111db0,%eax
+801000e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801000e7:	eb 58                	jmp    80100141 <bget+0x7c>
+    if(b->dev == dev && b->blockno == blockno){
+801000e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801000ec:	8b 40 04             	mov    0x4(%eax),%eax
+801000ef:	39 45 08             	cmp    %eax,0x8(%ebp)
+801000f2:	75 44                	jne    80100138 <bget+0x73>
+801000f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801000f7:	8b 40 08             	mov    0x8(%eax),%eax
+801000fa:	39 45 0c             	cmp    %eax,0xc(%ebp)
+801000fd:	75 39                	jne    80100138 <bget+0x73>
+      b->refcnt++;
+801000ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100102:	8b 40 4c             	mov    0x4c(%eax),%eax
+80100105:	8d 50 01             	lea    0x1(%eax),%edx
+80100108:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010010b:	89 50 4c             	mov    %edx,0x4c(%eax)
+      release(&bcache.lock);
+8010010e:	83 ec 0c             	sub    $0xc,%esp
+80100111:	68 60 d6 10 80       	push   $0x8010d660
+80100116:	e8 d3 56 00 00       	call   801057ee <release>
+8010011b:	83 c4 10             	add    $0x10,%esp
+      acquiresleep(&b->lock);
+8010011e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100121:	83 c0 0c             	add    $0xc,%eax
+80100124:	83 ec 0c             	sub    $0xc,%esp
+80100127:	50                   	push   %eax
+80100128:	e8 d6 54 00 00       	call   80105603 <acquiresleep>
+8010012d:	83 c4 10             	add    $0x10,%esp
+      return b;
+80100130:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100133:	e9 9d 00 00 00       	jmp    801001d5 <bget+0x110>
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+80100138:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010013b:	8b 40 54             	mov    0x54(%eax),%eax
+8010013e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80100141:	81 7d f4 5c 1d 11 80 	cmpl   $0x80111d5c,-0xc(%ebp)
+80100148:	75 9f                	jne    801000e9 <bget+0x24>
+  }
+
+  // Not cached; recycle an unused buffer.
+  // Even if refcnt==0, B_DIRTY indicates a buffer is in use
+  // because log.c has modified it but not yet committed it.
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+8010014a:	a1 ac 1d 11 80       	mov    0x80111dac,%eax
+8010014f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80100152:	eb 6b                	jmp    801001bf <bget+0xfa>
+    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+80100154:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100157:	8b 40 4c             	mov    0x4c(%eax),%eax
+8010015a:	85 c0                	test   %eax,%eax
+8010015c:	75 58                	jne    801001b6 <bget+0xf1>
+8010015e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100161:	8b 00                	mov    (%eax),%eax
+80100163:	83 e0 04             	and    $0x4,%eax
+80100166:	85 c0                	test   %eax,%eax
+80100168:	75 4c                	jne    801001b6 <bget+0xf1>
+      b->dev = dev;
+8010016a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010016d:	8b 55 08             	mov    0x8(%ebp),%edx
+80100170:	89 50 04             	mov    %edx,0x4(%eax)
+      b->blockno = blockno;
+80100173:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100176:	8b 55 0c             	mov    0xc(%ebp),%edx
+80100179:	89 50 08             	mov    %edx,0x8(%eax)
+      b->flags = 0;
+8010017c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010017f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+      b->refcnt = 1;
+80100185:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100188:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
+      release(&bcache.lock);
+8010018f:	83 ec 0c             	sub    $0xc,%esp
+80100192:	68 60 d6 10 80       	push   $0x8010d660
+80100197:	e8 52 56 00 00       	call   801057ee <release>
+8010019c:	83 c4 10             	add    $0x10,%esp
+      acquiresleep(&b->lock);
+8010019f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801001a2:	83 c0 0c             	add    $0xc,%eax
+801001a5:	83 ec 0c             	sub    $0xc,%esp
+801001a8:	50                   	push   %eax
+801001a9:	e8 55 54 00 00       	call   80105603 <acquiresleep>
+801001ae:	83 c4 10             	add    $0x10,%esp
+      return b;
+801001b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801001b4:	eb 1f                	jmp    801001d5 <bget+0x110>
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+801001b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801001b9:	8b 40 50             	mov    0x50(%eax),%eax
+801001bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801001bf:	81 7d f4 5c 1d 11 80 	cmpl   $0x80111d5c,-0xc(%ebp)
+801001c6:	75 8c                	jne    80100154 <bget+0x8f>
+    }
+  }
+  panic("bget: no buffers");
+801001c8:	83 ec 0c             	sub    $0xc,%esp
+801001cb:	68 0e 8d 10 80       	push   $0x80108d0e
+801001d0:	e8 fc 03 00 00       	call   801005d1 <panic>
+}
+801001d5:	c9                   	leave  
+801001d6:	c3                   	ret    
+
+801001d7 <bread>:
+
+// Return a locked buf with the contents of the indicated block.
+struct buf*
+bread(uint dev, uint blockno)
+{
+801001d7:	f3 0f 1e fb          	endbr32 
+801001db:	55                   	push   %ebp
+801001dc:	89 e5                	mov    %esp,%ebp
+801001de:	83 ec 18             	sub    $0x18,%esp
+  struct buf *b;
+
+  b = bget(dev, blockno);
+801001e1:	83 ec 08             	sub    $0x8,%esp
+801001e4:	ff 75 0c             	pushl  0xc(%ebp)
+801001e7:	ff 75 08             	pushl  0x8(%ebp)
+801001ea:	e8 d6 fe ff ff       	call   801000c5 <bget>
+801001ef:	83 c4 10             	add    $0x10,%esp
+801001f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if((b->flags & B_VALID) == 0) {
+801001f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801001f8:	8b 00                	mov    (%eax),%eax
+801001fa:	83 e0 02             	and    $0x2,%eax
+801001fd:	85 c0                	test   %eax,%eax
+801001ff:	75 0e                	jne    8010020f <bread+0x38>
+    iderw(b);
+80100201:	83 ec 0c             	sub    $0xc,%esp
+80100204:	ff 75 f4             	pushl  -0xc(%ebp)
+80100207:	e8 27 28 00 00       	call   80102a33 <iderw>
+8010020c:	83 c4 10             	add    $0x10,%esp
+  }
+  return b;
+8010020f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80100212:	c9                   	leave  
+80100213:	c3                   	ret    
+
+80100214 <bwrite>:
+
+// Write b's contents to disk.  Must be locked.
+void
+bwrite(struct buf *b)
+{
+80100214:	f3 0f 1e fb          	endbr32 
+80100218:	55                   	push   %ebp
+80100219:	89 e5                	mov    %esp,%ebp
+8010021b:	83 ec 08             	sub    $0x8,%esp
+  if(!holdingsleep(&b->lock))
+8010021e:	8b 45 08             	mov    0x8(%ebp),%eax
+80100221:	83 c0 0c             	add    $0xc,%eax
+80100224:	83 ec 0c             	sub    $0xc,%esp
+80100227:	50                   	push   %eax
+80100228:	e8 90 54 00 00       	call   801056bd <holdingsleep>
+8010022d:	83 c4 10             	add    $0x10,%esp
+80100230:	85 c0                	test   %eax,%eax
+80100232:	75 0d                	jne    80100241 <bwrite+0x2d>
+    panic("bwrite");
+80100234:	83 ec 0c             	sub    $0xc,%esp
+80100237:	68 1f 8d 10 80       	push   $0x80108d1f
+8010023c:	e8 90 03 00 00       	call   801005d1 <panic>
+  b->flags |= B_DIRTY;
+80100241:	8b 45 08             	mov    0x8(%ebp),%eax
+80100244:	8b 00                	mov    (%eax),%eax
+80100246:	83 c8 04             	or     $0x4,%eax
+80100249:	89 c2                	mov    %eax,%edx
+8010024b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010024e:	89 10                	mov    %edx,(%eax)
+  iderw(b);
+80100250:	83 ec 0c             	sub    $0xc,%esp
+80100253:	ff 75 08             	pushl  0x8(%ebp)
+80100256:	e8 d8 27 00 00       	call   80102a33 <iderw>
+8010025b:	83 c4 10             	add    $0x10,%esp
+}
+8010025e:	90                   	nop
+8010025f:	c9                   	leave  
+80100260:	c3                   	ret    
+
+80100261 <brelse>:
+
+// Release a locked buffer.
+// Move to the head of the MRU list.
+void
+brelse(struct buf *b)
+{
+80100261:	f3 0f 1e fb          	endbr32 
+80100265:	55                   	push   %ebp
+80100266:	89 e5                	mov    %esp,%ebp
+80100268:	83 ec 08             	sub    $0x8,%esp
+  if(!holdingsleep(&b->lock))
+8010026b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010026e:	83 c0 0c             	add    $0xc,%eax
+80100271:	83 ec 0c             	sub    $0xc,%esp
+80100274:	50                   	push   %eax
+80100275:	e8 43 54 00 00       	call   801056bd <holdingsleep>
+8010027a:	83 c4 10             	add    $0x10,%esp
+8010027d:	85 c0                	test   %eax,%eax
+8010027f:	75 0d                	jne    8010028e <brelse+0x2d>
+    panic("brelse");
+80100281:	83 ec 0c             	sub    $0xc,%esp
+80100284:	68 26 8d 10 80       	push   $0x80108d26
+80100289:	e8 43 03 00 00       	call   801005d1 <panic>
+
+  releasesleep(&b->lock);
+8010028e:	8b 45 08             	mov    0x8(%ebp),%eax
+80100291:	83 c0 0c             	add    $0xc,%eax
+80100294:	83 ec 0c             	sub    $0xc,%esp
+80100297:	50                   	push   %eax
+80100298:	e8 ce 53 00 00       	call   8010566b <releasesleep>
+8010029d:	83 c4 10             	add    $0x10,%esp
+
+  acquire(&bcache.lock);
+801002a0:	83 ec 0c             	sub    $0xc,%esp
+801002a3:	68 60 d6 10 80       	push   $0x8010d660
+801002a8:	e8 cf 54 00 00       	call   8010577c <acquire>
+801002ad:	83 c4 10             	add    $0x10,%esp
+  b->refcnt--;
+801002b0:	8b 45 08             	mov    0x8(%ebp),%eax
+801002b3:	8b 40 4c             	mov    0x4c(%eax),%eax
+801002b6:	8d 50 ff             	lea    -0x1(%eax),%edx
+801002b9:	8b 45 08             	mov    0x8(%ebp),%eax
+801002bc:	89 50 4c             	mov    %edx,0x4c(%eax)
+  if (b->refcnt == 0) {
+801002bf:	8b 45 08             	mov    0x8(%ebp),%eax
+801002c2:	8b 40 4c             	mov    0x4c(%eax),%eax
+801002c5:	85 c0                	test   %eax,%eax
+801002c7:	75 47                	jne    80100310 <brelse+0xaf>
+    // no one is waiting for it.
+    b->next->prev = b->prev;
+801002c9:	8b 45 08             	mov    0x8(%ebp),%eax
+801002cc:	8b 40 54             	mov    0x54(%eax),%eax
+801002cf:	8b 55 08             	mov    0x8(%ebp),%edx
+801002d2:	8b 52 50             	mov    0x50(%edx),%edx
+801002d5:	89 50 50             	mov    %edx,0x50(%eax)
+    b->prev->next = b->next;
+801002d8:	8b 45 08             	mov    0x8(%ebp),%eax
+801002db:	8b 40 50             	mov    0x50(%eax),%eax
+801002de:	8b 55 08             	mov    0x8(%ebp),%edx
+801002e1:	8b 52 54             	mov    0x54(%edx),%edx
+801002e4:	89 50 54             	mov    %edx,0x54(%eax)
+    b->next = bcache.head.next;
+801002e7:	8b 15 b0 1d 11 80    	mov    0x80111db0,%edx
+801002ed:	8b 45 08             	mov    0x8(%ebp),%eax
+801002f0:	89 50 54             	mov    %edx,0x54(%eax)
+    b->prev = &bcache.head;
+801002f3:	8b 45 08             	mov    0x8(%ebp),%eax
+801002f6:	c7 40 50 5c 1d 11 80 	movl   $0x80111d5c,0x50(%eax)
+    bcache.head.next->prev = b;
+801002fd:	a1 b0 1d 11 80       	mov    0x80111db0,%eax
+80100302:	8b 55 08             	mov    0x8(%ebp),%edx
+80100305:	89 50 50             	mov    %edx,0x50(%eax)
+    bcache.head.next = b;
+80100308:	8b 45 08             	mov    0x8(%ebp),%eax
+8010030b:	a3 b0 1d 11 80       	mov    %eax,0x80111db0
+  }
+  
+  release(&bcache.lock);
+80100310:	83 ec 0c             	sub    $0xc,%esp
+80100313:	68 60 d6 10 80       	push   $0x8010d660
+80100318:	e8 d1 54 00 00       	call   801057ee <release>
+8010031d:	83 c4 10             	add    $0x10,%esp
+}
+80100320:	90                   	nop
+80100321:	c9                   	leave  
+80100322:	c3                   	ret    
+
+80100323 <inb>:
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port)
+{
+80100323:	55                   	push   %ebp
+80100324:	89 e5                	mov    %esp,%ebp
+80100326:	83 ec 14             	sub    $0x14,%esp
+80100329:	8b 45 08             	mov    0x8(%ebp),%eax
+8010032c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80100330:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+80100334:	89 c2                	mov    %eax,%edx
+80100336:	ec                   	in     (%dx),%al
+80100337:	88 45 ff             	mov    %al,-0x1(%ebp)
+  return data;
+8010033a:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
+}
+8010033e:	c9                   	leave  
+8010033f:	c3                   	ret    
+
+80100340 <outb>:
+               "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+80100340:	55                   	push   %ebp
+80100341:	89 e5                	mov    %esp,%ebp
+80100343:	83 ec 08             	sub    $0x8,%esp
+80100346:	8b 45 08             	mov    0x8(%ebp),%eax
+80100349:	8b 55 0c             	mov    0xc(%ebp),%edx
+8010034c:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+80100350:	89 d0                	mov    %edx,%eax
+80100352:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80100355:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80100359:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+8010035d:	ee                   	out    %al,(%dx)
+}
+8010035e:	90                   	nop
+8010035f:	c9                   	leave  
+80100360:	c3                   	ret    
+
+80100361 <cli>:
+  asm volatile("movw %0, %%gs" : : "r" (v));
+}
+
+static inline void
+cli(void)
+{
+80100361:	55                   	push   %ebp
+80100362:	89 e5                	mov    %esp,%ebp
+  asm volatile("cli");
+80100364:	fa                   	cli    
+}
+80100365:	90                   	nop
+80100366:	5d                   	pop    %ebp
+80100367:	c3                   	ret    
+
+80100368 <printint>:
+  int locking;
+} cons;
+
+static void
+printint(int xx, int base, int sign)
+{
+80100368:	f3 0f 1e fb          	endbr32 
+8010036c:	55                   	push   %ebp
+8010036d:	89 e5                	mov    %esp,%ebp
+8010036f:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789abcdef";
+  char buf[16];
+  int i;
+  uint x;
+
+  if(sign && (sign = xx < 0))
+80100372:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80100376:	74 1c                	je     80100394 <printint+0x2c>
+80100378:	8b 45 08             	mov    0x8(%ebp),%eax
+8010037b:	c1 e8 1f             	shr    $0x1f,%eax
+8010037e:	0f b6 c0             	movzbl %al,%eax
+80100381:	89 45 10             	mov    %eax,0x10(%ebp)
+80100384:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80100388:	74 0a                	je     80100394 <printint+0x2c>
+    x = -xx;
+8010038a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010038d:	f7 d8                	neg    %eax
+8010038f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80100392:	eb 06                	jmp    8010039a <printint+0x32>
+  else
+    x = xx;
+80100394:	8b 45 08             	mov    0x8(%ebp),%eax
+80100397:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  i = 0;
+8010039a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+801003a1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+801003a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801003a7:	ba 00 00 00 00       	mov    $0x0,%edx
+801003ac:	f7 f1                	div    %ecx
+801003ae:	89 d1                	mov    %edx,%ecx
+801003b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801003b3:	8d 50 01             	lea    0x1(%eax),%edx
+801003b6:	89 55 f4             	mov    %edx,-0xc(%ebp)
+801003b9:	0f b6 91 04 a0 10 80 	movzbl -0x7fef5ffc(%ecx),%edx
+801003c0:	88 54 05 e0          	mov    %dl,-0x20(%ebp,%eax,1)
+  }while((x /= base) != 0);
+801003c4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+801003c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801003ca:	ba 00 00 00 00       	mov    $0x0,%edx
+801003cf:	f7 f1                	div    %ecx
+801003d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+801003d4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801003d8:	75 c7                	jne    801003a1 <printint+0x39>
+
+  if(sign)
+801003da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+801003de:	74 2a                	je     8010040a <printint+0xa2>
+    buf[i++] = '-';
+801003e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801003e3:	8d 50 01             	lea    0x1(%eax),%edx
+801003e6:	89 55 f4             	mov    %edx,-0xc(%ebp)
+801003e9:	c6 44 05 e0 2d       	movb   $0x2d,-0x20(%ebp,%eax,1)
+
+  while(--i >= 0)
+801003ee:	eb 1a                	jmp    8010040a <printint+0xa2>
+    consputc(buf[i]);
+801003f0:	8d 55 e0             	lea    -0x20(%ebp),%edx
+801003f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801003f6:	01 d0                	add    %edx,%eax
+801003f8:	0f b6 00             	movzbl (%eax),%eax
+801003fb:	0f be c0             	movsbl %al,%eax
+801003fe:	83 ec 0c             	sub    $0xc,%esp
+80100401:	50                   	push   %eax
+80100402:	e8 ff 03 00 00       	call   80100806 <consputc>
+80100407:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+8010040a:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+8010040e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80100412:	79 dc                	jns    801003f0 <printint+0x88>
+}
+80100414:	90                   	nop
+80100415:	90                   	nop
+80100416:	c9                   	leave  
+80100417:	c3                   	ret    
+
+80100418 <cprintf>:
+//PAGEBREAK: 50
+
+// Print to the console. only understands %d, %x, %p, %s.
+void
+cprintf(char *fmt, ...)
+{
+80100418:	f3 0f 1e fb          	endbr32 
+8010041c:	55                   	push   %ebp
+8010041d:	89 e5                	mov    %esp,%ebp
+8010041f:	83 ec 28             	sub    $0x28,%esp
+  int i, c, locking;
+  uint *argp;
+  char *s;
+
+  locking = cons.locking;
+80100422:	a1 f4 c5 10 80       	mov    0x8010c5f4,%eax
+80100427:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  if(locking)
+8010042a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+8010042e:	74 10                	je     80100440 <cprintf+0x28>
+    acquire(&cons.lock);
+80100430:	83 ec 0c             	sub    $0xc,%esp
+80100433:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100438:	e8 3f 53 00 00       	call   8010577c <acquire>
+8010043d:	83 c4 10             	add    $0x10,%esp
+
+  if (fmt == 0)
+80100440:	8b 45 08             	mov    0x8(%ebp),%eax
+80100443:	85 c0                	test   %eax,%eax
+80100445:	75 0d                	jne    80100454 <cprintf+0x3c>
+    panic("null fmt");
+80100447:	83 ec 0c             	sub    $0xc,%esp
+8010044a:	68 2d 8d 10 80       	push   $0x80108d2d
+8010044f:	e8 7d 01 00 00       	call   801005d1 <panic>
+
+  argp = (uint*)(void*)(&fmt + 1);
+80100454:	8d 45 0c             	lea    0xc(%ebp),%eax
+80100457:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+8010045a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80100461:	e9 2f 01 00 00       	jmp    80100595 <cprintf+0x17d>
+    if(c != '%'){
+80100466:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+8010046a:	74 13                	je     8010047f <cprintf+0x67>
+      consputc(c);
+8010046c:	83 ec 0c             	sub    $0xc,%esp
+8010046f:	ff 75 e4             	pushl  -0x1c(%ebp)
+80100472:	e8 8f 03 00 00       	call   80100806 <consputc>
+80100477:	83 c4 10             	add    $0x10,%esp
+      continue;
+8010047a:	e9 12 01 00 00       	jmp    80100591 <cprintf+0x179>
+    }
+    c = fmt[++i] & 0xff;
+8010047f:	8b 55 08             	mov    0x8(%ebp),%edx
+80100482:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80100486:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100489:	01 d0                	add    %edx,%eax
+8010048b:	0f b6 00             	movzbl (%eax),%eax
+8010048e:	0f be c0             	movsbl %al,%eax
+80100491:	25 ff 00 00 00       	and    $0xff,%eax
+80100496:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(c == 0)
+80100499:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+8010049d:	0f 84 14 01 00 00    	je     801005b7 <cprintf+0x19f>
+      break;
+    switch(c){
+801004a3:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+801004a7:	74 5e                	je     80100507 <cprintf+0xef>
+801004a9:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+801004ad:	0f 8f c2 00 00 00    	jg     80100575 <cprintf+0x15d>
+801004b3:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+801004b7:	74 6b                	je     80100524 <cprintf+0x10c>
+801004b9:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+801004bd:	0f 8f b2 00 00 00    	jg     80100575 <cprintf+0x15d>
+801004c3:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+801004c7:	74 3e                	je     80100507 <cprintf+0xef>
+801004c9:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+801004cd:	0f 8f a2 00 00 00    	jg     80100575 <cprintf+0x15d>
+801004d3:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+801004d7:	0f 84 89 00 00 00    	je     80100566 <cprintf+0x14e>
+801004dd:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+801004e1:	0f 85 8e 00 00 00    	jne    80100575 <cprintf+0x15d>
+    case 'd':
+      printint(*argp++, 10, 1);
+801004e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801004ea:	8d 50 04             	lea    0x4(%eax),%edx
+801004ed:	89 55 f0             	mov    %edx,-0x10(%ebp)
+801004f0:	8b 00                	mov    (%eax),%eax
+801004f2:	83 ec 04             	sub    $0x4,%esp
+801004f5:	6a 01                	push   $0x1
+801004f7:	6a 0a                	push   $0xa
+801004f9:	50                   	push   %eax
+801004fa:	e8 69 fe ff ff       	call   80100368 <printint>
+801004ff:	83 c4 10             	add    $0x10,%esp
+      break;
+80100502:	e9 8a 00 00 00       	jmp    80100591 <cprintf+0x179>
+    case 'x':
+    case 'p':
+      printint(*argp++, 16, 0);
+80100507:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010050a:	8d 50 04             	lea    0x4(%eax),%edx
+8010050d:	89 55 f0             	mov    %edx,-0x10(%ebp)
+80100510:	8b 00                	mov    (%eax),%eax
+80100512:	83 ec 04             	sub    $0x4,%esp
+80100515:	6a 00                	push   $0x0
+80100517:	6a 10                	push   $0x10
+80100519:	50                   	push   %eax
+8010051a:	e8 49 fe ff ff       	call   80100368 <printint>
+8010051f:	83 c4 10             	add    $0x10,%esp
+      break;
+80100522:	eb 6d                	jmp    80100591 <cprintf+0x179>
+    case 's':
+      if((s = (char*)*argp++) == 0)
+80100524:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80100527:	8d 50 04             	lea    0x4(%eax),%edx
+8010052a:	89 55 f0             	mov    %edx,-0x10(%ebp)
+8010052d:	8b 00                	mov    (%eax),%eax
+8010052f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80100532:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80100536:	75 22                	jne    8010055a <cprintf+0x142>
+        s = "(null)";
+80100538:	c7 45 ec 36 8d 10 80 	movl   $0x80108d36,-0x14(%ebp)
+      for(; *s; s++)
+8010053f:	eb 19                	jmp    8010055a <cprintf+0x142>
+        consputc(*s);
+80100541:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80100544:	0f b6 00             	movzbl (%eax),%eax
+80100547:	0f be c0             	movsbl %al,%eax
+8010054a:	83 ec 0c             	sub    $0xc,%esp
+8010054d:	50                   	push   %eax
+8010054e:	e8 b3 02 00 00       	call   80100806 <consputc>
+80100553:	83 c4 10             	add    $0x10,%esp
+      for(; *s; s++)
+80100556:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+8010055a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010055d:	0f b6 00             	movzbl (%eax),%eax
+80100560:	84 c0                	test   %al,%al
+80100562:	75 dd                	jne    80100541 <cprintf+0x129>
+      break;
+80100564:	eb 2b                	jmp    80100591 <cprintf+0x179>
+    case '%':
+      consputc('%');
+80100566:	83 ec 0c             	sub    $0xc,%esp
+80100569:	6a 25                	push   $0x25
+8010056b:	e8 96 02 00 00       	call   80100806 <consputc>
+80100570:	83 c4 10             	add    $0x10,%esp
+      break;
+80100573:	eb 1c                	jmp    80100591 <cprintf+0x179>
+    default:
+      // Print unknown % sequence to draw attention.
+      consputc('%');
+80100575:	83 ec 0c             	sub    $0xc,%esp
+80100578:	6a 25                	push   $0x25
+8010057a:	e8 87 02 00 00       	call   80100806 <consputc>
+8010057f:	83 c4 10             	add    $0x10,%esp
+      consputc(c);
+80100582:	83 ec 0c             	sub    $0xc,%esp
+80100585:	ff 75 e4             	pushl  -0x1c(%ebp)
+80100588:	e8 79 02 00 00       	call   80100806 <consputc>
+8010058d:	83 c4 10             	add    $0x10,%esp
+      break;
+80100590:	90                   	nop
+  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
+80100591:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80100595:	8b 55 08             	mov    0x8(%ebp),%edx
+80100598:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010059b:	01 d0                	add    %edx,%eax
+8010059d:	0f b6 00             	movzbl (%eax),%eax
+801005a0:	0f be c0             	movsbl %al,%eax
+801005a3:	25 ff 00 00 00       	and    $0xff,%eax
+801005a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+801005ab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+801005af:	0f 85 b1 fe ff ff    	jne    80100466 <cprintf+0x4e>
+801005b5:	eb 01                	jmp    801005b8 <cprintf+0x1a0>
+      break;
+801005b7:	90                   	nop
+    }
+  }
+
+  if(locking)
+801005b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+801005bc:	74 10                	je     801005ce <cprintf+0x1b6>
+    release(&cons.lock);
+801005be:	83 ec 0c             	sub    $0xc,%esp
+801005c1:	68 c0 c5 10 80       	push   $0x8010c5c0
+801005c6:	e8 23 52 00 00       	call   801057ee <release>
+801005cb:	83 c4 10             	add    $0x10,%esp
+}
+801005ce:	90                   	nop
+801005cf:	c9                   	leave  
+801005d0:	c3                   	ret    
+
+801005d1 <panic>:
+
+void
+panic(char *s)
+{
+801005d1:	f3 0f 1e fb          	endbr32 
+801005d5:	55                   	push   %ebp
+801005d6:	89 e5                	mov    %esp,%ebp
+801005d8:	83 ec 38             	sub    $0x38,%esp
+  int i;
+  uint pcs[10];
+
+  cli();
+801005db:	e8 81 fd ff ff       	call   80100361 <cli>
+  cons.locking = 0;
+801005e0:	c7 05 f4 c5 10 80 00 	movl   $0x0,0x8010c5f4
+801005e7:	00 00 00 
+  // use lapiccpunum so that we can call panic from mycpu()
+  cprintf("lapicid %d: panic: ", lapicid());
+801005ea:	e8 10 2b 00 00       	call   801030ff <lapicid>
+801005ef:	83 ec 08             	sub    $0x8,%esp
+801005f2:	50                   	push   %eax
+801005f3:	68 3d 8d 10 80       	push   $0x80108d3d
+801005f8:	e8 1b fe ff ff       	call   80100418 <cprintf>
+801005fd:	83 c4 10             	add    $0x10,%esp
+  cprintf(s);
+80100600:	8b 45 08             	mov    0x8(%ebp),%eax
+80100603:	83 ec 0c             	sub    $0xc,%esp
+80100606:	50                   	push   %eax
+80100607:	e8 0c fe ff ff       	call   80100418 <cprintf>
+8010060c:	83 c4 10             	add    $0x10,%esp
+  cprintf("\n");
+8010060f:	83 ec 0c             	sub    $0xc,%esp
+80100612:	68 51 8d 10 80       	push   $0x80108d51
+80100617:	e8 fc fd ff ff       	call   80100418 <cprintf>
+8010061c:	83 c4 10             	add    $0x10,%esp
+  getcallerpcs(&s, pcs);
+8010061f:	83 ec 08             	sub    $0x8,%esp
+80100622:	8d 45 cc             	lea    -0x34(%ebp),%eax
+80100625:	50                   	push   %eax
+80100626:	8d 45 08             	lea    0x8(%ebp),%eax
+80100629:	50                   	push   %eax
+8010062a:	e8 15 52 00 00       	call   80105844 <getcallerpcs>
+8010062f:	83 c4 10             	add    $0x10,%esp
+  for(i=0; i<10; i++)
+80100632:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80100639:	eb 1c                	jmp    80100657 <panic+0x86>
+    cprintf(" %p", pcs[i]);
+8010063b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010063e:	8b 44 85 cc          	mov    -0x34(%ebp,%eax,4),%eax
+80100642:	83 ec 08             	sub    $0x8,%esp
+80100645:	50                   	push   %eax
+80100646:	68 53 8d 10 80       	push   $0x80108d53
+8010064b:	e8 c8 fd ff ff       	call   80100418 <cprintf>
+80100650:	83 c4 10             	add    $0x10,%esp
+  for(i=0; i<10; i++)
+80100653:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80100657:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+8010065b:	7e de                	jle    8010063b <panic+0x6a>
+  panicked = 1; // freeze other CPU
+8010065d:	c7 05 a0 c5 10 80 01 	movl   $0x1,0x8010c5a0
+80100664:	00 00 00 
+  for(;;)
+80100667:	eb fe                	jmp    80100667 <panic+0x96>
+
+80100669 <cgaputc>:
+#define CRTPORT 0x3d4
+static ushort *crt = (ushort*)P2V(0xb8000);  // CGA memory
+
+static void
+cgaputc(int c)
+{
+80100669:	f3 0f 1e fb          	endbr32 
+8010066d:	55                   	push   %ebp
+8010066e:	89 e5                	mov    %esp,%ebp
+80100670:	53                   	push   %ebx
+80100671:	83 ec 14             	sub    $0x14,%esp
+  int pos;
+
+  // Cursor position: col + 80*row.
+  outb(CRTPORT, 14);
+80100674:	6a 0e                	push   $0xe
+80100676:	68 d4 03 00 00       	push   $0x3d4
+8010067b:	e8 c0 fc ff ff       	call   80100340 <outb>
+80100680:	83 c4 08             	add    $0x8,%esp
+  pos = inb(CRTPORT+1) << 8;
+80100683:	68 d5 03 00 00       	push   $0x3d5
+80100688:	e8 96 fc ff ff       	call   80100323 <inb>
+8010068d:	83 c4 04             	add    $0x4,%esp
+80100690:	0f b6 c0             	movzbl %al,%eax
+80100693:	c1 e0 08             	shl    $0x8,%eax
+80100696:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  outb(CRTPORT, 15);
+80100699:	6a 0f                	push   $0xf
+8010069b:	68 d4 03 00 00       	push   $0x3d4
+801006a0:	e8 9b fc ff ff       	call   80100340 <outb>
+801006a5:	83 c4 08             	add    $0x8,%esp
+  pos |= inb(CRTPORT+1);
+801006a8:	68 d5 03 00 00       	push   $0x3d5
+801006ad:	e8 71 fc ff ff       	call   80100323 <inb>
+801006b2:	83 c4 04             	add    $0x4,%esp
+801006b5:	0f b6 c0             	movzbl %al,%eax
+801006b8:	09 45 f4             	or     %eax,-0xc(%ebp)
+
+  if(c == '\n')
+801006bb:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
+801006bf:	75 30                	jne    801006f1 <cgaputc+0x88>
+    pos += 80 - pos%80;
+801006c1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+801006c4:	ba 67 66 66 66       	mov    $0x66666667,%edx
+801006c9:	89 c8                	mov    %ecx,%eax
+801006cb:	f7 ea                	imul   %edx
+801006cd:	c1 fa 05             	sar    $0x5,%edx
+801006d0:	89 c8                	mov    %ecx,%eax
+801006d2:	c1 f8 1f             	sar    $0x1f,%eax
+801006d5:	29 c2                	sub    %eax,%edx
+801006d7:	89 d0                	mov    %edx,%eax
+801006d9:	c1 e0 02             	shl    $0x2,%eax
+801006dc:	01 d0                	add    %edx,%eax
+801006de:	c1 e0 04             	shl    $0x4,%eax
+801006e1:	29 c1                	sub    %eax,%ecx
+801006e3:	89 ca                	mov    %ecx,%edx
+801006e5:	b8 50 00 00 00       	mov    $0x50,%eax
+801006ea:	29 d0                	sub    %edx,%eax
+801006ec:	01 45 f4             	add    %eax,-0xc(%ebp)
+801006ef:	eb 38                	jmp    80100729 <cgaputc+0xc0>
+  else if(c == BACKSPACE){
+801006f1:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
+801006f8:	75 0c                	jne    80100706 <cgaputc+0x9d>
+    if(pos > 0) --pos;
+801006fa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801006fe:	7e 29                	jle    80100729 <cgaputc+0xc0>
+80100700:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+80100704:	eb 23                	jmp    80100729 <cgaputc+0xc0>
+  } else
+    crt[pos++] = (c&0xff) | 0x0700;  // black on white
+80100706:	8b 45 08             	mov    0x8(%ebp),%eax
+80100709:	0f b6 c0             	movzbl %al,%eax
+8010070c:	80 cc 07             	or     $0x7,%ah
+8010070f:	89 c3                	mov    %eax,%ebx
+80100711:	8b 0d 00 a0 10 80    	mov    0x8010a000,%ecx
+80100717:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010071a:	8d 50 01             	lea    0x1(%eax),%edx
+8010071d:	89 55 f4             	mov    %edx,-0xc(%ebp)
+80100720:	01 c0                	add    %eax,%eax
+80100722:	01 c8                	add    %ecx,%eax
+80100724:	89 da                	mov    %ebx,%edx
+80100726:	66 89 10             	mov    %dx,(%eax)
+
+  if(pos < 0 || pos > 25*80)
+80100729:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010072d:	78 09                	js     80100738 <cgaputc+0xcf>
+8010072f:	81 7d f4 d0 07 00 00 	cmpl   $0x7d0,-0xc(%ebp)
+80100736:	7e 0d                	jle    80100745 <cgaputc+0xdc>
+    panic("pos under/overflow");
+80100738:	83 ec 0c             	sub    $0xc,%esp
+8010073b:	68 57 8d 10 80       	push   $0x80108d57
+80100740:	e8 8c fe ff ff       	call   801005d1 <panic>
+
+  if((pos/80) >= 24){  // Scroll up.
+80100745:	81 7d f4 7f 07 00 00 	cmpl   $0x77f,-0xc(%ebp)
+8010074c:	7e 4c                	jle    8010079a <cgaputc+0x131>
+    memmove(crt, crt+80, sizeof(crt[0])*23*80);
+8010074e:	a1 00 a0 10 80       	mov    0x8010a000,%eax
+80100753:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+80100759:	a1 00 a0 10 80       	mov    0x8010a000,%eax
+8010075e:	83 ec 04             	sub    $0x4,%esp
+80100761:	68 60 0e 00 00       	push   $0xe60
+80100766:	52                   	push   %edx
+80100767:	50                   	push   %eax
+80100768:	e8 75 53 00 00       	call   80105ae2 <memmove>
+8010076d:	83 c4 10             	add    $0x10,%esp
+    pos -= 80;
+80100770:	83 6d f4 50          	subl   $0x50,-0xc(%ebp)
+    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+80100774:	b8 80 07 00 00       	mov    $0x780,%eax
+80100779:	2b 45 f4             	sub    -0xc(%ebp),%eax
+8010077c:	8d 14 00             	lea    (%eax,%eax,1),%edx
+8010077f:	a1 00 a0 10 80       	mov    0x8010a000,%eax
+80100784:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+80100787:	01 c9                	add    %ecx,%ecx
+80100789:	01 c8                	add    %ecx,%eax
+8010078b:	83 ec 04             	sub    $0x4,%esp
+8010078e:	52                   	push   %edx
+8010078f:	6a 00                	push   $0x0
+80100791:	50                   	push   %eax
+80100792:	e8 84 52 00 00       	call   80105a1b <memset>
+80100797:	83 c4 10             	add    $0x10,%esp
+  }
+
+  outb(CRTPORT, 14);
+8010079a:	83 ec 08             	sub    $0x8,%esp
+8010079d:	6a 0e                	push   $0xe
+8010079f:	68 d4 03 00 00       	push   $0x3d4
+801007a4:	e8 97 fb ff ff       	call   80100340 <outb>
+801007a9:	83 c4 10             	add    $0x10,%esp
+  outb(CRTPORT+1, pos>>8);
+801007ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801007af:	c1 f8 08             	sar    $0x8,%eax
+801007b2:	0f b6 c0             	movzbl %al,%eax
+801007b5:	83 ec 08             	sub    $0x8,%esp
+801007b8:	50                   	push   %eax
+801007b9:	68 d5 03 00 00       	push   $0x3d5
+801007be:	e8 7d fb ff ff       	call   80100340 <outb>
+801007c3:	83 c4 10             	add    $0x10,%esp
+  outb(CRTPORT, 15);
+801007c6:	83 ec 08             	sub    $0x8,%esp
+801007c9:	6a 0f                	push   $0xf
+801007cb:	68 d4 03 00 00       	push   $0x3d4
+801007d0:	e8 6b fb ff ff       	call   80100340 <outb>
+801007d5:	83 c4 10             	add    $0x10,%esp
+  outb(CRTPORT+1, pos);
+801007d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801007db:	0f b6 c0             	movzbl %al,%eax
+801007de:	83 ec 08             	sub    $0x8,%esp
+801007e1:	50                   	push   %eax
+801007e2:	68 d5 03 00 00       	push   $0x3d5
+801007e7:	e8 54 fb ff ff       	call   80100340 <outb>
+801007ec:	83 c4 10             	add    $0x10,%esp
+  crt[pos] = ' ' | 0x0700;
+801007ef:	a1 00 a0 10 80       	mov    0x8010a000,%eax
+801007f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801007f7:	01 d2                	add    %edx,%edx
+801007f9:	01 d0                	add    %edx,%eax
+801007fb:	66 c7 00 20 07       	movw   $0x720,(%eax)
+}
+80100800:	90                   	nop
+80100801:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80100804:	c9                   	leave  
+80100805:	c3                   	ret    
+
+80100806 <consputc>:
+
+void
+consputc(int c)
+{
+80100806:	f3 0f 1e fb          	endbr32 
+8010080a:	55                   	push   %ebp
+8010080b:	89 e5                	mov    %esp,%ebp
+8010080d:	83 ec 08             	sub    $0x8,%esp
+  if(panicked){
+80100810:	a1 a0 c5 10 80       	mov    0x8010c5a0,%eax
+80100815:	85 c0                	test   %eax,%eax
+80100817:	74 07                	je     80100820 <consputc+0x1a>
+    cli();
+80100819:	e8 43 fb ff ff       	call   80100361 <cli>
+    for(;;)
+8010081e:	eb fe                	jmp    8010081e <consputc+0x18>
+      ;
+  }
+
+  if(c == BACKSPACE){
+80100820:	81 7d 08 00 01 00 00 	cmpl   $0x100,0x8(%ebp)
+80100827:	75 29                	jne    80100852 <consputc+0x4c>
+    uartputc('\b'); uartputc(' '); uartputc('\b');
+80100829:	83 ec 0c             	sub    $0xc,%esp
+8010082c:	6a 08                	push   $0x8
+8010082e:	e8 32 6c 00 00       	call   80107465 <uartputc>
+80100833:	83 c4 10             	add    $0x10,%esp
+80100836:	83 ec 0c             	sub    $0xc,%esp
+80100839:	6a 20                	push   $0x20
+8010083b:	e8 25 6c 00 00       	call   80107465 <uartputc>
+80100840:	83 c4 10             	add    $0x10,%esp
+80100843:	83 ec 0c             	sub    $0xc,%esp
+80100846:	6a 08                	push   $0x8
+80100848:	e8 18 6c 00 00       	call   80107465 <uartputc>
+8010084d:	83 c4 10             	add    $0x10,%esp
+80100850:	eb 0e                	jmp    80100860 <consputc+0x5a>
+  } else
+    uartputc(c);
+80100852:	83 ec 0c             	sub    $0xc,%esp
+80100855:	ff 75 08             	pushl  0x8(%ebp)
+80100858:	e8 08 6c 00 00       	call   80107465 <uartputc>
+8010085d:	83 c4 10             	add    $0x10,%esp
+  cgaputc(c);
+80100860:	83 ec 0c             	sub    $0xc,%esp
+80100863:	ff 75 08             	pushl  0x8(%ebp)
+80100866:	e8 fe fd ff ff       	call   80100669 <cgaputc>
+8010086b:	83 c4 10             	add    $0x10,%esp
+}
+8010086e:	90                   	nop
+8010086f:	c9                   	leave  
+80100870:	c3                   	ret    
+
+80100871 <consoleintr>:
+
+#define C(x)  ((x)-'@')  // Control-x
+
+void
+consoleintr(int (*getc)(void))
+{
+80100871:	f3 0f 1e fb          	endbr32 
+80100875:	55                   	push   %ebp
+80100876:	89 e5                	mov    %esp,%ebp
+80100878:	83 ec 18             	sub    $0x18,%esp
+  int c, doprocdump = 0;
+8010087b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+  acquire(&cons.lock);
+80100882:	83 ec 0c             	sub    $0xc,%esp
+80100885:	68 c0 c5 10 80       	push   $0x8010c5c0
+8010088a:	e8 ed 4e 00 00       	call   8010577c <acquire>
+8010088f:	83 c4 10             	add    $0x10,%esp
+  while((c = getc()) >= 0){
+80100892:	e9 52 01 00 00       	jmp    801009e9 <consoleintr+0x178>
+    switch(c){
+80100897:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
+8010089b:	0f 84 81 00 00 00    	je     80100922 <consoleintr+0xb1>
+801008a1:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
+801008a5:	0f 8f ac 00 00 00    	jg     80100957 <consoleintr+0xe6>
+801008ab:	83 7d f0 15          	cmpl   $0x15,-0x10(%ebp)
+801008af:	74 43                	je     801008f4 <consoleintr+0x83>
+801008b1:	83 7d f0 15          	cmpl   $0x15,-0x10(%ebp)
+801008b5:	0f 8f 9c 00 00 00    	jg     80100957 <consoleintr+0xe6>
+801008bb:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
+801008bf:	74 61                	je     80100922 <consoleintr+0xb1>
+801008c1:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
+801008c5:	0f 85 8c 00 00 00    	jne    80100957 <consoleintr+0xe6>
+    case C('P'):  // Process listing.
+      // procdump() locks cons.lock indirectly; invoke later
+      doprocdump = 1;
+801008cb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+      break;
+801008d2:	e9 12 01 00 00       	jmp    801009e9 <consoleintr+0x178>
+    case C('U'):  // Kill line.
+      while(input.e != input.w &&
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+        input.e--;
+801008d7:	a1 48 20 11 80       	mov    0x80112048,%eax
+801008dc:	83 e8 01             	sub    $0x1,%eax
+801008df:	a3 48 20 11 80       	mov    %eax,0x80112048
+        consputc(BACKSPACE);
+801008e4:	83 ec 0c             	sub    $0xc,%esp
+801008e7:	68 00 01 00 00       	push   $0x100
+801008ec:	e8 15 ff ff ff       	call   80100806 <consputc>
+801008f1:	83 c4 10             	add    $0x10,%esp
+      while(input.e != input.w &&
+801008f4:	8b 15 48 20 11 80    	mov    0x80112048,%edx
+801008fa:	a1 44 20 11 80       	mov    0x80112044,%eax
+801008ff:	39 c2                	cmp    %eax,%edx
+80100901:	0f 84 e2 00 00 00    	je     801009e9 <consoleintr+0x178>
+            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
+80100907:	a1 48 20 11 80       	mov    0x80112048,%eax
+8010090c:	83 e8 01             	sub    $0x1,%eax
+8010090f:	83 e0 7f             	and    $0x7f,%eax
+80100912:	0f b6 80 c0 1f 11 80 	movzbl -0x7feee040(%eax),%eax
+      while(input.e != input.w &&
+80100919:	3c 0a                	cmp    $0xa,%al
+8010091b:	75 ba                	jne    801008d7 <consoleintr+0x66>
+      }
+      break;
+8010091d:	e9 c7 00 00 00       	jmp    801009e9 <consoleintr+0x178>
+    case C('H'): case '\x7f':  // Backspace
+      if(input.e != input.w){
+80100922:	8b 15 48 20 11 80    	mov    0x80112048,%edx
+80100928:	a1 44 20 11 80       	mov    0x80112044,%eax
+8010092d:	39 c2                	cmp    %eax,%edx
+8010092f:	0f 84 b4 00 00 00    	je     801009e9 <consoleintr+0x178>
+        input.e--;
+80100935:	a1 48 20 11 80       	mov    0x80112048,%eax
+8010093a:	83 e8 01             	sub    $0x1,%eax
+8010093d:	a3 48 20 11 80       	mov    %eax,0x80112048
+        consputc(BACKSPACE);
+80100942:	83 ec 0c             	sub    $0xc,%esp
+80100945:	68 00 01 00 00       	push   $0x100
+8010094a:	e8 b7 fe ff ff       	call   80100806 <consputc>
+8010094f:	83 c4 10             	add    $0x10,%esp
+      }
+      break;
+80100952:	e9 92 00 00 00       	jmp    801009e9 <consoleintr+0x178>
+    default:
+      if(c != 0 && input.e-input.r < INPUT_BUF){
+80100957:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+8010095b:	0f 84 87 00 00 00    	je     801009e8 <consoleintr+0x177>
+80100961:	8b 15 48 20 11 80    	mov    0x80112048,%edx
+80100967:	a1 40 20 11 80       	mov    0x80112040,%eax
+8010096c:	29 c2                	sub    %eax,%edx
+8010096e:	89 d0                	mov    %edx,%eax
+80100970:	83 f8 7f             	cmp    $0x7f,%eax
+80100973:	77 73                	ja     801009e8 <consoleintr+0x177>
+        c = (c == '\r') ? '\n' : c;
+80100975:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+80100979:	74 05                	je     80100980 <consoleintr+0x10f>
+8010097b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010097e:	eb 05                	jmp    80100985 <consoleintr+0x114>
+80100980:	b8 0a 00 00 00       	mov    $0xa,%eax
+80100985:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        input.buf[input.e++ % INPUT_BUF] = c;
+80100988:	a1 48 20 11 80       	mov    0x80112048,%eax
+8010098d:	8d 50 01             	lea    0x1(%eax),%edx
+80100990:	89 15 48 20 11 80    	mov    %edx,0x80112048
+80100996:	83 e0 7f             	and    $0x7f,%eax
+80100999:	8b 55 f0             	mov    -0x10(%ebp),%edx
+8010099c:	88 90 c0 1f 11 80    	mov    %dl,-0x7feee040(%eax)
+        consputc(c);
+801009a2:	83 ec 0c             	sub    $0xc,%esp
+801009a5:	ff 75 f0             	pushl  -0x10(%ebp)
+801009a8:	e8 59 fe ff ff       	call   80100806 <consputc>
+801009ad:	83 c4 10             	add    $0x10,%esp
+        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
+801009b0:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+801009b4:	74 18                	je     801009ce <consoleintr+0x15d>
+801009b6:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+801009ba:	74 12                	je     801009ce <consoleintr+0x15d>
+801009bc:	a1 48 20 11 80       	mov    0x80112048,%eax
+801009c1:	8b 15 40 20 11 80    	mov    0x80112040,%edx
+801009c7:	83 ea 80             	sub    $0xffffff80,%edx
+801009ca:	39 d0                	cmp    %edx,%eax
+801009cc:	75 1a                	jne    801009e8 <consoleintr+0x177>
+          input.w = input.e;
+801009ce:	a1 48 20 11 80       	mov    0x80112048,%eax
+801009d3:	a3 44 20 11 80       	mov    %eax,0x80112044
+          wakeup(&input.r);
+801009d8:	83 ec 0c             	sub    $0xc,%esp
+801009db:	68 40 20 11 80       	push   $0x80112040
+801009e0:	e8 6b 48 00 00       	call   80105250 <wakeup>
+801009e5:	83 c4 10             	add    $0x10,%esp
+        }
+      }
+      break;
+801009e8:	90                   	nop
+  while((c = getc()) >= 0){
+801009e9:	8b 45 08             	mov    0x8(%ebp),%eax
+801009ec:	ff d0                	call   *%eax
+801009ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
+801009f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801009f5:	0f 89 9c fe ff ff    	jns    80100897 <consoleintr+0x26>
+    }
+  }
+  release(&cons.lock);
+801009fb:	83 ec 0c             	sub    $0xc,%esp
+801009fe:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100a03:	e8 e6 4d 00 00       	call   801057ee <release>
+80100a08:	83 c4 10             	add    $0x10,%esp
+  if(doprocdump) {
+80100a0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80100a0f:	74 05                	je     80100a16 <consoleintr+0x1a5>
+    procdump();  // now call procdump() wo. cons.lock held
+80100a11:	e8 00 49 00 00       	call   80105316 <procdump>
+  }
+}
+80100a16:	90                   	nop
+80100a17:	c9                   	leave  
+80100a18:	c3                   	ret    
+
+80100a19 <consoleread>:
+
+int
+consoleread(struct inode *ip, char *dst, int n)
+{
+80100a19:	f3 0f 1e fb          	endbr32 
+80100a1d:	55                   	push   %ebp
+80100a1e:	89 e5                	mov    %esp,%ebp
+80100a20:	83 ec 18             	sub    $0x18,%esp
+  uint target;
+  int c;
+
+  iunlock(ip);
+80100a23:	83 ec 0c             	sub    $0xc,%esp
+80100a26:	ff 75 08             	pushl  0x8(%ebp)
+80100a29:	e8 8b 11 00 00       	call   80101bb9 <iunlock>
+80100a2e:	83 c4 10             	add    $0x10,%esp
+  target = n;
+80100a31:	8b 45 10             	mov    0x10(%ebp),%eax
+80100a34:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  acquire(&cons.lock);
+80100a37:	83 ec 0c             	sub    $0xc,%esp
+80100a3a:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100a3f:	e8 38 4d 00 00       	call   8010577c <acquire>
+80100a44:	83 c4 10             	add    $0x10,%esp
+  while(n > 0){
+80100a47:	e9 ab 00 00 00       	jmp    80100af7 <consoleread+0xde>
+    while(input.r == input.w){
+      if(myproc()->killed){
+80100a4c:	e8 58 3b 00 00       	call   801045a9 <myproc>
+80100a51:	8b 40 34             	mov    0x34(%eax),%eax
+80100a54:	85 c0                	test   %eax,%eax
+80100a56:	74 28                	je     80100a80 <consoleread+0x67>
+        release(&cons.lock);
+80100a58:	83 ec 0c             	sub    $0xc,%esp
+80100a5b:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100a60:	e8 89 4d 00 00       	call   801057ee <release>
+80100a65:	83 c4 10             	add    $0x10,%esp
+        ilock(ip);
+80100a68:	83 ec 0c             	sub    $0xc,%esp
+80100a6b:	ff 75 08             	pushl  0x8(%ebp)
+80100a6e:	e8 2f 10 00 00       	call   80101aa2 <ilock>
+80100a73:	83 c4 10             	add    $0x10,%esp
+        return -1;
+80100a76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100a7b:	e9 ab 00 00 00       	jmp    80100b2b <consoleread+0x112>
+      }
+      sleep(&input.r, &cons.lock);
+80100a80:	83 ec 08             	sub    $0x8,%esp
+80100a83:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100a88:	68 40 20 11 80       	push   $0x80112040
+80100a8d:	e8 cc 46 00 00       	call   8010515e <sleep>
+80100a92:	83 c4 10             	add    $0x10,%esp
+    while(input.r == input.w){
+80100a95:	8b 15 40 20 11 80    	mov    0x80112040,%edx
+80100a9b:	a1 44 20 11 80       	mov    0x80112044,%eax
+80100aa0:	39 c2                	cmp    %eax,%edx
+80100aa2:	74 a8                	je     80100a4c <consoleread+0x33>
+    }
+    c = input.buf[input.r++ % INPUT_BUF];
+80100aa4:	a1 40 20 11 80       	mov    0x80112040,%eax
+80100aa9:	8d 50 01             	lea    0x1(%eax),%edx
+80100aac:	89 15 40 20 11 80    	mov    %edx,0x80112040
+80100ab2:	83 e0 7f             	and    $0x7f,%eax
+80100ab5:	0f b6 80 c0 1f 11 80 	movzbl -0x7feee040(%eax),%eax
+80100abc:	0f be c0             	movsbl %al,%eax
+80100abf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(c == C('D')){  // EOF
+80100ac2:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
+80100ac6:	75 17                	jne    80100adf <consoleread+0xc6>
+      if(n < target){
+80100ac8:	8b 45 10             	mov    0x10(%ebp),%eax
+80100acb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+80100ace:	76 2f                	jbe    80100aff <consoleread+0xe6>
+        // Save ^D for next time, to make sure
+        // caller gets a 0-byte result.
+        input.r--;
+80100ad0:	a1 40 20 11 80       	mov    0x80112040,%eax
+80100ad5:	83 e8 01             	sub    $0x1,%eax
+80100ad8:	a3 40 20 11 80       	mov    %eax,0x80112040
+      }
+      break;
+80100add:	eb 20                	jmp    80100aff <consoleread+0xe6>
+    }
+    *dst++ = c;
+80100adf:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100ae2:	8d 50 01             	lea    0x1(%eax),%edx
+80100ae5:	89 55 0c             	mov    %edx,0xc(%ebp)
+80100ae8:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80100aeb:	88 10                	mov    %dl,(%eax)
+    --n;
+80100aed:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+    if(c == '\n')
+80100af1:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+80100af5:	74 0b                	je     80100b02 <consoleread+0xe9>
+  while(n > 0){
+80100af7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80100afb:	7f 98                	jg     80100a95 <consoleread+0x7c>
+80100afd:	eb 04                	jmp    80100b03 <consoleread+0xea>
+      break;
+80100aff:	90                   	nop
+80100b00:	eb 01                	jmp    80100b03 <consoleread+0xea>
+      break;
+80100b02:	90                   	nop
+  }
+  release(&cons.lock);
+80100b03:	83 ec 0c             	sub    $0xc,%esp
+80100b06:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100b0b:	e8 de 4c 00 00       	call   801057ee <release>
+80100b10:	83 c4 10             	add    $0x10,%esp
+  ilock(ip);
+80100b13:	83 ec 0c             	sub    $0xc,%esp
+80100b16:	ff 75 08             	pushl  0x8(%ebp)
+80100b19:	e8 84 0f 00 00       	call   80101aa2 <ilock>
+80100b1e:	83 c4 10             	add    $0x10,%esp
+
+  return target - n;
+80100b21:	8b 45 10             	mov    0x10(%ebp),%eax
+80100b24:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80100b27:	29 c2                	sub    %eax,%edx
+80100b29:	89 d0                	mov    %edx,%eax
+}
+80100b2b:	c9                   	leave  
+80100b2c:	c3                   	ret    
+
+80100b2d <consolewrite>:
+
+int
+consolewrite(struct inode *ip, char *buf, int n)
+{
+80100b2d:	f3 0f 1e fb          	endbr32 
+80100b31:	55                   	push   %ebp
+80100b32:	89 e5                	mov    %esp,%ebp
+80100b34:	83 ec 18             	sub    $0x18,%esp
+  int i;
+
+  iunlock(ip);
+80100b37:	83 ec 0c             	sub    $0xc,%esp
+80100b3a:	ff 75 08             	pushl  0x8(%ebp)
+80100b3d:	e8 77 10 00 00       	call   80101bb9 <iunlock>
+80100b42:	83 c4 10             	add    $0x10,%esp
+  acquire(&cons.lock);
+80100b45:	83 ec 0c             	sub    $0xc,%esp
+80100b48:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100b4d:	e8 2a 4c 00 00       	call   8010577c <acquire>
+80100b52:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < n; i++)
+80100b55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80100b5c:	eb 21                	jmp    80100b7f <consolewrite+0x52>
+    consputc(buf[i] & 0xff);
+80100b5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80100b61:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100b64:	01 d0                	add    %edx,%eax
+80100b66:	0f b6 00             	movzbl (%eax),%eax
+80100b69:	0f be c0             	movsbl %al,%eax
+80100b6c:	0f b6 c0             	movzbl %al,%eax
+80100b6f:	83 ec 0c             	sub    $0xc,%esp
+80100b72:	50                   	push   %eax
+80100b73:	e8 8e fc ff ff       	call   80100806 <consputc>
+80100b78:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < n; i++)
+80100b7b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80100b7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100b82:	3b 45 10             	cmp    0x10(%ebp),%eax
+80100b85:	7c d7                	jl     80100b5e <consolewrite+0x31>
+  release(&cons.lock);
+80100b87:	83 ec 0c             	sub    $0xc,%esp
+80100b8a:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100b8f:	e8 5a 4c 00 00       	call   801057ee <release>
+80100b94:	83 c4 10             	add    $0x10,%esp
+  ilock(ip);
+80100b97:	83 ec 0c             	sub    $0xc,%esp
+80100b9a:	ff 75 08             	pushl  0x8(%ebp)
+80100b9d:	e8 00 0f 00 00       	call   80101aa2 <ilock>
+80100ba2:	83 c4 10             	add    $0x10,%esp
+
+  return n;
+80100ba5:	8b 45 10             	mov    0x10(%ebp),%eax
+}
+80100ba8:	c9                   	leave  
+80100ba9:	c3                   	ret    
+
+80100baa <consoleinit>:
+
+void
+consoleinit(void)
+{
+80100baa:	f3 0f 1e fb          	endbr32 
+80100bae:	55                   	push   %ebp
+80100baf:	89 e5                	mov    %esp,%ebp
+80100bb1:	83 ec 08             	sub    $0x8,%esp
+  initlock(&cons.lock, "console");
+80100bb4:	83 ec 08             	sub    $0x8,%esp
+80100bb7:	68 6a 8d 10 80       	push   $0x80108d6a
+80100bbc:	68 c0 c5 10 80       	push   $0x8010c5c0
+80100bc1:	e8 90 4b 00 00       	call   80105756 <initlock>
+80100bc6:	83 c4 10             	add    $0x10,%esp
+
+  devsw[CONSOLE].write = consolewrite;
+80100bc9:	c7 05 0c 2a 11 80 2d 	movl   $0x80100b2d,0x80112a0c
+80100bd0:	0b 10 80 
+  devsw[CONSOLE].read = consoleread;
+80100bd3:	c7 05 08 2a 11 80 19 	movl   $0x80100a19,0x80112a08
+80100bda:	0a 10 80 
+  cons.locking = 1;
+80100bdd:	c7 05 f4 c5 10 80 01 	movl   $0x1,0x8010c5f4
+80100be4:	00 00 00 
+
+  ioapicenable(IRQ_KBD, 0);
+80100be7:	83 ec 08             	sub    $0x8,%esp
+80100bea:	6a 00                	push   $0x0
+80100bec:	6a 01                	push   $0x1
+80100bee:	e8 19 20 00 00       	call   80102c0c <ioapicenable>
+80100bf3:	83 c4 10             	add    $0x10,%esp
+}
+80100bf6:	90                   	nop
+80100bf7:	c9                   	leave  
+80100bf8:	c3                   	ret    
+
+80100bf9 <exec>:
+#include "x86.h"
+#include "elf.h"
+
+int
+exec(char *path, char **argv)
+{
+80100bf9:	f3 0f 1e fb          	endbr32 
+80100bfd:	55                   	push   %ebp
+80100bfe:	89 e5                	mov    %esp,%ebp
+80100c00:	81 ec 18 01 00 00    	sub    $0x118,%esp
+  uint argc, sz, sp, ustack[3+MAXARG+1];
+  struct elfhdr elf;
+  struct inode *ip;
+  struct proghdr ph;
+  pde_t *pgdir, *oldpgdir;
+  struct proc *curproc = myproc();
+80100c06:	e8 9e 39 00 00       	call   801045a9 <myproc>
+80100c0b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+
+  begin_op();
+80100c0e:	e8 5e 2a 00 00       	call   80103671 <begin_op>
+
+  if((ip = namei(path)) == 0){
+80100c13:	83 ec 0c             	sub    $0xc,%esp
+80100c16:	ff 75 08             	pushl  0x8(%ebp)
+80100c19:	e8 ef 19 00 00       	call   8010260d <namei>
+80100c1e:	83 c4 10             	add    $0x10,%esp
+80100c21:	89 45 d8             	mov    %eax,-0x28(%ebp)
+80100c24:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+80100c28:	75 1f                	jne    80100c49 <exec+0x50>
+    end_op();
+80100c2a:	e8 d2 2a 00 00       	call   80103701 <end_op>
+    cprintf("exec: fail\n");
+80100c2f:	83 ec 0c             	sub    $0xc,%esp
+80100c32:	68 72 8d 10 80       	push   $0x80108d72
+80100c37:	e8 dc f7 ff ff       	call   80100418 <cprintf>
+80100c3c:	83 c4 10             	add    $0x10,%esp
+    return -1;
+80100c3f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80100c44:	e9 ef 03 00 00       	jmp    80101038 <exec+0x43f>
+  }
+  ilock(ip);
+80100c49:	83 ec 0c             	sub    $0xc,%esp
+80100c4c:	ff 75 d8             	pushl  -0x28(%ebp)
+80100c4f:	e8 4e 0e 00 00       	call   80101aa2 <ilock>
+80100c54:	83 c4 10             	add    $0x10,%esp
+  pgdir = 0;
+80100c57:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+
+  // Check ELF header
+  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
+80100c5e:	6a 34                	push   $0x34
+80100c60:	6a 00                	push   $0x0
+80100c62:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
+80100c68:	50                   	push   %eax
+80100c69:	ff 75 d8             	pushl  -0x28(%ebp)
+80100c6c:	e8 39 13 00 00       	call   80101faa <readi>
+80100c71:	83 c4 10             	add    $0x10,%esp
+80100c74:	83 f8 34             	cmp    $0x34,%eax
+80100c77:	0f 85 64 03 00 00    	jne    80100fe1 <exec+0x3e8>
+    goto bad;
+  if(elf.magic != ELF_MAGIC)
+80100c7d:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
+80100c83:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
+80100c88:	0f 85 56 03 00 00    	jne    80100fe4 <exec+0x3eb>
+    goto bad;
+
+  if((pgdir = setupkvm()) == 0)
+80100c8e:	e8 e6 77 00 00       	call   80108479 <setupkvm>
+80100c93:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+80100c96:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
+80100c9a:	0f 84 47 03 00 00    	je     80100fe7 <exec+0x3ee>
+    goto bad;
+
+  // Load program into memory.
+  sz = 0;
+80100ca0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100ca7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+80100cae:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
+80100cb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
+80100cb7:	e9 de 00 00 00       	jmp    80100d9a <exec+0x1a1>
+    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
+80100cbc:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80100cbf:	6a 20                	push   $0x20
+80100cc1:	50                   	push   %eax
+80100cc2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
+80100cc8:	50                   	push   %eax
+80100cc9:	ff 75 d8             	pushl  -0x28(%ebp)
+80100ccc:	e8 d9 12 00 00       	call   80101faa <readi>
+80100cd1:	83 c4 10             	add    $0x10,%esp
+80100cd4:	83 f8 20             	cmp    $0x20,%eax
+80100cd7:	0f 85 0d 03 00 00    	jne    80100fea <exec+0x3f1>
+      goto bad;
+    if(ph.type != ELF_PROG_LOAD)
+80100cdd:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
+80100ce3:	83 f8 01             	cmp    $0x1,%eax
+80100ce6:	0f 85 a0 00 00 00    	jne    80100d8c <exec+0x193>
+      continue;
+    if(ph.memsz < ph.filesz)
+80100cec:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
+80100cf2:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
+80100cf8:	39 c2                	cmp    %eax,%edx
+80100cfa:	0f 82 ed 02 00 00    	jb     80100fed <exec+0x3f4>
+      goto bad;
+    if(ph.vaddr + ph.memsz < ph.vaddr)
+80100d00:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
+80100d06:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
+80100d0c:	01 c2                	add    %eax,%edx
+80100d0e:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100d14:	39 c2                	cmp    %eax,%edx
+80100d16:	0f 82 d4 02 00 00    	jb     80100ff0 <exec+0x3f7>
+      goto bad;
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+80100d1c:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
+80100d22:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
+80100d28:	01 d0                	add    %edx,%eax
+80100d2a:	83 ec 04             	sub    $0x4,%esp
+80100d2d:	50                   	push   %eax
+80100d2e:	ff 75 e0             	pushl  -0x20(%ebp)
+80100d31:	ff 75 d4             	pushl  -0x2c(%ebp)
+80100d34:	e8 fe 7a 00 00       	call   80108837 <allocuvm>
+80100d39:	83 c4 10             	add    $0x10,%esp
+80100d3c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80100d3f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+80100d43:	0f 84 aa 02 00 00    	je     80100ff3 <exec+0x3fa>
+      goto bad;
+    if(ph.vaddr % PGSIZE != 0)
+80100d49:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
+80100d4f:	25 ff 0f 00 00       	and    $0xfff,%eax
+80100d54:	85 c0                	test   %eax,%eax
+80100d56:	0f 85 9a 02 00 00    	jne    80100ff6 <exec+0x3fd>
+      goto bad;
+    if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+80100d5c:	8b 95 f8 fe ff ff    	mov    -0x108(%ebp),%edx
+80100d62:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
+80100d68:	8b 8d f0 fe ff ff    	mov    -0x110(%ebp),%ecx
+80100d6e:	83 ec 0c             	sub    $0xc,%esp
+80100d71:	52                   	push   %edx
+80100d72:	50                   	push   %eax
+80100d73:	ff 75 d8             	pushl  -0x28(%ebp)
+80100d76:	51                   	push   %ecx
+80100d77:	ff 75 d4             	pushl  -0x2c(%ebp)
+80100d7a:	e8 e7 79 00 00       	call   80108766 <loaduvm>
+80100d7f:	83 c4 20             	add    $0x20,%esp
+80100d82:	85 c0                	test   %eax,%eax
+80100d84:	0f 88 6f 02 00 00    	js     80100ff9 <exec+0x400>
+80100d8a:	eb 01                	jmp    80100d8d <exec+0x194>
+      continue;
+80100d8c:	90                   	nop
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+80100d8d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+80100d91:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80100d94:	83 c0 20             	add    $0x20,%eax
+80100d97:	89 45 e8             	mov    %eax,-0x18(%ebp)
+80100d9a:	0f b7 85 34 ff ff ff 	movzwl -0xcc(%ebp),%eax
+80100da1:	0f b7 c0             	movzwl %ax,%eax
+80100da4:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+80100da7:	0f 8c 0f ff ff ff    	jl     80100cbc <exec+0xc3>
+      goto bad;
+  }
+  iunlockput(ip);
+80100dad:	83 ec 0c             	sub    $0xc,%esp
+80100db0:	ff 75 d8             	pushl  -0x28(%ebp)
+80100db3:	e8 27 0f 00 00       	call   80101cdf <iunlockput>
+80100db8:	83 c4 10             	add    $0x10,%esp
+  end_op();
+80100dbb:	e8 41 29 00 00       	call   80103701 <end_op>
+  ip = 0;
+80100dc0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
+
+  // Allocate two pages at the next page boundary.
+  // Make the first inaccessible.  Use the second as the user stack.
+  sz = PGROUNDUP(sz);
+80100dc7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100dca:	05 ff 0f 00 00       	add    $0xfff,%eax
+80100dcf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80100dd4:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+80100dd7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100dda:	05 00 20 00 00       	add    $0x2000,%eax
+80100ddf:	83 ec 04             	sub    $0x4,%esp
+80100de2:	50                   	push   %eax
+80100de3:	ff 75 e0             	pushl  -0x20(%ebp)
+80100de6:	ff 75 d4             	pushl  -0x2c(%ebp)
+80100de9:	e8 49 7a 00 00       	call   80108837 <allocuvm>
+80100dee:	83 c4 10             	add    $0x10,%esp
+80100df1:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80100df4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+80100df8:	0f 84 fe 01 00 00    	je     80100ffc <exec+0x403>
+    goto bad;
+  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
+80100dfe:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100e01:	2d 00 20 00 00       	sub    $0x2000,%eax
+80100e06:	83 ec 08             	sub    $0x8,%esp
+80100e09:	50                   	push   %eax
+80100e0a:	ff 75 d4             	pushl  -0x2c(%ebp)
+80100e0d:	e8 93 7c 00 00       	call   80108aa5 <clearpteu>
+80100e12:	83 c4 10             	add    $0x10,%esp
+  sp = sz;
+80100e15:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80100e18:	89 45 dc             	mov    %eax,-0x24(%ebp)
+
+  // Push argument strings, prepare rest of stack in ustack.
+  for(argc = 0; argv[argc]; argc++) {
+80100e1b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+80100e22:	e9 96 00 00 00       	jmp    80100ebd <exec+0x2c4>
+    if(argc >= MAXARG)
+80100e27:	83 7d e4 1f          	cmpl   $0x1f,-0x1c(%ebp)
+80100e2b:	0f 87 ce 01 00 00    	ja     80100fff <exec+0x406>
+      goto bad;
+    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
+80100e31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100e34:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100e3b:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100e3e:	01 d0                	add    %edx,%eax
+80100e40:	8b 00                	mov    (%eax),%eax
+80100e42:	83 ec 0c             	sub    $0xc,%esp
+80100e45:	50                   	push   %eax
+80100e46:	e8 39 4e 00 00       	call   80105c84 <strlen>
+80100e4b:	83 c4 10             	add    $0x10,%esp
+80100e4e:	89 c2                	mov    %eax,%edx
+80100e50:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80100e53:	29 d0                	sub    %edx,%eax
+80100e55:	83 e8 01             	sub    $0x1,%eax
+80100e58:	83 e0 fc             	and    $0xfffffffc,%eax
+80100e5b:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+80100e5e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100e61:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100e68:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100e6b:	01 d0                	add    %edx,%eax
+80100e6d:	8b 00                	mov    (%eax),%eax
+80100e6f:	83 ec 0c             	sub    $0xc,%esp
+80100e72:	50                   	push   %eax
+80100e73:	e8 0c 4e 00 00       	call   80105c84 <strlen>
+80100e78:	83 c4 10             	add    $0x10,%esp
+80100e7b:	83 c0 01             	add    $0x1,%eax
+80100e7e:	89 c1                	mov    %eax,%ecx
+80100e80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100e83:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100e8a:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100e8d:	01 d0                	add    %edx,%eax
+80100e8f:	8b 00                	mov    (%eax),%eax
+80100e91:	51                   	push   %ecx
+80100e92:	50                   	push   %eax
+80100e93:	ff 75 dc             	pushl  -0x24(%ebp)
+80100e96:	ff 75 d4             	pushl  -0x2c(%ebp)
+80100e99:	e8 bf 7d 00 00       	call   80108c5d <copyout>
+80100e9e:	83 c4 10             	add    $0x10,%esp
+80100ea1:	85 c0                	test   %eax,%eax
+80100ea3:	0f 88 59 01 00 00    	js     80101002 <exec+0x409>
+      goto bad;
+    ustack[3+argc] = sp;
+80100ea9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100eac:	8d 50 03             	lea    0x3(%eax),%edx
+80100eaf:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80100eb2:	89 84 95 3c ff ff ff 	mov    %eax,-0xc4(%ebp,%edx,4)
+  for(argc = 0; argv[argc]; argc++) {
+80100eb9:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
+80100ebd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100ec0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
+80100eca:	01 d0                	add    %edx,%eax
+80100ecc:	8b 00                	mov    (%eax),%eax
+80100ece:	85 c0                	test   %eax,%eax
+80100ed0:	0f 85 51 ff ff ff    	jne    80100e27 <exec+0x22e>
+  }
+  ustack[3+argc] = 0;
+80100ed6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100ed9:	83 c0 03             	add    $0x3,%eax
+80100edc:	c7 84 85 3c ff ff ff 	movl   $0x0,-0xc4(%ebp,%eax,4)
+80100ee3:	00 00 00 00 
+
+  ustack[0] = 0xffffffff;  // fake return PC
+80100ee7:	c7 85 3c ff ff ff ff 	movl   $0xffffffff,-0xc4(%ebp)
+80100eee:	ff ff ff 
+  ustack[1] = argc;
+80100ef1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100ef4:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
+  ustack[2] = sp - (argc+1)*4;  // argv pointer
+80100efa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100efd:	83 c0 01             	add    $0x1,%eax
+80100f00:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80100f07:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80100f0a:	29 d0                	sub    %edx,%eax
+80100f0c:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
+
+  sp -= (3+argc+1) * 4;
+80100f12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100f15:	83 c0 04             	add    $0x4,%eax
+80100f18:	c1 e0 02             	shl    $0x2,%eax
+80100f1b:	29 45 dc             	sub    %eax,-0x24(%ebp)
+  if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
+80100f1e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80100f21:	83 c0 04             	add    $0x4,%eax
+80100f24:	c1 e0 02             	shl    $0x2,%eax
+80100f27:	50                   	push   %eax
+80100f28:	8d 85 3c ff ff ff    	lea    -0xc4(%ebp),%eax
+80100f2e:	50                   	push   %eax
+80100f2f:	ff 75 dc             	pushl  -0x24(%ebp)
+80100f32:	ff 75 d4             	pushl  -0x2c(%ebp)
+80100f35:	e8 23 7d 00 00       	call   80108c5d <copyout>
+80100f3a:	83 c4 10             	add    $0x10,%esp
+80100f3d:	85 c0                	test   %eax,%eax
+80100f3f:	0f 88 c0 00 00 00    	js     80101005 <exec+0x40c>
+    goto bad;
+
+  // Save program name for debugging.
+  for(last=s=path; *s; s++)
+80100f45:	8b 45 08             	mov    0x8(%ebp),%eax
+80100f48:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80100f4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100f4e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80100f51:	eb 17                	jmp    80100f6a <exec+0x371>
+    if(*s == '/')
+80100f53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100f56:	0f b6 00             	movzbl (%eax),%eax
+80100f59:	3c 2f                	cmp    $0x2f,%al
+80100f5b:	75 09                	jne    80100f66 <exec+0x36d>
+      last = s+1;
+80100f5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100f60:	83 c0 01             	add    $0x1,%eax
+80100f63:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(last=s=path; *s; s++)
+80100f66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80100f6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80100f6d:	0f b6 00             	movzbl (%eax),%eax
+80100f70:	84 c0                	test   %al,%al
+80100f72:	75 df                	jne    80100f53 <exec+0x35a>
+  safestrcpy(curproc->name, last, sizeof(curproc->name));
+80100f74:	8b 45 d0             	mov    -0x30(%ebp),%eax
+80100f77:	83 ec 04             	sub    $0x4,%esp
+80100f7a:	6a 10                	push   $0x10
+80100f7c:	ff 75 f0             	pushl  -0x10(%ebp)
+80100f7f:	50                   	push   %eax
+80100f80:	e8 b1 4c 00 00       	call   80105c36 <safestrcpy>
+80100f85:	83 c4 10             	add    $0x10,%esp
+
+  // Commit to the user image.
+  oldpgdir = curproc->pgdir;
+80100f88:	8b 45 d0             	mov    -0x30(%ebp),%eax
+80100f8b:	8b 40 18             	mov    0x18(%eax),%eax
+80100f8e:	89 45 cc             	mov    %eax,-0x34(%ebp)
+  curproc->pgdir = pgdir;
+80100f91:	8b 45 d0             	mov    -0x30(%ebp),%eax
+80100f94:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+80100f97:	89 50 18             	mov    %edx,0x18(%eax)
+  curproc->sz = sz;
+80100f9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
+80100f9d:	8b 55 e0             	mov    -0x20(%ebp),%edx
+80100fa0:	89 50 14             	mov    %edx,0x14(%eax)
+  curproc->tf->eip = elf.entry;  // main
+80100fa3:	8b 45 d0             	mov    -0x30(%ebp),%eax
+80100fa6:	8b 40 28             	mov    0x28(%eax),%eax
+80100fa9:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
+80100faf:	89 50 38             	mov    %edx,0x38(%eax)
+  curproc->tf->esp = sp;
+80100fb2:	8b 45 d0             	mov    -0x30(%ebp),%eax
+80100fb5:	8b 40 28             	mov    0x28(%eax),%eax
+80100fb8:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80100fbb:	89 50 44             	mov    %edx,0x44(%eax)
+  // exec function has change 
+  #ifdef DML
+  proc->priority = 2;
+  #endif
+  switchuvm(curproc);
+80100fbe:	83 ec 0c             	sub    $0xc,%esp
+80100fc1:	ff 75 d0             	pushl  -0x30(%ebp)
+80100fc4:	e8 86 75 00 00       	call   8010854f <switchuvm>
+80100fc9:	83 c4 10             	add    $0x10,%esp
+  freevm(oldpgdir);
+80100fcc:	83 ec 0c             	sub    $0xc,%esp
+80100fcf:	ff 75 cc             	pushl  -0x34(%ebp)
+80100fd2:	e8 31 7a 00 00       	call   80108a08 <freevm>
+80100fd7:	83 c4 10             	add    $0x10,%esp
+  return 0;
+80100fda:	b8 00 00 00 00       	mov    $0x0,%eax
+80100fdf:	eb 57                	jmp    80101038 <exec+0x43f>
+    goto bad;
+80100fe1:	90                   	nop
+80100fe2:	eb 22                	jmp    80101006 <exec+0x40d>
+    goto bad;
+80100fe4:	90                   	nop
+80100fe5:	eb 1f                	jmp    80101006 <exec+0x40d>
+    goto bad;
+80100fe7:	90                   	nop
+80100fe8:	eb 1c                	jmp    80101006 <exec+0x40d>
+      goto bad;
+80100fea:	90                   	nop
+80100feb:	eb 19                	jmp    80101006 <exec+0x40d>
+      goto bad;
+80100fed:	90                   	nop
+80100fee:	eb 16                	jmp    80101006 <exec+0x40d>
+      goto bad;
+80100ff0:	90                   	nop
+80100ff1:	eb 13                	jmp    80101006 <exec+0x40d>
+      goto bad;
+80100ff3:	90                   	nop
+80100ff4:	eb 10                	jmp    80101006 <exec+0x40d>
+      goto bad;
+80100ff6:	90                   	nop
+80100ff7:	eb 0d                	jmp    80101006 <exec+0x40d>
+      goto bad;
+80100ff9:	90                   	nop
+80100ffa:	eb 0a                	jmp    80101006 <exec+0x40d>
+    goto bad;
+80100ffc:	90                   	nop
+80100ffd:	eb 07                	jmp    80101006 <exec+0x40d>
+      goto bad;
+80100fff:	90                   	nop
+80101000:	eb 04                	jmp    80101006 <exec+0x40d>
+      goto bad;
+80101002:	90                   	nop
+80101003:	eb 01                	jmp    80101006 <exec+0x40d>
+    goto bad;
+80101005:	90                   	nop
+
+ bad:
+  if(pgdir)
+80101006:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
+8010100a:	74 0e                	je     8010101a <exec+0x421>
+    freevm(pgdir);
+8010100c:	83 ec 0c             	sub    $0xc,%esp
+8010100f:	ff 75 d4             	pushl  -0x2c(%ebp)
+80101012:	e8 f1 79 00 00       	call   80108a08 <freevm>
+80101017:	83 c4 10             	add    $0x10,%esp
+  if(ip){
+8010101a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+8010101e:	74 13                	je     80101033 <exec+0x43a>
+    iunlockput(ip);
+80101020:	83 ec 0c             	sub    $0xc,%esp
+80101023:	ff 75 d8             	pushl  -0x28(%ebp)
+80101026:	e8 b4 0c 00 00       	call   80101cdf <iunlockput>
+8010102b:	83 c4 10             	add    $0x10,%esp
+    end_op();
+8010102e:	e8 ce 26 00 00       	call   80103701 <end_op>
+  }
+  return -1;
+80101033:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80101038:	c9                   	leave  
+80101039:	c3                   	ret    
+
+8010103a <fileinit>:
+  struct file file[NFILE];
+} ftable;
+
+void
+fileinit(void)
+{
+8010103a:	f3 0f 1e fb          	endbr32 
+8010103e:	55                   	push   %ebp
+8010103f:	89 e5                	mov    %esp,%ebp
+80101041:	83 ec 08             	sub    $0x8,%esp
+  initlock(&ftable.lock, "ftable");
+80101044:	83 ec 08             	sub    $0x8,%esp
+80101047:	68 7e 8d 10 80       	push   $0x80108d7e
+8010104c:	68 60 20 11 80       	push   $0x80112060
+80101051:	e8 00 47 00 00       	call   80105756 <initlock>
+80101056:	83 c4 10             	add    $0x10,%esp
+}
+80101059:	90                   	nop
+8010105a:	c9                   	leave  
+8010105b:	c3                   	ret    
+
+8010105c <filealloc>:
+
+// Allocate a file structure.
+struct file*
+filealloc(void)
+{
+8010105c:	f3 0f 1e fb          	endbr32 
+80101060:	55                   	push   %ebp
+80101061:	89 e5                	mov    %esp,%ebp
+80101063:	83 ec 18             	sub    $0x18,%esp
+  struct file *f;
+
+  acquire(&ftable.lock);
+80101066:	83 ec 0c             	sub    $0xc,%esp
+80101069:	68 60 20 11 80       	push   $0x80112060
+8010106e:	e8 09 47 00 00       	call   8010577c <acquire>
+80101073:	83 c4 10             	add    $0x10,%esp
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+80101076:	c7 45 f4 94 20 11 80 	movl   $0x80112094,-0xc(%ebp)
+8010107d:	eb 2d                	jmp    801010ac <filealloc+0x50>
+    if(f->ref == 0){
+8010107f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101082:	8b 40 04             	mov    0x4(%eax),%eax
+80101085:	85 c0                	test   %eax,%eax
+80101087:	75 1f                	jne    801010a8 <filealloc+0x4c>
+      f->ref = 1;
+80101089:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010108c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
+      release(&ftable.lock);
+80101093:	83 ec 0c             	sub    $0xc,%esp
+80101096:	68 60 20 11 80       	push   $0x80112060
+8010109b:	e8 4e 47 00 00       	call   801057ee <release>
+801010a0:	83 c4 10             	add    $0x10,%esp
+      return f;
+801010a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801010a6:	eb 23                	jmp    801010cb <filealloc+0x6f>
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+801010a8:	83 45 f4 18          	addl   $0x18,-0xc(%ebp)
+801010ac:	b8 f4 29 11 80       	mov    $0x801129f4,%eax
+801010b1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+801010b4:	72 c9                	jb     8010107f <filealloc+0x23>
+    }
+  }
+  release(&ftable.lock);
+801010b6:	83 ec 0c             	sub    $0xc,%esp
+801010b9:	68 60 20 11 80       	push   $0x80112060
+801010be:	e8 2b 47 00 00       	call   801057ee <release>
+801010c3:	83 c4 10             	add    $0x10,%esp
+  return 0;
+801010c6:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+801010cb:	c9                   	leave  
+801010cc:	c3                   	ret    
+
+801010cd <filedup>:
+
+// Increment ref count for file f.
+struct file*
+filedup(struct file *f)
+{
+801010cd:	f3 0f 1e fb          	endbr32 
+801010d1:	55                   	push   %ebp
+801010d2:	89 e5                	mov    %esp,%ebp
+801010d4:	83 ec 08             	sub    $0x8,%esp
+  acquire(&ftable.lock);
+801010d7:	83 ec 0c             	sub    $0xc,%esp
+801010da:	68 60 20 11 80       	push   $0x80112060
+801010df:	e8 98 46 00 00       	call   8010577c <acquire>
+801010e4:	83 c4 10             	add    $0x10,%esp
+  if(f->ref < 1)
+801010e7:	8b 45 08             	mov    0x8(%ebp),%eax
+801010ea:	8b 40 04             	mov    0x4(%eax),%eax
+801010ed:	85 c0                	test   %eax,%eax
+801010ef:	7f 0d                	jg     801010fe <filedup+0x31>
+    panic("filedup");
+801010f1:	83 ec 0c             	sub    $0xc,%esp
+801010f4:	68 85 8d 10 80       	push   $0x80108d85
+801010f9:	e8 d3 f4 ff ff       	call   801005d1 <panic>
+  f->ref++;
+801010fe:	8b 45 08             	mov    0x8(%ebp),%eax
+80101101:	8b 40 04             	mov    0x4(%eax),%eax
+80101104:	8d 50 01             	lea    0x1(%eax),%edx
+80101107:	8b 45 08             	mov    0x8(%ebp),%eax
+8010110a:	89 50 04             	mov    %edx,0x4(%eax)
+  release(&ftable.lock);
+8010110d:	83 ec 0c             	sub    $0xc,%esp
+80101110:	68 60 20 11 80       	push   $0x80112060
+80101115:	e8 d4 46 00 00       	call   801057ee <release>
+8010111a:	83 c4 10             	add    $0x10,%esp
+  return f;
+8010111d:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+80101120:	c9                   	leave  
+80101121:	c3                   	ret    
+
+80101122 <fileclose>:
+
+// Close file f.  (Decrement ref count, close when reaches 0.)
+void
+fileclose(struct file *f)
+{
+80101122:	f3 0f 1e fb          	endbr32 
+80101126:	55                   	push   %ebp
+80101127:	89 e5                	mov    %esp,%ebp
+80101129:	83 ec 28             	sub    $0x28,%esp
+  struct file ff;
+
+  acquire(&ftable.lock);
+8010112c:	83 ec 0c             	sub    $0xc,%esp
+8010112f:	68 60 20 11 80       	push   $0x80112060
+80101134:	e8 43 46 00 00       	call   8010577c <acquire>
+80101139:	83 c4 10             	add    $0x10,%esp
+  if(f->ref < 1)
+8010113c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010113f:	8b 40 04             	mov    0x4(%eax),%eax
+80101142:	85 c0                	test   %eax,%eax
+80101144:	7f 0d                	jg     80101153 <fileclose+0x31>
+    panic("fileclose");
+80101146:	83 ec 0c             	sub    $0xc,%esp
+80101149:	68 8d 8d 10 80       	push   $0x80108d8d
+8010114e:	e8 7e f4 ff ff       	call   801005d1 <panic>
+  if(--f->ref > 0){
+80101153:	8b 45 08             	mov    0x8(%ebp),%eax
+80101156:	8b 40 04             	mov    0x4(%eax),%eax
+80101159:	8d 50 ff             	lea    -0x1(%eax),%edx
+8010115c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010115f:	89 50 04             	mov    %edx,0x4(%eax)
+80101162:	8b 45 08             	mov    0x8(%ebp),%eax
+80101165:	8b 40 04             	mov    0x4(%eax),%eax
+80101168:	85 c0                	test   %eax,%eax
+8010116a:	7e 15                	jle    80101181 <fileclose+0x5f>
+    release(&ftable.lock);
+8010116c:	83 ec 0c             	sub    $0xc,%esp
+8010116f:	68 60 20 11 80       	push   $0x80112060
+80101174:	e8 75 46 00 00       	call   801057ee <release>
+80101179:	83 c4 10             	add    $0x10,%esp
+8010117c:	e9 8b 00 00 00       	jmp    8010120c <fileclose+0xea>
+    return;
+  }
+  ff = *f;
+80101181:	8b 45 08             	mov    0x8(%ebp),%eax
+80101184:	8b 10                	mov    (%eax),%edx
+80101186:	89 55 e0             	mov    %edx,-0x20(%ebp)
+80101189:	8b 50 04             	mov    0x4(%eax),%edx
+8010118c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+8010118f:	8b 50 08             	mov    0x8(%eax),%edx
+80101192:	89 55 e8             	mov    %edx,-0x18(%ebp)
+80101195:	8b 50 0c             	mov    0xc(%eax),%edx
+80101198:	89 55 ec             	mov    %edx,-0x14(%ebp)
+8010119b:	8b 50 10             	mov    0x10(%eax),%edx
+8010119e:	89 55 f0             	mov    %edx,-0x10(%ebp)
+801011a1:	8b 40 14             	mov    0x14(%eax),%eax
+801011a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  f->ref = 0;
+801011a7:	8b 45 08             	mov    0x8(%ebp),%eax
+801011aa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+  f->type = FD_NONE;
+801011b1:	8b 45 08             	mov    0x8(%ebp),%eax
+801011b4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  release(&ftable.lock);
+801011ba:	83 ec 0c             	sub    $0xc,%esp
+801011bd:	68 60 20 11 80       	push   $0x80112060
+801011c2:	e8 27 46 00 00       	call   801057ee <release>
+801011c7:	83 c4 10             	add    $0x10,%esp
+
+  if(ff.type == FD_PIPE)
+801011ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801011cd:	83 f8 01             	cmp    $0x1,%eax
+801011d0:	75 19                	jne    801011eb <fileclose+0xc9>
+    pipeclose(ff.pipe, ff.writable);
+801011d2:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+801011d6:	0f be d0             	movsbl %al,%edx
+801011d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801011dc:	83 ec 08             	sub    $0x8,%esp
+801011df:	52                   	push   %edx
+801011e0:	50                   	push   %eax
+801011e1:	e8 c1 2e 00 00       	call   801040a7 <pipeclose>
+801011e6:	83 c4 10             	add    $0x10,%esp
+801011e9:	eb 21                	jmp    8010120c <fileclose+0xea>
+  else if(ff.type == FD_INODE){
+801011eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801011ee:	83 f8 02             	cmp    $0x2,%eax
+801011f1:	75 19                	jne    8010120c <fileclose+0xea>
+    begin_op();
+801011f3:	e8 79 24 00 00       	call   80103671 <begin_op>
+    iput(ff.ip);
+801011f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801011fb:	83 ec 0c             	sub    $0xc,%esp
+801011fe:	50                   	push   %eax
+801011ff:	e8 07 0a 00 00       	call   80101c0b <iput>
+80101204:	83 c4 10             	add    $0x10,%esp
+    end_op();
+80101207:	e8 f5 24 00 00       	call   80103701 <end_op>
+  }
+}
+8010120c:	c9                   	leave  
+8010120d:	c3                   	ret    
+
+8010120e <filestat>:
+
+// Get metadata about file f.
+int
+filestat(struct file *f, struct stat *st)
+{
+8010120e:	f3 0f 1e fb          	endbr32 
+80101212:	55                   	push   %ebp
+80101213:	89 e5                	mov    %esp,%ebp
+80101215:	83 ec 08             	sub    $0x8,%esp
+  if(f->type == FD_INODE){
+80101218:	8b 45 08             	mov    0x8(%ebp),%eax
+8010121b:	8b 00                	mov    (%eax),%eax
+8010121d:	83 f8 02             	cmp    $0x2,%eax
+80101220:	75 40                	jne    80101262 <filestat+0x54>
+    ilock(f->ip);
+80101222:	8b 45 08             	mov    0x8(%ebp),%eax
+80101225:	8b 40 10             	mov    0x10(%eax),%eax
+80101228:	83 ec 0c             	sub    $0xc,%esp
+8010122b:	50                   	push   %eax
+8010122c:	e8 71 08 00 00       	call   80101aa2 <ilock>
+80101231:	83 c4 10             	add    $0x10,%esp
+    stati(f->ip, st);
+80101234:	8b 45 08             	mov    0x8(%ebp),%eax
+80101237:	8b 40 10             	mov    0x10(%eax),%eax
+8010123a:	83 ec 08             	sub    $0x8,%esp
+8010123d:	ff 75 0c             	pushl  0xc(%ebp)
+80101240:	50                   	push   %eax
+80101241:	e8 1a 0d 00 00       	call   80101f60 <stati>
+80101246:	83 c4 10             	add    $0x10,%esp
+    iunlock(f->ip);
+80101249:	8b 45 08             	mov    0x8(%ebp),%eax
+8010124c:	8b 40 10             	mov    0x10(%eax),%eax
+8010124f:	83 ec 0c             	sub    $0xc,%esp
+80101252:	50                   	push   %eax
+80101253:	e8 61 09 00 00       	call   80101bb9 <iunlock>
+80101258:	83 c4 10             	add    $0x10,%esp
+    return 0;
+8010125b:	b8 00 00 00 00       	mov    $0x0,%eax
+80101260:	eb 05                	jmp    80101267 <filestat+0x59>
+  }
+  return -1;
+80101262:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80101267:	c9                   	leave  
+80101268:	c3                   	ret    
+
+80101269 <fileread>:
+
+// Read from file f.
+int
+fileread(struct file *f, char *addr, int n)
+{
+80101269:	f3 0f 1e fb          	endbr32 
+8010126d:	55                   	push   %ebp
+8010126e:	89 e5                	mov    %esp,%ebp
+80101270:	83 ec 18             	sub    $0x18,%esp
+  int r;
+
+  if(f->readable == 0)
+80101273:	8b 45 08             	mov    0x8(%ebp),%eax
+80101276:	0f b6 40 08          	movzbl 0x8(%eax),%eax
+8010127a:	84 c0                	test   %al,%al
+8010127c:	75 0a                	jne    80101288 <fileread+0x1f>
+    return -1;
+8010127e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101283:	e9 9b 00 00 00       	jmp    80101323 <fileread+0xba>
+  if(f->type == FD_PIPE)
+80101288:	8b 45 08             	mov    0x8(%ebp),%eax
+8010128b:	8b 00                	mov    (%eax),%eax
+8010128d:	83 f8 01             	cmp    $0x1,%eax
+80101290:	75 1a                	jne    801012ac <fileread+0x43>
+    return piperead(f->pipe, addr, n);
+80101292:	8b 45 08             	mov    0x8(%ebp),%eax
+80101295:	8b 40 0c             	mov    0xc(%eax),%eax
+80101298:	83 ec 04             	sub    $0x4,%esp
+8010129b:	ff 75 10             	pushl  0x10(%ebp)
+8010129e:	ff 75 0c             	pushl  0xc(%ebp)
+801012a1:	50                   	push   %eax
+801012a2:	e8 b5 2f 00 00       	call   8010425c <piperead>
+801012a7:	83 c4 10             	add    $0x10,%esp
+801012aa:	eb 77                	jmp    80101323 <fileread+0xba>
+  if(f->type == FD_INODE){
+801012ac:	8b 45 08             	mov    0x8(%ebp),%eax
+801012af:	8b 00                	mov    (%eax),%eax
+801012b1:	83 f8 02             	cmp    $0x2,%eax
+801012b4:	75 60                	jne    80101316 <fileread+0xad>
+    ilock(f->ip);
+801012b6:	8b 45 08             	mov    0x8(%ebp),%eax
+801012b9:	8b 40 10             	mov    0x10(%eax),%eax
+801012bc:	83 ec 0c             	sub    $0xc,%esp
+801012bf:	50                   	push   %eax
+801012c0:	e8 dd 07 00 00       	call   80101aa2 <ilock>
+801012c5:	83 c4 10             	add    $0x10,%esp
+    if((r = readi(f->ip, addr, f->off, n)) > 0)
+801012c8:	8b 4d 10             	mov    0x10(%ebp),%ecx
+801012cb:	8b 45 08             	mov    0x8(%ebp),%eax
+801012ce:	8b 50 14             	mov    0x14(%eax),%edx
+801012d1:	8b 45 08             	mov    0x8(%ebp),%eax
+801012d4:	8b 40 10             	mov    0x10(%eax),%eax
+801012d7:	51                   	push   %ecx
+801012d8:	52                   	push   %edx
+801012d9:	ff 75 0c             	pushl  0xc(%ebp)
+801012dc:	50                   	push   %eax
+801012dd:	e8 c8 0c 00 00       	call   80101faa <readi>
+801012e2:	83 c4 10             	add    $0x10,%esp
+801012e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801012e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801012ec:	7e 11                	jle    801012ff <fileread+0x96>
+      f->off += r;
+801012ee:	8b 45 08             	mov    0x8(%ebp),%eax
+801012f1:	8b 50 14             	mov    0x14(%eax),%edx
+801012f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801012f7:	01 c2                	add    %eax,%edx
+801012f9:	8b 45 08             	mov    0x8(%ebp),%eax
+801012fc:	89 50 14             	mov    %edx,0x14(%eax)
+    iunlock(f->ip);
+801012ff:	8b 45 08             	mov    0x8(%ebp),%eax
+80101302:	8b 40 10             	mov    0x10(%eax),%eax
+80101305:	83 ec 0c             	sub    $0xc,%esp
+80101308:	50                   	push   %eax
+80101309:	e8 ab 08 00 00       	call   80101bb9 <iunlock>
+8010130e:	83 c4 10             	add    $0x10,%esp
+    return r;
+80101311:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101314:	eb 0d                	jmp    80101323 <fileread+0xba>
+  }
+  panic("fileread");
+80101316:	83 ec 0c             	sub    $0xc,%esp
+80101319:	68 97 8d 10 80       	push   $0x80108d97
+8010131e:	e8 ae f2 ff ff       	call   801005d1 <panic>
+}
+80101323:	c9                   	leave  
+80101324:	c3                   	ret    
+
+80101325 <filewrite>:
+
+//PAGEBREAK!
+// Write to file f.
+int
+filewrite(struct file *f, char *addr, int n)
+{
+80101325:	f3 0f 1e fb          	endbr32 
+80101329:	55                   	push   %ebp
+8010132a:	89 e5                	mov    %esp,%ebp
+8010132c:	53                   	push   %ebx
+8010132d:	83 ec 14             	sub    $0x14,%esp
+  int r;
+
+  if(f->writable == 0)
+80101330:	8b 45 08             	mov    0x8(%ebp),%eax
+80101333:	0f b6 40 09          	movzbl 0x9(%eax),%eax
+80101337:	84 c0                	test   %al,%al
+80101339:	75 0a                	jne    80101345 <filewrite+0x20>
+    return -1;
+8010133b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101340:	e9 1b 01 00 00       	jmp    80101460 <filewrite+0x13b>
+  if(f->type == FD_PIPE)
+80101345:	8b 45 08             	mov    0x8(%ebp),%eax
+80101348:	8b 00                	mov    (%eax),%eax
+8010134a:	83 f8 01             	cmp    $0x1,%eax
+8010134d:	75 1d                	jne    8010136c <filewrite+0x47>
+    return pipewrite(f->pipe, addr, n);
+8010134f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101352:	8b 40 0c             	mov    0xc(%eax),%eax
+80101355:	83 ec 04             	sub    $0x4,%esp
+80101358:	ff 75 10             	pushl  0x10(%ebp)
+8010135b:	ff 75 0c             	pushl  0xc(%ebp)
+8010135e:	50                   	push   %eax
+8010135f:	e8 f2 2d 00 00       	call   80104156 <pipewrite>
+80101364:	83 c4 10             	add    $0x10,%esp
+80101367:	e9 f4 00 00 00       	jmp    80101460 <filewrite+0x13b>
+  if(f->type == FD_INODE){
+8010136c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010136f:	8b 00                	mov    (%eax),%eax
+80101371:	83 f8 02             	cmp    $0x2,%eax
+80101374:	0f 85 d9 00 00 00    	jne    80101453 <filewrite+0x12e>
+    // the maximum log transaction size, including
+    // i-node, indirect block, allocation blocks,
+    // and 2 blocks of slop for non-aligned writes.
+    // this really belongs lower down, since writei()
+    // might be writing a device like the console.
+    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
+8010137a:	c7 45 ec 00 06 00 00 	movl   $0x600,-0x14(%ebp)
+    int i = 0;
+80101381:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while(i < n){
+80101388:	e9 a3 00 00 00       	jmp    80101430 <filewrite+0x10b>
+      int n1 = n - i;
+8010138d:	8b 45 10             	mov    0x10(%ebp),%eax
+80101390:	2b 45 f4             	sub    -0xc(%ebp),%eax
+80101393:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      if(n1 > max)
+80101396:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101399:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+8010139c:	7e 06                	jle    801013a4 <filewrite+0x7f>
+        n1 = max;
+8010139e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801013a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+      begin_op();
+801013a4:	e8 c8 22 00 00       	call   80103671 <begin_op>
+      ilock(f->ip);
+801013a9:	8b 45 08             	mov    0x8(%ebp),%eax
+801013ac:	8b 40 10             	mov    0x10(%eax),%eax
+801013af:	83 ec 0c             	sub    $0xc,%esp
+801013b2:	50                   	push   %eax
+801013b3:	e8 ea 06 00 00       	call   80101aa2 <ilock>
+801013b8:	83 c4 10             	add    $0x10,%esp
+      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
+801013bb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+801013be:	8b 45 08             	mov    0x8(%ebp),%eax
+801013c1:	8b 50 14             	mov    0x14(%eax),%edx
+801013c4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+801013c7:	8b 45 0c             	mov    0xc(%ebp),%eax
+801013ca:	01 c3                	add    %eax,%ebx
+801013cc:	8b 45 08             	mov    0x8(%ebp),%eax
+801013cf:	8b 40 10             	mov    0x10(%eax),%eax
+801013d2:	51                   	push   %ecx
+801013d3:	52                   	push   %edx
+801013d4:	53                   	push   %ebx
+801013d5:	50                   	push   %eax
+801013d6:	e8 28 0d 00 00       	call   80102103 <writei>
+801013db:	83 c4 10             	add    $0x10,%esp
+801013de:	89 45 e8             	mov    %eax,-0x18(%ebp)
+801013e1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+801013e5:	7e 11                	jle    801013f8 <filewrite+0xd3>
+        f->off += r;
+801013e7:	8b 45 08             	mov    0x8(%ebp),%eax
+801013ea:	8b 50 14             	mov    0x14(%eax),%edx
+801013ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801013f0:	01 c2                	add    %eax,%edx
+801013f2:	8b 45 08             	mov    0x8(%ebp),%eax
+801013f5:	89 50 14             	mov    %edx,0x14(%eax)
+      iunlock(f->ip);
+801013f8:	8b 45 08             	mov    0x8(%ebp),%eax
+801013fb:	8b 40 10             	mov    0x10(%eax),%eax
+801013fe:	83 ec 0c             	sub    $0xc,%esp
+80101401:	50                   	push   %eax
+80101402:	e8 b2 07 00 00       	call   80101bb9 <iunlock>
+80101407:	83 c4 10             	add    $0x10,%esp
+      end_op();
+8010140a:	e8 f2 22 00 00       	call   80103701 <end_op>
+
+      if(r < 0)
+8010140f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+80101413:	78 29                	js     8010143e <filewrite+0x119>
+        break;
+      if(r != n1)
+80101415:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80101418:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+8010141b:	74 0d                	je     8010142a <filewrite+0x105>
+        panic("short filewrite");
+8010141d:	83 ec 0c             	sub    $0xc,%esp
+80101420:	68 a0 8d 10 80       	push   $0x80108da0
+80101425:	e8 a7 f1 ff ff       	call   801005d1 <panic>
+      i += r;
+8010142a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+8010142d:	01 45 f4             	add    %eax,-0xc(%ebp)
+    while(i < n){
+80101430:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101433:	3b 45 10             	cmp    0x10(%ebp),%eax
+80101436:	0f 8c 51 ff ff ff    	jl     8010138d <filewrite+0x68>
+8010143c:	eb 01                	jmp    8010143f <filewrite+0x11a>
+        break;
+8010143e:	90                   	nop
+    }
+    return i == n ? n : -1;
+8010143f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101442:	3b 45 10             	cmp    0x10(%ebp),%eax
+80101445:	75 05                	jne    8010144c <filewrite+0x127>
+80101447:	8b 45 10             	mov    0x10(%ebp),%eax
+8010144a:	eb 14                	jmp    80101460 <filewrite+0x13b>
+8010144c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101451:	eb 0d                	jmp    80101460 <filewrite+0x13b>
+  }
+  panic("filewrite");
+80101453:	83 ec 0c             	sub    $0xc,%esp
+80101456:	68 b0 8d 10 80       	push   $0x80108db0
+8010145b:	e8 71 f1 ff ff       	call   801005d1 <panic>
+}
+80101460:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80101463:	c9                   	leave  
+80101464:	c3                   	ret    
+
+80101465 <readsb>:
+struct superblock sb; 
+
+// Read the super block.
+void
+readsb(int dev, struct superblock *sb)
+{
+80101465:	f3 0f 1e fb          	endbr32 
+80101469:	55                   	push   %ebp
+8010146a:	89 e5                	mov    %esp,%ebp
+8010146c:	83 ec 18             	sub    $0x18,%esp
+  struct buf *bp;
+
+  bp = bread(dev, 1);
+8010146f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101472:	83 ec 08             	sub    $0x8,%esp
+80101475:	6a 01                	push   $0x1
+80101477:	50                   	push   %eax
+80101478:	e8 5a ed ff ff       	call   801001d7 <bread>
+8010147d:	83 c4 10             	add    $0x10,%esp
+80101480:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memmove(sb, bp->data, sizeof(*sb));
+80101483:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101486:	83 c0 5c             	add    $0x5c,%eax
+80101489:	83 ec 04             	sub    $0x4,%esp
+8010148c:	6a 1c                	push   $0x1c
+8010148e:	50                   	push   %eax
+8010148f:	ff 75 0c             	pushl  0xc(%ebp)
+80101492:	e8 4b 46 00 00       	call   80105ae2 <memmove>
+80101497:	83 c4 10             	add    $0x10,%esp
+  brelse(bp);
+8010149a:	83 ec 0c             	sub    $0xc,%esp
+8010149d:	ff 75 f4             	pushl  -0xc(%ebp)
+801014a0:	e8 bc ed ff ff       	call   80100261 <brelse>
+801014a5:	83 c4 10             	add    $0x10,%esp
+}
+801014a8:	90                   	nop
+801014a9:	c9                   	leave  
+801014aa:	c3                   	ret    
+
+801014ab <bzero>:
+
+// Zero a block.
+static void
+bzero(int dev, int bno)
+{
+801014ab:	f3 0f 1e fb          	endbr32 
+801014af:	55                   	push   %ebp
+801014b0:	89 e5                	mov    %esp,%ebp
+801014b2:	83 ec 18             	sub    $0x18,%esp
+  struct buf *bp;
+
+  bp = bread(dev, bno);
+801014b5:	8b 55 0c             	mov    0xc(%ebp),%edx
+801014b8:	8b 45 08             	mov    0x8(%ebp),%eax
+801014bb:	83 ec 08             	sub    $0x8,%esp
+801014be:	52                   	push   %edx
+801014bf:	50                   	push   %eax
+801014c0:	e8 12 ed ff ff       	call   801001d7 <bread>
+801014c5:	83 c4 10             	add    $0x10,%esp
+801014c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(bp->data, 0, BSIZE);
+801014cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801014ce:	83 c0 5c             	add    $0x5c,%eax
+801014d1:	83 ec 04             	sub    $0x4,%esp
+801014d4:	68 00 02 00 00       	push   $0x200
+801014d9:	6a 00                	push   $0x0
+801014db:	50                   	push   %eax
+801014dc:	e8 3a 45 00 00       	call   80105a1b <memset>
+801014e1:	83 c4 10             	add    $0x10,%esp
+  log_write(bp);
+801014e4:	83 ec 0c             	sub    $0xc,%esp
+801014e7:	ff 75 f4             	pushl  -0xc(%ebp)
+801014ea:	e8 cb 23 00 00       	call   801038ba <log_write>
+801014ef:	83 c4 10             	add    $0x10,%esp
+  brelse(bp);
+801014f2:	83 ec 0c             	sub    $0xc,%esp
+801014f5:	ff 75 f4             	pushl  -0xc(%ebp)
+801014f8:	e8 64 ed ff ff       	call   80100261 <brelse>
+801014fd:	83 c4 10             	add    $0x10,%esp
+}
+80101500:	90                   	nop
+80101501:	c9                   	leave  
+80101502:	c3                   	ret    
+
+80101503 <balloc>:
+// Blocks.
+
+// Allocate a zeroed disk block.
+static uint
+balloc(uint dev)
+{
+80101503:	f3 0f 1e fb          	endbr32 
+80101507:	55                   	push   %ebp
+80101508:	89 e5                	mov    %esp,%ebp
+8010150a:	83 ec 18             	sub    $0x18,%esp
+  int b, bi, m;
+  struct buf *bp;
+
+  bp = 0;
+8010150d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(b = 0; b < sb.size; b += BPB){
+80101514:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+8010151b:	e9 13 01 00 00       	jmp    80101633 <balloc+0x130>
+    bp = bread(dev, BBLOCK(b, sb));
+80101520:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101523:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
+80101529:	85 c0                	test   %eax,%eax
+8010152b:	0f 48 c2             	cmovs  %edx,%eax
+8010152e:	c1 f8 0c             	sar    $0xc,%eax
+80101531:	89 c2                	mov    %eax,%edx
+80101533:	a1 78 2a 11 80       	mov    0x80112a78,%eax
+80101538:	01 d0                	add    %edx,%eax
+8010153a:	83 ec 08             	sub    $0x8,%esp
+8010153d:	50                   	push   %eax
+8010153e:	ff 75 08             	pushl  0x8(%ebp)
+80101541:	e8 91 ec ff ff       	call   801001d7 <bread>
+80101546:	83 c4 10             	add    $0x10,%esp
+80101549:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+8010154c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+80101553:	e9 a6 00 00 00       	jmp    801015fe <balloc+0xfb>
+      m = 1 << (bi % 8);
+80101558:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010155b:	99                   	cltd   
+8010155c:	c1 ea 1d             	shr    $0x1d,%edx
+8010155f:	01 d0                	add    %edx,%eax
+80101561:	83 e0 07             	and    $0x7,%eax
+80101564:	29 d0                	sub    %edx,%eax
+80101566:	ba 01 00 00 00       	mov    $0x1,%edx
+8010156b:	89 c1                	mov    %eax,%ecx
+8010156d:	d3 e2                	shl    %cl,%edx
+8010156f:	89 d0                	mov    %edx,%eax
+80101571:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+80101574:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101577:	8d 50 07             	lea    0x7(%eax),%edx
+8010157a:	85 c0                	test   %eax,%eax
+8010157c:	0f 48 c2             	cmovs  %edx,%eax
+8010157f:	c1 f8 03             	sar    $0x3,%eax
+80101582:	89 c2                	mov    %eax,%edx
+80101584:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101587:	0f b6 44 10 5c       	movzbl 0x5c(%eax,%edx,1),%eax
+8010158c:	0f b6 c0             	movzbl %al,%eax
+8010158f:	23 45 e8             	and    -0x18(%ebp),%eax
+80101592:	85 c0                	test   %eax,%eax
+80101594:	75 64                	jne    801015fa <balloc+0xf7>
+        bp->data[bi/8] |= m;  // Mark block in use.
+80101596:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101599:	8d 50 07             	lea    0x7(%eax),%edx
+8010159c:	85 c0                	test   %eax,%eax
+8010159e:	0f 48 c2             	cmovs  %edx,%eax
+801015a1:	c1 f8 03             	sar    $0x3,%eax
+801015a4:	8b 55 ec             	mov    -0x14(%ebp),%edx
+801015a7:	0f b6 54 02 5c       	movzbl 0x5c(%edx,%eax,1),%edx
+801015ac:	89 d1                	mov    %edx,%ecx
+801015ae:	8b 55 e8             	mov    -0x18(%ebp),%edx
+801015b1:	09 ca                	or     %ecx,%edx
+801015b3:	89 d1                	mov    %edx,%ecx
+801015b5:	8b 55 ec             	mov    -0x14(%ebp),%edx
+801015b8:	88 4c 02 5c          	mov    %cl,0x5c(%edx,%eax,1)
+        log_write(bp);
+801015bc:	83 ec 0c             	sub    $0xc,%esp
+801015bf:	ff 75 ec             	pushl  -0x14(%ebp)
+801015c2:	e8 f3 22 00 00       	call   801038ba <log_write>
+801015c7:	83 c4 10             	add    $0x10,%esp
+        brelse(bp);
+801015ca:	83 ec 0c             	sub    $0xc,%esp
+801015cd:	ff 75 ec             	pushl  -0x14(%ebp)
+801015d0:	e8 8c ec ff ff       	call   80100261 <brelse>
+801015d5:	83 c4 10             	add    $0x10,%esp
+        bzero(dev, b + bi);
+801015d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801015db:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801015de:	01 c2                	add    %eax,%edx
+801015e0:	8b 45 08             	mov    0x8(%ebp),%eax
+801015e3:	83 ec 08             	sub    $0x8,%esp
+801015e6:	52                   	push   %edx
+801015e7:	50                   	push   %eax
+801015e8:	e8 be fe ff ff       	call   801014ab <bzero>
+801015ed:	83 c4 10             	add    $0x10,%esp
+        return b + bi;
+801015f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801015f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801015f6:	01 d0                	add    %edx,%eax
+801015f8:	eb 57                	jmp    80101651 <balloc+0x14e>
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+801015fa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+801015fe:	81 7d f0 ff 0f 00 00 	cmpl   $0xfff,-0x10(%ebp)
+80101605:	7f 17                	jg     8010161e <balloc+0x11b>
+80101607:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010160a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010160d:	01 d0                	add    %edx,%eax
+8010160f:	89 c2                	mov    %eax,%edx
+80101611:	a1 60 2a 11 80       	mov    0x80112a60,%eax
+80101616:	39 c2                	cmp    %eax,%edx
+80101618:	0f 82 3a ff ff ff    	jb     80101558 <balloc+0x55>
+      }
+    }
+    brelse(bp);
+8010161e:	83 ec 0c             	sub    $0xc,%esp
+80101621:	ff 75 ec             	pushl  -0x14(%ebp)
+80101624:	e8 38 ec ff ff       	call   80100261 <brelse>
+80101629:	83 c4 10             	add    $0x10,%esp
+  for(b = 0; b < sb.size; b += BPB){
+8010162c:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+80101633:	8b 15 60 2a 11 80    	mov    0x80112a60,%edx
+80101639:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010163c:	39 c2                	cmp    %eax,%edx
+8010163e:	0f 87 dc fe ff ff    	ja     80101520 <balloc+0x1d>
+  }
+  panic("balloc: out of blocks");
+80101644:	83 ec 0c             	sub    $0xc,%esp
+80101647:	68 bc 8d 10 80       	push   $0x80108dbc
+8010164c:	e8 80 ef ff ff       	call   801005d1 <panic>
+}
+80101651:	c9                   	leave  
+80101652:	c3                   	ret    
+
+80101653 <bfree>:
+
+// Free a disk block.
+static void
+bfree(int dev, uint b)
+{
+80101653:	f3 0f 1e fb          	endbr32 
+80101657:	55                   	push   %ebp
+80101658:	89 e5                	mov    %esp,%ebp
+8010165a:	83 ec 18             	sub    $0x18,%esp
+  struct buf *bp;
+  int bi, m;
+
+  bp = bread(dev, BBLOCK(b, sb));
+8010165d:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101660:	c1 e8 0c             	shr    $0xc,%eax
+80101663:	89 c2                	mov    %eax,%edx
+80101665:	a1 78 2a 11 80       	mov    0x80112a78,%eax
+8010166a:	01 c2                	add    %eax,%edx
+8010166c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010166f:	83 ec 08             	sub    $0x8,%esp
+80101672:	52                   	push   %edx
+80101673:	50                   	push   %eax
+80101674:	e8 5e eb ff ff       	call   801001d7 <bread>
+80101679:	83 c4 10             	add    $0x10,%esp
+8010167c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  bi = b % BPB;
+8010167f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101682:	25 ff 0f 00 00       	and    $0xfff,%eax
+80101687:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  m = 1 << (bi % 8);
+8010168a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010168d:	99                   	cltd   
+8010168e:	c1 ea 1d             	shr    $0x1d,%edx
+80101691:	01 d0                	add    %edx,%eax
+80101693:	83 e0 07             	and    $0x7,%eax
+80101696:	29 d0                	sub    %edx,%eax
+80101698:	ba 01 00 00 00       	mov    $0x1,%edx
+8010169d:	89 c1                	mov    %eax,%ecx
+8010169f:	d3 e2                	shl    %cl,%edx
+801016a1:	89 d0                	mov    %edx,%eax
+801016a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((bp->data[bi/8] & m) == 0)
+801016a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801016a9:	8d 50 07             	lea    0x7(%eax),%edx
+801016ac:	85 c0                	test   %eax,%eax
+801016ae:	0f 48 c2             	cmovs  %edx,%eax
+801016b1:	c1 f8 03             	sar    $0x3,%eax
+801016b4:	89 c2                	mov    %eax,%edx
+801016b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801016b9:	0f b6 44 10 5c       	movzbl 0x5c(%eax,%edx,1),%eax
+801016be:	0f b6 c0             	movzbl %al,%eax
+801016c1:	23 45 ec             	and    -0x14(%ebp),%eax
+801016c4:	85 c0                	test   %eax,%eax
+801016c6:	75 0d                	jne    801016d5 <bfree+0x82>
+    panic("freeing free block");
+801016c8:	83 ec 0c             	sub    $0xc,%esp
+801016cb:	68 d2 8d 10 80       	push   $0x80108dd2
+801016d0:	e8 fc ee ff ff       	call   801005d1 <panic>
+  bp->data[bi/8] &= ~m;
+801016d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801016d8:	8d 50 07             	lea    0x7(%eax),%edx
+801016db:	85 c0                	test   %eax,%eax
+801016dd:	0f 48 c2             	cmovs  %edx,%eax
+801016e0:	c1 f8 03             	sar    $0x3,%eax
+801016e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801016e6:	0f b6 54 02 5c       	movzbl 0x5c(%edx,%eax,1),%edx
+801016eb:	89 d1                	mov    %edx,%ecx
+801016ed:	8b 55 ec             	mov    -0x14(%ebp),%edx
+801016f0:	f7 d2                	not    %edx
+801016f2:	21 ca                	and    %ecx,%edx
+801016f4:	89 d1                	mov    %edx,%ecx
+801016f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801016f9:	88 4c 02 5c          	mov    %cl,0x5c(%edx,%eax,1)
+  log_write(bp);
+801016fd:	83 ec 0c             	sub    $0xc,%esp
+80101700:	ff 75 f4             	pushl  -0xc(%ebp)
+80101703:	e8 b2 21 00 00       	call   801038ba <log_write>
+80101708:	83 c4 10             	add    $0x10,%esp
+  brelse(bp);
+8010170b:	83 ec 0c             	sub    $0xc,%esp
+8010170e:	ff 75 f4             	pushl  -0xc(%ebp)
+80101711:	e8 4b eb ff ff       	call   80100261 <brelse>
+80101716:	83 c4 10             	add    $0x10,%esp
+}
+80101719:	90                   	nop
+8010171a:	c9                   	leave  
+8010171b:	c3                   	ret    
+
+8010171c <iinit>:
+  struct inode inode[NINODE];
+} icache;
+
+void
+iinit(int dev)
+{
+8010171c:	f3 0f 1e fb          	endbr32 
+80101720:	55                   	push   %ebp
+80101721:	89 e5                	mov    %esp,%ebp
+80101723:	57                   	push   %edi
+80101724:	56                   	push   %esi
+80101725:	53                   	push   %ebx
+80101726:	83 ec 2c             	sub    $0x2c,%esp
+  int i = 0;
+80101729:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  
+  initlock(&icache.lock, "icache");
+80101730:	83 ec 08             	sub    $0x8,%esp
+80101733:	68 e5 8d 10 80       	push   $0x80108de5
+80101738:	68 80 2a 11 80       	push   $0x80112a80
+8010173d:	e8 14 40 00 00       	call   80105756 <initlock>
+80101742:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < NINODE; i++) {
+80101745:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+8010174c:	eb 2d                	jmp    8010177b <iinit+0x5f>
+    initsleeplock(&icache.inode[i].lock, "inode");
+8010174e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80101751:	89 d0                	mov    %edx,%eax
+80101753:	c1 e0 03             	shl    $0x3,%eax
+80101756:	01 d0                	add    %edx,%eax
+80101758:	c1 e0 04             	shl    $0x4,%eax
+8010175b:	83 c0 30             	add    $0x30,%eax
+8010175e:	05 80 2a 11 80       	add    $0x80112a80,%eax
+80101763:	83 c0 10             	add    $0x10,%eax
+80101766:	83 ec 08             	sub    $0x8,%esp
+80101769:	68 ec 8d 10 80       	push   $0x80108dec
+8010176e:	50                   	push   %eax
+8010176f:	e8 4f 3e 00 00       	call   801055c3 <initsleeplock>
+80101774:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < NINODE; i++) {
+80101777:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
+8010177b:	83 7d e4 31          	cmpl   $0x31,-0x1c(%ebp)
+8010177f:	7e cd                	jle    8010174e <iinit+0x32>
+  }
+
+  readsb(dev, &sb);
+80101781:	83 ec 08             	sub    $0x8,%esp
+80101784:	68 60 2a 11 80       	push   $0x80112a60
+80101789:	ff 75 08             	pushl  0x8(%ebp)
+8010178c:	e8 d4 fc ff ff       	call   80101465 <readsb>
+80101791:	83 c4 10             	add    $0x10,%esp
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+80101794:	a1 78 2a 11 80       	mov    0x80112a78,%eax
+80101799:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+8010179c:	8b 3d 74 2a 11 80    	mov    0x80112a74,%edi
+801017a2:	8b 35 70 2a 11 80    	mov    0x80112a70,%esi
+801017a8:	8b 1d 6c 2a 11 80    	mov    0x80112a6c,%ebx
+801017ae:	8b 0d 68 2a 11 80    	mov    0x80112a68,%ecx
+801017b4:	8b 15 64 2a 11 80    	mov    0x80112a64,%edx
+801017ba:	a1 60 2a 11 80       	mov    0x80112a60,%eax
+801017bf:	ff 75 d4             	pushl  -0x2c(%ebp)
+801017c2:	57                   	push   %edi
+801017c3:	56                   	push   %esi
+801017c4:	53                   	push   %ebx
+801017c5:	51                   	push   %ecx
+801017c6:	52                   	push   %edx
+801017c7:	50                   	push   %eax
+801017c8:	68 f4 8d 10 80       	push   $0x80108df4
+801017cd:	e8 46 ec ff ff       	call   80100418 <cprintf>
+801017d2:	83 c4 20             	add    $0x20,%esp
+ inodestart %d bmap start %d\n", sb.size, sb.nblocks,
+          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
+          sb.bmapstart);
+}
+801017d5:	90                   	nop
+801017d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
+801017d9:	5b                   	pop    %ebx
+801017da:	5e                   	pop    %esi
+801017db:	5f                   	pop    %edi
+801017dc:	5d                   	pop    %ebp
+801017dd:	c3                   	ret    
+
+801017de <ialloc>:
+// Allocate an inode on device dev.
+// Mark it as allocated by  giving it type type.
+// Returns an unlocked but allocated and referenced inode.
+struct inode*
+ialloc(uint dev, short type)
+{
+801017de:	f3 0f 1e fb          	endbr32 
+801017e2:	55                   	push   %ebp
+801017e3:	89 e5                	mov    %esp,%ebp
+801017e5:	83 ec 28             	sub    $0x28,%esp
+801017e8:	8b 45 0c             	mov    0xc(%ebp),%eax
+801017eb:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
+  int inum;
+  struct buf *bp;
+  struct dinode *dip;
+
+  for(inum = 1; inum < sb.ninodes; inum++){
+801017ef:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+801017f6:	e9 9e 00 00 00       	jmp    80101899 <ialloc+0xbb>
+    bp = bread(dev, IBLOCK(inum, sb));
+801017fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801017fe:	c1 e8 03             	shr    $0x3,%eax
+80101801:	89 c2                	mov    %eax,%edx
+80101803:	a1 74 2a 11 80       	mov    0x80112a74,%eax
+80101808:	01 d0                	add    %edx,%eax
+8010180a:	83 ec 08             	sub    $0x8,%esp
+8010180d:	50                   	push   %eax
+8010180e:	ff 75 08             	pushl  0x8(%ebp)
+80101811:	e8 c1 e9 ff ff       	call   801001d7 <bread>
+80101816:	83 c4 10             	add    $0x10,%esp
+80101819:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    dip = (struct dinode*)bp->data + inum%IPB;
+8010181c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010181f:	8d 50 5c             	lea    0x5c(%eax),%edx
+80101822:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101825:	83 e0 07             	and    $0x7,%eax
+80101828:	c1 e0 06             	shl    $0x6,%eax
+8010182b:	01 d0                	add    %edx,%eax
+8010182d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(dip->type == 0){  // a free inode
+80101830:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101833:	0f b7 00             	movzwl (%eax),%eax
+80101836:	66 85 c0             	test   %ax,%ax
+80101839:	75 4c                	jne    80101887 <ialloc+0xa9>
+      memset(dip, 0, sizeof(*dip));
+8010183b:	83 ec 04             	sub    $0x4,%esp
+8010183e:	6a 40                	push   $0x40
+80101840:	6a 00                	push   $0x0
+80101842:	ff 75 ec             	pushl  -0x14(%ebp)
+80101845:	e8 d1 41 00 00       	call   80105a1b <memset>
+8010184a:	83 c4 10             	add    $0x10,%esp
+      dip->type = type;
+8010184d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101850:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
+80101854:	66 89 10             	mov    %dx,(%eax)
+      log_write(bp);   // mark it allocated on the disk
+80101857:	83 ec 0c             	sub    $0xc,%esp
+8010185a:	ff 75 f0             	pushl  -0x10(%ebp)
+8010185d:	e8 58 20 00 00       	call   801038ba <log_write>
+80101862:	83 c4 10             	add    $0x10,%esp
+      brelse(bp);
+80101865:	83 ec 0c             	sub    $0xc,%esp
+80101868:	ff 75 f0             	pushl  -0x10(%ebp)
+8010186b:	e8 f1 e9 ff ff       	call   80100261 <brelse>
+80101870:	83 c4 10             	add    $0x10,%esp
+      return iget(dev, inum);
+80101873:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101876:	83 ec 08             	sub    $0x8,%esp
+80101879:	50                   	push   %eax
+8010187a:	ff 75 08             	pushl  0x8(%ebp)
+8010187d:	e8 fc 00 00 00       	call   8010197e <iget>
+80101882:	83 c4 10             	add    $0x10,%esp
+80101885:	eb 30                	jmp    801018b7 <ialloc+0xd9>
+    }
+    brelse(bp);
+80101887:	83 ec 0c             	sub    $0xc,%esp
+8010188a:	ff 75 f0             	pushl  -0x10(%ebp)
+8010188d:	e8 cf e9 ff ff       	call   80100261 <brelse>
+80101892:	83 c4 10             	add    $0x10,%esp
+  for(inum = 1; inum < sb.ninodes; inum++){
+80101895:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80101899:	8b 15 68 2a 11 80    	mov    0x80112a68,%edx
+8010189f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801018a2:	39 c2                	cmp    %eax,%edx
+801018a4:	0f 87 51 ff ff ff    	ja     801017fb <ialloc+0x1d>
+  }
+  panic("ialloc: no inodes");
+801018aa:	83 ec 0c             	sub    $0xc,%esp
+801018ad:	68 47 8e 10 80       	push   $0x80108e47
+801018b2:	e8 1a ed ff ff       	call   801005d1 <panic>
+}
+801018b7:	c9                   	leave  
+801018b8:	c3                   	ret    
+
+801018b9 <iupdate>:
+// Must be called after every change to an ip->xxx field
+// that lives on disk, since i-node cache is write-through.
+// Caller must hold ip->lock.
+void
+iupdate(struct inode *ip)
+{
+801018b9:	f3 0f 1e fb          	endbr32 
+801018bd:	55                   	push   %ebp
+801018be:	89 e5                	mov    %esp,%ebp
+801018c0:	83 ec 18             	sub    $0x18,%esp
+  struct buf *bp;
+  struct dinode *dip;
+
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+801018c3:	8b 45 08             	mov    0x8(%ebp),%eax
+801018c6:	8b 40 04             	mov    0x4(%eax),%eax
+801018c9:	c1 e8 03             	shr    $0x3,%eax
+801018cc:	89 c2                	mov    %eax,%edx
+801018ce:	a1 74 2a 11 80       	mov    0x80112a74,%eax
+801018d3:	01 c2                	add    %eax,%edx
+801018d5:	8b 45 08             	mov    0x8(%ebp),%eax
+801018d8:	8b 00                	mov    (%eax),%eax
+801018da:	83 ec 08             	sub    $0x8,%esp
+801018dd:	52                   	push   %edx
+801018de:	50                   	push   %eax
+801018df:	e8 f3 e8 ff ff       	call   801001d7 <bread>
+801018e4:	83 c4 10             	add    $0x10,%esp
+801018e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+801018ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801018ed:	8d 50 5c             	lea    0x5c(%eax),%edx
+801018f0:	8b 45 08             	mov    0x8(%ebp),%eax
+801018f3:	8b 40 04             	mov    0x4(%eax),%eax
+801018f6:	83 e0 07             	and    $0x7,%eax
+801018f9:	c1 e0 06             	shl    $0x6,%eax
+801018fc:	01 d0                	add    %edx,%eax
+801018fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  dip->type = ip->type;
+80101901:	8b 45 08             	mov    0x8(%ebp),%eax
+80101904:	0f b7 50 50          	movzwl 0x50(%eax),%edx
+80101908:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010190b:	66 89 10             	mov    %dx,(%eax)
+  dip->major = ip->major;
+8010190e:	8b 45 08             	mov    0x8(%ebp),%eax
+80101911:	0f b7 50 52          	movzwl 0x52(%eax),%edx
+80101915:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101918:	66 89 50 02          	mov    %dx,0x2(%eax)
+  dip->minor = ip->minor;
+8010191c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010191f:	0f b7 50 54          	movzwl 0x54(%eax),%edx
+80101923:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101926:	66 89 50 04          	mov    %dx,0x4(%eax)
+  dip->nlink = ip->nlink;
+8010192a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010192d:	0f b7 50 56          	movzwl 0x56(%eax),%edx
+80101931:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101934:	66 89 50 06          	mov    %dx,0x6(%eax)
+  dip->size = ip->size;
+80101938:	8b 45 08             	mov    0x8(%ebp),%eax
+8010193b:	8b 50 58             	mov    0x58(%eax),%edx
+8010193e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101941:	89 50 08             	mov    %edx,0x8(%eax)
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+80101944:	8b 45 08             	mov    0x8(%ebp),%eax
+80101947:	8d 50 5c             	lea    0x5c(%eax),%edx
+8010194a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010194d:	83 c0 0c             	add    $0xc,%eax
+80101950:	83 ec 04             	sub    $0x4,%esp
+80101953:	6a 34                	push   $0x34
+80101955:	52                   	push   %edx
+80101956:	50                   	push   %eax
+80101957:	e8 86 41 00 00       	call   80105ae2 <memmove>
+8010195c:	83 c4 10             	add    $0x10,%esp
+  log_write(bp);
+8010195f:	83 ec 0c             	sub    $0xc,%esp
+80101962:	ff 75 f4             	pushl  -0xc(%ebp)
+80101965:	e8 50 1f 00 00       	call   801038ba <log_write>
+8010196a:	83 c4 10             	add    $0x10,%esp
+  brelse(bp);
+8010196d:	83 ec 0c             	sub    $0xc,%esp
+80101970:	ff 75 f4             	pushl  -0xc(%ebp)
+80101973:	e8 e9 e8 ff ff       	call   80100261 <brelse>
+80101978:	83 c4 10             	add    $0x10,%esp
+}
+8010197b:	90                   	nop
+8010197c:	c9                   	leave  
+8010197d:	c3                   	ret    
+
+8010197e <iget>:
+// Find the inode with number inum on device dev
+// and return the in-memory copy. Does not lock
+// the inode and does not read it from disk.
+static struct inode*
+iget(uint dev, uint inum)
+{
+8010197e:	f3 0f 1e fb          	endbr32 
+80101982:	55                   	push   %ebp
+80101983:	89 e5                	mov    %esp,%ebp
+80101985:	83 ec 18             	sub    $0x18,%esp
+  struct inode *ip, *empty;
+
+  acquire(&icache.lock);
+80101988:	83 ec 0c             	sub    $0xc,%esp
+8010198b:	68 80 2a 11 80       	push   $0x80112a80
+80101990:	e8 e7 3d 00 00       	call   8010577c <acquire>
+80101995:	83 c4 10             	add    $0x10,%esp
+
+  // Is the inode already cached?
+  empty = 0;
+80101998:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+8010199f:	c7 45 f4 b4 2a 11 80 	movl   $0x80112ab4,-0xc(%ebp)
+801019a6:	eb 60                	jmp    80101a08 <iget+0x8a>
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+801019a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019ab:	8b 40 08             	mov    0x8(%eax),%eax
+801019ae:	85 c0                	test   %eax,%eax
+801019b0:	7e 39                	jle    801019eb <iget+0x6d>
+801019b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019b5:	8b 00                	mov    (%eax),%eax
+801019b7:	39 45 08             	cmp    %eax,0x8(%ebp)
+801019ba:	75 2f                	jne    801019eb <iget+0x6d>
+801019bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019bf:	8b 40 04             	mov    0x4(%eax),%eax
+801019c2:	39 45 0c             	cmp    %eax,0xc(%ebp)
+801019c5:	75 24                	jne    801019eb <iget+0x6d>
+      ip->ref++;
+801019c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019ca:	8b 40 08             	mov    0x8(%eax),%eax
+801019cd:	8d 50 01             	lea    0x1(%eax),%edx
+801019d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019d3:	89 50 08             	mov    %edx,0x8(%eax)
+      release(&icache.lock);
+801019d6:	83 ec 0c             	sub    $0xc,%esp
+801019d9:	68 80 2a 11 80       	push   $0x80112a80
+801019de:	e8 0b 3e 00 00       	call   801057ee <release>
+801019e3:	83 c4 10             	add    $0x10,%esp
+      return ip;
+801019e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019e9:	eb 77                	jmp    80101a62 <iget+0xe4>
+    }
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+801019eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801019ef:	75 10                	jne    80101a01 <iget+0x83>
+801019f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019f4:	8b 40 08             	mov    0x8(%eax),%eax
+801019f7:	85 c0                	test   %eax,%eax
+801019f9:	75 06                	jne    80101a01 <iget+0x83>
+      empty = ip;
+801019fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801019fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+80101a01:	81 45 f4 90 00 00 00 	addl   $0x90,-0xc(%ebp)
+80101a08:	81 7d f4 d4 46 11 80 	cmpl   $0x801146d4,-0xc(%ebp)
+80101a0f:	72 97                	jb     801019a8 <iget+0x2a>
+  }
+
+  // Recycle an inode cache entry.
+  if(empty == 0)
+80101a11:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80101a15:	75 0d                	jne    80101a24 <iget+0xa6>
+    panic("iget: no inodes");
+80101a17:	83 ec 0c             	sub    $0xc,%esp
+80101a1a:	68 59 8e 10 80       	push   $0x80108e59
+80101a1f:	e8 ad eb ff ff       	call   801005d1 <panic>
+
+  ip = empty;
+80101a24:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101a27:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  ip->dev = dev;
+80101a2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101a2d:	8b 55 08             	mov    0x8(%ebp),%edx
+80101a30:	89 10                	mov    %edx,(%eax)
+  ip->inum = inum;
+80101a32:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101a35:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101a38:	89 50 04             	mov    %edx,0x4(%eax)
+  ip->ref = 1;
+80101a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101a3e:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
+  ip->valid = 0;
+80101a45:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101a48:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
+  release(&icache.lock);
+80101a4f:	83 ec 0c             	sub    $0xc,%esp
+80101a52:	68 80 2a 11 80       	push   $0x80112a80
+80101a57:	e8 92 3d 00 00       	call   801057ee <release>
+80101a5c:	83 c4 10             	add    $0x10,%esp
+
+  return ip;
+80101a5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80101a62:	c9                   	leave  
+80101a63:	c3                   	ret    
+
+80101a64 <idup>:
+
+// Increment reference count for ip.
+// Returns ip to enable ip = idup(ip1) idiom.
+struct inode*
+idup(struct inode *ip)
+{
+80101a64:	f3 0f 1e fb          	endbr32 
+80101a68:	55                   	push   %ebp
+80101a69:	89 e5                	mov    %esp,%ebp
+80101a6b:	83 ec 08             	sub    $0x8,%esp
+  acquire(&icache.lock);
+80101a6e:	83 ec 0c             	sub    $0xc,%esp
+80101a71:	68 80 2a 11 80       	push   $0x80112a80
+80101a76:	e8 01 3d 00 00       	call   8010577c <acquire>
+80101a7b:	83 c4 10             	add    $0x10,%esp
+  ip->ref++;
+80101a7e:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a81:	8b 40 08             	mov    0x8(%eax),%eax
+80101a84:	8d 50 01             	lea    0x1(%eax),%edx
+80101a87:	8b 45 08             	mov    0x8(%ebp),%eax
+80101a8a:	89 50 08             	mov    %edx,0x8(%eax)
+  release(&icache.lock);
+80101a8d:	83 ec 0c             	sub    $0xc,%esp
+80101a90:	68 80 2a 11 80       	push   $0x80112a80
+80101a95:	e8 54 3d 00 00       	call   801057ee <release>
+80101a9a:	83 c4 10             	add    $0x10,%esp
+  return ip;
+80101a9d:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+80101aa0:	c9                   	leave  
+80101aa1:	c3                   	ret    
+
+80101aa2 <ilock>:
+
+// Lock the given inode.
+// Reads the inode from disk if necessary.
+void
+ilock(struct inode *ip)
+{
+80101aa2:	f3 0f 1e fb          	endbr32 
+80101aa6:	55                   	push   %ebp
+80101aa7:	89 e5                	mov    %esp,%ebp
+80101aa9:	83 ec 18             	sub    $0x18,%esp
+  struct buf *bp;
+  struct dinode *dip;
+
+  if(ip == 0 || ip->ref < 1)
+80101aac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80101ab0:	74 0a                	je     80101abc <ilock+0x1a>
+80101ab2:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ab5:	8b 40 08             	mov    0x8(%eax),%eax
+80101ab8:	85 c0                	test   %eax,%eax
+80101aba:	7f 0d                	jg     80101ac9 <ilock+0x27>
+    panic("ilock");
+80101abc:	83 ec 0c             	sub    $0xc,%esp
+80101abf:	68 69 8e 10 80       	push   $0x80108e69
+80101ac4:	e8 08 eb ff ff       	call   801005d1 <panic>
+
+  acquiresleep(&ip->lock);
+80101ac9:	8b 45 08             	mov    0x8(%ebp),%eax
+80101acc:	83 c0 0c             	add    $0xc,%eax
+80101acf:	83 ec 0c             	sub    $0xc,%esp
+80101ad2:	50                   	push   %eax
+80101ad3:	e8 2b 3b 00 00       	call   80105603 <acquiresleep>
+80101ad8:	83 c4 10             	add    $0x10,%esp
+
+  if(ip->valid == 0){
+80101adb:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ade:	8b 40 4c             	mov    0x4c(%eax),%eax
+80101ae1:	85 c0                	test   %eax,%eax
+80101ae3:	0f 85 cd 00 00 00    	jne    80101bb6 <ilock+0x114>
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+80101ae9:	8b 45 08             	mov    0x8(%ebp),%eax
+80101aec:	8b 40 04             	mov    0x4(%eax),%eax
+80101aef:	c1 e8 03             	shr    $0x3,%eax
+80101af2:	89 c2                	mov    %eax,%edx
+80101af4:	a1 74 2a 11 80       	mov    0x80112a74,%eax
+80101af9:	01 c2                	add    %eax,%edx
+80101afb:	8b 45 08             	mov    0x8(%ebp),%eax
+80101afe:	8b 00                	mov    (%eax),%eax
+80101b00:	83 ec 08             	sub    $0x8,%esp
+80101b03:	52                   	push   %edx
+80101b04:	50                   	push   %eax
+80101b05:	e8 cd e6 ff ff       	call   801001d7 <bread>
+80101b0a:	83 c4 10             	add    $0x10,%esp
+80101b0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+80101b10:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101b13:	8d 50 5c             	lea    0x5c(%eax),%edx
+80101b16:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b19:	8b 40 04             	mov    0x4(%eax),%eax
+80101b1c:	83 e0 07             	and    $0x7,%eax
+80101b1f:	c1 e0 06             	shl    $0x6,%eax
+80101b22:	01 d0                	add    %edx,%eax
+80101b24:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    ip->type = dip->type;
+80101b27:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101b2a:	0f b7 10             	movzwl (%eax),%edx
+80101b2d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b30:	66 89 50 50          	mov    %dx,0x50(%eax)
+    ip->major = dip->major;
+80101b34:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101b37:	0f b7 50 02          	movzwl 0x2(%eax),%edx
+80101b3b:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b3e:	66 89 50 52          	mov    %dx,0x52(%eax)
+    ip->minor = dip->minor;
+80101b42:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101b45:	0f b7 50 04          	movzwl 0x4(%eax),%edx
+80101b49:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b4c:	66 89 50 54          	mov    %dx,0x54(%eax)
+    ip->nlink = dip->nlink;
+80101b50:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101b53:	0f b7 50 06          	movzwl 0x6(%eax),%edx
+80101b57:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b5a:	66 89 50 56          	mov    %dx,0x56(%eax)
+    ip->size = dip->size;
+80101b5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101b61:	8b 50 08             	mov    0x8(%eax),%edx
+80101b64:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b67:	89 50 58             	mov    %edx,0x58(%eax)
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+80101b6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101b6d:	8d 50 0c             	lea    0xc(%eax),%edx
+80101b70:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b73:	83 c0 5c             	add    $0x5c,%eax
+80101b76:	83 ec 04             	sub    $0x4,%esp
+80101b79:	6a 34                	push   $0x34
+80101b7b:	52                   	push   %edx
+80101b7c:	50                   	push   %eax
+80101b7d:	e8 60 3f 00 00       	call   80105ae2 <memmove>
+80101b82:	83 c4 10             	add    $0x10,%esp
+    brelse(bp);
+80101b85:	83 ec 0c             	sub    $0xc,%esp
+80101b88:	ff 75 f4             	pushl  -0xc(%ebp)
+80101b8b:	e8 d1 e6 ff ff       	call   80100261 <brelse>
+80101b90:	83 c4 10             	add    $0x10,%esp
+    ip->valid = 1;
+80101b93:	8b 45 08             	mov    0x8(%ebp),%eax
+80101b96:	c7 40 4c 01 00 00 00 	movl   $0x1,0x4c(%eax)
+    if(ip->type == 0)
+80101b9d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ba0:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+80101ba4:	66 85 c0             	test   %ax,%ax
+80101ba7:	75 0d                	jne    80101bb6 <ilock+0x114>
+      panic("ilock: no type");
+80101ba9:	83 ec 0c             	sub    $0xc,%esp
+80101bac:	68 6f 8e 10 80       	push   $0x80108e6f
+80101bb1:	e8 1b ea ff ff       	call   801005d1 <panic>
+  }
+}
+80101bb6:	90                   	nop
+80101bb7:	c9                   	leave  
+80101bb8:	c3                   	ret    
+
+80101bb9 <iunlock>:
+
+// Unlock the given inode.
+void
+iunlock(struct inode *ip)
+{
+80101bb9:	f3 0f 1e fb          	endbr32 
+80101bbd:	55                   	push   %ebp
+80101bbe:	89 e5                	mov    %esp,%ebp
+80101bc0:	83 ec 08             	sub    $0x8,%esp
+  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+80101bc3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80101bc7:	74 20                	je     80101be9 <iunlock+0x30>
+80101bc9:	8b 45 08             	mov    0x8(%ebp),%eax
+80101bcc:	83 c0 0c             	add    $0xc,%eax
+80101bcf:	83 ec 0c             	sub    $0xc,%esp
+80101bd2:	50                   	push   %eax
+80101bd3:	e8 e5 3a 00 00       	call   801056bd <holdingsleep>
+80101bd8:	83 c4 10             	add    $0x10,%esp
+80101bdb:	85 c0                	test   %eax,%eax
+80101bdd:	74 0a                	je     80101be9 <iunlock+0x30>
+80101bdf:	8b 45 08             	mov    0x8(%ebp),%eax
+80101be2:	8b 40 08             	mov    0x8(%eax),%eax
+80101be5:	85 c0                	test   %eax,%eax
+80101be7:	7f 0d                	jg     80101bf6 <iunlock+0x3d>
+    panic("iunlock");
+80101be9:	83 ec 0c             	sub    $0xc,%esp
+80101bec:	68 7e 8e 10 80       	push   $0x80108e7e
+80101bf1:	e8 db e9 ff ff       	call   801005d1 <panic>
+
+  releasesleep(&ip->lock);
+80101bf6:	8b 45 08             	mov    0x8(%ebp),%eax
+80101bf9:	83 c0 0c             	add    $0xc,%eax
+80101bfc:	83 ec 0c             	sub    $0xc,%esp
+80101bff:	50                   	push   %eax
+80101c00:	e8 66 3a 00 00       	call   8010566b <releasesleep>
+80101c05:	83 c4 10             	add    $0x10,%esp
+}
+80101c08:	90                   	nop
+80101c09:	c9                   	leave  
+80101c0a:	c3                   	ret    
+
+80101c0b <iput>:
+// to it, free the inode (and its content) on disk.
+// All calls to iput() must be inside a transaction in
+// case it has to free the inode.
+void
+iput(struct inode *ip)
+{
+80101c0b:	f3 0f 1e fb          	endbr32 
+80101c0f:	55                   	push   %ebp
+80101c10:	89 e5                	mov    %esp,%ebp
+80101c12:	83 ec 18             	sub    $0x18,%esp
+  acquiresleep(&ip->lock);
+80101c15:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c18:	83 c0 0c             	add    $0xc,%eax
+80101c1b:	83 ec 0c             	sub    $0xc,%esp
+80101c1e:	50                   	push   %eax
+80101c1f:	e8 df 39 00 00       	call   80105603 <acquiresleep>
+80101c24:	83 c4 10             	add    $0x10,%esp
+  if(ip->valid && ip->nlink == 0){
+80101c27:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c2a:	8b 40 4c             	mov    0x4c(%eax),%eax
+80101c2d:	85 c0                	test   %eax,%eax
+80101c2f:	74 6a                	je     80101c9b <iput+0x90>
+80101c31:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c34:	0f b7 40 56          	movzwl 0x56(%eax),%eax
+80101c38:	66 85 c0             	test   %ax,%ax
+80101c3b:	75 5e                	jne    80101c9b <iput+0x90>
+    acquire(&icache.lock);
+80101c3d:	83 ec 0c             	sub    $0xc,%esp
+80101c40:	68 80 2a 11 80       	push   $0x80112a80
+80101c45:	e8 32 3b 00 00       	call   8010577c <acquire>
+80101c4a:	83 c4 10             	add    $0x10,%esp
+    int r = ip->ref;
+80101c4d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c50:	8b 40 08             	mov    0x8(%eax),%eax
+80101c53:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    release(&icache.lock);
+80101c56:	83 ec 0c             	sub    $0xc,%esp
+80101c59:	68 80 2a 11 80       	push   $0x80112a80
+80101c5e:	e8 8b 3b 00 00       	call   801057ee <release>
+80101c63:	83 c4 10             	add    $0x10,%esp
+    if(r == 1){
+80101c66:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
+80101c6a:	75 2f                	jne    80101c9b <iput+0x90>
+      // inode has no links and no other references: truncate and free.
+      itrunc(ip);
+80101c6c:	83 ec 0c             	sub    $0xc,%esp
+80101c6f:	ff 75 08             	pushl  0x8(%ebp)
+80101c72:	e8 b5 01 00 00       	call   80101e2c <itrunc>
+80101c77:	83 c4 10             	add    $0x10,%esp
+      ip->type = 0;
+80101c7a:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c7d:	66 c7 40 50 00 00    	movw   $0x0,0x50(%eax)
+      iupdate(ip);
+80101c83:	83 ec 0c             	sub    $0xc,%esp
+80101c86:	ff 75 08             	pushl  0x8(%ebp)
+80101c89:	e8 2b fc ff ff       	call   801018b9 <iupdate>
+80101c8e:	83 c4 10             	add    $0x10,%esp
+      ip->valid = 0;
+80101c91:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c94:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
+    }
+  }
+  releasesleep(&ip->lock);
+80101c9b:	8b 45 08             	mov    0x8(%ebp),%eax
+80101c9e:	83 c0 0c             	add    $0xc,%eax
+80101ca1:	83 ec 0c             	sub    $0xc,%esp
+80101ca4:	50                   	push   %eax
+80101ca5:	e8 c1 39 00 00       	call   8010566b <releasesleep>
+80101caa:	83 c4 10             	add    $0x10,%esp
+
+  acquire(&icache.lock);
+80101cad:	83 ec 0c             	sub    $0xc,%esp
+80101cb0:	68 80 2a 11 80       	push   $0x80112a80
+80101cb5:	e8 c2 3a 00 00       	call   8010577c <acquire>
+80101cba:	83 c4 10             	add    $0x10,%esp
+  ip->ref--;
+80101cbd:	8b 45 08             	mov    0x8(%ebp),%eax
+80101cc0:	8b 40 08             	mov    0x8(%eax),%eax
+80101cc3:	8d 50 ff             	lea    -0x1(%eax),%edx
+80101cc6:	8b 45 08             	mov    0x8(%ebp),%eax
+80101cc9:	89 50 08             	mov    %edx,0x8(%eax)
+  release(&icache.lock);
+80101ccc:	83 ec 0c             	sub    $0xc,%esp
+80101ccf:	68 80 2a 11 80       	push   $0x80112a80
+80101cd4:	e8 15 3b 00 00       	call   801057ee <release>
+80101cd9:	83 c4 10             	add    $0x10,%esp
+}
+80101cdc:	90                   	nop
+80101cdd:	c9                   	leave  
+80101cde:	c3                   	ret    
+
+80101cdf <iunlockput>:
+
+// Common idiom: unlock, then put.
+void
+iunlockput(struct inode *ip)
+{
+80101cdf:	f3 0f 1e fb          	endbr32 
+80101ce3:	55                   	push   %ebp
+80101ce4:	89 e5                	mov    %esp,%ebp
+80101ce6:	83 ec 08             	sub    $0x8,%esp
+  iunlock(ip);
+80101ce9:	83 ec 0c             	sub    $0xc,%esp
+80101cec:	ff 75 08             	pushl  0x8(%ebp)
+80101cef:	e8 c5 fe ff ff       	call   80101bb9 <iunlock>
+80101cf4:	83 c4 10             	add    $0x10,%esp
+  iput(ip);
+80101cf7:	83 ec 0c             	sub    $0xc,%esp
+80101cfa:	ff 75 08             	pushl  0x8(%ebp)
+80101cfd:	e8 09 ff ff ff       	call   80101c0b <iput>
+80101d02:	83 c4 10             	add    $0x10,%esp
+}
+80101d05:	90                   	nop
+80101d06:	c9                   	leave  
+80101d07:	c3                   	ret    
+
+80101d08 <bmap>:
+
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+80101d08:	f3 0f 1e fb          	endbr32 
+80101d0c:	55                   	push   %ebp
+80101d0d:	89 e5                	mov    %esp,%ebp
+80101d0f:	83 ec 18             	sub    $0x18,%esp
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+80101d12:	83 7d 0c 0b          	cmpl   $0xb,0xc(%ebp)
+80101d16:	77 42                	ja     80101d5a <bmap+0x52>
+    if((addr = ip->addrs[bn]) == 0)
+80101d18:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d1b:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101d1e:	83 c2 14             	add    $0x14,%edx
+80101d21:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
+80101d25:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101d28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80101d2c:	75 24                	jne    80101d52 <bmap+0x4a>
+      ip->addrs[bn] = addr = balloc(ip->dev);
+80101d2e:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d31:	8b 00                	mov    (%eax),%eax
+80101d33:	83 ec 0c             	sub    $0xc,%esp
+80101d36:	50                   	push   %eax
+80101d37:	e8 c7 f7 ff ff       	call   80101503 <balloc>
+80101d3c:	83 c4 10             	add    $0x10,%esp
+80101d3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101d42:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d45:	8b 55 0c             	mov    0xc(%ebp),%edx
+80101d48:	8d 4a 14             	lea    0x14(%edx),%ecx
+80101d4b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101d4e:	89 54 88 0c          	mov    %edx,0xc(%eax,%ecx,4)
+    return addr;
+80101d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101d55:	e9 d0 00 00 00       	jmp    80101e2a <bmap+0x122>
+  }
+  bn -= NDIRECT;
+80101d5a:	83 6d 0c 0c          	subl   $0xc,0xc(%ebp)
+
+  if(bn < NINDIRECT){
+80101d5e:	83 7d 0c 7f          	cmpl   $0x7f,0xc(%ebp)
+80101d62:	0f 87 b5 00 00 00    	ja     80101e1d <bmap+0x115>
+    // Load indirect block, allocating if necessary.
+    if((addr = ip->addrs[NDIRECT]) == 0)
+80101d68:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d6b:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
+80101d71:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101d74:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80101d78:	75 20                	jne    80101d9a <bmap+0x92>
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+80101d7a:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d7d:	8b 00                	mov    (%eax),%eax
+80101d7f:	83 ec 0c             	sub    $0xc,%esp
+80101d82:	50                   	push   %eax
+80101d83:	e8 7b f7 ff ff       	call   80101503 <balloc>
+80101d88:	83 c4 10             	add    $0x10,%esp
+80101d8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101d8e:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d91:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101d94:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
+    bp = bread(ip->dev, addr);
+80101d9a:	8b 45 08             	mov    0x8(%ebp),%eax
+80101d9d:	8b 00                	mov    (%eax),%eax
+80101d9f:	83 ec 08             	sub    $0x8,%esp
+80101da2:	ff 75 f4             	pushl  -0xc(%ebp)
+80101da5:	50                   	push   %eax
+80101da6:	e8 2c e4 ff ff       	call   801001d7 <bread>
+80101dab:	83 c4 10             	add    $0x10,%esp
+80101dae:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    a = (uint*)bp->data;
+80101db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101db4:	83 c0 5c             	add    $0x5c,%eax
+80101db7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if((addr = a[bn]) == 0){
+80101dba:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101dbd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80101dc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101dc7:	01 d0                	add    %edx,%eax
+80101dc9:	8b 00                	mov    (%eax),%eax
+80101dcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101dce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80101dd2:	75 36                	jne    80101e0a <bmap+0x102>
+      a[bn] = addr = balloc(ip->dev);
+80101dd4:	8b 45 08             	mov    0x8(%ebp),%eax
+80101dd7:	8b 00                	mov    (%eax),%eax
+80101dd9:	83 ec 0c             	sub    $0xc,%esp
+80101ddc:	50                   	push   %eax
+80101ddd:	e8 21 f7 ff ff       	call   80101503 <balloc>
+80101de2:	83 c4 10             	add    $0x10,%esp
+80101de5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80101de8:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101deb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80101df2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101df5:	01 c2                	add    %eax,%edx
+80101df7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101dfa:	89 02                	mov    %eax,(%edx)
+      log_write(bp);
+80101dfc:	83 ec 0c             	sub    $0xc,%esp
+80101dff:	ff 75 f0             	pushl  -0x10(%ebp)
+80101e02:	e8 b3 1a 00 00       	call   801038ba <log_write>
+80101e07:	83 c4 10             	add    $0x10,%esp
+    }
+    brelse(bp);
+80101e0a:	83 ec 0c             	sub    $0xc,%esp
+80101e0d:	ff 75 f0             	pushl  -0x10(%ebp)
+80101e10:	e8 4c e4 ff ff       	call   80100261 <brelse>
+80101e15:	83 c4 10             	add    $0x10,%esp
+    return addr;
+80101e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80101e1b:	eb 0d                	jmp    80101e2a <bmap+0x122>
+  }
+
+  panic("bmap: out of range");
+80101e1d:	83 ec 0c             	sub    $0xc,%esp
+80101e20:	68 86 8e 10 80       	push   $0x80108e86
+80101e25:	e8 a7 e7 ff ff       	call   801005d1 <panic>
+}
+80101e2a:	c9                   	leave  
+80101e2b:	c3                   	ret    
+
+80101e2c <itrunc>:
+// to it (no directory entries referring to it)
+// and has no in-memory reference to it (is
+// not an open file or current directory).
+static void
+itrunc(struct inode *ip)
+{
+80101e2c:	f3 0f 1e fb          	endbr32 
+80101e30:	55                   	push   %ebp
+80101e31:	89 e5                	mov    %esp,%ebp
+80101e33:	83 ec 18             	sub    $0x18,%esp
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+80101e36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80101e3d:	eb 45                	jmp    80101e84 <itrunc+0x58>
+    if(ip->addrs[i]){
+80101e3f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e42:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101e45:	83 c2 14             	add    $0x14,%edx
+80101e48:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
+80101e4c:	85 c0                	test   %eax,%eax
+80101e4e:	74 30                	je     80101e80 <itrunc+0x54>
+      bfree(ip->dev, ip->addrs[i]);
+80101e50:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e53:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101e56:	83 c2 14             	add    $0x14,%edx
+80101e59:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
+80101e5d:	8b 55 08             	mov    0x8(%ebp),%edx
+80101e60:	8b 12                	mov    (%edx),%edx
+80101e62:	83 ec 08             	sub    $0x8,%esp
+80101e65:	50                   	push   %eax
+80101e66:	52                   	push   %edx
+80101e67:	e8 e7 f7 ff ff       	call   80101653 <bfree>
+80101e6c:	83 c4 10             	add    $0x10,%esp
+      ip->addrs[i] = 0;
+80101e6f:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e72:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80101e75:	83 c2 14             	add    $0x14,%edx
+80101e78:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
+80101e7f:	00 
+  for(i = 0; i < NDIRECT; i++){
+80101e80:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80101e84:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
+80101e88:	7e b5                	jle    80101e3f <itrunc+0x13>
+    }
+  }
+
+  if(ip->addrs[NDIRECT]){
+80101e8a:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e8d:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
+80101e93:	85 c0                	test   %eax,%eax
+80101e95:	0f 84 aa 00 00 00    	je     80101f45 <itrunc+0x119>
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+80101e9b:	8b 45 08             	mov    0x8(%ebp),%eax
+80101e9e:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
+80101ea4:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ea7:	8b 00                	mov    (%eax),%eax
+80101ea9:	83 ec 08             	sub    $0x8,%esp
+80101eac:	52                   	push   %edx
+80101ead:	50                   	push   %eax
+80101eae:	e8 24 e3 ff ff       	call   801001d7 <bread>
+80101eb3:	83 c4 10             	add    $0x10,%esp
+80101eb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    a = (uint*)bp->data;
+80101eb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80101ebc:	83 c0 5c             	add    $0x5c,%eax
+80101ebf:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    for(j = 0; j < NINDIRECT; j++){
+80101ec2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+80101ec9:	eb 3c                	jmp    80101f07 <itrunc+0xdb>
+      if(a[j])
+80101ecb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101ece:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80101ed5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80101ed8:	01 d0                	add    %edx,%eax
+80101eda:	8b 00                	mov    (%eax),%eax
+80101edc:	85 c0                	test   %eax,%eax
+80101ede:	74 23                	je     80101f03 <itrunc+0xd7>
+        bfree(ip->dev, a[j]);
+80101ee0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101ee3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80101eea:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80101eed:	01 d0                	add    %edx,%eax
+80101eef:	8b 00                	mov    (%eax),%eax
+80101ef1:	8b 55 08             	mov    0x8(%ebp),%edx
+80101ef4:	8b 12                	mov    (%edx),%edx
+80101ef6:	83 ec 08             	sub    $0x8,%esp
+80101ef9:	50                   	push   %eax
+80101efa:	52                   	push   %edx
+80101efb:	e8 53 f7 ff ff       	call   80101653 <bfree>
+80101f00:	83 c4 10             	add    $0x10,%esp
+    for(j = 0; j < NINDIRECT; j++){
+80101f03:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+80101f07:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80101f0a:	83 f8 7f             	cmp    $0x7f,%eax
+80101f0d:	76 bc                	jbe    80101ecb <itrunc+0x9f>
+    }
+    brelse(bp);
+80101f0f:	83 ec 0c             	sub    $0xc,%esp
+80101f12:	ff 75 ec             	pushl  -0x14(%ebp)
+80101f15:	e8 47 e3 ff ff       	call   80100261 <brelse>
+80101f1a:	83 c4 10             	add    $0x10,%esp
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+80101f1d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f20:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
+80101f26:	8b 55 08             	mov    0x8(%ebp),%edx
+80101f29:	8b 12                	mov    (%edx),%edx
+80101f2b:	83 ec 08             	sub    $0x8,%esp
+80101f2e:	50                   	push   %eax
+80101f2f:	52                   	push   %edx
+80101f30:	e8 1e f7 ff ff       	call   80101653 <bfree>
+80101f35:	83 c4 10             	add    $0x10,%esp
+    ip->addrs[NDIRECT] = 0;
+80101f38:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f3b:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
+80101f42:	00 00 00 
+  }
+
+  ip->size = 0;
+80101f45:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f48:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
+  iupdate(ip);
+80101f4f:	83 ec 0c             	sub    $0xc,%esp
+80101f52:	ff 75 08             	pushl  0x8(%ebp)
+80101f55:	e8 5f f9 ff ff       	call   801018b9 <iupdate>
+80101f5a:	83 c4 10             	add    $0x10,%esp
+}
+80101f5d:	90                   	nop
+80101f5e:	c9                   	leave  
+80101f5f:	c3                   	ret    
+
+80101f60 <stati>:
+
+// Copy stat information from inode.
+// Caller must hold ip->lock.
+void
+stati(struct inode *ip, struct stat *st)
+{
+80101f60:	f3 0f 1e fb          	endbr32 
+80101f64:	55                   	push   %ebp
+80101f65:	89 e5                	mov    %esp,%ebp
+  st->dev = ip->dev;
+80101f67:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f6a:	8b 00                	mov    (%eax),%eax
+80101f6c:	89 c2                	mov    %eax,%edx
+80101f6e:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101f71:	89 50 04             	mov    %edx,0x4(%eax)
+  st->ino = ip->inum;
+80101f74:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f77:	8b 50 04             	mov    0x4(%eax),%edx
+80101f7a:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101f7d:	89 50 08             	mov    %edx,0x8(%eax)
+  st->type = ip->type;
+80101f80:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f83:	0f b7 50 50          	movzwl 0x50(%eax),%edx
+80101f87:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101f8a:	66 89 10             	mov    %dx,(%eax)
+  st->nlink = ip->nlink;
+80101f8d:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f90:	0f b7 50 56          	movzwl 0x56(%eax),%edx
+80101f94:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101f97:	66 89 50 0c          	mov    %dx,0xc(%eax)
+  st->size = ip->size;
+80101f9b:	8b 45 08             	mov    0x8(%ebp),%eax
+80101f9e:	8b 50 58             	mov    0x58(%eax),%edx
+80101fa1:	8b 45 0c             	mov    0xc(%ebp),%eax
+80101fa4:	89 50 10             	mov    %edx,0x10(%eax)
+}
+80101fa7:	90                   	nop
+80101fa8:	5d                   	pop    %ebp
+80101fa9:	c3                   	ret    
+
+80101faa <readi>:
+//PAGEBREAK!
+// Read data from inode.
+// Caller must hold ip->lock.
+int
+readi(struct inode *ip, char *dst, uint off, uint n)
+{
+80101faa:	f3 0f 1e fb          	endbr32 
+80101fae:	55                   	push   %ebp
+80101faf:	89 e5                	mov    %esp,%ebp
+80101fb1:	83 ec 18             	sub    $0x18,%esp
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+80101fb4:	8b 45 08             	mov    0x8(%ebp),%eax
+80101fb7:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+80101fbb:	66 83 f8 03          	cmp    $0x3,%ax
+80101fbf:	75 5c                	jne    8010201d <readi+0x73>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+80101fc1:	8b 45 08             	mov    0x8(%ebp),%eax
+80101fc4:	0f b7 40 52          	movzwl 0x52(%eax),%eax
+80101fc8:	66 85 c0             	test   %ax,%ax
+80101fcb:	78 20                	js     80101fed <readi+0x43>
+80101fcd:	8b 45 08             	mov    0x8(%ebp),%eax
+80101fd0:	0f b7 40 52          	movzwl 0x52(%eax),%eax
+80101fd4:	66 83 f8 09          	cmp    $0x9,%ax
+80101fd8:	7f 13                	jg     80101fed <readi+0x43>
+80101fda:	8b 45 08             	mov    0x8(%ebp),%eax
+80101fdd:	0f b7 40 52          	movzwl 0x52(%eax),%eax
+80101fe1:	98                   	cwtl   
+80101fe2:	8b 04 c5 00 2a 11 80 	mov    -0x7feed600(,%eax,8),%eax
+80101fe9:	85 c0                	test   %eax,%eax
+80101feb:	75 0a                	jne    80101ff7 <readi+0x4d>
+      return -1;
+80101fed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80101ff2:	e9 0a 01 00 00       	jmp    80102101 <readi+0x157>
+    return devsw[ip->major].read(ip, dst, n);
+80101ff7:	8b 45 08             	mov    0x8(%ebp),%eax
+80101ffa:	0f b7 40 52          	movzwl 0x52(%eax),%eax
+80101ffe:	98                   	cwtl   
+80101fff:	8b 04 c5 00 2a 11 80 	mov    -0x7feed600(,%eax,8),%eax
+80102006:	8b 55 14             	mov    0x14(%ebp),%edx
+80102009:	83 ec 04             	sub    $0x4,%esp
+8010200c:	52                   	push   %edx
+8010200d:	ff 75 0c             	pushl  0xc(%ebp)
+80102010:	ff 75 08             	pushl  0x8(%ebp)
+80102013:	ff d0                	call   *%eax
+80102015:	83 c4 10             	add    $0x10,%esp
+80102018:	e9 e4 00 00 00       	jmp    80102101 <readi+0x157>
+  }
+
+  if(off > ip->size || off + n < off)
+8010201d:	8b 45 08             	mov    0x8(%ebp),%eax
+80102020:	8b 40 58             	mov    0x58(%eax),%eax
+80102023:	39 45 10             	cmp    %eax,0x10(%ebp)
+80102026:	77 0d                	ja     80102035 <readi+0x8b>
+80102028:	8b 55 10             	mov    0x10(%ebp),%edx
+8010202b:	8b 45 14             	mov    0x14(%ebp),%eax
+8010202e:	01 d0                	add    %edx,%eax
+80102030:	39 45 10             	cmp    %eax,0x10(%ebp)
+80102033:	76 0a                	jbe    8010203f <readi+0x95>
+    return -1;
+80102035:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010203a:	e9 c2 00 00 00       	jmp    80102101 <readi+0x157>
+  if(off + n > ip->size)
+8010203f:	8b 55 10             	mov    0x10(%ebp),%edx
+80102042:	8b 45 14             	mov    0x14(%ebp),%eax
+80102045:	01 c2                	add    %eax,%edx
+80102047:	8b 45 08             	mov    0x8(%ebp),%eax
+8010204a:	8b 40 58             	mov    0x58(%eax),%eax
+8010204d:	39 c2                	cmp    %eax,%edx
+8010204f:	76 0c                	jbe    8010205d <readi+0xb3>
+    n = ip->size - off;
+80102051:	8b 45 08             	mov    0x8(%ebp),%eax
+80102054:	8b 40 58             	mov    0x58(%eax),%eax
+80102057:	2b 45 10             	sub    0x10(%ebp),%eax
+8010205a:	89 45 14             	mov    %eax,0x14(%ebp)
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+8010205d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80102064:	e9 89 00 00 00       	jmp    801020f2 <readi+0x148>
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+80102069:	8b 45 10             	mov    0x10(%ebp),%eax
+8010206c:	c1 e8 09             	shr    $0x9,%eax
+8010206f:	83 ec 08             	sub    $0x8,%esp
+80102072:	50                   	push   %eax
+80102073:	ff 75 08             	pushl  0x8(%ebp)
+80102076:	e8 8d fc ff ff       	call   80101d08 <bmap>
+8010207b:	83 c4 10             	add    $0x10,%esp
+8010207e:	8b 55 08             	mov    0x8(%ebp),%edx
+80102081:	8b 12                	mov    (%edx),%edx
+80102083:	83 ec 08             	sub    $0x8,%esp
+80102086:	50                   	push   %eax
+80102087:	52                   	push   %edx
+80102088:	e8 4a e1 ff ff       	call   801001d7 <bread>
+8010208d:	83 c4 10             	add    $0x10,%esp
+80102090:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    m = min(n - tot, BSIZE - off%BSIZE);
+80102093:	8b 45 10             	mov    0x10(%ebp),%eax
+80102096:	25 ff 01 00 00       	and    $0x1ff,%eax
+8010209b:	ba 00 02 00 00       	mov    $0x200,%edx
+801020a0:	29 c2                	sub    %eax,%edx
+801020a2:	8b 45 14             	mov    0x14(%ebp),%eax
+801020a5:	2b 45 f4             	sub    -0xc(%ebp),%eax
+801020a8:	39 c2                	cmp    %eax,%edx
+801020aa:	0f 46 c2             	cmovbe %edx,%eax
+801020ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memmove(dst, bp->data + off%BSIZE, m);
+801020b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801020b3:	8d 50 5c             	lea    0x5c(%eax),%edx
+801020b6:	8b 45 10             	mov    0x10(%ebp),%eax
+801020b9:	25 ff 01 00 00       	and    $0x1ff,%eax
+801020be:	01 d0                	add    %edx,%eax
+801020c0:	83 ec 04             	sub    $0x4,%esp
+801020c3:	ff 75 ec             	pushl  -0x14(%ebp)
+801020c6:	50                   	push   %eax
+801020c7:	ff 75 0c             	pushl  0xc(%ebp)
+801020ca:	e8 13 3a 00 00       	call   80105ae2 <memmove>
+801020cf:	83 c4 10             	add    $0x10,%esp
+    brelse(bp);
+801020d2:	83 ec 0c             	sub    $0xc,%esp
+801020d5:	ff 75 f0             	pushl  -0x10(%ebp)
+801020d8:	e8 84 e1 ff ff       	call   80100261 <brelse>
+801020dd:	83 c4 10             	add    $0x10,%esp
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+801020e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801020e3:	01 45 f4             	add    %eax,-0xc(%ebp)
+801020e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801020e9:	01 45 10             	add    %eax,0x10(%ebp)
+801020ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801020ef:	01 45 0c             	add    %eax,0xc(%ebp)
+801020f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801020f5:	3b 45 14             	cmp    0x14(%ebp),%eax
+801020f8:	0f 82 6b ff ff ff    	jb     80102069 <readi+0xbf>
+  }
+  return n;
+801020fe:	8b 45 14             	mov    0x14(%ebp),%eax
+}
+80102101:	c9                   	leave  
+80102102:	c3                   	ret    
+
+80102103 <writei>:
+// PAGEBREAK!
+// Write data to inode.
+// Caller must hold ip->lock.
+int
+writei(struct inode *ip, char *src, uint off, uint n)
+{
+80102103:	f3 0f 1e fb          	endbr32 
+80102107:	55                   	push   %ebp
+80102108:	89 e5                	mov    %esp,%ebp
+8010210a:	83 ec 18             	sub    $0x18,%esp
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+8010210d:	8b 45 08             	mov    0x8(%ebp),%eax
+80102110:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+80102114:	66 83 f8 03          	cmp    $0x3,%ax
+80102118:	75 5c                	jne    80102176 <writei+0x73>
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+8010211a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010211d:	0f b7 40 52          	movzwl 0x52(%eax),%eax
+80102121:	66 85 c0             	test   %ax,%ax
+80102124:	78 20                	js     80102146 <writei+0x43>
+80102126:	8b 45 08             	mov    0x8(%ebp),%eax
+80102129:	0f b7 40 52          	movzwl 0x52(%eax),%eax
+8010212d:	66 83 f8 09          	cmp    $0x9,%ax
+80102131:	7f 13                	jg     80102146 <writei+0x43>
+80102133:	8b 45 08             	mov    0x8(%ebp),%eax
+80102136:	0f b7 40 52          	movzwl 0x52(%eax),%eax
+8010213a:	98                   	cwtl   
+8010213b:	8b 04 c5 04 2a 11 80 	mov    -0x7feed5fc(,%eax,8),%eax
+80102142:	85 c0                	test   %eax,%eax
+80102144:	75 0a                	jne    80102150 <writei+0x4d>
+      return -1;
+80102146:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010214b:	e9 3b 01 00 00       	jmp    8010228b <writei+0x188>
+    return devsw[ip->major].write(ip, src, n);
+80102150:	8b 45 08             	mov    0x8(%ebp),%eax
+80102153:	0f b7 40 52          	movzwl 0x52(%eax),%eax
+80102157:	98                   	cwtl   
+80102158:	8b 04 c5 04 2a 11 80 	mov    -0x7feed5fc(,%eax,8),%eax
+8010215f:	8b 55 14             	mov    0x14(%ebp),%edx
+80102162:	83 ec 04             	sub    $0x4,%esp
+80102165:	52                   	push   %edx
+80102166:	ff 75 0c             	pushl  0xc(%ebp)
+80102169:	ff 75 08             	pushl  0x8(%ebp)
+8010216c:	ff d0                	call   *%eax
+8010216e:	83 c4 10             	add    $0x10,%esp
+80102171:	e9 15 01 00 00       	jmp    8010228b <writei+0x188>
+  }
+
+  if(off > ip->size || off + n < off)
+80102176:	8b 45 08             	mov    0x8(%ebp),%eax
+80102179:	8b 40 58             	mov    0x58(%eax),%eax
+8010217c:	39 45 10             	cmp    %eax,0x10(%ebp)
+8010217f:	77 0d                	ja     8010218e <writei+0x8b>
+80102181:	8b 55 10             	mov    0x10(%ebp),%edx
+80102184:	8b 45 14             	mov    0x14(%ebp),%eax
+80102187:	01 d0                	add    %edx,%eax
+80102189:	39 45 10             	cmp    %eax,0x10(%ebp)
+8010218c:	76 0a                	jbe    80102198 <writei+0x95>
+    return -1;
+8010218e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80102193:	e9 f3 00 00 00       	jmp    8010228b <writei+0x188>
+  if(off + n > MAXFILE*BSIZE)
+80102198:	8b 55 10             	mov    0x10(%ebp),%edx
+8010219b:	8b 45 14             	mov    0x14(%ebp),%eax
+8010219e:	01 d0                	add    %edx,%eax
+801021a0:	3d 00 18 01 00       	cmp    $0x11800,%eax
+801021a5:	76 0a                	jbe    801021b1 <writei+0xae>
+    return -1;
+801021a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801021ac:	e9 da 00 00 00       	jmp    8010228b <writei+0x188>
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+801021b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801021b8:	e9 97 00 00 00       	jmp    80102254 <writei+0x151>
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+801021bd:	8b 45 10             	mov    0x10(%ebp),%eax
+801021c0:	c1 e8 09             	shr    $0x9,%eax
+801021c3:	83 ec 08             	sub    $0x8,%esp
+801021c6:	50                   	push   %eax
+801021c7:	ff 75 08             	pushl  0x8(%ebp)
+801021ca:	e8 39 fb ff ff       	call   80101d08 <bmap>
+801021cf:	83 c4 10             	add    $0x10,%esp
+801021d2:	8b 55 08             	mov    0x8(%ebp),%edx
+801021d5:	8b 12                	mov    (%edx),%edx
+801021d7:	83 ec 08             	sub    $0x8,%esp
+801021da:	50                   	push   %eax
+801021db:	52                   	push   %edx
+801021dc:	e8 f6 df ff ff       	call   801001d7 <bread>
+801021e1:	83 c4 10             	add    $0x10,%esp
+801021e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    m = min(n - tot, BSIZE - off%BSIZE);
+801021e7:	8b 45 10             	mov    0x10(%ebp),%eax
+801021ea:	25 ff 01 00 00       	and    $0x1ff,%eax
+801021ef:	ba 00 02 00 00       	mov    $0x200,%edx
+801021f4:	29 c2                	sub    %eax,%edx
+801021f6:	8b 45 14             	mov    0x14(%ebp),%eax
+801021f9:	2b 45 f4             	sub    -0xc(%ebp),%eax
+801021fc:	39 c2                	cmp    %eax,%edx
+801021fe:	0f 46 c2             	cmovbe %edx,%eax
+80102201:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memmove(bp->data + off%BSIZE, src, m);
+80102204:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80102207:	8d 50 5c             	lea    0x5c(%eax),%edx
+8010220a:	8b 45 10             	mov    0x10(%ebp),%eax
+8010220d:	25 ff 01 00 00       	and    $0x1ff,%eax
+80102212:	01 d0                	add    %edx,%eax
+80102214:	83 ec 04             	sub    $0x4,%esp
+80102217:	ff 75 ec             	pushl  -0x14(%ebp)
+8010221a:	ff 75 0c             	pushl  0xc(%ebp)
+8010221d:	50                   	push   %eax
+8010221e:	e8 bf 38 00 00       	call   80105ae2 <memmove>
+80102223:	83 c4 10             	add    $0x10,%esp
+    log_write(bp);
+80102226:	83 ec 0c             	sub    $0xc,%esp
+80102229:	ff 75 f0             	pushl  -0x10(%ebp)
+8010222c:	e8 89 16 00 00       	call   801038ba <log_write>
+80102231:	83 c4 10             	add    $0x10,%esp
+    brelse(bp);
+80102234:	83 ec 0c             	sub    $0xc,%esp
+80102237:	ff 75 f0             	pushl  -0x10(%ebp)
+8010223a:	e8 22 e0 ff ff       	call   80100261 <brelse>
+8010223f:	83 c4 10             	add    $0x10,%esp
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+80102242:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80102245:	01 45 f4             	add    %eax,-0xc(%ebp)
+80102248:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010224b:	01 45 10             	add    %eax,0x10(%ebp)
+8010224e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80102251:	01 45 0c             	add    %eax,0xc(%ebp)
+80102254:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102257:	3b 45 14             	cmp    0x14(%ebp),%eax
+8010225a:	0f 82 5d ff ff ff    	jb     801021bd <writei+0xba>
+  }
+
+  if(n > 0 && off > ip->size){
+80102260:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+80102264:	74 22                	je     80102288 <writei+0x185>
+80102266:	8b 45 08             	mov    0x8(%ebp),%eax
+80102269:	8b 40 58             	mov    0x58(%eax),%eax
+8010226c:	39 45 10             	cmp    %eax,0x10(%ebp)
+8010226f:	76 17                	jbe    80102288 <writei+0x185>
+    ip->size = off;
+80102271:	8b 45 08             	mov    0x8(%ebp),%eax
+80102274:	8b 55 10             	mov    0x10(%ebp),%edx
+80102277:	89 50 58             	mov    %edx,0x58(%eax)
+    iupdate(ip);
+8010227a:	83 ec 0c             	sub    $0xc,%esp
+8010227d:	ff 75 08             	pushl  0x8(%ebp)
+80102280:	e8 34 f6 ff ff       	call   801018b9 <iupdate>
+80102285:	83 c4 10             	add    $0x10,%esp
+  }
+  return n;
+80102288:	8b 45 14             	mov    0x14(%ebp),%eax
+}
+8010228b:	c9                   	leave  
+8010228c:	c3                   	ret    
+
+8010228d <namecmp>:
+//PAGEBREAK!
+// Directories
+
+int
+namecmp(const char *s, const char *t)
+{
+8010228d:	f3 0f 1e fb          	endbr32 
+80102291:	55                   	push   %ebp
+80102292:	89 e5                	mov    %esp,%ebp
+80102294:	83 ec 08             	sub    $0x8,%esp
+  return strncmp(s, t, DIRSIZ);
+80102297:	83 ec 04             	sub    $0x4,%esp
+8010229a:	6a 0e                	push   $0xe
+8010229c:	ff 75 0c             	pushl  0xc(%ebp)
+8010229f:	ff 75 08             	pushl  0x8(%ebp)
+801022a2:	e8 d9 38 00 00       	call   80105b80 <strncmp>
+801022a7:	83 c4 10             	add    $0x10,%esp
+}
+801022aa:	c9                   	leave  
+801022ab:	c3                   	ret    
+
+801022ac <dirlookup>:
+
+// Look for a directory entry in a directory.
+// If found, set *poff to byte offset of entry.
+struct inode*
+dirlookup(struct inode *dp, char *name, uint *poff)
+{
+801022ac:	f3 0f 1e fb          	endbr32 
+801022b0:	55                   	push   %ebp
+801022b1:	89 e5                	mov    %esp,%ebp
+801022b3:	83 ec 28             	sub    $0x28,%esp
+  uint off, inum;
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+801022b6:	8b 45 08             	mov    0x8(%ebp),%eax
+801022b9:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+801022bd:	66 83 f8 01          	cmp    $0x1,%ax
+801022c1:	74 0d                	je     801022d0 <dirlookup+0x24>
+    panic("dirlookup not DIR");
+801022c3:	83 ec 0c             	sub    $0xc,%esp
+801022c6:	68 99 8e 10 80       	push   $0x80108e99
+801022cb:	e8 01 e3 ff ff       	call   801005d1 <panic>
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+801022d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801022d7:	eb 7b                	jmp    80102354 <dirlookup+0xa8>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+801022d9:	6a 10                	push   $0x10
+801022db:	ff 75 f4             	pushl  -0xc(%ebp)
+801022de:	8d 45 e0             	lea    -0x20(%ebp),%eax
+801022e1:	50                   	push   %eax
+801022e2:	ff 75 08             	pushl  0x8(%ebp)
+801022e5:	e8 c0 fc ff ff       	call   80101faa <readi>
+801022ea:	83 c4 10             	add    $0x10,%esp
+801022ed:	83 f8 10             	cmp    $0x10,%eax
+801022f0:	74 0d                	je     801022ff <dirlookup+0x53>
+      panic("dirlookup read");
+801022f2:	83 ec 0c             	sub    $0xc,%esp
+801022f5:	68 ab 8e 10 80       	push   $0x80108eab
+801022fa:	e8 d2 e2 ff ff       	call   801005d1 <panic>
+    if(de.inum == 0)
+801022ff:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
+80102303:	66 85 c0             	test   %ax,%ax
+80102306:	74 47                	je     8010234f <dirlookup+0xa3>
+      continue;
+    if(namecmp(name, de.name) == 0){
+80102308:	83 ec 08             	sub    $0x8,%esp
+8010230b:	8d 45 e0             	lea    -0x20(%ebp),%eax
+8010230e:	83 c0 02             	add    $0x2,%eax
+80102311:	50                   	push   %eax
+80102312:	ff 75 0c             	pushl  0xc(%ebp)
+80102315:	e8 73 ff ff ff       	call   8010228d <namecmp>
+8010231a:	83 c4 10             	add    $0x10,%esp
+8010231d:	85 c0                	test   %eax,%eax
+8010231f:	75 2f                	jne    80102350 <dirlookup+0xa4>
+      // entry matches path element
+      if(poff)
+80102321:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80102325:	74 08                	je     8010232f <dirlookup+0x83>
+        *poff = off;
+80102327:	8b 45 10             	mov    0x10(%ebp),%eax
+8010232a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010232d:	89 10                	mov    %edx,(%eax)
+      inum = de.inum;
+8010232f:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
+80102333:	0f b7 c0             	movzwl %ax,%eax
+80102336:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      return iget(dp->dev, inum);
+80102339:	8b 45 08             	mov    0x8(%ebp),%eax
+8010233c:	8b 00                	mov    (%eax),%eax
+8010233e:	83 ec 08             	sub    $0x8,%esp
+80102341:	ff 75 f0             	pushl  -0x10(%ebp)
+80102344:	50                   	push   %eax
+80102345:	e8 34 f6 ff ff       	call   8010197e <iget>
+8010234a:	83 c4 10             	add    $0x10,%esp
+8010234d:	eb 19                	jmp    80102368 <dirlookup+0xbc>
+      continue;
+8010234f:	90                   	nop
+  for(off = 0; off < dp->size; off += sizeof(de)){
+80102350:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
+80102354:	8b 45 08             	mov    0x8(%ebp),%eax
+80102357:	8b 40 58             	mov    0x58(%eax),%eax
+8010235a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+8010235d:	0f 82 76 ff ff ff    	jb     801022d9 <dirlookup+0x2d>
+    }
+  }
+
+  return 0;
+80102363:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80102368:	c9                   	leave  
+80102369:	c3                   	ret    
+
+8010236a <dirlink>:
+
+// Write a new directory entry (name, inum) into the directory dp.
+int
+dirlink(struct inode *dp, char *name, uint inum)
+{
+8010236a:	f3 0f 1e fb          	endbr32 
+8010236e:	55                   	push   %ebp
+8010236f:	89 e5                	mov    %esp,%ebp
+80102371:	83 ec 28             	sub    $0x28,%esp
+  int off;
+  struct dirent de;
+  struct inode *ip;
+
+  // Check that name is not present.
+  if((ip = dirlookup(dp, name, 0)) != 0){
+80102374:	83 ec 04             	sub    $0x4,%esp
+80102377:	6a 00                	push   $0x0
+80102379:	ff 75 0c             	pushl  0xc(%ebp)
+8010237c:	ff 75 08             	pushl  0x8(%ebp)
+8010237f:	e8 28 ff ff ff       	call   801022ac <dirlookup>
+80102384:	83 c4 10             	add    $0x10,%esp
+80102387:	89 45 f0             	mov    %eax,-0x10(%ebp)
+8010238a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+8010238e:	74 18                	je     801023a8 <dirlink+0x3e>
+    iput(ip);
+80102390:	83 ec 0c             	sub    $0xc,%esp
+80102393:	ff 75 f0             	pushl  -0x10(%ebp)
+80102396:	e8 70 f8 ff ff       	call   80101c0b <iput>
+8010239b:	83 c4 10             	add    $0x10,%esp
+    return -1;
+8010239e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801023a3:	e9 9c 00 00 00       	jmp    80102444 <dirlink+0xda>
+  }
+
+  // Look for an empty dirent.
+  for(off = 0; off < dp->size; off += sizeof(de)){
+801023a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801023af:	eb 39                	jmp    801023ea <dirlink+0x80>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+801023b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801023b4:	6a 10                	push   $0x10
+801023b6:	50                   	push   %eax
+801023b7:	8d 45 e0             	lea    -0x20(%ebp),%eax
+801023ba:	50                   	push   %eax
+801023bb:	ff 75 08             	pushl  0x8(%ebp)
+801023be:	e8 e7 fb ff ff       	call   80101faa <readi>
+801023c3:	83 c4 10             	add    $0x10,%esp
+801023c6:	83 f8 10             	cmp    $0x10,%eax
+801023c9:	74 0d                	je     801023d8 <dirlink+0x6e>
+      panic("dirlink read");
+801023cb:	83 ec 0c             	sub    $0xc,%esp
+801023ce:	68 ba 8e 10 80       	push   $0x80108eba
+801023d3:	e8 f9 e1 ff ff       	call   801005d1 <panic>
+    if(de.inum == 0)
+801023d8:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
+801023dc:	66 85 c0             	test   %ax,%ax
+801023df:	74 18                	je     801023f9 <dirlink+0x8f>
+  for(off = 0; off < dp->size; off += sizeof(de)){
+801023e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801023e4:	83 c0 10             	add    $0x10,%eax
+801023e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801023ea:	8b 45 08             	mov    0x8(%ebp),%eax
+801023ed:	8b 50 58             	mov    0x58(%eax),%edx
+801023f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801023f3:	39 c2                	cmp    %eax,%edx
+801023f5:	77 ba                	ja     801023b1 <dirlink+0x47>
+801023f7:	eb 01                	jmp    801023fa <dirlink+0x90>
+      break;
+801023f9:	90                   	nop
+  }
+
+  strncpy(de.name, name, DIRSIZ);
+801023fa:	83 ec 04             	sub    $0x4,%esp
+801023fd:	6a 0e                	push   $0xe
+801023ff:	ff 75 0c             	pushl  0xc(%ebp)
+80102402:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80102405:	83 c0 02             	add    $0x2,%eax
+80102408:	50                   	push   %eax
+80102409:	e8 cc 37 00 00       	call   80105bda <strncpy>
+8010240e:	83 c4 10             	add    $0x10,%esp
+  de.inum = inum;
+80102411:	8b 45 10             	mov    0x10(%ebp),%eax
+80102414:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80102418:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010241b:	6a 10                	push   $0x10
+8010241d:	50                   	push   %eax
+8010241e:	8d 45 e0             	lea    -0x20(%ebp),%eax
+80102421:	50                   	push   %eax
+80102422:	ff 75 08             	pushl  0x8(%ebp)
+80102425:	e8 d9 fc ff ff       	call   80102103 <writei>
+8010242a:	83 c4 10             	add    $0x10,%esp
+8010242d:	83 f8 10             	cmp    $0x10,%eax
+80102430:	74 0d                	je     8010243f <dirlink+0xd5>
+    panic("dirlink");
+80102432:	83 ec 0c             	sub    $0xc,%esp
+80102435:	68 c7 8e 10 80       	push   $0x80108ec7
+8010243a:	e8 92 e1 ff ff       	call   801005d1 <panic>
+
+  return 0;
+8010243f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80102444:	c9                   	leave  
+80102445:	c3                   	ret    
+
+80102446 <skipelem>:
+//   skipelem("a", name) = "", setting name = "a"
+//   skipelem("", name) = skipelem("////", name) = 0
+//
+static char*
+skipelem(char *path, char *name)
+{
+80102446:	f3 0f 1e fb          	endbr32 
+8010244a:	55                   	push   %ebp
+8010244b:	89 e5                	mov    %esp,%ebp
+8010244d:	83 ec 18             	sub    $0x18,%esp
+  char *s;
+  int len;
+
+  while(*path == '/')
+80102450:	eb 04                	jmp    80102456 <skipelem+0x10>
+    path++;
+80102452:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  while(*path == '/')
+80102456:	8b 45 08             	mov    0x8(%ebp),%eax
+80102459:	0f b6 00             	movzbl (%eax),%eax
+8010245c:	3c 2f                	cmp    $0x2f,%al
+8010245e:	74 f2                	je     80102452 <skipelem+0xc>
+  if(*path == 0)
+80102460:	8b 45 08             	mov    0x8(%ebp),%eax
+80102463:	0f b6 00             	movzbl (%eax),%eax
+80102466:	84 c0                	test   %al,%al
+80102468:	75 07                	jne    80102471 <skipelem+0x2b>
+    return 0;
+8010246a:	b8 00 00 00 00       	mov    $0x0,%eax
+8010246f:	eb 77                	jmp    801024e8 <skipelem+0xa2>
+  s = path;
+80102471:	8b 45 08             	mov    0x8(%ebp),%eax
+80102474:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(*path != '/' && *path != 0)
+80102477:	eb 04                	jmp    8010247d <skipelem+0x37>
+    path++;
+80102479:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  while(*path != '/' && *path != 0)
+8010247d:	8b 45 08             	mov    0x8(%ebp),%eax
+80102480:	0f b6 00             	movzbl (%eax),%eax
+80102483:	3c 2f                	cmp    $0x2f,%al
+80102485:	74 0a                	je     80102491 <skipelem+0x4b>
+80102487:	8b 45 08             	mov    0x8(%ebp),%eax
+8010248a:	0f b6 00             	movzbl (%eax),%eax
+8010248d:	84 c0                	test   %al,%al
+8010248f:	75 e8                	jne    80102479 <skipelem+0x33>
+  len = path - s;
+80102491:	8b 45 08             	mov    0x8(%ebp),%eax
+80102494:	2b 45 f4             	sub    -0xc(%ebp),%eax
+80102497:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(len >= DIRSIZ)
+8010249a:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+8010249e:	7e 15                	jle    801024b5 <skipelem+0x6f>
+    memmove(name, s, DIRSIZ);
+801024a0:	83 ec 04             	sub    $0x4,%esp
+801024a3:	6a 0e                	push   $0xe
+801024a5:	ff 75 f4             	pushl  -0xc(%ebp)
+801024a8:	ff 75 0c             	pushl  0xc(%ebp)
+801024ab:	e8 32 36 00 00       	call   80105ae2 <memmove>
+801024b0:	83 c4 10             	add    $0x10,%esp
+801024b3:	eb 26                	jmp    801024db <skipelem+0x95>
+  else {
+    memmove(name, s, len);
+801024b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801024b8:	83 ec 04             	sub    $0x4,%esp
+801024bb:	50                   	push   %eax
+801024bc:	ff 75 f4             	pushl  -0xc(%ebp)
+801024bf:	ff 75 0c             	pushl  0xc(%ebp)
+801024c2:	e8 1b 36 00 00       	call   80105ae2 <memmove>
+801024c7:	83 c4 10             	add    $0x10,%esp
+    name[len] = 0;
+801024ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
+801024cd:	8b 45 0c             	mov    0xc(%ebp),%eax
+801024d0:	01 d0                	add    %edx,%eax
+801024d2:	c6 00 00             	movb   $0x0,(%eax)
+  }
+  while(*path == '/')
+801024d5:	eb 04                	jmp    801024db <skipelem+0x95>
+    path++;
+801024d7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  while(*path == '/')
+801024db:	8b 45 08             	mov    0x8(%ebp),%eax
+801024de:	0f b6 00             	movzbl (%eax),%eax
+801024e1:	3c 2f                	cmp    $0x2f,%al
+801024e3:	74 f2                	je     801024d7 <skipelem+0x91>
+  return path;
+801024e5:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+801024e8:	c9                   	leave  
+801024e9:	c3                   	ret    
+
+801024ea <namex>:
+// If parent != 0, return the inode for the parent and copy the final
+// path element into name, which must have room for DIRSIZ bytes.
+// Must be called inside a transaction since it calls iput().
+static struct inode*
+namex(char *path, int nameiparent, char *name)
+{
+801024ea:	f3 0f 1e fb          	endbr32 
+801024ee:	55                   	push   %ebp
+801024ef:	89 e5                	mov    %esp,%ebp
+801024f1:	83 ec 18             	sub    $0x18,%esp
+  struct inode *ip, *next;
+
+  if(*path == '/')
+801024f4:	8b 45 08             	mov    0x8(%ebp),%eax
+801024f7:	0f b6 00             	movzbl (%eax),%eax
+801024fa:	3c 2f                	cmp    $0x2f,%al
+801024fc:	75 17                	jne    80102515 <namex+0x2b>
+    ip = iget(ROOTDEV, ROOTINO);
+801024fe:	83 ec 08             	sub    $0x8,%esp
+80102501:	6a 01                	push   $0x1
+80102503:	6a 01                	push   $0x1
+80102505:	e8 74 f4 ff ff       	call   8010197e <iget>
+8010250a:	83 c4 10             	add    $0x10,%esp
+8010250d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80102510:	e9 ba 00 00 00       	jmp    801025cf <namex+0xe5>
+  else
+    ip = idup(myproc()->cwd);
+80102515:	e8 8f 20 00 00       	call   801045a9 <myproc>
+8010251a:	8b 40 78             	mov    0x78(%eax),%eax
+8010251d:	83 ec 0c             	sub    $0xc,%esp
+80102520:	50                   	push   %eax
+80102521:	e8 3e f5 ff ff       	call   80101a64 <idup>
+80102526:	83 c4 10             	add    $0x10,%esp
+80102529:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+  while((path = skipelem(path, name)) != 0){
+8010252c:	e9 9e 00 00 00       	jmp    801025cf <namex+0xe5>
+    ilock(ip);
+80102531:	83 ec 0c             	sub    $0xc,%esp
+80102534:	ff 75 f4             	pushl  -0xc(%ebp)
+80102537:	e8 66 f5 ff ff       	call   80101aa2 <ilock>
+8010253c:	83 c4 10             	add    $0x10,%esp
+    if(ip->type != T_DIR){
+8010253f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102542:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+80102546:	66 83 f8 01          	cmp    $0x1,%ax
+8010254a:	74 18                	je     80102564 <namex+0x7a>
+      iunlockput(ip);
+8010254c:	83 ec 0c             	sub    $0xc,%esp
+8010254f:	ff 75 f4             	pushl  -0xc(%ebp)
+80102552:	e8 88 f7 ff ff       	call   80101cdf <iunlockput>
+80102557:	83 c4 10             	add    $0x10,%esp
+      return 0;
+8010255a:	b8 00 00 00 00       	mov    $0x0,%eax
+8010255f:	e9 a7 00 00 00       	jmp    8010260b <namex+0x121>
+    }
+    if(nameiparent && *path == '\0'){
+80102564:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+80102568:	74 20                	je     8010258a <namex+0xa0>
+8010256a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010256d:	0f b6 00             	movzbl (%eax),%eax
+80102570:	84 c0                	test   %al,%al
+80102572:	75 16                	jne    8010258a <namex+0xa0>
+      // Stop one level early.
+      iunlock(ip);
+80102574:	83 ec 0c             	sub    $0xc,%esp
+80102577:	ff 75 f4             	pushl  -0xc(%ebp)
+8010257a:	e8 3a f6 ff ff       	call   80101bb9 <iunlock>
+8010257f:	83 c4 10             	add    $0x10,%esp
+      return ip;
+80102582:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102585:	e9 81 00 00 00       	jmp    8010260b <namex+0x121>
+    }
+    if((next = dirlookup(ip, name, 0)) == 0){
+8010258a:	83 ec 04             	sub    $0x4,%esp
+8010258d:	6a 00                	push   $0x0
+8010258f:	ff 75 10             	pushl  0x10(%ebp)
+80102592:	ff 75 f4             	pushl  -0xc(%ebp)
+80102595:	e8 12 fd ff ff       	call   801022ac <dirlookup>
+8010259a:	83 c4 10             	add    $0x10,%esp
+8010259d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+801025a0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801025a4:	75 15                	jne    801025bb <namex+0xd1>
+      iunlockput(ip);
+801025a6:	83 ec 0c             	sub    $0xc,%esp
+801025a9:	ff 75 f4             	pushl  -0xc(%ebp)
+801025ac:	e8 2e f7 ff ff       	call   80101cdf <iunlockput>
+801025b1:	83 c4 10             	add    $0x10,%esp
+      return 0;
+801025b4:	b8 00 00 00 00       	mov    $0x0,%eax
+801025b9:	eb 50                	jmp    8010260b <namex+0x121>
+    }
+    iunlockput(ip);
+801025bb:	83 ec 0c             	sub    $0xc,%esp
+801025be:	ff 75 f4             	pushl  -0xc(%ebp)
+801025c1:	e8 19 f7 ff ff       	call   80101cdf <iunlockput>
+801025c6:	83 c4 10             	add    $0x10,%esp
+    ip = next;
+801025c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801025cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while((path = skipelem(path, name)) != 0){
+801025cf:	83 ec 08             	sub    $0x8,%esp
+801025d2:	ff 75 10             	pushl  0x10(%ebp)
+801025d5:	ff 75 08             	pushl  0x8(%ebp)
+801025d8:	e8 69 fe ff ff       	call   80102446 <skipelem>
+801025dd:	83 c4 10             	add    $0x10,%esp
+801025e0:	89 45 08             	mov    %eax,0x8(%ebp)
+801025e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+801025e7:	0f 85 44 ff ff ff    	jne    80102531 <namex+0x47>
+  }
+  if(nameiparent){
+801025ed:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+801025f1:	74 15                	je     80102608 <namex+0x11e>
+    iput(ip);
+801025f3:	83 ec 0c             	sub    $0xc,%esp
+801025f6:	ff 75 f4             	pushl  -0xc(%ebp)
+801025f9:	e8 0d f6 ff ff       	call   80101c0b <iput>
+801025fe:	83 c4 10             	add    $0x10,%esp
+    return 0;
+80102601:	b8 00 00 00 00       	mov    $0x0,%eax
+80102606:	eb 03                	jmp    8010260b <namex+0x121>
+  }
+  return ip;
+80102608:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+8010260b:	c9                   	leave  
+8010260c:	c3                   	ret    
+
+8010260d <namei>:
+
+struct inode*
+namei(char *path)
+{
+8010260d:	f3 0f 1e fb          	endbr32 
+80102611:	55                   	push   %ebp
+80102612:	89 e5                	mov    %esp,%ebp
+80102614:	83 ec 18             	sub    $0x18,%esp
+  char name[DIRSIZ];
+  return namex(path, 0, name);
+80102617:	83 ec 04             	sub    $0x4,%esp
+8010261a:	8d 45 ea             	lea    -0x16(%ebp),%eax
+8010261d:	50                   	push   %eax
+8010261e:	6a 00                	push   $0x0
+80102620:	ff 75 08             	pushl  0x8(%ebp)
+80102623:	e8 c2 fe ff ff       	call   801024ea <namex>
+80102628:	83 c4 10             	add    $0x10,%esp
+}
+8010262b:	c9                   	leave  
+8010262c:	c3                   	ret    
+
+8010262d <nameiparent>:
+
+struct inode*
+nameiparent(char *path, char *name)
+{
+8010262d:	f3 0f 1e fb          	endbr32 
+80102631:	55                   	push   %ebp
+80102632:	89 e5                	mov    %esp,%ebp
+80102634:	83 ec 08             	sub    $0x8,%esp
+  return namex(path, 1, name);
+80102637:	83 ec 04             	sub    $0x4,%esp
+8010263a:	ff 75 0c             	pushl  0xc(%ebp)
+8010263d:	6a 01                	push   $0x1
+8010263f:	ff 75 08             	pushl  0x8(%ebp)
+80102642:	e8 a3 fe ff ff       	call   801024ea <namex>
+80102647:	83 c4 10             	add    $0x10,%esp
+}
+8010264a:	c9                   	leave  
+8010264b:	c3                   	ret    
+
+8010264c <inb>:
+{
+8010264c:	55                   	push   %ebp
+8010264d:	89 e5                	mov    %esp,%ebp
+8010264f:	83 ec 14             	sub    $0x14,%esp
+80102652:	8b 45 08             	mov    0x8(%ebp),%eax
+80102655:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102659:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+8010265d:	89 c2                	mov    %eax,%edx
+8010265f:	ec                   	in     (%dx),%al
+80102660:	88 45 ff             	mov    %al,-0x1(%ebp)
+  return data;
+80102663:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
+}
+80102667:	c9                   	leave  
+80102668:	c3                   	ret    
+
+80102669 <insl>:
+{
+80102669:	55                   	push   %ebp
+8010266a:	89 e5                	mov    %esp,%ebp
+8010266c:	57                   	push   %edi
+8010266d:	53                   	push   %ebx
+  asm volatile("cld; rep insl" :
+8010266e:	8b 55 08             	mov    0x8(%ebp),%edx
+80102671:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+80102674:	8b 45 10             	mov    0x10(%ebp),%eax
+80102677:	89 cb                	mov    %ecx,%ebx
+80102679:	89 df                	mov    %ebx,%edi
+8010267b:	89 c1                	mov    %eax,%ecx
+8010267d:	fc                   	cld    
+8010267e:	f3 6d                	rep insl (%dx),%es:(%edi)
+80102680:	89 c8                	mov    %ecx,%eax
+80102682:	89 fb                	mov    %edi,%ebx
+80102684:	89 5d 0c             	mov    %ebx,0xc(%ebp)
+80102687:	89 45 10             	mov    %eax,0x10(%ebp)
+}
+8010268a:	90                   	nop
+8010268b:	5b                   	pop    %ebx
+8010268c:	5f                   	pop    %edi
+8010268d:	5d                   	pop    %ebp
+8010268e:	c3                   	ret    
+
+8010268f <outb>:
+{
+8010268f:	55                   	push   %ebp
+80102690:	89 e5                	mov    %esp,%ebp
+80102692:	83 ec 08             	sub    $0x8,%esp
+80102695:	8b 45 08             	mov    0x8(%ebp),%eax
+80102698:	8b 55 0c             	mov    0xc(%ebp),%edx
+8010269b:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+8010269f:	89 d0                	mov    %edx,%eax
+801026a1:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+801026a4:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+801026a8:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+801026ac:	ee                   	out    %al,(%dx)
+}
+801026ad:	90                   	nop
+801026ae:	c9                   	leave  
+801026af:	c3                   	ret    
+
+801026b0 <outsl>:
+{
+801026b0:	55                   	push   %ebp
+801026b1:	89 e5                	mov    %esp,%ebp
+801026b3:	56                   	push   %esi
+801026b4:	53                   	push   %ebx
+  asm volatile("cld; rep outsl" :
+801026b5:	8b 55 08             	mov    0x8(%ebp),%edx
+801026b8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+801026bb:	8b 45 10             	mov    0x10(%ebp),%eax
+801026be:	89 cb                	mov    %ecx,%ebx
+801026c0:	89 de                	mov    %ebx,%esi
+801026c2:	89 c1                	mov    %eax,%ecx
+801026c4:	fc                   	cld    
+801026c5:	f3 6f                	rep outsl %ds:(%esi),(%dx)
+801026c7:	89 c8                	mov    %ecx,%eax
+801026c9:	89 f3                	mov    %esi,%ebx
+801026cb:	89 5d 0c             	mov    %ebx,0xc(%ebp)
+801026ce:	89 45 10             	mov    %eax,0x10(%ebp)
+}
+801026d1:	90                   	nop
+801026d2:	5b                   	pop    %ebx
+801026d3:	5e                   	pop    %esi
+801026d4:	5d                   	pop    %ebp
+801026d5:	c3                   	ret    
+
+801026d6 <idewait>:
+static void idestart(struct buf*);
+
+// Wait for IDE disk to become ready.
+static int
+idewait(int checkerr)
+{
+801026d6:	f3 0f 1e fb          	endbr32 
+801026da:	55                   	push   %ebp
+801026db:	89 e5                	mov    %esp,%ebp
+801026dd:	83 ec 10             	sub    $0x10,%esp
+  int r;
+
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+801026e0:	90                   	nop
+801026e1:	68 f7 01 00 00       	push   $0x1f7
+801026e6:	e8 61 ff ff ff       	call   8010264c <inb>
+801026eb:	83 c4 04             	add    $0x4,%esp
+801026ee:	0f b6 c0             	movzbl %al,%eax
+801026f1:	89 45 fc             	mov    %eax,-0x4(%ebp)
+801026f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+801026f7:	25 c0 00 00 00       	and    $0xc0,%eax
+801026fc:	83 f8 40             	cmp    $0x40,%eax
+801026ff:	75 e0                	jne    801026e1 <idewait+0xb>
+    ;
+  if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+80102701:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80102705:	74 11                	je     80102718 <idewait+0x42>
+80102707:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010270a:	83 e0 21             	and    $0x21,%eax
+8010270d:	85 c0                	test   %eax,%eax
+8010270f:	74 07                	je     80102718 <idewait+0x42>
+    return -1;
+80102711:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80102716:	eb 05                	jmp    8010271d <idewait+0x47>
+  return 0;
+80102718:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+8010271d:	c9                   	leave  
+8010271e:	c3                   	ret    
+
+8010271f <ideinit>:
+
+void
+ideinit(void)
+{
+8010271f:	f3 0f 1e fb          	endbr32 
+80102723:	55                   	push   %ebp
+80102724:	89 e5                	mov    %esp,%ebp
+80102726:	83 ec 18             	sub    $0x18,%esp
+  int i;
+
+  initlock(&idelock, "ide");
+80102729:	83 ec 08             	sub    $0x8,%esp
+8010272c:	68 cf 8e 10 80       	push   $0x80108ecf
+80102731:	68 00 c6 10 80       	push   $0x8010c600
+80102736:	e8 1b 30 00 00       	call   80105756 <initlock>
+8010273b:	83 c4 10             	add    $0x10,%esp
+  ioapicenable(IRQ_IDE, ncpu - 1);
+8010273e:	a1 a0 4d 11 80       	mov    0x80114da0,%eax
+80102743:	83 e8 01             	sub    $0x1,%eax
+80102746:	83 ec 08             	sub    $0x8,%esp
+80102749:	50                   	push   %eax
+8010274a:	6a 0e                	push   $0xe
+8010274c:	e8 bb 04 00 00       	call   80102c0c <ioapicenable>
+80102751:	83 c4 10             	add    $0x10,%esp
+  idewait(0);
+80102754:	83 ec 0c             	sub    $0xc,%esp
+80102757:	6a 00                	push   $0x0
+80102759:	e8 78 ff ff ff       	call   801026d6 <idewait>
+8010275e:	83 c4 10             	add    $0x10,%esp
+
+  // Check if disk 1 is present
+  outb(0x1f6, 0xe0 | (1<<4));
+80102761:	83 ec 08             	sub    $0x8,%esp
+80102764:	68 f0 00 00 00       	push   $0xf0
+80102769:	68 f6 01 00 00       	push   $0x1f6
+8010276e:	e8 1c ff ff ff       	call   8010268f <outb>
+80102773:	83 c4 10             	add    $0x10,%esp
+  for(i=0; i<1000; i++){
+80102776:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+8010277d:	eb 24                	jmp    801027a3 <ideinit+0x84>
+    if(inb(0x1f7) != 0){
+8010277f:	83 ec 0c             	sub    $0xc,%esp
+80102782:	68 f7 01 00 00       	push   $0x1f7
+80102787:	e8 c0 fe ff ff       	call   8010264c <inb>
+8010278c:	83 c4 10             	add    $0x10,%esp
+8010278f:	84 c0                	test   %al,%al
+80102791:	74 0c                	je     8010279f <ideinit+0x80>
+      havedisk1 = 1;
+80102793:	c7 05 38 c6 10 80 01 	movl   $0x1,0x8010c638
+8010279a:	00 00 00 
+      break;
+8010279d:	eb 0d                	jmp    801027ac <ideinit+0x8d>
+  for(i=0; i<1000; i++){
+8010279f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801027a3:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
+801027aa:	7e d3                	jle    8010277f <ideinit+0x60>
+    }
+  }
+
+  // Switch back to disk 0.
+  outb(0x1f6, 0xe0 | (0<<4));
+801027ac:	83 ec 08             	sub    $0x8,%esp
+801027af:	68 e0 00 00 00       	push   $0xe0
+801027b4:	68 f6 01 00 00       	push   $0x1f6
+801027b9:	e8 d1 fe ff ff       	call   8010268f <outb>
+801027be:	83 c4 10             	add    $0x10,%esp
+}
+801027c1:	90                   	nop
+801027c2:	c9                   	leave  
+801027c3:	c3                   	ret    
+
+801027c4 <idestart>:
+
+// Start the request for b.  Caller must hold idelock.
+static void
+idestart(struct buf *b)
+{
+801027c4:	f3 0f 1e fb          	endbr32 
+801027c8:	55                   	push   %ebp
+801027c9:	89 e5                	mov    %esp,%ebp
+801027cb:	83 ec 18             	sub    $0x18,%esp
+  if(b == 0)
+801027ce:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+801027d2:	75 0d                	jne    801027e1 <idestart+0x1d>
+    panic("idestart");
+801027d4:	83 ec 0c             	sub    $0xc,%esp
+801027d7:	68 d3 8e 10 80       	push   $0x80108ed3
+801027dc:	e8 f0 dd ff ff       	call   801005d1 <panic>
+  if(b->blockno >= FSSIZE)
+801027e1:	8b 45 08             	mov    0x8(%ebp),%eax
+801027e4:	8b 40 08             	mov    0x8(%eax),%eax
+801027e7:	3d e7 03 00 00       	cmp    $0x3e7,%eax
+801027ec:	76 0d                	jbe    801027fb <idestart+0x37>
+    panic("incorrect blockno");
+801027ee:	83 ec 0c             	sub    $0xc,%esp
+801027f1:	68 dc 8e 10 80       	push   $0x80108edc
+801027f6:	e8 d6 dd ff ff       	call   801005d1 <panic>
+  int sector_per_block =  BSIZE/SECTOR_SIZE;
+801027fb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+  int sector = b->blockno * sector_per_block;
+80102802:	8b 45 08             	mov    0x8(%ebp),%eax
+80102805:	8b 50 08             	mov    0x8(%eax),%edx
+80102808:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010280b:	0f af c2             	imul   %edx,%eax
+8010280e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
+80102811:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
+80102815:	75 07                	jne    8010281e <idestart+0x5a>
+80102817:	b8 20 00 00 00       	mov    $0x20,%eax
+8010281c:	eb 05                	jmp    80102823 <idestart+0x5f>
+8010281e:	b8 c4 00 00 00       	mov    $0xc4,%eax
+80102823:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
+80102826:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
+8010282a:	75 07                	jne    80102833 <idestart+0x6f>
+8010282c:	b8 30 00 00 00       	mov    $0x30,%eax
+80102831:	eb 05                	jmp    80102838 <idestart+0x74>
+80102833:	b8 c5 00 00 00       	mov    $0xc5,%eax
+80102838:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+  if (sector_per_block > 7) panic("idestart");
+8010283b:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
+8010283f:	7e 0d                	jle    8010284e <idestart+0x8a>
+80102841:	83 ec 0c             	sub    $0xc,%esp
+80102844:	68 d3 8e 10 80       	push   $0x80108ed3
+80102849:	e8 83 dd ff ff       	call   801005d1 <panic>
+
+  idewait(0);
+8010284e:	83 ec 0c             	sub    $0xc,%esp
+80102851:	6a 00                	push   $0x0
+80102853:	e8 7e fe ff ff       	call   801026d6 <idewait>
+80102858:	83 c4 10             	add    $0x10,%esp
+  outb(0x3f6, 0);  // generate interrupt
+8010285b:	83 ec 08             	sub    $0x8,%esp
+8010285e:	6a 00                	push   $0x0
+80102860:	68 f6 03 00 00       	push   $0x3f6
+80102865:	e8 25 fe ff ff       	call   8010268f <outb>
+8010286a:	83 c4 10             	add    $0x10,%esp
+  outb(0x1f2, sector_per_block);  // number of sectors
+8010286d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102870:	0f b6 c0             	movzbl %al,%eax
+80102873:	83 ec 08             	sub    $0x8,%esp
+80102876:	50                   	push   %eax
+80102877:	68 f2 01 00 00       	push   $0x1f2
+8010287c:	e8 0e fe ff ff       	call   8010268f <outb>
+80102881:	83 c4 10             	add    $0x10,%esp
+  outb(0x1f3, sector & 0xff);
+80102884:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80102887:	0f b6 c0             	movzbl %al,%eax
+8010288a:	83 ec 08             	sub    $0x8,%esp
+8010288d:	50                   	push   %eax
+8010288e:	68 f3 01 00 00       	push   $0x1f3
+80102893:	e8 f7 fd ff ff       	call   8010268f <outb>
+80102898:	83 c4 10             	add    $0x10,%esp
+  outb(0x1f4, (sector >> 8) & 0xff);
+8010289b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010289e:	c1 f8 08             	sar    $0x8,%eax
+801028a1:	0f b6 c0             	movzbl %al,%eax
+801028a4:	83 ec 08             	sub    $0x8,%esp
+801028a7:	50                   	push   %eax
+801028a8:	68 f4 01 00 00       	push   $0x1f4
+801028ad:	e8 dd fd ff ff       	call   8010268f <outb>
+801028b2:	83 c4 10             	add    $0x10,%esp
+  outb(0x1f5, (sector >> 16) & 0xff);
+801028b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801028b8:	c1 f8 10             	sar    $0x10,%eax
+801028bb:	0f b6 c0             	movzbl %al,%eax
+801028be:	83 ec 08             	sub    $0x8,%esp
+801028c1:	50                   	push   %eax
+801028c2:	68 f5 01 00 00       	push   $0x1f5
+801028c7:	e8 c3 fd ff ff       	call   8010268f <outb>
+801028cc:	83 c4 10             	add    $0x10,%esp
+  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+801028cf:	8b 45 08             	mov    0x8(%ebp),%eax
+801028d2:	8b 40 04             	mov    0x4(%eax),%eax
+801028d5:	c1 e0 04             	shl    $0x4,%eax
+801028d8:	83 e0 10             	and    $0x10,%eax
+801028db:	89 c2                	mov    %eax,%edx
+801028dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801028e0:	c1 f8 18             	sar    $0x18,%eax
+801028e3:	83 e0 0f             	and    $0xf,%eax
+801028e6:	09 d0                	or     %edx,%eax
+801028e8:	83 c8 e0             	or     $0xffffffe0,%eax
+801028eb:	0f b6 c0             	movzbl %al,%eax
+801028ee:	83 ec 08             	sub    $0x8,%esp
+801028f1:	50                   	push   %eax
+801028f2:	68 f6 01 00 00       	push   $0x1f6
+801028f7:	e8 93 fd ff ff       	call   8010268f <outb>
+801028fc:	83 c4 10             	add    $0x10,%esp
+  if(b->flags & B_DIRTY){
+801028ff:	8b 45 08             	mov    0x8(%ebp),%eax
+80102902:	8b 00                	mov    (%eax),%eax
+80102904:	83 e0 04             	and    $0x4,%eax
+80102907:	85 c0                	test   %eax,%eax
+80102909:	74 35                	je     80102940 <idestart+0x17c>
+    outb(0x1f7, write_cmd);
+8010290b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+8010290e:	0f b6 c0             	movzbl %al,%eax
+80102911:	83 ec 08             	sub    $0x8,%esp
+80102914:	50                   	push   %eax
+80102915:	68 f7 01 00 00       	push   $0x1f7
+8010291a:	e8 70 fd ff ff       	call   8010268f <outb>
+8010291f:	83 c4 10             	add    $0x10,%esp
+    outsl(0x1f0, b->data, BSIZE/4);
+80102922:	8b 45 08             	mov    0x8(%ebp),%eax
+80102925:	83 c0 5c             	add    $0x5c,%eax
+80102928:	83 ec 04             	sub    $0x4,%esp
+8010292b:	68 80 00 00 00       	push   $0x80
+80102930:	50                   	push   %eax
+80102931:	68 f0 01 00 00       	push   $0x1f0
+80102936:	e8 75 fd ff ff       	call   801026b0 <outsl>
+8010293b:	83 c4 10             	add    $0x10,%esp
+  } else {
+    outb(0x1f7, read_cmd);
+  }
+}
+8010293e:	eb 17                	jmp    80102957 <idestart+0x193>
+    outb(0x1f7, read_cmd);
+80102940:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80102943:	0f b6 c0             	movzbl %al,%eax
+80102946:	83 ec 08             	sub    $0x8,%esp
+80102949:	50                   	push   %eax
+8010294a:	68 f7 01 00 00       	push   $0x1f7
+8010294f:	e8 3b fd ff ff       	call   8010268f <outb>
+80102954:	83 c4 10             	add    $0x10,%esp
+}
+80102957:	90                   	nop
+80102958:	c9                   	leave  
+80102959:	c3                   	ret    
+
+8010295a <ideintr>:
+
+// Interrupt handler.
+void
+ideintr(void)
+{
+8010295a:	f3 0f 1e fb          	endbr32 
+8010295e:	55                   	push   %ebp
+8010295f:	89 e5                	mov    %esp,%ebp
+80102961:	83 ec 18             	sub    $0x18,%esp
+  struct buf *b;
+
+  // First queued buffer is the active request.
+  acquire(&idelock);
+80102964:	83 ec 0c             	sub    $0xc,%esp
+80102967:	68 00 c6 10 80       	push   $0x8010c600
+8010296c:	e8 0b 2e 00 00       	call   8010577c <acquire>
+80102971:	83 c4 10             	add    $0x10,%esp
+
+  if((b = idequeue) == 0){
+80102974:	a1 34 c6 10 80       	mov    0x8010c634,%eax
+80102979:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010297c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80102980:	75 15                	jne    80102997 <ideintr+0x3d>
+    release(&idelock);
+80102982:	83 ec 0c             	sub    $0xc,%esp
+80102985:	68 00 c6 10 80       	push   $0x8010c600
+8010298a:	e8 5f 2e 00 00       	call   801057ee <release>
+8010298f:	83 c4 10             	add    $0x10,%esp
+    return;
+80102992:	e9 9a 00 00 00       	jmp    80102a31 <ideintr+0xd7>
+  }
+  idequeue = b->qnext;
+80102997:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010299a:	8b 40 58             	mov    0x58(%eax),%eax
+8010299d:	a3 34 c6 10 80       	mov    %eax,0x8010c634
+
+  // Read data if needed.
+  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+801029a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801029a5:	8b 00                	mov    (%eax),%eax
+801029a7:	83 e0 04             	and    $0x4,%eax
+801029aa:	85 c0                	test   %eax,%eax
+801029ac:	75 2d                	jne    801029db <ideintr+0x81>
+801029ae:	83 ec 0c             	sub    $0xc,%esp
+801029b1:	6a 01                	push   $0x1
+801029b3:	e8 1e fd ff ff       	call   801026d6 <idewait>
+801029b8:	83 c4 10             	add    $0x10,%esp
+801029bb:	85 c0                	test   %eax,%eax
+801029bd:	78 1c                	js     801029db <ideintr+0x81>
+    insl(0x1f0, b->data, BSIZE/4);
+801029bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801029c2:	83 c0 5c             	add    $0x5c,%eax
+801029c5:	83 ec 04             	sub    $0x4,%esp
+801029c8:	68 80 00 00 00       	push   $0x80
+801029cd:	50                   	push   %eax
+801029ce:	68 f0 01 00 00       	push   $0x1f0
+801029d3:	e8 91 fc ff ff       	call   80102669 <insl>
+801029d8:	83 c4 10             	add    $0x10,%esp
+
+  // Wake process waiting for this buf.
+  b->flags |= B_VALID;
+801029db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801029de:	8b 00                	mov    (%eax),%eax
+801029e0:	83 c8 02             	or     $0x2,%eax
+801029e3:	89 c2                	mov    %eax,%edx
+801029e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801029e8:	89 10                	mov    %edx,(%eax)
+  b->flags &= ~B_DIRTY;
+801029ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801029ed:	8b 00                	mov    (%eax),%eax
+801029ef:	83 e0 fb             	and    $0xfffffffb,%eax
+801029f2:	89 c2                	mov    %eax,%edx
+801029f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801029f7:	89 10                	mov    %edx,(%eax)
+  wakeup(b);
+801029f9:	83 ec 0c             	sub    $0xc,%esp
+801029fc:	ff 75 f4             	pushl  -0xc(%ebp)
+801029ff:	e8 4c 28 00 00       	call   80105250 <wakeup>
+80102a04:	83 c4 10             	add    $0x10,%esp
+
+  // Start disk on next buf in queue.
+  if(idequeue != 0)
+80102a07:	a1 34 c6 10 80       	mov    0x8010c634,%eax
+80102a0c:	85 c0                	test   %eax,%eax
+80102a0e:	74 11                	je     80102a21 <ideintr+0xc7>
+    idestart(idequeue);
+80102a10:	a1 34 c6 10 80       	mov    0x8010c634,%eax
+80102a15:	83 ec 0c             	sub    $0xc,%esp
+80102a18:	50                   	push   %eax
+80102a19:	e8 a6 fd ff ff       	call   801027c4 <idestart>
+80102a1e:	83 c4 10             	add    $0x10,%esp
+
+  release(&idelock);
+80102a21:	83 ec 0c             	sub    $0xc,%esp
+80102a24:	68 00 c6 10 80       	push   $0x8010c600
+80102a29:	e8 c0 2d 00 00       	call   801057ee <release>
+80102a2e:	83 c4 10             	add    $0x10,%esp
+}
+80102a31:	c9                   	leave  
+80102a32:	c3                   	ret    
+
+80102a33 <iderw>:
+// Sync buf with disk.
+// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+// Else if B_VALID is not set, read buf from disk, set B_VALID.
+void
+iderw(struct buf *b)
+{
+80102a33:	f3 0f 1e fb          	endbr32 
+80102a37:	55                   	push   %ebp
+80102a38:	89 e5                	mov    %esp,%ebp
+80102a3a:	83 ec 18             	sub    $0x18,%esp
+  struct buf **pp;
+
+  if(!holdingsleep(&b->lock))
+80102a3d:	8b 45 08             	mov    0x8(%ebp),%eax
+80102a40:	83 c0 0c             	add    $0xc,%eax
+80102a43:	83 ec 0c             	sub    $0xc,%esp
+80102a46:	50                   	push   %eax
+80102a47:	e8 71 2c 00 00       	call   801056bd <holdingsleep>
+80102a4c:	83 c4 10             	add    $0x10,%esp
+80102a4f:	85 c0                	test   %eax,%eax
+80102a51:	75 0d                	jne    80102a60 <iderw+0x2d>
+    panic("iderw: buf not locked");
+80102a53:	83 ec 0c             	sub    $0xc,%esp
+80102a56:	68 ee 8e 10 80       	push   $0x80108eee
+80102a5b:	e8 71 db ff ff       	call   801005d1 <panic>
+  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+80102a60:	8b 45 08             	mov    0x8(%ebp),%eax
+80102a63:	8b 00                	mov    (%eax),%eax
+80102a65:	83 e0 06             	and    $0x6,%eax
+80102a68:	83 f8 02             	cmp    $0x2,%eax
+80102a6b:	75 0d                	jne    80102a7a <iderw+0x47>
+    panic("iderw: nothing to do");
+80102a6d:	83 ec 0c             	sub    $0xc,%esp
+80102a70:	68 04 8f 10 80       	push   $0x80108f04
+80102a75:	e8 57 db ff ff       	call   801005d1 <panic>
+  if(b->dev != 0 && !havedisk1)
+80102a7a:	8b 45 08             	mov    0x8(%ebp),%eax
+80102a7d:	8b 40 04             	mov    0x4(%eax),%eax
+80102a80:	85 c0                	test   %eax,%eax
+80102a82:	74 16                	je     80102a9a <iderw+0x67>
+80102a84:	a1 38 c6 10 80       	mov    0x8010c638,%eax
+80102a89:	85 c0                	test   %eax,%eax
+80102a8b:	75 0d                	jne    80102a9a <iderw+0x67>
+    panic("iderw: ide disk 1 not present");
+80102a8d:	83 ec 0c             	sub    $0xc,%esp
+80102a90:	68 19 8f 10 80       	push   $0x80108f19
+80102a95:	e8 37 db ff ff       	call   801005d1 <panic>
+
+  acquire(&idelock);  //DOC:acquire-lock
+80102a9a:	83 ec 0c             	sub    $0xc,%esp
+80102a9d:	68 00 c6 10 80       	push   $0x8010c600
+80102aa2:	e8 d5 2c 00 00       	call   8010577c <acquire>
+80102aa7:	83 c4 10             	add    $0x10,%esp
+
+  // Append b to idequeue.
+  b->qnext = 0;
+80102aaa:	8b 45 08             	mov    0x8(%ebp),%eax
+80102aad:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
+  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+80102ab4:	c7 45 f4 34 c6 10 80 	movl   $0x8010c634,-0xc(%ebp)
+80102abb:	eb 0b                	jmp    80102ac8 <iderw+0x95>
+80102abd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102ac0:	8b 00                	mov    (%eax),%eax
+80102ac2:	83 c0 58             	add    $0x58,%eax
+80102ac5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80102ac8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102acb:	8b 00                	mov    (%eax),%eax
+80102acd:	85 c0                	test   %eax,%eax
+80102acf:	75 ec                	jne    80102abd <iderw+0x8a>
+    ;
+  *pp = b;
+80102ad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102ad4:	8b 55 08             	mov    0x8(%ebp),%edx
+80102ad7:	89 10                	mov    %edx,(%eax)
+
+  // Start disk if necessary.
+  if(idequeue == b)
+80102ad9:	a1 34 c6 10 80       	mov    0x8010c634,%eax
+80102ade:	39 45 08             	cmp    %eax,0x8(%ebp)
+80102ae1:	75 23                	jne    80102b06 <iderw+0xd3>
+    idestart(b);
+80102ae3:	83 ec 0c             	sub    $0xc,%esp
+80102ae6:	ff 75 08             	pushl  0x8(%ebp)
+80102ae9:	e8 d6 fc ff ff       	call   801027c4 <idestart>
+80102aee:	83 c4 10             	add    $0x10,%esp
+
+  // Wait for request to finish.
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+80102af1:	eb 13                	jmp    80102b06 <iderw+0xd3>
+    sleep(b, &idelock);
+80102af3:	83 ec 08             	sub    $0x8,%esp
+80102af6:	68 00 c6 10 80       	push   $0x8010c600
+80102afb:	ff 75 08             	pushl  0x8(%ebp)
+80102afe:	e8 5b 26 00 00       	call   8010515e <sleep>
+80102b03:	83 c4 10             	add    $0x10,%esp
+  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+80102b06:	8b 45 08             	mov    0x8(%ebp),%eax
+80102b09:	8b 00                	mov    (%eax),%eax
+80102b0b:	83 e0 06             	and    $0x6,%eax
+80102b0e:	83 f8 02             	cmp    $0x2,%eax
+80102b11:	75 e0                	jne    80102af3 <iderw+0xc0>
+  }
+
+
+  release(&idelock);
+80102b13:	83 ec 0c             	sub    $0xc,%esp
+80102b16:	68 00 c6 10 80       	push   $0x8010c600
+80102b1b:	e8 ce 2c 00 00       	call   801057ee <release>
+80102b20:	83 c4 10             	add    $0x10,%esp
+}
+80102b23:	90                   	nop
+80102b24:	c9                   	leave  
+80102b25:	c3                   	ret    
+
+80102b26 <ioapicread>:
+  uint data;
+};
+
+static uint
+ioapicread(int reg)
+{
+80102b26:	f3 0f 1e fb          	endbr32 
+80102b2a:	55                   	push   %ebp
+80102b2b:	89 e5                	mov    %esp,%ebp
+  ioapic->reg = reg;
+80102b2d:	a1 d4 46 11 80       	mov    0x801146d4,%eax
+80102b32:	8b 55 08             	mov    0x8(%ebp),%edx
+80102b35:	89 10                	mov    %edx,(%eax)
+  return ioapic->data;
+80102b37:	a1 d4 46 11 80       	mov    0x801146d4,%eax
+80102b3c:	8b 40 10             	mov    0x10(%eax),%eax
+}
+80102b3f:	5d                   	pop    %ebp
+80102b40:	c3                   	ret    
+
+80102b41 <ioapicwrite>:
+
+static void
+ioapicwrite(int reg, uint data)
+{
+80102b41:	f3 0f 1e fb          	endbr32 
+80102b45:	55                   	push   %ebp
+80102b46:	89 e5                	mov    %esp,%ebp
+  ioapic->reg = reg;
+80102b48:	a1 d4 46 11 80       	mov    0x801146d4,%eax
+80102b4d:	8b 55 08             	mov    0x8(%ebp),%edx
+80102b50:	89 10                	mov    %edx,(%eax)
+  ioapic->data = data;
+80102b52:	a1 d4 46 11 80       	mov    0x801146d4,%eax
+80102b57:	8b 55 0c             	mov    0xc(%ebp),%edx
+80102b5a:	89 50 10             	mov    %edx,0x10(%eax)
+}
+80102b5d:	90                   	nop
+80102b5e:	5d                   	pop    %ebp
+80102b5f:	c3                   	ret    
+
+80102b60 <ioapicinit>:
+
+void
+ioapicinit(void)
+{
+80102b60:	f3 0f 1e fb          	endbr32 
+80102b64:	55                   	push   %ebp
+80102b65:	89 e5                	mov    %esp,%ebp
+80102b67:	83 ec 18             	sub    $0x18,%esp
+  int i, id, maxintr;
+
+  ioapic = (volatile struct ioapic*)IOAPIC;
+80102b6a:	c7 05 d4 46 11 80 00 	movl   $0xfec00000,0x801146d4
+80102b71:	00 c0 fe 
+  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
+80102b74:	6a 01                	push   $0x1
+80102b76:	e8 ab ff ff ff       	call   80102b26 <ioapicread>
+80102b7b:	83 c4 04             	add    $0x4,%esp
+80102b7e:	c1 e8 10             	shr    $0x10,%eax
+80102b81:	25 ff 00 00 00       	and    $0xff,%eax
+80102b86:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  id = ioapicread(REG_ID) >> 24;
+80102b89:	6a 00                	push   $0x0
+80102b8b:	e8 96 ff ff ff       	call   80102b26 <ioapicread>
+80102b90:	83 c4 04             	add    $0x4,%esp
+80102b93:	c1 e8 18             	shr    $0x18,%eax
+80102b96:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(id != ioapicid)
+80102b99:	0f b6 05 00 48 11 80 	movzbl 0x80114800,%eax
+80102ba0:	0f b6 c0             	movzbl %al,%eax
+80102ba3:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+80102ba6:	74 10                	je     80102bb8 <ioapicinit+0x58>
+    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
+80102ba8:	83 ec 0c             	sub    $0xc,%esp
+80102bab:	68 38 8f 10 80       	push   $0x80108f38
+80102bb0:	e8 63 d8 ff ff       	call   80100418 <cprintf>
+80102bb5:	83 c4 10             	add    $0x10,%esp
+
+  // Mark all interrupts edge-triggered, active high, disabled,
+  // and not routed to any CPUs.
+  for(i = 0; i <= maxintr; i++){
+80102bb8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80102bbf:	eb 3f                	jmp    80102c00 <ioapicinit+0xa0>
+    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
+80102bc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102bc4:	83 c0 20             	add    $0x20,%eax
+80102bc7:	0d 00 00 01 00       	or     $0x10000,%eax
+80102bcc:	89 c2                	mov    %eax,%edx
+80102bce:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102bd1:	83 c0 08             	add    $0x8,%eax
+80102bd4:	01 c0                	add    %eax,%eax
+80102bd6:	83 ec 08             	sub    $0x8,%esp
+80102bd9:	52                   	push   %edx
+80102bda:	50                   	push   %eax
+80102bdb:	e8 61 ff ff ff       	call   80102b41 <ioapicwrite>
+80102be0:	83 c4 10             	add    $0x10,%esp
+    ioapicwrite(REG_TABLE+2*i+1, 0);
+80102be3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102be6:	83 c0 08             	add    $0x8,%eax
+80102be9:	01 c0                	add    %eax,%eax
+80102beb:	83 c0 01             	add    $0x1,%eax
+80102bee:	83 ec 08             	sub    $0x8,%esp
+80102bf1:	6a 00                	push   $0x0
+80102bf3:	50                   	push   %eax
+80102bf4:	e8 48 ff ff ff       	call   80102b41 <ioapicwrite>
+80102bf9:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i <= maxintr; i++){
+80102bfc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80102c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102c03:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+80102c06:	7e b9                	jle    80102bc1 <ioapicinit+0x61>
+  }
+}
+80102c08:	90                   	nop
+80102c09:	90                   	nop
+80102c0a:	c9                   	leave  
+80102c0b:	c3                   	ret    
+
+80102c0c <ioapicenable>:
+
+void
+ioapicenable(int irq, int cpunum)
+{
+80102c0c:	f3 0f 1e fb          	endbr32 
+80102c10:	55                   	push   %ebp
+80102c11:	89 e5                	mov    %esp,%ebp
+  // Mark interrupt edge-triggered, active high,
+  // enabled, and routed to the given cpunum,
+  // which happens to be that cpu's APIC ID.
+  ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
+80102c13:	8b 45 08             	mov    0x8(%ebp),%eax
+80102c16:	83 c0 20             	add    $0x20,%eax
+80102c19:	89 c2                	mov    %eax,%edx
+80102c1b:	8b 45 08             	mov    0x8(%ebp),%eax
+80102c1e:	83 c0 08             	add    $0x8,%eax
+80102c21:	01 c0                	add    %eax,%eax
+80102c23:	52                   	push   %edx
+80102c24:	50                   	push   %eax
+80102c25:	e8 17 ff ff ff       	call   80102b41 <ioapicwrite>
+80102c2a:	83 c4 08             	add    $0x8,%esp
+  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
+80102c2d:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102c30:	c1 e0 18             	shl    $0x18,%eax
+80102c33:	89 c2                	mov    %eax,%edx
+80102c35:	8b 45 08             	mov    0x8(%ebp),%eax
+80102c38:	83 c0 08             	add    $0x8,%eax
+80102c3b:	01 c0                	add    %eax,%eax
+80102c3d:	83 c0 01             	add    $0x1,%eax
+80102c40:	52                   	push   %edx
+80102c41:	50                   	push   %eax
+80102c42:	e8 fa fe ff ff       	call   80102b41 <ioapicwrite>
+80102c47:	83 c4 08             	add    $0x8,%esp
+}
+80102c4a:	90                   	nop
+80102c4b:	c9                   	leave  
+80102c4c:	c3                   	ret    
+
+80102c4d <kinit1>:
+// the pages mapped by entrypgdir on free list.
+// 2. main() calls kinit2() with the rest of the physical pages
+// after installing a full page table that maps them on all cores.
+void
+kinit1(void *vstart, void *vend)
+{
+80102c4d:	f3 0f 1e fb          	endbr32 
+80102c51:	55                   	push   %ebp
+80102c52:	89 e5                	mov    %esp,%ebp
+80102c54:	83 ec 08             	sub    $0x8,%esp
+  initlock(&kmem.lock, "kmem");
+80102c57:	83 ec 08             	sub    $0x8,%esp
+80102c5a:	68 6a 8f 10 80       	push   $0x80108f6a
+80102c5f:	68 e0 46 11 80       	push   $0x801146e0
+80102c64:	e8 ed 2a 00 00       	call   80105756 <initlock>
+80102c69:	83 c4 10             	add    $0x10,%esp
+  kmem.use_lock = 0;
+80102c6c:	c7 05 14 47 11 80 00 	movl   $0x0,0x80114714
+80102c73:	00 00 00 
+  freerange(vstart, vend);
+80102c76:	83 ec 08             	sub    $0x8,%esp
+80102c79:	ff 75 0c             	pushl  0xc(%ebp)
+80102c7c:	ff 75 08             	pushl  0x8(%ebp)
+80102c7f:	e8 2e 00 00 00       	call   80102cb2 <freerange>
+80102c84:	83 c4 10             	add    $0x10,%esp
+}
+80102c87:	90                   	nop
+80102c88:	c9                   	leave  
+80102c89:	c3                   	ret    
+
+80102c8a <kinit2>:
+
+void
+kinit2(void *vstart, void *vend)
+{
+80102c8a:	f3 0f 1e fb          	endbr32 
+80102c8e:	55                   	push   %ebp
+80102c8f:	89 e5                	mov    %esp,%ebp
+80102c91:	83 ec 08             	sub    $0x8,%esp
+  freerange(vstart, vend);
+80102c94:	83 ec 08             	sub    $0x8,%esp
+80102c97:	ff 75 0c             	pushl  0xc(%ebp)
+80102c9a:	ff 75 08             	pushl  0x8(%ebp)
+80102c9d:	e8 10 00 00 00       	call   80102cb2 <freerange>
+80102ca2:	83 c4 10             	add    $0x10,%esp
+  kmem.use_lock = 1;
+80102ca5:	c7 05 14 47 11 80 01 	movl   $0x1,0x80114714
+80102cac:	00 00 00 
+}
+80102caf:	90                   	nop
+80102cb0:	c9                   	leave  
+80102cb1:	c3                   	ret    
+
+80102cb2 <freerange>:
+
+void
+freerange(void *vstart, void *vend)
+{
+80102cb2:	f3 0f 1e fb          	endbr32 
+80102cb6:	55                   	push   %ebp
+80102cb7:	89 e5                	mov    %esp,%ebp
+80102cb9:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  p = (char*)PGROUNDUP((uint)vstart);
+80102cbc:	8b 45 08             	mov    0x8(%ebp),%eax
+80102cbf:	05 ff 0f 00 00       	add    $0xfff,%eax
+80102cc4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80102cc9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102ccc:	eb 15                	jmp    80102ce3 <freerange+0x31>
+    kfree(p);
+80102cce:	83 ec 0c             	sub    $0xc,%esp
+80102cd1:	ff 75 f4             	pushl  -0xc(%ebp)
+80102cd4:	e8 1b 00 00 00       	call   80102cf4 <kfree>
+80102cd9:	83 c4 10             	add    $0x10,%esp
+  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
+80102cdc:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+80102ce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102ce6:	05 00 10 00 00       	add    $0x1000,%eax
+80102ceb:	39 45 0c             	cmp    %eax,0xc(%ebp)
+80102cee:	73 de                	jae    80102cce <freerange+0x1c>
+}
+80102cf0:	90                   	nop
+80102cf1:	90                   	nop
+80102cf2:	c9                   	leave  
+80102cf3:	c3                   	ret    
+
+80102cf4 <kfree>:
+// which normally should have been returned by a
+// call to kalloc().  (The exception is when
+// initializing the allocator; see kinit above.)
+void
+kfree(char *v)
+{
+80102cf4:	f3 0f 1e fb          	endbr32 
+80102cf8:	55                   	push   %ebp
+80102cf9:	89 e5                	mov    %esp,%ebp
+80102cfb:	83 ec 18             	sub    $0x18,%esp
+  struct run *r;
+
+  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+80102cfe:	8b 45 08             	mov    0x8(%ebp),%eax
+80102d01:	25 ff 0f 00 00       	and    $0xfff,%eax
+80102d06:	85 c0                	test   %eax,%eax
+80102d08:	75 18                	jne    80102d22 <kfree+0x2e>
+80102d0a:	81 7d 08 48 7d 11 80 	cmpl   $0x80117d48,0x8(%ebp)
+80102d11:	72 0f                	jb     80102d22 <kfree+0x2e>
+80102d13:	8b 45 08             	mov    0x8(%ebp),%eax
+80102d16:	05 00 00 00 80       	add    $0x80000000,%eax
+80102d1b:	3d ff ff ff 0d       	cmp    $0xdffffff,%eax
+80102d20:	76 0d                	jbe    80102d2f <kfree+0x3b>
+    panic("kfree");
+80102d22:	83 ec 0c             	sub    $0xc,%esp
+80102d25:	68 6f 8f 10 80       	push   $0x80108f6f
+80102d2a:	e8 a2 d8 ff ff       	call   801005d1 <panic>
+
+  // Fill with junk to catch dangling refs.
+  memset(v, 1, PGSIZE);
+80102d2f:	83 ec 04             	sub    $0x4,%esp
+80102d32:	68 00 10 00 00       	push   $0x1000
+80102d37:	6a 01                	push   $0x1
+80102d39:	ff 75 08             	pushl  0x8(%ebp)
+80102d3c:	e8 da 2c 00 00       	call   80105a1b <memset>
+80102d41:	83 c4 10             	add    $0x10,%esp
+
+  if(kmem.use_lock)
+80102d44:	a1 14 47 11 80       	mov    0x80114714,%eax
+80102d49:	85 c0                	test   %eax,%eax
+80102d4b:	74 10                	je     80102d5d <kfree+0x69>
+    acquire(&kmem.lock);
+80102d4d:	83 ec 0c             	sub    $0xc,%esp
+80102d50:	68 e0 46 11 80       	push   $0x801146e0
+80102d55:	e8 22 2a 00 00       	call   8010577c <acquire>
+80102d5a:	83 c4 10             	add    $0x10,%esp
+  r = (struct run*)v;
+80102d5d:	8b 45 08             	mov    0x8(%ebp),%eax
+80102d60:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  r->next = kmem.freelist;
+80102d63:	8b 15 18 47 11 80    	mov    0x80114718,%edx
+80102d69:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102d6c:	89 10                	mov    %edx,(%eax)
+  kmem.freelist = r;
+80102d6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102d71:	a3 18 47 11 80       	mov    %eax,0x80114718
+  if(kmem.use_lock)
+80102d76:	a1 14 47 11 80       	mov    0x80114714,%eax
+80102d7b:	85 c0                	test   %eax,%eax
+80102d7d:	74 10                	je     80102d8f <kfree+0x9b>
+    release(&kmem.lock);
+80102d7f:	83 ec 0c             	sub    $0xc,%esp
+80102d82:	68 e0 46 11 80       	push   $0x801146e0
+80102d87:	e8 62 2a 00 00       	call   801057ee <release>
+80102d8c:	83 c4 10             	add    $0x10,%esp
+}
+80102d8f:	90                   	nop
+80102d90:	c9                   	leave  
+80102d91:	c3                   	ret    
+
+80102d92 <kalloc>:
+// Allocate one 4096-byte page of physical memory.
+// Returns a pointer that the kernel can use.
+// Returns 0 if the memory cannot be allocated.
+char*
+kalloc(void)
+{
+80102d92:	f3 0f 1e fb          	endbr32 
+80102d96:	55                   	push   %ebp
+80102d97:	89 e5                	mov    %esp,%ebp
+80102d99:	83 ec 18             	sub    $0x18,%esp
+  struct run *r;
+
+  if(kmem.use_lock)
+80102d9c:	a1 14 47 11 80       	mov    0x80114714,%eax
+80102da1:	85 c0                	test   %eax,%eax
+80102da3:	74 10                	je     80102db5 <kalloc+0x23>
+    acquire(&kmem.lock);
+80102da5:	83 ec 0c             	sub    $0xc,%esp
+80102da8:	68 e0 46 11 80       	push   $0x801146e0
+80102dad:	e8 ca 29 00 00       	call   8010577c <acquire>
+80102db2:	83 c4 10             	add    $0x10,%esp
+  r = kmem.freelist;
+80102db5:	a1 18 47 11 80       	mov    0x80114718,%eax
+80102dba:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(r)
+80102dbd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80102dc1:	74 0a                	je     80102dcd <kalloc+0x3b>
+    kmem.freelist = r->next;
+80102dc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102dc6:	8b 00                	mov    (%eax),%eax
+80102dc8:	a3 18 47 11 80       	mov    %eax,0x80114718
+  if(kmem.use_lock)
+80102dcd:	a1 14 47 11 80       	mov    0x80114714,%eax
+80102dd2:	85 c0                	test   %eax,%eax
+80102dd4:	74 10                	je     80102de6 <kalloc+0x54>
+    release(&kmem.lock);
+80102dd6:	83 ec 0c             	sub    $0xc,%esp
+80102dd9:	68 e0 46 11 80       	push   $0x801146e0
+80102dde:	e8 0b 2a 00 00       	call   801057ee <release>
+80102de3:	83 c4 10             	add    $0x10,%esp
+  return (char*)r;
+80102de6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80102de9:	c9                   	leave  
+80102dea:	c3                   	ret    
+
+80102deb <inb>:
+{
+80102deb:	55                   	push   %ebp
+80102dec:	89 e5                	mov    %esp,%ebp
+80102dee:	83 ec 14             	sub    $0x14,%esp
+80102df1:	8b 45 08             	mov    0x8(%ebp),%eax
+80102df4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102df8:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+80102dfc:	89 c2                	mov    %eax,%edx
+80102dfe:	ec                   	in     (%dx),%al
+80102dff:	88 45 ff             	mov    %al,-0x1(%ebp)
+  return data;
+80102e02:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
+}
+80102e06:	c9                   	leave  
+80102e07:	c3                   	ret    
+
+80102e08 <kbdgetc>:
+#include "defs.h"
+#include "kbd.h"
+
+int
+kbdgetc(void)
+{
+80102e08:	f3 0f 1e fb          	endbr32 
+80102e0c:	55                   	push   %ebp
+80102e0d:	89 e5                	mov    %esp,%ebp
+80102e0f:	83 ec 10             	sub    $0x10,%esp
+  static uchar *charcode[4] = {
+    normalmap, shiftmap, ctlmap, ctlmap
+  };
+  uint st, data, c;
+
+  st = inb(KBSTATP);
+80102e12:	6a 64                	push   $0x64
+80102e14:	e8 d2 ff ff ff       	call   80102deb <inb>
+80102e19:	83 c4 04             	add    $0x4,%esp
+80102e1c:	0f b6 c0             	movzbl %al,%eax
+80102e1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if((st & KBS_DIB) == 0)
+80102e22:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80102e25:	83 e0 01             	and    $0x1,%eax
+80102e28:	85 c0                	test   %eax,%eax
+80102e2a:	75 0a                	jne    80102e36 <kbdgetc+0x2e>
+    return -1;
+80102e2c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80102e31:	e9 23 01 00 00       	jmp    80102f59 <kbdgetc+0x151>
+  data = inb(KBDATAP);
+80102e36:	6a 60                	push   $0x60
+80102e38:	e8 ae ff ff ff       	call   80102deb <inb>
+80102e3d:	83 c4 04             	add    $0x4,%esp
+80102e40:	0f b6 c0             	movzbl %al,%eax
+80102e43:	89 45 fc             	mov    %eax,-0x4(%ebp)
+
+  if(data == 0xE0){
+80102e46:	81 7d fc e0 00 00 00 	cmpl   $0xe0,-0x4(%ebp)
+80102e4d:	75 17                	jne    80102e66 <kbdgetc+0x5e>
+    shift |= E0ESC;
+80102e4f:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102e54:	83 c8 40             	or     $0x40,%eax
+80102e57:	a3 3c c6 10 80       	mov    %eax,0x8010c63c
+    return 0;
+80102e5c:	b8 00 00 00 00       	mov    $0x0,%eax
+80102e61:	e9 f3 00 00 00       	jmp    80102f59 <kbdgetc+0x151>
+  } else if(data & 0x80){
+80102e66:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102e69:	25 80 00 00 00       	and    $0x80,%eax
+80102e6e:	85 c0                	test   %eax,%eax
+80102e70:	74 45                	je     80102eb7 <kbdgetc+0xaf>
+    // Key released
+    data = (shift & E0ESC ? data : data & 0x7F);
+80102e72:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102e77:	83 e0 40             	and    $0x40,%eax
+80102e7a:	85 c0                	test   %eax,%eax
+80102e7c:	75 08                	jne    80102e86 <kbdgetc+0x7e>
+80102e7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102e81:	83 e0 7f             	and    $0x7f,%eax
+80102e84:	eb 03                	jmp    80102e89 <kbdgetc+0x81>
+80102e86:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102e89:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    shift &= ~(shiftcode[data] | E0ESC);
+80102e8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102e8f:	05 20 a0 10 80       	add    $0x8010a020,%eax
+80102e94:	0f b6 00             	movzbl (%eax),%eax
+80102e97:	83 c8 40             	or     $0x40,%eax
+80102e9a:	0f b6 c0             	movzbl %al,%eax
+80102e9d:	f7 d0                	not    %eax
+80102e9f:	89 c2                	mov    %eax,%edx
+80102ea1:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102ea6:	21 d0                	and    %edx,%eax
+80102ea8:	a3 3c c6 10 80       	mov    %eax,0x8010c63c
+    return 0;
+80102ead:	b8 00 00 00 00       	mov    $0x0,%eax
+80102eb2:	e9 a2 00 00 00       	jmp    80102f59 <kbdgetc+0x151>
+  } else if(shift & E0ESC){
+80102eb7:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102ebc:	83 e0 40             	and    $0x40,%eax
+80102ebf:	85 c0                	test   %eax,%eax
+80102ec1:	74 14                	je     80102ed7 <kbdgetc+0xcf>
+    // Last character was an E0 escape; or with 0x80
+    data |= 0x80;
+80102ec3:	81 4d fc 80 00 00 00 	orl    $0x80,-0x4(%ebp)
+    shift &= ~E0ESC;
+80102eca:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102ecf:	83 e0 bf             	and    $0xffffffbf,%eax
+80102ed2:	a3 3c c6 10 80       	mov    %eax,0x8010c63c
+  }
+
+  shift |= shiftcode[data];
+80102ed7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102eda:	05 20 a0 10 80       	add    $0x8010a020,%eax
+80102edf:	0f b6 00             	movzbl (%eax),%eax
+80102ee2:	0f b6 d0             	movzbl %al,%edx
+80102ee5:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102eea:	09 d0                	or     %edx,%eax
+80102eec:	a3 3c c6 10 80       	mov    %eax,0x8010c63c
+  shift ^= togglecode[data];
+80102ef1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102ef4:	05 20 a1 10 80       	add    $0x8010a120,%eax
+80102ef9:	0f b6 00             	movzbl (%eax),%eax
+80102efc:	0f b6 d0             	movzbl %al,%edx
+80102eff:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102f04:	31 d0                	xor    %edx,%eax
+80102f06:	a3 3c c6 10 80       	mov    %eax,0x8010c63c
+  c = charcode[shift & (CTL | SHIFT)][data];
+80102f0b:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102f10:	83 e0 03             	and    $0x3,%eax
+80102f13:	8b 14 85 20 a5 10 80 	mov    -0x7fef5ae0(,%eax,4),%edx
+80102f1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80102f1d:	01 d0                	add    %edx,%eax
+80102f1f:	0f b6 00             	movzbl (%eax),%eax
+80102f22:	0f b6 c0             	movzbl %al,%eax
+80102f25:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  if(shift & CAPSLOCK){
+80102f28:	a1 3c c6 10 80       	mov    0x8010c63c,%eax
+80102f2d:	83 e0 08             	and    $0x8,%eax
+80102f30:	85 c0                	test   %eax,%eax
+80102f32:	74 22                	je     80102f56 <kbdgetc+0x14e>
+    if('a' <= c && c <= 'z')
+80102f34:	83 7d f8 60          	cmpl   $0x60,-0x8(%ebp)
+80102f38:	76 0c                	jbe    80102f46 <kbdgetc+0x13e>
+80102f3a:	83 7d f8 7a          	cmpl   $0x7a,-0x8(%ebp)
+80102f3e:	77 06                	ja     80102f46 <kbdgetc+0x13e>
+      c += 'A' - 'a';
+80102f40:	83 6d f8 20          	subl   $0x20,-0x8(%ebp)
+80102f44:	eb 10                	jmp    80102f56 <kbdgetc+0x14e>
+    else if('A' <= c && c <= 'Z')
+80102f46:	83 7d f8 40          	cmpl   $0x40,-0x8(%ebp)
+80102f4a:	76 0a                	jbe    80102f56 <kbdgetc+0x14e>
+80102f4c:	83 7d f8 5a          	cmpl   $0x5a,-0x8(%ebp)
+80102f50:	77 04                	ja     80102f56 <kbdgetc+0x14e>
+      c += 'a' - 'A';
+80102f52:	83 45 f8 20          	addl   $0x20,-0x8(%ebp)
+  }
+  return c;
+80102f56:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80102f59:	c9                   	leave  
+80102f5a:	c3                   	ret    
+
+80102f5b <kbdintr>:
+
+void
+kbdintr(void)
+{
+80102f5b:	f3 0f 1e fb          	endbr32 
+80102f5f:	55                   	push   %ebp
+80102f60:	89 e5                	mov    %esp,%ebp
+80102f62:	83 ec 08             	sub    $0x8,%esp
+  consoleintr(kbdgetc);
+80102f65:	83 ec 0c             	sub    $0xc,%esp
+80102f68:	68 08 2e 10 80       	push   $0x80102e08
+80102f6d:	e8 ff d8 ff ff       	call   80100871 <consoleintr>
+80102f72:	83 c4 10             	add    $0x10,%esp
+}
+80102f75:	90                   	nop
+80102f76:	c9                   	leave  
+80102f77:	c3                   	ret    
+
+80102f78 <inb>:
+{
+80102f78:	55                   	push   %ebp
+80102f79:	89 e5                	mov    %esp,%ebp
+80102f7b:	83 ec 14             	sub    $0x14,%esp
+80102f7e:	8b 45 08             	mov    0x8(%ebp),%eax
+80102f81:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80102f85:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+80102f89:	89 c2                	mov    %eax,%edx
+80102f8b:	ec                   	in     (%dx),%al
+80102f8c:	88 45 ff             	mov    %al,-0x1(%ebp)
+  return data;
+80102f8f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
+}
+80102f93:	c9                   	leave  
+80102f94:	c3                   	ret    
+
+80102f95 <outb>:
+{
+80102f95:	55                   	push   %ebp
+80102f96:	89 e5                	mov    %esp,%ebp
+80102f98:	83 ec 08             	sub    $0x8,%esp
+80102f9b:	8b 45 08             	mov    0x8(%ebp),%eax
+80102f9e:	8b 55 0c             	mov    0xc(%ebp),%edx
+80102fa1:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+80102fa5:	89 d0                	mov    %edx,%eax
+80102fa7:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80102faa:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80102fae:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80102fb2:	ee                   	out    %al,(%dx)
+}
+80102fb3:	90                   	nop
+80102fb4:	c9                   	leave  
+80102fb5:	c3                   	ret    
+
+80102fb6 <lapicw>:
+volatile uint *lapic;  // Initialized in mp.c
+
+//PAGEBREAK!
+static void
+lapicw(int index, int value)
+{
+80102fb6:	f3 0f 1e fb          	endbr32 
+80102fba:	55                   	push   %ebp
+80102fbb:	89 e5                	mov    %esp,%ebp
+  lapic[index] = value;
+80102fbd:	a1 1c 47 11 80       	mov    0x8011471c,%eax
+80102fc2:	8b 55 08             	mov    0x8(%ebp),%edx
+80102fc5:	c1 e2 02             	shl    $0x2,%edx
+80102fc8:	01 c2                	add    %eax,%edx
+80102fca:	8b 45 0c             	mov    0xc(%ebp),%eax
+80102fcd:	89 02                	mov    %eax,(%edx)
+  lapic[ID];  // wait for write to finish, by reading
+80102fcf:	a1 1c 47 11 80       	mov    0x8011471c,%eax
+80102fd4:	83 c0 20             	add    $0x20,%eax
+80102fd7:	8b 00                	mov    (%eax),%eax
+}
+80102fd9:	90                   	nop
+80102fda:	5d                   	pop    %ebp
+80102fdb:	c3                   	ret    
+
+80102fdc <lapicinit>:
+
+void
+lapicinit(void)
+{
+80102fdc:	f3 0f 1e fb          	endbr32 
+80102fe0:	55                   	push   %ebp
+80102fe1:	89 e5                	mov    %esp,%ebp
+  if(!lapic)
+80102fe3:	a1 1c 47 11 80       	mov    0x8011471c,%eax
+80102fe8:	85 c0                	test   %eax,%eax
+80102fea:	0f 84 0c 01 00 00    	je     801030fc <lapicinit+0x120>
+    return;
+
+  // Enable local APIC; set spurious interrupt vector.
+  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
+80102ff0:	68 3f 01 00 00       	push   $0x13f
+80102ff5:	6a 3c                	push   $0x3c
+80102ff7:	e8 ba ff ff ff       	call   80102fb6 <lapicw>
+80102ffc:	83 c4 08             	add    $0x8,%esp
+
+  // The timer repeatedly counts down at bus frequency
+  // from lapic[TICR] and then issues an interrupt.
+  // If xv6 cared more about precise timekeeping,
+  // TICR would be calibrated using an external time source.
+  lapicw(TDCR, X1);
+80102fff:	6a 0b                	push   $0xb
+80103001:	68 f8 00 00 00       	push   $0xf8
+80103006:	e8 ab ff ff ff       	call   80102fb6 <lapicw>
+8010300b:	83 c4 08             	add    $0x8,%esp
+  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
+8010300e:	68 20 00 02 00       	push   $0x20020
+80103013:	68 c8 00 00 00       	push   $0xc8
+80103018:	e8 99 ff ff ff       	call   80102fb6 <lapicw>
+8010301d:	83 c4 08             	add    $0x8,%esp
+  lapicw(TICR, 10000000);
+80103020:	68 80 96 98 00       	push   $0x989680
+80103025:	68 e0 00 00 00       	push   $0xe0
+8010302a:	e8 87 ff ff ff       	call   80102fb6 <lapicw>
+8010302f:	83 c4 08             	add    $0x8,%esp
+
+  // Disable logical interrupt lines.
+  lapicw(LINT0, MASKED);
+80103032:	68 00 00 01 00       	push   $0x10000
+80103037:	68 d4 00 00 00       	push   $0xd4
+8010303c:	e8 75 ff ff ff       	call   80102fb6 <lapicw>
+80103041:	83 c4 08             	add    $0x8,%esp
+  lapicw(LINT1, MASKED);
+80103044:	68 00 00 01 00       	push   $0x10000
+80103049:	68 d8 00 00 00       	push   $0xd8
+8010304e:	e8 63 ff ff ff       	call   80102fb6 <lapicw>
+80103053:	83 c4 08             	add    $0x8,%esp
+
+  // Disable performance counter overflow interrupts
+  // on machines that provide that interrupt entry.
+  if(((lapic[VER]>>16) & 0xFF) >= 4)
+80103056:	a1 1c 47 11 80       	mov    0x8011471c,%eax
+8010305b:	83 c0 30             	add    $0x30,%eax
+8010305e:	8b 00                	mov    (%eax),%eax
+80103060:	c1 e8 10             	shr    $0x10,%eax
+80103063:	25 fc 00 00 00       	and    $0xfc,%eax
+80103068:	85 c0                	test   %eax,%eax
+8010306a:	74 12                	je     8010307e <lapicinit+0xa2>
+    lapicw(PCINT, MASKED);
+8010306c:	68 00 00 01 00       	push   $0x10000
+80103071:	68 d0 00 00 00       	push   $0xd0
+80103076:	e8 3b ff ff ff       	call   80102fb6 <lapicw>
+8010307b:	83 c4 08             	add    $0x8,%esp
+
+  // Map error interrupt to IRQ_ERROR.
+  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
+8010307e:	6a 33                	push   $0x33
+80103080:	68 dc 00 00 00       	push   $0xdc
+80103085:	e8 2c ff ff ff       	call   80102fb6 <lapicw>
+8010308a:	83 c4 08             	add    $0x8,%esp
+
+  // Clear error status register (requires back-to-back writes).
+  lapicw(ESR, 0);
+8010308d:	6a 00                	push   $0x0
+8010308f:	68 a0 00 00 00       	push   $0xa0
+80103094:	e8 1d ff ff ff       	call   80102fb6 <lapicw>
+80103099:	83 c4 08             	add    $0x8,%esp
+  lapicw(ESR, 0);
+8010309c:	6a 00                	push   $0x0
+8010309e:	68 a0 00 00 00       	push   $0xa0
+801030a3:	e8 0e ff ff ff       	call   80102fb6 <lapicw>
+801030a8:	83 c4 08             	add    $0x8,%esp
+
+  // Ack any outstanding interrupts.
+  lapicw(EOI, 0);
+801030ab:	6a 00                	push   $0x0
+801030ad:	6a 2c                	push   $0x2c
+801030af:	e8 02 ff ff ff       	call   80102fb6 <lapicw>
+801030b4:	83 c4 08             	add    $0x8,%esp
+
+  // Send an Init Level De-Assert to synchronise arbitration ID's.
+  lapicw(ICRHI, 0);
+801030b7:	6a 00                	push   $0x0
+801030b9:	68 c4 00 00 00       	push   $0xc4
+801030be:	e8 f3 fe ff ff       	call   80102fb6 <lapicw>
+801030c3:	83 c4 08             	add    $0x8,%esp
+  lapicw(ICRLO, BCAST | INIT | LEVEL);
+801030c6:	68 00 85 08 00       	push   $0x88500
+801030cb:	68 c0 00 00 00       	push   $0xc0
+801030d0:	e8 e1 fe ff ff       	call   80102fb6 <lapicw>
+801030d5:	83 c4 08             	add    $0x8,%esp
+  while(lapic[ICRLO] & DELIVS)
+801030d8:	90                   	nop
+801030d9:	a1 1c 47 11 80       	mov    0x8011471c,%eax
+801030de:	05 00 03 00 00       	add    $0x300,%eax
+801030e3:	8b 00                	mov    (%eax),%eax
+801030e5:	25 00 10 00 00       	and    $0x1000,%eax
+801030ea:	85 c0                	test   %eax,%eax
+801030ec:	75 eb                	jne    801030d9 <lapicinit+0xfd>
+    ;
+
+  // Enable interrupts on the APIC (but not on the processor).
+  lapicw(TPR, 0);
+801030ee:	6a 00                	push   $0x0
+801030f0:	6a 20                	push   $0x20
+801030f2:	e8 bf fe ff ff       	call   80102fb6 <lapicw>
+801030f7:	83 c4 08             	add    $0x8,%esp
+801030fa:	eb 01                	jmp    801030fd <lapicinit+0x121>
+    return;
+801030fc:	90                   	nop
+}
+801030fd:	c9                   	leave  
+801030fe:	c3                   	ret    
+
+801030ff <lapicid>:
+
+int
+lapicid(void)
+{
+801030ff:	f3 0f 1e fb          	endbr32 
+80103103:	55                   	push   %ebp
+80103104:	89 e5                	mov    %esp,%ebp
+  if (!lapic)
+80103106:	a1 1c 47 11 80       	mov    0x8011471c,%eax
+8010310b:	85 c0                	test   %eax,%eax
+8010310d:	75 07                	jne    80103116 <lapicid+0x17>
+    return 0;
+8010310f:	b8 00 00 00 00       	mov    $0x0,%eax
+80103114:	eb 0d                	jmp    80103123 <lapicid+0x24>
+  return lapic[ID] >> 24;
+80103116:	a1 1c 47 11 80       	mov    0x8011471c,%eax
+8010311b:	83 c0 20             	add    $0x20,%eax
+8010311e:	8b 00                	mov    (%eax),%eax
+80103120:	c1 e8 18             	shr    $0x18,%eax
+}
+80103123:	5d                   	pop    %ebp
+80103124:	c3                   	ret    
+
+80103125 <lapiceoi>:
+
+// Acknowledge interrupt.
+void
+lapiceoi(void)
+{
+80103125:	f3 0f 1e fb          	endbr32 
+80103129:	55                   	push   %ebp
+8010312a:	89 e5                	mov    %esp,%ebp
+  if(lapic)
+8010312c:	a1 1c 47 11 80       	mov    0x8011471c,%eax
+80103131:	85 c0                	test   %eax,%eax
+80103133:	74 0c                	je     80103141 <lapiceoi+0x1c>
+    lapicw(EOI, 0);
+80103135:	6a 00                	push   $0x0
+80103137:	6a 2c                	push   $0x2c
+80103139:	e8 78 fe ff ff       	call   80102fb6 <lapicw>
+8010313e:	83 c4 08             	add    $0x8,%esp
+}
+80103141:	90                   	nop
+80103142:	c9                   	leave  
+80103143:	c3                   	ret    
+
+80103144 <microdelay>:
+
+// Spin for a given number of microseconds.
+// On real hardware would want to tune this dynamically.
+void
+microdelay(int us)
+{
+80103144:	f3 0f 1e fb          	endbr32 
+80103148:	55                   	push   %ebp
+80103149:	89 e5                	mov    %esp,%ebp
+}
+8010314b:	90                   	nop
+8010314c:	5d                   	pop    %ebp
+8010314d:	c3                   	ret    
+
+8010314e <lapicstartap>:
+
+// Start additional processor running entry code at addr.
+// See Appendix B of MultiProcessor Specification.
+void
+lapicstartap(uchar apicid, uint addr)
+{
+8010314e:	f3 0f 1e fb          	endbr32 
+80103152:	55                   	push   %ebp
+80103153:	89 e5                	mov    %esp,%ebp
+80103155:	83 ec 14             	sub    $0x14,%esp
+80103158:	8b 45 08             	mov    0x8(%ebp),%eax
+8010315b:	88 45 ec             	mov    %al,-0x14(%ebp)
+  ushort *wrv;
+
+  // "The BSP must initialize CMOS shutdown code to 0AH
+  // and the warm reset vector (DWORD based at 40:67) to point at
+  // the AP startup code prior to the [universal startup algorithm]."
+  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
+8010315e:	6a 0f                	push   $0xf
+80103160:	6a 70                	push   $0x70
+80103162:	e8 2e fe ff ff       	call   80102f95 <outb>
+80103167:	83 c4 08             	add    $0x8,%esp
+  outb(CMOS_PORT+1, 0x0A);
+8010316a:	6a 0a                	push   $0xa
+8010316c:	6a 71                	push   $0x71
+8010316e:	e8 22 fe ff ff       	call   80102f95 <outb>
+80103173:	83 c4 08             	add    $0x8,%esp
+  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
+80103176:	c7 45 f8 67 04 00 80 	movl   $0x80000467,-0x8(%ebp)
+  wrv[0] = 0;
+8010317d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80103180:	66 c7 00 00 00       	movw   $0x0,(%eax)
+  wrv[1] = addr >> 4;
+80103185:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103188:	c1 e8 04             	shr    $0x4,%eax
+8010318b:	89 c2                	mov    %eax,%edx
+8010318d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80103190:	83 c0 02             	add    $0x2,%eax
+80103193:	66 89 10             	mov    %dx,(%eax)
+
+  // "Universal startup algorithm."
+  // Send INIT (level-triggered) interrupt to reset other CPU.
+  lapicw(ICRHI, apicid<<24);
+80103196:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
+8010319a:	c1 e0 18             	shl    $0x18,%eax
+8010319d:	50                   	push   %eax
+8010319e:	68 c4 00 00 00       	push   $0xc4
+801031a3:	e8 0e fe ff ff       	call   80102fb6 <lapicw>
+801031a8:	83 c4 08             	add    $0x8,%esp
+  lapicw(ICRLO, INIT | LEVEL | ASSERT);
+801031ab:	68 00 c5 00 00       	push   $0xc500
+801031b0:	68 c0 00 00 00       	push   $0xc0
+801031b5:	e8 fc fd ff ff       	call   80102fb6 <lapicw>
+801031ba:	83 c4 08             	add    $0x8,%esp
+  microdelay(200);
+801031bd:	68 c8 00 00 00       	push   $0xc8
+801031c2:	e8 7d ff ff ff       	call   80103144 <microdelay>
+801031c7:	83 c4 04             	add    $0x4,%esp
+  lapicw(ICRLO, INIT | LEVEL);
+801031ca:	68 00 85 00 00       	push   $0x8500
+801031cf:	68 c0 00 00 00       	push   $0xc0
+801031d4:	e8 dd fd ff ff       	call   80102fb6 <lapicw>
+801031d9:	83 c4 08             	add    $0x8,%esp
+  microdelay(100);    // should be 10ms, but too slow in Bochs!
+801031dc:	6a 64                	push   $0x64
+801031de:	e8 61 ff ff ff       	call   80103144 <microdelay>
+801031e3:	83 c4 04             	add    $0x4,%esp
+  // Send startup IPI (twice!) to enter code.
+  // Regular hardware is supposed to only accept a STARTUP
+  // when it is in the halted state due to an INIT.  So the second
+  // should be ignored, but it is part of the official Intel algorithm.
+  // Bochs complains about the second one.  Too bad for Bochs.
+  for(i = 0; i < 2; i++){
+801031e6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+801031ed:	eb 3d                	jmp    8010322c <lapicstartap+0xde>
+    lapicw(ICRHI, apicid<<24);
+801031ef:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
+801031f3:	c1 e0 18             	shl    $0x18,%eax
+801031f6:	50                   	push   %eax
+801031f7:	68 c4 00 00 00       	push   $0xc4
+801031fc:	e8 b5 fd ff ff       	call   80102fb6 <lapicw>
+80103201:	83 c4 08             	add    $0x8,%esp
+    lapicw(ICRLO, STARTUP | (addr>>12));
+80103204:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103207:	c1 e8 0c             	shr    $0xc,%eax
+8010320a:	80 cc 06             	or     $0x6,%ah
+8010320d:	50                   	push   %eax
+8010320e:	68 c0 00 00 00       	push   $0xc0
+80103213:	e8 9e fd ff ff       	call   80102fb6 <lapicw>
+80103218:	83 c4 08             	add    $0x8,%esp
+    microdelay(200);
+8010321b:	68 c8 00 00 00       	push   $0xc8
+80103220:	e8 1f ff ff ff       	call   80103144 <microdelay>
+80103225:	83 c4 04             	add    $0x4,%esp
+  for(i = 0; i < 2; i++){
+80103228:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+8010322c:	83 7d fc 01          	cmpl   $0x1,-0x4(%ebp)
+80103230:	7e bd                	jle    801031ef <lapicstartap+0xa1>
+  }
+}
+80103232:	90                   	nop
+80103233:	90                   	nop
+80103234:	c9                   	leave  
+80103235:	c3                   	ret    
+
+80103236 <cmos_read>:
+#define MONTH   0x08
+#define YEAR    0x09
+
+static uint
+cmos_read(uint reg)
+{
+80103236:	f3 0f 1e fb          	endbr32 
+8010323a:	55                   	push   %ebp
+8010323b:	89 e5                	mov    %esp,%ebp
+  outb(CMOS_PORT,  reg);
+8010323d:	8b 45 08             	mov    0x8(%ebp),%eax
+80103240:	0f b6 c0             	movzbl %al,%eax
+80103243:	50                   	push   %eax
+80103244:	6a 70                	push   $0x70
+80103246:	e8 4a fd ff ff       	call   80102f95 <outb>
+8010324b:	83 c4 08             	add    $0x8,%esp
+  microdelay(200);
+8010324e:	68 c8 00 00 00       	push   $0xc8
+80103253:	e8 ec fe ff ff       	call   80103144 <microdelay>
+80103258:	83 c4 04             	add    $0x4,%esp
+
+  return inb(CMOS_RETURN);
+8010325b:	6a 71                	push   $0x71
+8010325d:	e8 16 fd ff ff       	call   80102f78 <inb>
+80103262:	83 c4 04             	add    $0x4,%esp
+80103265:	0f b6 c0             	movzbl %al,%eax
+}
+80103268:	c9                   	leave  
+80103269:	c3                   	ret    
+
+8010326a <fill_rtcdate>:
+
+static void
+fill_rtcdate(struct rtcdate *r)
+{
+8010326a:	f3 0f 1e fb          	endbr32 
+8010326e:	55                   	push   %ebp
+8010326f:	89 e5                	mov    %esp,%ebp
+  r->second = cmos_read(SECS);
+80103271:	6a 00                	push   $0x0
+80103273:	e8 be ff ff ff       	call   80103236 <cmos_read>
+80103278:	83 c4 04             	add    $0x4,%esp
+8010327b:	8b 55 08             	mov    0x8(%ebp),%edx
+8010327e:	89 02                	mov    %eax,(%edx)
+  r->minute = cmos_read(MINS);
+80103280:	6a 02                	push   $0x2
+80103282:	e8 af ff ff ff       	call   80103236 <cmos_read>
+80103287:	83 c4 04             	add    $0x4,%esp
+8010328a:	8b 55 08             	mov    0x8(%ebp),%edx
+8010328d:	89 42 04             	mov    %eax,0x4(%edx)
+  r->hour   = cmos_read(HOURS);
+80103290:	6a 04                	push   $0x4
+80103292:	e8 9f ff ff ff       	call   80103236 <cmos_read>
+80103297:	83 c4 04             	add    $0x4,%esp
+8010329a:	8b 55 08             	mov    0x8(%ebp),%edx
+8010329d:	89 42 08             	mov    %eax,0x8(%edx)
+  r->day    = cmos_read(DAY);
+801032a0:	6a 07                	push   $0x7
+801032a2:	e8 8f ff ff ff       	call   80103236 <cmos_read>
+801032a7:	83 c4 04             	add    $0x4,%esp
+801032aa:	8b 55 08             	mov    0x8(%ebp),%edx
+801032ad:	89 42 0c             	mov    %eax,0xc(%edx)
+  r->month  = cmos_read(MONTH);
+801032b0:	6a 08                	push   $0x8
+801032b2:	e8 7f ff ff ff       	call   80103236 <cmos_read>
+801032b7:	83 c4 04             	add    $0x4,%esp
+801032ba:	8b 55 08             	mov    0x8(%ebp),%edx
+801032bd:	89 42 10             	mov    %eax,0x10(%edx)
+  r->year   = cmos_read(YEAR);
+801032c0:	6a 09                	push   $0x9
+801032c2:	e8 6f ff ff ff       	call   80103236 <cmos_read>
+801032c7:	83 c4 04             	add    $0x4,%esp
+801032ca:	8b 55 08             	mov    0x8(%ebp),%edx
+801032cd:	89 42 14             	mov    %eax,0x14(%edx)
+}
+801032d0:	90                   	nop
+801032d1:	c9                   	leave  
+801032d2:	c3                   	ret    
+
+801032d3 <cmostime>:
+
+// qemu seems to use 24-hour GWT and the values are BCD encoded
+void
+cmostime(struct rtcdate *r)
+{
+801032d3:	f3 0f 1e fb          	endbr32 
+801032d7:	55                   	push   %ebp
+801032d8:	89 e5                	mov    %esp,%ebp
+801032da:	83 ec 48             	sub    $0x48,%esp
+  struct rtcdate t1, t2;
+  int sb, bcd;
+
+  sb = cmos_read(CMOS_STATB);
+801032dd:	6a 0b                	push   $0xb
+801032df:	e8 52 ff ff ff       	call   80103236 <cmos_read>
+801032e4:	83 c4 04             	add    $0x4,%esp
+801032e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+  bcd = (sb & (1 << 2)) == 0;
+801032ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801032ed:	83 e0 04             	and    $0x4,%eax
+801032f0:	85 c0                	test   %eax,%eax
+801032f2:	0f 94 c0             	sete   %al
+801032f5:	0f b6 c0             	movzbl %al,%eax
+801032f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  // make sure CMOS doesn't modify time while we read it
+  for(;;) {
+    fill_rtcdate(&t1);
+801032fb:	8d 45 d8             	lea    -0x28(%ebp),%eax
+801032fe:	50                   	push   %eax
+801032ff:	e8 66 ff ff ff       	call   8010326a <fill_rtcdate>
+80103304:	83 c4 04             	add    $0x4,%esp
+    if(cmos_read(CMOS_STATA) & CMOS_UIP)
+80103307:	6a 0a                	push   $0xa
+80103309:	e8 28 ff ff ff       	call   80103236 <cmos_read>
+8010330e:	83 c4 04             	add    $0x4,%esp
+80103311:	25 80 00 00 00       	and    $0x80,%eax
+80103316:	85 c0                	test   %eax,%eax
+80103318:	75 27                	jne    80103341 <cmostime+0x6e>
+        continue;
+    fill_rtcdate(&t2);
+8010331a:	8d 45 c0             	lea    -0x40(%ebp),%eax
+8010331d:	50                   	push   %eax
+8010331e:	e8 47 ff ff ff       	call   8010326a <fill_rtcdate>
+80103323:	83 c4 04             	add    $0x4,%esp
+    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+80103326:	83 ec 04             	sub    $0x4,%esp
+80103329:	6a 18                	push   $0x18
+8010332b:	8d 45 c0             	lea    -0x40(%ebp),%eax
+8010332e:	50                   	push   %eax
+8010332f:	8d 45 d8             	lea    -0x28(%ebp),%eax
+80103332:	50                   	push   %eax
+80103333:	e8 4e 27 00 00       	call   80105a86 <memcmp>
+80103338:	83 c4 10             	add    $0x10,%esp
+8010333b:	85 c0                	test   %eax,%eax
+8010333d:	74 05                	je     80103344 <cmostime+0x71>
+8010333f:	eb ba                	jmp    801032fb <cmostime+0x28>
+        continue;
+80103341:	90                   	nop
+    fill_rtcdate(&t1);
+80103342:	eb b7                	jmp    801032fb <cmostime+0x28>
+      break;
+80103344:	90                   	nop
+  }
+
+  // convert
+  if(bcd) {
+80103345:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80103349:	0f 84 b4 00 00 00    	je     80103403 <cmostime+0x130>
+#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+    CONV(second);
+8010334f:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80103352:	c1 e8 04             	shr    $0x4,%eax
+80103355:	89 c2                	mov    %eax,%edx
+80103357:	89 d0                	mov    %edx,%eax
+80103359:	c1 e0 02             	shl    $0x2,%eax
+8010335c:	01 d0                	add    %edx,%eax
+8010335e:	01 c0                	add    %eax,%eax
+80103360:	89 c2                	mov    %eax,%edx
+80103362:	8b 45 d8             	mov    -0x28(%ebp),%eax
+80103365:	83 e0 0f             	and    $0xf,%eax
+80103368:	01 d0                	add    %edx,%eax
+8010336a:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    CONV(minute);
+8010336d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80103370:	c1 e8 04             	shr    $0x4,%eax
+80103373:	89 c2                	mov    %eax,%edx
+80103375:	89 d0                	mov    %edx,%eax
+80103377:	c1 e0 02             	shl    $0x2,%eax
+8010337a:	01 d0                	add    %edx,%eax
+8010337c:	01 c0                	add    %eax,%eax
+8010337e:	89 c2                	mov    %eax,%edx
+80103380:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80103383:	83 e0 0f             	and    $0xf,%eax
+80103386:	01 d0                	add    %edx,%eax
+80103388:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    CONV(hour  );
+8010338b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+8010338e:	c1 e8 04             	shr    $0x4,%eax
+80103391:	89 c2                	mov    %eax,%edx
+80103393:	89 d0                	mov    %edx,%eax
+80103395:	c1 e0 02             	shl    $0x2,%eax
+80103398:	01 d0                	add    %edx,%eax
+8010339a:	01 c0                	add    %eax,%eax
+8010339c:	89 c2                	mov    %eax,%edx
+8010339e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801033a1:	83 e0 0f             	and    $0xf,%eax
+801033a4:	01 d0                	add    %edx,%eax
+801033a6:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    CONV(day   );
+801033a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801033ac:	c1 e8 04             	shr    $0x4,%eax
+801033af:	89 c2                	mov    %eax,%edx
+801033b1:	89 d0                	mov    %edx,%eax
+801033b3:	c1 e0 02             	shl    $0x2,%eax
+801033b6:	01 d0                	add    %edx,%eax
+801033b8:	01 c0                	add    %eax,%eax
+801033ba:	89 c2                	mov    %eax,%edx
+801033bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801033bf:	83 e0 0f             	and    $0xf,%eax
+801033c2:	01 d0                	add    %edx,%eax
+801033c4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    CONV(month );
+801033c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801033ca:	c1 e8 04             	shr    $0x4,%eax
+801033cd:	89 c2                	mov    %eax,%edx
+801033cf:	89 d0                	mov    %edx,%eax
+801033d1:	c1 e0 02             	shl    $0x2,%eax
+801033d4:	01 d0                	add    %edx,%eax
+801033d6:	01 c0                	add    %eax,%eax
+801033d8:	89 c2                	mov    %eax,%edx
+801033da:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801033dd:	83 e0 0f             	and    $0xf,%eax
+801033e0:	01 d0                	add    %edx,%eax
+801033e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    CONV(year  );
+801033e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801033e8:	c1 e8 04             	shr    $0x4,%eax
+801033eb:	89 c2                	mov    %eax,%edx
+801033ed:	89 d0                	mov    %edx,%eax
+801033ef:	c1 e0 02             	shl    $0x2,%eax
+801033f2:	01 d0                	add    %edx,%eax
+801033f4:	01 c0                	add    %eax,%eax
+801033f6:	89 c2                	mov    %eax,%edx
+801033f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801033fb:	83 e0 0f             	and    $0xf,%eax
+801033fe:	01 d0                	add    %edx,%eax
+80103400:	89 45 ec             	mov    %eax,-0x14(%ebp)
+#undef     CONV
+  }
+
+  *r = t1;
+80103403:	8b 45 08             	mov    0x8(%ebp),%eax
+80103406:	8b 55 d8             	mov    -0x28(%ebp),%edx
+80103409:	89 10                	mov    %edx,(%eax)
+8010340b:	8b 55 dc             	mov    -0x24(%ebp),%edx
+8010340e:	89 50 04             	mov    %edx,0x4(%eax)
+80103411:	8b 55 e0             	mov    -0x20(%ebp),%edx
+80103414:	89 50 08             	mov    %edx,0x8(%eax)
+80103417:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+8010341a:	89 50 0c             	mov    %edx,0xc(%eax)
+8010341d:	8b 55 e8             	mov    -0x18(%ebp),%edx
+80103420:	89 50 10             	mov    %edx,0x10(%eax)
+80103423:	8b 55 ec             	mov    -0x14(%ebp),%edx
+80103426:	89 50 14             	mov    %edx,0x14(%eax)
+  r->year += 2000;
+80103429:	8b 45 08             	mov    0x8(%ebp),%eax
+8010342c:	8b 40 14             	mov    0x14(%eax),%eax
+8010342f:	8d 90 d0 07 00 00    	lea    0x7d0(%eax),%edx
+80103435:	8b 45 08             	mov    0x8(%ebp),%eax
+80103438:	89 50 14             	mov    %edx,0x14(%eax)
+}
+8010343b:	90                   	nop
+8010343c:	c9                   	leave  
+8010343d:	c3                   	ret    
+
+8010343e <initlog>:
+static void recover_from_log(void);
+static void commit();
+
+void
+initlog(int dev)
+{
+8010343e:	f3 0f 1e fb          	endbr32 
+80103442:	55                   	push   %ebp
+80103443:	89 e5                	mov    %esp,%ebp
+80103445:	83 ec 28             	sub    $0x28,%esp
+  if (sizeof(struct logheader) >= BSIZE)
+    panic("initlog: too big logheader");
+
+  struct superblock sb;
+  initlock(&log.lock, "log");
+80103448:	83 ec 08             	sub    $0x8,%esp
+8010344b:	68 75 8f 10 80       	push   $0x80108f75
+80103450:	68 20 47 11 80       	push   $0x80114720
+80103455:	e8 fc 22 00 00       	call   80105756 <initlock>
+8010345a:	83 c4 10             	add    $0x10,%esp
+  readsb(dev, &sb);
+8010345d:	83 ec 08             	sub    $0x8,%esp
+80103460:	8d 45 dc             	lea    -0x24(%ebp),%eax
+80103463:	50                   	push   %eax
+80103464:	ff 75 08             	pushl  0x8(%ebp)
+80103467:	e8 f9 df ff ff       	call   80101465 <readsb>
+8010346c:	83 c4 10             	add    $0x10,%esp
+  log.start = sb.logstart;
+8010346f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103472:	a3 54 47 11 80       	mov    %eax,0x80114754
+  log.size = sb.nlog;
+80103477:	8b 45 e8             	mov    -0x18(%ebp),%eax
+8010347a:	a3 58 47 11 80       	mov    %eax,0x80114758
+  log.dev = dev;
+8010347f:	8b 45 08             	mov    0x8(%ebp),%eax
+80103482:	a3 64 47 11 80       	mov    %eax,0x80114764
+  recover_from_log();
+80103487:	e8 bf 01 00 00       	call   8010364b <recover_from_log>
+}
+8010348c:	90                   	nop
+8010348d:	c9                   	leave  
+8010348e:	c3                   	ret    
+
+8010348f <install_trans>:
+
+// Copy committed blocks from log to their home location
+static void
+install_trans(void)
+{
+8010348f:	f3 0f 1e fb          	endbr32 
+80103493:	55                   	push   %ebp
+80103494:	89 e5                	mov    %esp,%ebp
+80103496:	83 ec 18             	sub    $0x18,%esp
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+80103499:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801034a0:	e9 95 00 00 00       	jmp    8010353a <install_trans+0xab>
+    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+801034a5:	8b 15 54 47 11 80    	mov    0x80114754,%edx
+801034ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801034ae:	01 d0                	add    %edx,%eax
+801034b0:	83 c0 01             	add    $0x1,%eax
+801034b3:	89 c2                	mov    %eax,%edx
+801034b5:	a1 64 47 11 80       	mov    0x80114764,%eax
+801034ba:	83 ec 08             	sub    $0x8,%esp
+801034bd:	52                   	push   %edx
+801034be:	50                   	push   %eax
+801034bf:	e8 13 cd ff ff       	call   801001d7 <bread>
+801034c4:	83 c4 10             	add    $0x10,%esp
+801034c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+801034ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801034cd:	83 c0 10             	add    $0x10,%eax
+801034d0:	8b 04 85 2c 47 11 80 	mov    -0x7feeb8d4(,%eax,4),%eax
+801034d7:	89 c2                	mov    %eax,%edx
+801034d9:	a1 64 47 11 80       	mov    0x80114764,%eax
+801034de:	83 ec 08             	sub    $0x8,%esp
+801034e1:	52                   	push   %edx
+801034e2:	50                   	push   %eax
+801034e3:	e8 ef cc ff ff       	call   801001d7 <bread>
+801034e8:	83 c4 10             	add    $0x10,%esp
+801034eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+801034ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801034f1:	8d 50 5c             	lea    0x5c(%eax),%edx
+801034f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801034f7:	83 c0 5c             	add    $0x5c,%eax
+801034fa:	83 ec 04             	sub    $0x4,%esp
+801034fd:	68 00 02 00 00       	push   $0x200
+80103502:	52                   	push   %edx
+80103503:	50                   	push   %eax
+80103504:	e8 d9 25 00 00       	call   80105ae2 <memmove>
+80103509:	83 c4 10             	add    $0x10,%esp
+    bwrite(dbuf);  // write dst to disk
+8010350c:	83 ec 0c             	sub    $0xc,%esp
+8010350f:	ff 75 ec             	pushl  -0x14(%ebp)
+80103512:	e8 fd cc ff ff       	call   80100214 <bwrite>
+80103517:	83 c4 10             	add    $0x10,%esp
+    brelse(lbuf);
+8010351a:	83 ec 0c             	sub    $0xc,%esp
+8010351d:	ff 75 f0             	pushl  -0x10(%ebp)
+80103520:	e8 3c cd ff ff       	call   80100261 <brelse>
+80103525:	83 c4 10             	add    $0x10,%esp
+    brelse(dbuf);
+80103528:	83 ec 0c             	sub    $0xc,%esp
+8010352b:	ff 75 ec             	pushl  -0x14(%ebp)
+8010352e:	e8 2e cd ff ff       	call   80100261 <brelse>
+80103533:	83 c4 10             	add    $0x10,%esp
+  for (tail = 0; tail < log.lh.n; tail++) {
+80103536:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+8010353a:	a1 68 47 11 80       	mov    0x80114768,%eax
+8010353f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+80103542:	0f 8c 5d ff ff ff    	jl     801034a5 <install_trans+0x16>
+  }
+}
+80103548:	90                   	nop
+80103549:	90                   	nop
+8010354a:	c9                   	leave  
+8010354b:	c3                   	ret    
+
+8010354c <read_head>:
+
+// Read the log header from disk into the in-memory log header
+static void
+read_head(void)
+{
+8010354c:	f3 0f 1e fb          	endbr32 
+80103550:	55                   	push   %ebp
+80103551:	89 e5                	mov    %esp,%ebp
+80103553:	83 ec 18             	sub    $0x18,%esp
+  struct buf *buf = bread(log.dev, log.start);
+80103556:	a1 54 47 11 80       	mov    0x80114754,%eax
+8010355b:	89 c2                	mov    %eax,%edx
+8010355d:	a1 64 47 11 80       	mov    0x80114764,%eax
+80103562:	83 ec 08             	sub    $0x8,%esp
+80103565:	52                   	push   %edx
+80103566:	50                   	push   %eax
+80103567:	e8 6b cc ff ff       	call   801001d7 <bread>
+8010356c:	83 c4 10             	add    $0x10,%esp
+8010356f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  struct logheader *lh = (struct logheader *) (buf->data);
+80103572:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103575:	83 c0 5c             	add    $0x5c,%eax
+80103578:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  int i;
+  log.lh.n = lh->n;
+8010357b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010357e:	8b 00                	mov    (%eax),%eax
+80103580:	a3 68 47 11 80       	mov    %eax,0x80114768
+  for (i = 0; i < log.lh.n; i++) {
+80103585:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+8010358c:	eb 1b                	jmp    801035a9 <read_head+0x5d>
+    log.lh.block[i] = lh->block[i];
+8010358e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103591:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80103594:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
+80103598:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010359b:	83 c2 10             	add    $0x10,%edx
+8010359e:	89 04 95 2c 47 11 80 	mov    %eax,-0x7feeb8d4(,%edx,4)
+  for (i = 0; i < log.lh.n; i++) {
+801035a5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801035a9:	a1 68 47 11 80       	mov    0x80114768,%eax
+801035ae:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+801035b1:	7c db                	jl     8010358e <read_head+0x42>
+  }
+  brelse(buf);
+801035b3:	83 ec 0c             	sub    $0xc,%esp
+801035b6:	ff 75 f0             	pushl  -0x10(%ebp)
+801035b9:	e8 a3 cc ff ff       	call   80100261 <brelse>
+801035be:	83 c4 10             	add    $0x10,%esp
+}
+801035c1:	90                   	nop
+801035c2:	c9                   	leave  
+801035c3:	c3                   	ret    
+
+801035c4 <write_head>:
+// Write in-memory log header to disk.
+// This is the true point at which the
+// current transaction commits.
+static void
+write_head(void)
+{
+801035c4:	f3 0f 1e fb          	endbr32 
+801035c8:	55                   	push   %ebp
+801035c9:	89 e5                	mov    %esp,%ebp
+801035cb:	83 ec 18             	sub    $0x18,%esp
+  struct buf *buf = bread(log.dev, log.start);
+801035ce:	a1 54 47 11 80       	mov    0x80114754,%eax
+801035d3:	89 c2                	mov    %eax,%edx
+801035d5:	a1 64 47 11 80       	mov    0x80114764,%eax
+801035da:	83 ec 08             	sub    $0x8,%esp
+801035dd:	52                   	push   %edx
+801035de:	50                   	push   %eax
+801035df:	e8 f3 cb ff ff       	call   801001d7 <bread>
+801035e4:	83 c4 10             	add    $0x10,%esp
+801035e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  struct logheader *hb = (struct logheader *) (buf->data);
+801035ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801035ed:	83 c0 5c             	add    $0x5c,%eax
+801035f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  int i;
+  hb->n = log.lh.n;
+801035f3:	8b 15 68 47 11 80    	mov    0x80114768,%edx
+801035f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801035fc:	89 10                	mov    %edx,(%eax)
+  for (i = 0; i < log.lh.n; i++) {
+801035fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80103605:	eb 1b                	jmp    80103622 <write_head+0x5e>
+    hb->block[i] = log.lh.block[i];
+80103607:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010360a:	83 c0 10             	add    $0x10,%eax
+8010360d:	8b 0c 85 2c 47 11 80 	mov    -0x7feeb8d4(,%eax,4),%ecx
+80103614:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103617:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010361a:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
+  for (i = 0; i < log.lh.n; i++) {
+8010361e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80103622:	a1 68 47 11 80       	mov    0x80114768,%eax
+80103627:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+8010362a:	7c db                	jl     80103607 <write_head+0x43>
+  }
+  bwrite(buf);
+8010362c:	83 ec 0c             	sub    $0xc,%esp
+8010362f:	ff 75 f0             	pushl  -0x10(%ebp)
+80103632:	e8 dd cb ff ff       	call   80100214 <bwrite>
+80103637:	83 c4 10             	add    $0x10,%esp
+  brelse(buf);
+8010363a:	83 ec 0c             	sub    $0xc,%esp
+8010363d:	ff 75 f0             	pushl  -0x10(%ebp)
+80103640:	e8 1c cc ff ff       	call   80100261 <brelse>
+80103645:	83 c4 10             	add    $0x10,%esp
+}
+80103648:	90                   	nop
+80103649:	c9                   	leave  
+8010364a:	c3                   	ret    
+
+8010364b <recover_from_log>:
+
+static void
+recover_from_log(void)
+{
+8010364b:	f3 0f 1e fb          	endbr32 
+8010364f:	55                   	push   %ebp
+80103650:	89 e5                	mov    %esp,%ebp
+80103652:	83 ec 08             	sub    $0x8,%esp
+  read_head();
+80103655:	e8 f2 fe ff ff       	call   8010354c <read_head>
+  install_trans(); // if committed, copy from log to disk
+8010365a:	e8 30 fe ff ff       	call   8010348f <install_trans>
+  log.lh.n = 0;
+8010365f:	c7 05 68 47 11 80 00 	movl   $0x0,0x80114768
+80103666:	00 00 00 
+  write_head(); // clear the log
+80103669:	e8 56 ff ff ff       	call   801035c4 <write_head>
+}
+8010366e:	90                   	nop
+8010366f:	c9                   	leave  
+80103670:	c3                   	ret    
+
+80103671 <begin_op>:
+
+// called at the start of each FS system call.
+void
+begin_op(void)
+{
+80103671:	f3 0f 1e fb          	endbr32 
+80103675:	55                   	push   %ebp
+80103676:	89 e5                	mov    %esp,%ebp
+80103678:	83 ec 08             	sub    $0x8,%esp
+  acquire(&log.lock);
+8010367b:	83 ec 0c             	sub    $0xc,%esp
+8010367e:	68 20 47 11 80       	push   $0x80114720
+80103683:	e8 f4 20 00 00       	call   8010577c <acquire>
+80103688:	83 c4 10             	add    $0x10,%esp
+  while(1){
+    if(log.committing){
+8010368b:	a1 60 47 11 80       	mov    0x80114760,%eax
+80103690:	85 c0                	test   %eax,%eax
+80103692:	74 17                	je     801036ab <begin_op+0x3a>
+      sleep(&log, &log.lock);
+80103694:	83 ec 08             	sub    $0x8,%esp
+80103697:	68 20 47 11 80       	push   $0x80114720
+8010369c:	68 20 47 11 80       	push   $0x80114720
+801036a1:	e8 b8 1a 00 00       	call   8010515e <sleep>
+801036a6:	83 c4 10             	add    $0x10,%esp
+801036a9:	eb e0                	jmp    8010368b <begin_op+0x1a>
+    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+801036ab:	8b 0d 68 47 11 80    	mov    0x80114768,%ecx
+801036b1:	a1 5c 47 11 80       	mov    0x8011475c,%eax
+801036b6:	8d 50 01             	lea    0x1(%eax),%edx
+801036b9:	89 d0                	mov    %edx,%eax
+801036bb:	c1 e0 02             	shl    $0x2,%eax
+801036be:	01 d0                	add    %edx,%eax
+801036c0:	01 c0                	add    %eax,%eax
+801036c2:	01 c8                	add    %ecx,%eax
+801036c4:	83 f8 1e             	cmp    $0x1e,%eax
+801036c7:	7e 17                	jle    801036e0 <begin_op+0x6f>
+      // this op might exhaust log space; wait for commit.
+      sleep(&log, &log.lock);
+801036c9:	83 ec 08             	sub    $0x8,%esp
+801036cc:	68 20 47 11 80       	push   $0x80114720
+801036d1:	68 20 47 11 80       	push   $0x80114720
+801036d6:	e8 83 1a 00 00       	call   8010515e <sleep>
+801036db:	83 c4 10             	add    $0x10,%esp
+801036de:	eb ab                	jmp    8010368b <begin_op+0x1a>
+    } else {
+      log.outstanding += 1;
+801036e0:	a1 5c 47 11 80       	mov    0x8011475c,%eax
+801036e5:	83 c0 01             	add    $0x1,%eax
+801036e8:	a3 5c 47 11 80       	mov    %eax,0x8011475c
+      release(&log.lock);
+801036ed:	83 ec 0c             	sub    $0xc,%esp
+801036f0:	68 20 47 11 80       	push   $0x80114720
+801036f5:	e8 f4 20 00 00       	call   801057ee <release>
+801036fa:	83 c4 10             	add    $0x10,%esp
+      break;
+801036fd:	90                   	nop
+    }
+  }
+}
+801036fe:	90                   	nop
+801036ff:	c9                   	leave  
+80103700:	c3                   	ret    
+
+80103701 <end_op>:
+
+// called at the end of each FS system call.
+// commits if this was the last outstanding operation.
+void
+end_op(void)
+{
+80103701:	f3 0f 1e fb          	endbr32 
+80103705:	55                   	push   %ebp
+80103706:	89 e5                	mov    %esp,%ebp
+80103708:	83 ec 18             	sub    $0x18,%esp
+  int do_commit = 0;
+8010370b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+  acquire(&log.lock);
+80103712:	83 ec 0c             	sub    $0xc,%esp
+80103715:	68 20 47 11 80       	push   $0x80114720
+8010371a:	e8 5d 20 00 00       	call   8010577c <acquire>
+8010371f:	83 c4 10             	add    $0x10,%esp
+  log.outstanding -= 1;
+80103722:	a1 5c 47 11 80       	mov    0x8011475c,%eax
+80103727:	83 e8 01             	sub    $0x1,%eax
+8010372a:	a3 5c 47 11 80       	mov    %eax,0x8011475c
+  if(log.committing)
+8010372f:	a1 60 47 11 80       	mov    0x80114760,%eax
+80103734:	85 c0                	test   %eax,%eax
+80103736:	74 0d                	je     80103745 <end_op+0x44>
+    panic("log.committing");
+80103738:	83 ec 0c             	sub    $0xc,%esp
+8010373b:	68 79 8f 10 80       	push   $0x80108f79
+80103740:	e8 8c ce ff ff       	call   801005d1 <panic>
+  if(log.outstanding == 0){
+80103745:	a1 5c 47 11 80       	mov    0x8011475c,%eax
+8010374a:	85 c0                	test   %eax,%eax
+8010374c:	75 13                	jne    80103761 <end_op+0x60>
+    do_commit = 1;
+8010374e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+    log.committing = 1;
+80103755:	c7 05 60 47 11 80 01 	movl   $0x1,0x80114760
+8010375c:	00 00 00 
+8010375f:	eb 10                	jmp    80103771 <end_op+0x70>
+  } else {
+    // begin_op() may be waiting for log space,
+    // and decrementing log.outstanding has decreased
+    // the amount of reserved space.
+    wakeup(&log);
+80103761:	83 ec 0c             	sub    $0xc,%esp
+80103764:	68 20 47 11 80       	push   $0x80114720
+80103769:	e8 e2 1a 00 00       	call   80105250 <wakeup>
+8010376e:	83 c4 10             	add    $0x10,%esp
+  }
+  release(&log.lock);
+80103771:	83 ec 0c             	sub    $0xc,%esp
+80103774:	68 20 47 11 80       	push   $0x80114720
+80103779:	e8 70 20 00 00       	call   801057ee <release>
+8010377e:	83 c4 10             	add    $0x10,%esp
+
+  if(do_commit){
+80103781:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80103785:	74 3f                	je     801037c6 <end_op+0xc5>
+    // call commit w/o holding locks, since not allowed
+    // to sleep with locks.
+    commit();
+80103787:	e8 fa 00 00 00       	call   80103886 <commit>
+    acquire(&log.lock);
+8010378c:	83 ec 0c             	sub    $0xc,%esp
+8010378f:	68 20 47 11 80       	push   $0x80114720
+80103794:	e8 e3 1f 00 00       	call   8010577c <acquire>
+80103799:	83 c4 10             	add    $0x10,%esp
+    log.committing = 0;
+8010379c:	c7 05 60 47 11 80 00 	movl   $0x0,0x80114760
+801037a3:	00 00 00 
+    wakeup(&log);
+801037a6:	83 ec 0c             	sub    $0xc,%esp
+801037a9:	68 20 47 11 80       	push   $0x80114720
+801037ae:	e8 9d 1a 00 00       	call   80105250 <wakeup>
+801037b3:	83 c4 10             	add    $0x10,%esp
+    release(&log.lock);
+801037b6:	83 ec 0c             	sub    $0xc,%esp
+801037b9:	68 20 47 11 80       	push   $0x80114720
+801037be:	e8 2b 20 00 00       	call   801057ee <release>
+801037c3:	83 c4 10             	add    $0x10,%esp
+  }
+}
+801037c6:	90                   	nop
+801037c7:	c9                   	leave  
+801037c8:	c3                   	ret    
+
+801037c9 <write_log>:
+
+// Copy modified blocks from cache to log.
+static void
+write_log(void)
+{
+801037c9:	f3 0f 1e fb          	endbr32 
+801037cd:	55                   	push   %ebp
+801037ce:	89 e5                	mov    %esp,%ebp
+801037d0:	83 ec 18             	sub    $0x18,%esp
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+801037d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801037da:	e9 95 00 00 00       	jmp    80103874 <write_log+0xab>
+    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+801037df:	8b 15 54 47 11 80    	mov    0x80114754,%edx
+801037e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801037e8:	01 d0                	add    %edx,%eax
+801037ea:	83 c0 01             	add    $0x1,%eax
+801037ed:	89 c2                	mov    %eax,%edx
+801037ef:	a1 64 47 11 80       	mov    0x80114764,%eax
+801037f4:	83 ec 08             	sub    $0x8,%esp
+801037f7:	52                   	push   %edx
+801037f8:	50                   	push   %eax
+801037f9:	e8 d9 c9 ff ff       	call   801001d7 <bread>
+801037fe:	83 c4 10             	add    $0x10,%esp
+80103801:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+80103804:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103807:	83 c0 10             	add    $0x10,%eax
+8010380a:	8b 04 85 2c 47 11 80 	mov    -0x7feeb8d4(,%eax,4),%eax
+80103811:	89 c2                	mov    %eax,%edx
+80103813:	a1 64 47 11 80       	mov    0x80114764,%eax
+80103818:	83 ec 08             	sub    $0x8,%esp
+8010381b:	52                   	push   %edx
+8010381c:	50                   	push   %eax
+8010381d:	e8 b5 c9 ff ff       	call   801001d7 <bread>
+80103822:	83 c4 10             	add    $0x10,%esp
+80103825:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    memmove(to->data, from->data, BSIZE);
+80103828:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010382b:	8d 50 5c             	lea    0x5c(%eax),%edx
+8010382e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103831:	83 c0 5c             	add    $0x5c,%eax
+80103834:	83 ec 04             	sub    $0x4,%esp
+80103837:	68 00 02 00 00       	push   $0x200
+8010383c:	52                   	push   %edx
+8010383d:	50                   	push   %eax
+8010383e:	e8 9f 22 00 00       	call   80105ae2 <memmove>
+80103843:	83 c4 10             	add    $0x10,%esp
+    bwrite(to);  // write the log
+80103846:	83 ec 0c             	sub    $0xc,%esp
+80103849:	ff 75 f0             	pushl  -0x10(%ebp)
+8010384c:	e8 c3 c9 ff ff       	call   80100214 <bwrite>
+80103851:	83 c4 10             	add    $0x10,%esp
+    brelse(from);
+80103854:	83 ec 0c             	sub    $0xc,%esp
+80103857:	ff 75 ec             	pushl  -0x14(%ebp)
+8010385a:	e8 02 ca ff ff       	call   80100261 <brelse>
+8010385f:	83 c4 10             	add    $0x10,%esp
+    brelse(to);
+80103862:	83 ec 0c             	sub    $0xc,%esp
+80103865:	ff 75 f0             	pushl  -0x10(%ebp)
+80103868:	e8 f4 c9 ff ff       	call   80100261 <brelse>
+8010386d:	83 c4 10             	add    $0x10,%esp
+  for (tail = 0; tail < log.lh.n; tail++) {
+80103870:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80103874:	a1 68 47 11 80       	mov    0x80114768,%eax
+80103879:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+8010387c:	0f 8c 5d ff ff ff    	jl     801037df <write_log+0x16>
+  }
+}
+80103882:	90                   	nop
+80103883:	90                   	nop
+80103884:	c9                   	leave  
+80103885:	c3                   	ret    
+
+80103886 <commit>:
+
+static void
+commit()
+{
+80103886:	f3 0f 1e fb          	endbr32 
+8010388a:	55                   	push   %ebp
+8010388b:	89 e5                	mov    %esp,%ebp
+8010388d:	83 ec 08             	sub    $0x8,%esp
+  if (log.lh.n > 0) {
+80103890:	a1 68 47 11 80       	mov    0x80114768,%eax
+80103895:	85 c0                	test   %eax,%eax
+80103897:	7e 1e                	jle    801038b7 <commit+0x31>
+    write_log();     // Write modified blocks from cache to log
+80103899:	e8 2b ff ff ff       	call   801037c9 <write_log>
+    write_head();    // Write header to disk -- the real commit
+8010389e:	e8 21 fd ff ff       	call   801035c4 <write_head>
+    install_trans(); // Now install writes to home locations
+801038a3:	e8 e7 fb ff ff       	call   8010348f <install_trans>
+    log.lh.n = 0;
+801038a8:	c7 05 68 47 11 80 00 	movl   $0x0,0x80114768
+801038af:	00 00 00 
+    write_head();    // Erase the transaction from the log
+801038b2:	e8 0d fd ff ff       	call   801035c4 <write_head>
+  }
+}
+801038b7:	90                   	nop
+801038b8:	c9                   	leave  
+801038b9:	c3                   	ret    
+
+801038ba <log_write>:
+//   modify bp->data[]
+//   log_write(bp)
+//   brelse(bp)
+void
+log_write(struct buf *b)
+{
+801038ba:	f3 0f 1e fb          	endbr32 
+801038be:	55                   	push   %ebp
+801038bf:	89 e5                	mov    %esp,%ebp
+801038c1:	83 ec 18             	sub    $0x18,%esp
+  int i;
+
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+801038c4:	a1 68 47 11 80       	mov    0x80114768,%eax
+801038c9:	83 f8 1d             	cmp    $0x1d,%eax
+801038cc:	7f 12                	jg     801038e0 <log_write+0x26>
+801038ce:	a1 68 47 11 80       	mov    0x80114768,%eax
+801038d3:	8b 15 58 47 11 80    	mov    0x80114758,%edx
+801038d9:	83 ea 01             	sub    $0x1,%edx
+801038dc:	39 d0                	cmp    %edx,%eax
+801038de:	7c 0d                	jl     801038ed <log_write+0x33>
+    panic("too big a transaction");
+801038e0:	83 ec 0c             	sub    $0xc,%esp
+801038e3:	68 88 8f 10 80       	push   $0x80108f88
+801038e8:	e8 e4 cc ff ff       	call   801005d1 <panic>
+  if (log.outstanding < 1)
+801038ed:	a1 5c 47 11 80       	mov    0x8011475c,%eax
+801038f2:	85 c0                	test   %eax,%eax
+801038f4:	7f 0d                	jg     80103903 <log_write+0x49>
+    panic("log_write outside of trans");
+801038f6:	83 ec 0c             	sub    $0xc,%esp
+801038f9:	68 9e 8f 10 80       	push   $0x80108f9e
+801038fe:	e8 ce cc ff ff       	call   801005d1 <panic>
+
+  acquire(&log.lock);
+80103903:	83 ec 0c             	sub    $0xc,%esp
+80103906:	68 20 47 11 80       	push   $0x80114720
+8010390b:	e8 6c 1e 00 00       	call   8010577c <acquire>
+80103910:	83 c4 10             	add    $0x10,%esp
+  for (i = 0; i < log.lh.n; i++) {
+80103913:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+8010391a:	eb 1d                	jmp    80103939 <log_write+0x7f>
+    if (log.lh.block[i] == b->blockno)   // log absorbtion
+8010391c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010391f:	83 c0 10             	add    $0x10,%eax
+80103922:	8b 04 85 2c 47 11 80 	mov    -0x7feeb8d4(,%eax,4),%eax
+80103929:	89 c2                	mov    %eax,%edx
+8010392b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010392e:	8b 40 08             	mov    0x8(%eax),%eax
+80103931:	39 c2                	cmp    %eax,%edx
+80103933:	74 10                	je     80103945 <log_write+0x8b>
+  for (i = 0; i < log.lh.n; i++) {
+80103935:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80103939:	a1 68 47 11 80       	mov    0x80114768,%eax
+8010393e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+80103941:	7c d9                	jl     8010391c <log_write+0x62>
+80103943:	eb 01                	jmp    80103946 <log_write+0x8c>
+      break;
+80103945:	90                   	nop
+  }
+  log.lh.block[i] = b->blockno;
+80103946:	8b 45 08             	mov    0x8(%ebp),%eax
+80103949:	8b 40 08             	mov    0x8(%eax),%eax
+8010394c:	89 c2                	mov    %eax,%edx
+8010394e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103951:	83 c0 10             	add    $0x10,%eax
+80103954:	89 14 85 2c 47 11 80 	mov    %edx,-0x7feeb8d4(,%eax,4)
+  if (i == log.lh.n)
+8010395b:	a1 68 47 11 80       	mov    0x80114768,%eax
+80103960:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+80103963:	75 0d                	jne    80103972 <log_write+0xb8>
+    log.lh.n++;
+80103965:	a1 68 47 11 80       	mov    0x80114768,%eax
+8010396a:	83 c0 01             	add    $0x1,%eax
+8010396d:	a3 68 47 11 80       	mov    %eax,0x80114768
+  b->flags |= B_DIRTY; // prevent eviction
+80103972:	8b 45 08             	mov    0x8(%ebp),%eax
+80103975:	8b 00                	mov    (%eax),%eax
+80103977:	83 c8 04             	or     $0x4,%eax
+8010397a:	89 c2                	mov    %eax,%edx
+8010397c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010397f:	89 10                	mov    %edx,(%eax)
+  release(&log.lock);
+80103981:	83 ec 0c             	sub    $0xc,%esp
+80103984:	68 20 47 11 80       	push   $0x80114720
+80103989:	e8 60 1e 00 00       	call   801057ee <release>
+8010398e:	83 c4 10             	add    $0x10,%esp
+}
+80103991:	90                   	nop
+80103992:	c9                   	leave  
+80103993:	c3                   	ret    
+
+80103994 <xchg>:
+  asm volatile("sti");
+}
+
+static inline uint
+xchg(volatile uint *addr, uint newval)
+{
+80103994:	55                   	push   %ebp
+80103995:	89 e5                	mov    %esp,%ebp
+80103997:	83 ec 10             	sub    $0x10,%esp
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+8010399a:	8b 55 08             	mov    0x8(%ebp),%edx
+8010399d:	8b 45 0c             	mov    0xc(%ebp),%eax
+801039a0:	8b 4d 08             	mov    0x8(%ebp),%ecx
+801039a3:	f0 87 02             	lock xchg %eax,(%edx)
+801039a6:	89 45 fc             	mov    %eax,-0x4(%ebp)
+               "+m" (*addr), "=a" (result) :
+               "1" (newval) :
+               "cc");
+  return result;
+801039a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+801039ac:	c9                   	leave  
+801039ad:	c3                   	ret    
+
+801039ae <main>:
+// Bootstrap processor starts running C code here.
+// Allocate a real stack and switch to it, first
+// doing some setup required for memory allocator to work.
+int
+main(void)
+{
+801039ae:	f3 0f 1e fb          	endbr32 
+801039b2:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+801039b6:	83 e4 f0             	and    $0xfffffff0,%esp
+801039b9:	ff 71 fc             	pushl  -0x4(%ecx)
+801039bc:	55                   	push   %ebp
+801039bd:	89 e5                	mov    %esp,%ebp
+801039bf:	51                   	push   %ecx
+801039c0:	83 ec 04             	sub    $0x4,%esp
+  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+801039c3:	83 ec 08             	sub    $0x8,%esp
+801039c6:	68 00 00 40 80       	push   $0x80400000
+801039cb:	68 48 7d 11 80       	push   $0x80117d48
+801039d0:	e8 78 f2 ff ff       	call   80102c4d <kinit1>
+801039d5:	83 c4 10             	add    $0x10,%esp
+  kvmalloc();      // kernel page table
+801039d8:	e8 39 4b 00 00       	call   80108516 <kvmalloc>
+  mpinit();        // detect other processors
+801039dd:	e8 d9 03 00 00       	call   80103dbb <mpinit>
+  lapicinit();     // interrupt controller
+801039e2:	e8 f5 f5 ff ff       	call   80102fdc <lapicinit>
+  seginit();       // segment descriptors
+801039e7:	e8 05 46 00 00       	call   80107ff1 <seginit>
+  picinit();       // disable pic
+801039ec:	e8 35 05 00 00       	call   80103f26 <picinit>
+  ioapicinit();    // another interrupt controller
+801039f1:	e8 6a f1 ff ff       	call   80102b60 <ioapicinit>
+  consoleinit();   // console hardware
+801039f6:	e8 af d1 ff ff       	call   80100baa <consoleinit>
+  uartinit();      // serial port
+801039fb:	e8 7a 39 00 00       	call   8010737a <uartinit>
+  pinit();         // process table
+80103a00:	e8 e7 0a 00 00       	call   801044ec <pinit>
+  tvinit();        // trap vectors
+80103a05:	e8 28 35 00 00       	call   80106f32 <tvinit>
+  binit();         // buffer cache
+80103a0a:	e8 25 c6 ff ff       	call   80100034 <binit>
+  fileinit();      // file table
+80103a0f:	e8 26 d6 ff ff       	call   8010103a <fileinit>
+  ideinit();       // disk 
+80103a14:	e8 06 ed ff ff       	call   8010271f <ideinit>
+  startothers();   // start other processors
+80103a19:	e8 88 00 00 00       	call   80103aa6 <startothers>
+  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+80103a1e:	83 ec 08             	sub    $0x8,%esp
+80103a21:	68 00 00 00 8e       	push   $0x8e000000
+80103a26:	68 00 00 40 80       	push   $0x80400000
+80103a2b:	e8 5a f2 ff ff       	call   80102c8a <kinit2>
+80103a30:	83 c4 10             	add    $0x10,%esp
+  userinit();      // first user process
+80103a33:	e8 3d 0d 00 00       	call   80104775 <userinit>
+  mpmain();        // finish this processor's setup
+80103a38:	e8 1e 00 00 00       	call   80103a5b <mpmain>
+
+80103a3d <mpenter>:
+}
+
+// Other CPUs jump here from entryother.S.
+static void
+mpenter(void)
+{
+80103a3d:	f3 0f 1e fb          	endbr32 
+80103a41:	55                   	push   %ebp
+80103a42:	89 e5                	mov    %esp,%ebp
+80103a44:	83 ec 08             	sub    $0x8,%esp
+  switchkvm();
+80103a47:	e8 e6 4a 00 00       	call   80108532 <switchkvm>
+  seginit();
+80103a4c:	e8 a0 45 00 00       	call   80107ff1 <seginit>
+  lapicinit();
+80103a51:	e8 86 f5 ff ff       	call   80102fdc <lapicinit>
+  mpmain();
+80103a56:	e8 00 00 00 00       	call   80103a5b <mpmain>
+
+80103a5b <mpmain>:
+}
+
+// Common CPU setup code.
+static void
+mpmain(void)
+{
+80103a5b:	f3 0f 1e fb          	endbr32 
+80103a5f:	55                   	push   %ebp
+80103a60:	89 e5                	mov    %esp,%ebp
+80103a62:	53                   	push   %ebx
+80103a63:	83 ec 04             	sub    $0x4,%esp
+  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
+80103a66:	e8 a3 0a 00 00       	call   8010450e <cpuid>
+80103a6b:	89 c3                	mov    %eax,%ebx
+80103a6d:	e8 9c 0a 00 00       	call   8010450e <cpuid>
+80103a72:	83 ec 04             	sub    $0x4,%esp
+80103a75:	53                   	push   %ebx
+80103a76:	50                   	push   %eax
+80103a77:	68 b9 8f 10 80       	push   $0x80108fb9
+80103a7c:	e8 97 c9 ff ff       	call   80100418 <cprintf>
+80103a81:	83 c4 10             	add    $0x10,%esp
+  idtinit();       // load idt register
+80103a84:	e8 23 36 00 00       	call   801070ac <idtinit>
+  xchg(&(mycpu()->started), 1); // tell startothers() we're up
+80103a89:	e8 9f 0a 00 00       	call   8010452d <mycpu>
+80103a8e:	05 a0 00 00 00       	add    $0xa0,%eax
+80103a93:	83 ec 08             	sub    $0x8,%esp
+80103a96:	6a 01                	push   $0x1
+80103a98:	50                   	push   %eax
+80103a99:	e8 f6 fe ff ff       	call   80103994 <xchg>
+80103a9e:	83 c4 10             	add    $0x10,%esp
+  scheduler();     // start running processes
+80103aa1:	e8 9e 14 00 00       	call   80104f44 <scheduler>
+
+80103aa6 <startothers>:
+pde_t entrypgdir[];  // For entry.S
+
+// Start the non-boot (AP) processors.
+static void
+startothers(void)
+{
+80103aa6:	f3 0f 1e fb          	endbr32 
+80103aaa:	55                   	push   %ebp
+80103aab:	89 e5                	mov    %esp,%ebp
+80103aad:	83 ec 18             	sub    $0x18,%esp
+  char *stack;
+
+  // Write entry code to unused memory at 0x7000.
+  // The linker has placed the image of entryother.S in
+  // _binary_entryother_start.
+  code = P2V(0x7000);
+80103ab0:	c7 45 f0 00 70 00 80 	movl   $0x80007000,-0x10(%ebp)
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+80103ab7:	b8 8a 00 00 00       	mov    $0x8a,%eax
+80103abc:	83 ec 04             	sub    $0x4,%esp
+80103abf:	50                   	push   %eax
+80103ac0:	68 0c c5 10 80       	push   $0x8010c50c
+80103ac5:	ff 75 f0             	pushl  -0x10(%ebp)
+80103ac8:	e8 15 20 00 00       	call   80105ae2 <memmove>
+80103acd:	83 c4 10             	add    $0x10,%esp
+
+  for(c = cpus; c < cpus+ncpu; c++){
+80103ad0:	c7 45 f4 20 48 11 80 	movl   $0x80114820,-0xc(%ebp)
+80103ad7:	eb 79                	jmp    80103b52 <startothers+0xac>
+    if(c == mycpu())  // We've started already.
+80103ad9:	e8 4f 0a 00 00       	call   8010452d <mycpu>
+80103ade:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+80103ae1:	74 67                	je     80103b4a <startothers+0xa4>
+      continue;
+
+    // Tell entryother.S what stack to use, where to enter, and what
+    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+    // is running in low  memory, so we use entrypgdir for the APs too.
+    stack = kalloc();
+80103ae3:	e8 aa f2 ff ff       	call   80102d92 <kalloc>
+80103ae8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    *(void**)(code-4) = stack + KSTACKSIZE;
+80103aeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103aee:	83 e8 04             	sub    $0x4,%eax
+80103af1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+80103af4:	81 c2 00 10 00 00    	add    $0x1000,%edx
+80103afa:	89 10                	mov    %edx,(%eax)
+    *(void(**)(void))(code-8) = mpenter;
+80103afc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103aff:	83 e8 08             	sub    $0x8,%eax
+80103b02:	c7 00 3d 3a 10 80    	movl   $0x80103a3d,(%eax)
+    *(int**)(code-12) = (void *) V2P(entrypgdir);
+80103b08:	b8 00 b0 10 80       	mov    $0x8010b000,%eax
+80103b0d:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
+80103b13:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103b16:	83 e8 0c             	sub    $0xc,%eax
+80103b19:	89 10                	mov    %edx,(%eax)
+
+    lapicstartap(c->apicid, V2P(code));
+80103b1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103b1e:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
+80103b24:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103b27:	0f b6 00             	movzbl (%eax),%eax
+80103b2a:	0f b6 c0             	movzbl %al,%eax
+80103b2d:	83 ec 08             	sub    $0x8,%esp
+80103b30:	52                   	push   %edx
+80103b31:	50                   	push   %eax
+80103b32:	e8 17 f6 ff ff       	call   8010314e <lapicstartap>
+80103b37:	83 c4 10             	add    $0x10,%esp
+
+    // wait for cpu to finish mpmain()
+    while(c->started == 0)
+80103b3a:	90                   	nop
+80103b3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103b3e:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
+80103b44:	85 c0                	test   %eax,%eax
+80103b46:	74 f3                	je     80103b3b <startothers+0x95>
+80103b48:	eb 01                	jmp    80103b4b <startothers+0xa5>
+      continue;
+80103b4a:	90                   	nop
+  for(c = cpus; c < cpus+ncpu; c++){
+80103b4b:	81 45 f4 b0 00 00 00 	addl   $0xb0,-0xc(%ebp)
+80103b52:	a1 a0 4d 11 80       	mov    0x80114da0,%eax
+80103b57:	69 c0 b0 00 00 00    	imul   $0xb0,%eax,%eax
+80103b5d:	05 20 48 11 80       	add    $0x80114820,%eax
+80103b62:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+80103b65:	0f 82 6e ff ff ff    	jb     80103ad9 <startothers+0x33>
+      ;
+  }
+}
+80103b6b:	90                   	nop
+80103b6c:	90                   	nop
+80103b6d:	c9                   	leave  
+80103b6e:	c3                   	ret    
+
+80103b6f <inb>:
+{
+80103b6f:	55                   	push   %ebp
+80103b70:	89 e5                	mov    %esp,%ebp
+80103b72:	83 ec 14             	sub    $0x14,%esp
+80103b75:	8b 45 08             	mov    0x8(%ebp),%eax
+80103b78:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80103b7c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+80103b80:	89 c2                	mov    %eax,%edx
+80103b82:	ec                   	in     (%dx),%al
+80103b83:	88 45 ff             	mov    %al,-0x1(%ebp)
+  return data;
+80103b86:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
+}
+80103b8a:	c9                   	leave  
+80103b8b:	c3                   	ret    
+
+80103b8c <outb>:
+{
+80103b8c:	55                   	push   %ebp
+80103b8d:	89 e5                	mov    %esp,%ebp
+80103b8f:	83 ec 08             	sub    $0x8,%esp
+80103b92:	8b 45 08             	mov    0x8(%ebp),%eax
+80103b95:	8b 55 0c             	mov    0xc(%ebp),%edx
+80103b98:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+80103b9c:	89 d0                	mov    %edx,%eax
+80103b9e:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80103ba1:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80103ba5:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80103ba9:	ee                   	out    %al,(%dx)
+}
+80103baa:	90                   	nop
+80103bab:	c9                   	leave  
+80103bac:	c3                   	ret    
+
+80103bad <sum>:
+int ncpu;
+uchar ioapicid;
+
+static uchar
+sum(uchar *addr, int len)
+{
+80103bad:	f3 0f 1e fb          	endbr32 
+80103bb1:	55                   	push   %ebp
+80103bb2:	89 e5                	mov    %esp,%ebp
+80103bb4:	83 ec 10             	sub    $0x10,%esp
+  int i, sum;
+
+  sum = 0;
+80103bb7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+  for(i=0; i<len; i++)
+80103bbe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+80103bc5:	eb 15                	jmp    80103bdc <sum+0x2f>
+    sum += addr[i];
+80103bc7:	8b 55 fc             	mov    -0x4(%ebp),%edx
+80103bca:	8b 45 08             	mov    0x8(%ebp),%eax
+80103bcd:	01 d0                	add    %edx,%eax
+80103bcf:	0f b6 00             	movzbl (%eax),%eax
+80103bd2:	0f b6 c0             	movzbl %al,%eax
+80103bd5:	01 45 f8             	add    %eax,-0x8(%ebp)
+  for(i=0; i<len; i++)
+80103bd8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+80103bdc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80103bdf:	3b 45 0c             	cmp    0xc(%ebp),%eax
+80103be2:	7c e3                	jl     80103bc7 <sum+0x1a>
+  return sum;
+80103be4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+80103be7:	c9                   	leave  
+80103be8:	c3                   	ret    
+
+80103be9 <mpsearch1>:
+
+// Look for an MP structure in the len bytes at addr.
+static struct mp*
+mpsearch1(uint a, int len)
+{
+80103be9:	f3 0f 1e fb          	endbr32 
+80103bed:	55                   	push   %ebp
+80103bee:	89 e5                	mov    %esp,%ebp
+80103bf0:	83 ec 18             	sub    $0x18,%esp
+  uchar *e, *p, *addr;
+
+  addr = P2V(a);
+80103bf3:	8b 45 08             	mov    0x8(%ebp),%eax
+80103bf6:	05 00 00 00 80       	add    $0x80000000,%eax
+80103bfb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  e = addr+len;
+80103bfe:	8b 55 0c             	mov    0xc(%ebp),%edx
+80103c01:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103c04:	01 d0                	add    %edx,%eax
+80103c06:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  for(p = addr; p < e; p += sizeof(struct mp))
+80103c09:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103c0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80103c0f:	eb 36                	jmp    80103c47 <mpsearch1+0x5e>
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+80103c11:	83 ec 04             	sub    $0x4,%esp
+80103c14:	6a 04                	push   $0x4
+80103c16:	68 d0 8f 10 80       	push   $0x80108fd0
+80103c1b:	ff 75 f4             	pushl  -0xc(%ebp)
+80103c1e:	e8 63 1e 00 00       	call   80105a86 <memcmp>
+80103c23:	83 c4 10             	add    $0x10,%esp
+80103c26:	85 c0                	test   %eax,%eax
+80103c28:	75 19                	jne    80103c43 <mpsearch1+0x5a>
+80103c2a:	83 ec 08             	sub    $0x8,%esp
+80103c2d:	6a 10                	push   $0x10
+80103c2f:	ff 75 f4             	pushl  -0xc(%ebp)
+80103c32:	e8 76 ff ff ff       	call   80103bad <sum>
+80103c37:	83 c4 10             	add    $0x10,%esp
+80103c3a:	84 c0                	test   %al,%al
+80103c3c:	75 05                	jne    80103c43 <mpsearch1+0x5a>
+      return (struct mp*)p;
+80103c3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103c41:	eb 11                	jmp    80103c54 <mpsearch1+0x6b>
+  for(p = addr; p < e; p += sizeof(struct mp))
+80103c43:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
+80103c47:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103c4a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+80103c4d:	72 c2                	jb     80103c11 <mpsearch1+0x28>
+  return 0;
+80103c4f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80103c54:	c9                   	leave  
+80103c55:	c3                   	ret    
+
+80103c56 <mpsearch>:
+// 1) in the first KB of the EBDA;
+// 2) in the last KB of system base memory;
+// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
+static struct mp*
+mpsearch(void)
+{
+80103c56:	f3 0f 1e fb          	endbr32 
+80103c5a:	55                   	push   %ebp
+80103c5b:	89 e5                	mov    %esp,%ebp
+80103c5d:	83 ec 18             	sub    $0x18,%esp
+  uchar *bda;
+  uint p;
+  struct mp *mp;
+
+  bda = (uchar *) P2V(0x400);
+80103c60:	c7 45 f4 00 04 00 80 	movl   $0x80000400,-0xc(%ebp)
+  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
+80103c67:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103c6a:	83 c0 0f             	add    $0xf,%eax
+80103c6d:	0f b6 00             	movzbl (%eax),%eax
+80103c70:	0f b6 c0             	movzbl %al,%eax
+80103c73:	c1 e0 08             	shl    $0x8,%eax
+80103c76:	89 c2                	mov    %eax,%edx
+80103c78:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103c7b:	83 c0 0e             	add    $0xe,%eax
+80103c7e:	0f b6 00             	movzbl (%eax),%eax
+80103c81:	0f b6 c0             	movzbl %al,%eax
+80103c84:	09 d0                	or     %edx,%eax
+80103c86:	c1 e0 04             	shl    $0x4,%eax
+80103c89:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80103c8c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80103c90:	74 21                	je     80103cb3 <mpsearch+0x5d>
+    if((mp = mpsearch1(p, 1024)))
+80103c92:	83 ec 08             	sub    $0x8,%esp
+80103c95:	68 00 04 00 00       	push   $0x400
+80103c9a:	ff 75 f0             	pushl  -0x10(%ebp)
+80103c9d:	e8 47 ff ff ff       	call   80103be9 <mpsearch1>
+80103ca2:	83 c4 10             	add    $0x10,%esp
+80103ca5:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80103ca8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80103cac:	74 51                	je     80103cff <mpsearch+0xa9>
+      return mp;
+80103cae:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103cb1:	eb 61                	jmp    80103d14 <mpsearch+0xbe>
+  } else {
+    p = ((bda[0x14]<<8)|bda[0x13])*1024;
+80103cb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103cb6:	83 c0 14             	add    $0x14,%eax
+80103cb9:	0f b6 00             	movzbl (%eax),%eax
+80103cbc:	0f b6 c0             	movzbl %al,%eax
+80103cbf:	c1 e0 08             	shl    $0x8,%eax
+80103cc2:	89 c2                	mov    %eax,%edx
+80103cc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103cc7:	83 c0 13             	add    $0x13,%eax
+80103cca:	0f b6 00             	movzbl (%eax),%eax
+80103ccd:	0f b6 c0             	movzbl %al,%eax
+80103cd0:	09 d0                	or     %edx,%eax
+80103cd2:	c1 e0 0a             	shl    $0xa,%eax
+80103cd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if((mp = mpsearch1(p-1024, 1024)))
+80103cd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103cdb:	2d 00 04 00 00       	sub    $0x400,%eax
+80103ce0:	83 ec 08             	sub    $0x8,%esp
+80103ce3:	68 00 04 00 00       	push   $0x400
+80103ce8:	50                   	push   %eax
+80103ce9:	e8 fb fe ff ff       	call   80103be9 <mpsearch1>
+80103cee:	83 c4 10             	add    $0x10,%esp
+80103cf1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80103cf4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80103cf8:	74 05                	je     80103cff <mpsearch+0xa9>
+      return mp;
+80103cfa:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103cfd:	eb 15                	jmp    80103d14 <mpsearch+0xbe>
+  }
+  return mpsearch1(0xF0000, 0x10000);
+80103cff:	83 ec 08             	sub    $0x8,%esp
+80103d02:	68 00 00 01 00       	push   $0x10000
+80103d07:	68 00 00 0f 00       	push   $0xf0000
+80103d0c:	e8 d8 fe ff ff       	call   80103be9 <mpsearch1>
+80103d11:	83 c4 10             	add    $0x10,%esp
+}
+80103d14:	c9                   	leave  
+80103d15:	c3                   	ret    
+
+80103d16 <mpconfig>:
+// Check for correct signature, calculate the checksum and,
+// if correct, check the version.
+// To do: check extended table checksum.
+static struct mpconf*
+mpconfig(struct mp **pmp)
+{
+80103d16:	f3 0f 1e fb          	endbr32 
+80103d1a:	55                   	push   %ebp
+80103d1b:	89 e5                	mov    %esp,%ebp
+80103d1d:	83 ec 18             	sub    $0x18,%esp
+  struct mpconf *conf;
+  struct mp *mp;
+
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+80103d20:	e8 31 ff ff ff       	call   80103c56 <mpsearch>
+80103d25:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80103d28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80103d2c:	74 0a                	je     80103d38 <mpconfig+0x22>
+80103d2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103d31:	8b 40 04             	mov    0x4(%eax),%eax
+80103d34:	85 c0                	test   %eax,%eax
+80103d36:	75 07                	jne    80103d3f <mpconfig+0x29>
+    return 0;
+80103d38:	b8 00 00 00 00       	mov    $0x0,%eax
+80103d3d:	eb 7a                	jmp    80103db9 <mpconfig+0xa3>
+  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+80103d3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103d42:	8b 40 04             	mov    0x4(%eax),%eax
+80103d45:	05 00 00 00 80       	add    $0x80000000,%eax
+80103d4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(memcmp(conf, "PCMP", 4) != 0)
+80103d4d:	83 ec 04             	sub    $0x4,%esp
+80103d50:	6a 04                	push   $0x4
+80103d52:	68 d5 8f 10 80       	push   $0x80108fd5
+80103d57:	ff 75 f0             	pushl  -0x10(%ebp)
+80103d5a:	e8 27 1d 00 00       	call   80105a86 <memcmp>
+80103d5f:	83 c4 10             	add    $0x10,%esp
+80103d62:	85 c0                	test   %eax,%eax
+80103d64:	74 07                	je     80103d6d <mpconfig+0x57>
+    return 0;
+80103d66:	b8 00 00 00 00       	mov    $0x0,%eax
+80103d6b:	eb 4c                	jmp    80103db9 <mpconfig+0xa3>
+  if(conf->version != 1 && conf->version != 4)
+80103d6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103d70:	0f b6 40 06          	movzbl 0x6(%eax),%eax
+80103d74:	3c 01                	cmp    $0x1,%al
+80103d76:	74 12                	je     80103d8a <mpconfig+0x74>
+80103d78:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103d7b:	0f b6 40 06          	movzbl 0x6(%eax),%eax
+80103d7f:	3c 04                	cmp    $0x4,%al
+80103d81:	74 07                	je     80103d8a <mpconfig+0x74>
+    return 0;
+80103d83:	b8 00 00 00 00       	mov    $0x0,%eax
+80103d88:	eb 2f                	jmp    80103db9 <mpconfig+0xa3>
+  if(sum((uchar*)conf, conf->length) != 0)
+80103d8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80103d8d:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+80103d91:	0f b7 c0             	movzwl %ax,%eax
+80103d94:	83 ec 08             	sub    $0x8,%esp
+80103d97:	50                   	push   %eax
+80103d98:	ff 75 f0             	pushl  -0x10(%ebp)
+80103d9b:	e8 0d fe ff ff       	call   80103bad <sum>
+80103da0:	83 c4 10             	add    $0x10,%esp
+80103da3:	84 c0                	test   %al,%al
+80103da5:	74 07                	je     80103dae <mpconfig+0x98>
+    return 0;
+80103da7:	b8 00 00 00 00       	mov    $0x0,%eax
+80103dac:	eb 0b                	jmp    80103db9 <mpconfig+0xa3>
+  *pmp = mp;
+80103dae:	8b 45 08             	mov    0x8(%ebp),%eax
+80103db1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80103db4:	89 10                	mov    %edx,(%eax)
+  return conf;
+80103db6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+80103db9:	c9                   	leave  
+80103dba:	c3                   	ret    
+
+80103dbb <mpinit>:
+
+void
+mpinit(void)
+{
+80103dbb:	f3 0f 1e fb          	endbr32 
+80103dbf:	55                   	push   %ebp
+80103dc0:	89 e5                	mov    %esp,%ebp
+80103dc2:	83 ec 28             	sub    $0x28,%esp
+  struct mp *mp;
+  struct mpconf *conf;
+  struct mpproc *proc;
+  struct mpioapic *ioapic;
+
+  if((conf = mpconfig(&mp)) == 0)
+80103dc5:	83 ec 0c             	sub    $0xc,%esp
+80103dc8:	8d 45 dc             	lea    -0x24(%ebp),%eax
+80103dcb:	50                   	push   %eax
+80103dcc:	e8 45 ff ff ff       	call   80103d16 <mpconfig>
+80103dd1:	83 c4 10             	add    $0x10,%esp
+80103dd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80103dd7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80103ddb:	75 0d                	jne    80103dea <mpinit+0x2f>
+    panic("Expect to run on an SMP");
+80103ddd:	83 ec 0c             	sub    $0xc,%esp
+80103de0:	68 da 8f 10 80       	push   $0x80108fda
+80103de5:	e8 e7 c7 ff ff       	call   801005d1 <panic>
+  ismp = 1;
+80103dea:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+  lapic = (uint*)conf->lapicaddr;
+80103df1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103df4:	8b 40 24             	mov    0x24(%eax),%eax
+80103df7:	a3 1c 47 11 80       	mov    %eax,0x8011471c
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+80103dfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103dff:	83 c0 2c             	add    $0x2c,%eax
+80103e02:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80103e05:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103e08:	0f b7 40 04          	movzwl 0x4(%eax),%eax
+80103e0c:	0f b7 d0             	movzwl %ax,%edx
+80103e0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80103e12:	01 d0                	add    %edx,%eax
+80103e14:	89 45 e8             	mov    %eax,-0x18(%ebp)
+80103e17:	e9 8c 00 00 00       	jmp    80103ea8 <mpinit+0xed>
+    switch(*p){
+80103e1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103e1f:	0f b6 00             	movzbl (%eax),%eax
+80103e22:	0f b6 c0             	movzbl %al,%eax
+80103e25:	83 f8 04             	cmp    $0x4,%eax
+80103e28:	7f 76                	jg     80103ea0 <mpinit+0xe5>
+80103e2a:	83 f8 03             	cmp    $0x3,%eax
+80103e2d:	7d 6b                	jge    80103e9a <mpinit+0xdf>
+80103e2f:	83 f8 02             	cmp    $0x2,%eax
+80103e32:	74 4e                	je     80103e82 <mpinit+0xc7>
+80103e34:	83 f8 02             	cmp    $0x2,%eax
+80103e37:	7f 67                	jg     80103ea0 <mpinit+0xe5>
+80103e39:	85 c0                	test   %eax,%eax
+80103e3b:	74 07                	je     80103e44 <mpinit+0x89>
+80103e3d:	83 f8 01             	cmp    $0x1,%eax
+80103e40:	74 58                	je     80103e9a <mpinit+0xdf>
+80103e42:	eb 5c                	jmp    80103ea0 <mpinit+0xe5>
+    case MPPROC:
+      proc = (struct mpproc*)p;
+80103e44:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103e47:	89 45 e0             	mov    %eax,-0x20(%ebp)
+      if(ncpu < NCPU) {
+80103e4a:	a1 a0 4d 11 80       	mov    0x80114da0,%eax
+80103e4f:	83 f8 07             	cmp    $0x7,%eax
+80103e52:	7f 28                	jg     80103e7c <mpinit+0xc1>
+        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+80103e54:	8b 15 a0 4d 11 80    	mov    0x80114da0,%edx
+80103e5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80103e5d:	0f b6 40 01          	movzbl 0x1(%eax),%eax
+80103e61:	69 d2 b0 00 00 00    	imul   $0xb0,%edx,%edx
+80103e67:	81 c2 20 48 11 80    	add    $0x80114820,%edx
+80103e6d:	88 02                	mov    %al,(%edx)
+        ncpu++;
+80103e6f:	a1 a0 4d 11 80       	mov    0x80114da0,%eax
+80103e74:	83 c0 01             	add    $0x1,%eax
+80103e77:	a3 a0 4d 11 80       	mov    %eax,0x80114da0
+      }
+      p += sizeof(struct mpproc);
+80103e7c:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
+      continue;
+80103e80:	eb 26                	jmp    80103ea8 <mpinit+0xed>
+    case MPIOAPIC:
+      ioapic = (struct mpioapic*)p;
+80103e82:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103e85:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+      ioapicid = ioapic->apicno;
+80103e88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80103e8b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
+80103e8f:	a2 00 48 11 80       	mov    %al,0x80114800
+      p += sizeof(struct mpioapic);
+80103e94:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
+      continue;
+80103e98:	eb 0e                	jmp    80103ea8 <mpinit+0xed>
+    case MPBUS:
+    case MPIOINTR:
+    case MPLINTR:
+      p += 8;
+80103e9a:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
+      continue;
+80103e9e:	eb 08                	jmp    80103ea8 <mpinit+0xed>
+    default:
+      ismp = 0;
+80103ea0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+      break;
+80103ea7:	90                   	nop
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+80103ea8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103eab:	3b 45 e8             	cmp    -0x18(%ebp),%eax
+80103eae:	0f 82 68 ff ff ff    	jb     80103e1c <mpinit+0x61>
+    }
+  }
+  if(!ismp)
+80103eb4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80103eb8:	75 0d                	jne    80103ec7 <mpinit+0x10c>
+    panic("Didn't find a suitable machine");
+80103eba:	83 ec 0c             	sub    $0xc,%esp
+80103ebd:	68 f4 8f 10 80       	push   $0x80108ff4
+80103ec2:	e8 0a c7 ff ff       	call   801005d1 <panic>
+
+  if(mp->imcrp){
+80103ec7:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80103eca:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
+80103ece:	84 c0                	test   %al,%al
+80103ed0:	74 30                	je     80103f02 <mpinit+0x147>
+    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
+    // But it would on real hardware.
+    outb(0x22, 0x70);   // Select IMCR
+80103ed2:	83 ec 08             	sub    $0x8,%esp
+80103ed5:	6a 70                	push   $0x70
+80103ed7:	6a 22                	push   $0x22
+80103ed9:	e8 ae fc ff ff       	call   80103b8c <outb>
+80103ede:	83 c4 10             	add    $0x10,%esp
+    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+80103ee1:	83 ec 0c             	sub    $0xc,%esp
+80103ee4:	6a 23                	push   $0x23
+80103ee6:	e8 84 fc ff ff       	call   80103b6f <inb>
+80103eeb:	83 c4 10             	add    $0x10,%esp
+80103eee:	83 c8 01             	or     $0x1,%eax
+80103ef1:	0f b6 c0             	movzbl %al,%eax
+80103ef4:	83 ec 08             	sub    $0x8,%esp
+80103ef7:	50                   	push   %eax
+80103ef8:	6a 23                	push   $0x23
+80103efa:	e8 8d fc ff ff       	call   80103b8c <outb>
+80103eff:	83 c4 10             	add    $0x10,%esp
+  }
+}
+80103f02:	90                   	nop
+80103f03:	c9                   	leave  
+80103f04:	c3                   	ret    
+
+80103f05 <outb>:
+{
+80103f05:	55                   	push   %ebp
+80103f06:	89 e5                	mov    %esp,%ebp
+80103f08:	83 ec 08             	sub    $0x8,%esp
+80103f0b:	8b 45 08             	mov    0x8(%ebp),%eax
+80103f0e:	8b 55 0c             	mov    0xc(%ebp),%edx
+80103f11:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+80103f15:	89 d0                	mov    %edx,%eax
+80103f17:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+80103f1a:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80103f1e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80103f22:	ee                   	out    %al,(%dx)
+}
+80103f23:	90                   	nop
+80103f24:	c9                   	leave  
+80103f25:	c3                   	ret    
+
+80103f26 <picinit>:
+#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+
+// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+void
+picinit(void)
+{
+80103f26:	f3 0f 1e fb          	endbr32 
+80103f2a:	55                   	push   %ebp
+80103f2b:	89 e5                	mov    %esp,%ebp
+  // mask all interrupts
+  outb(IO_PIC1+1, 0xFF);
+80103f2d:	68 ff 00 00 00       	push   $0xff
+80103f32:	6a 21                	push   $0x21
+80103f34:	e8 cc ff ff ff       	call   80103f05 <outb>
+80103f39:	83 c4 08             	add    $0x8,%esp
+  outb(IO_PIC2+1, 0xFF);
+80103f3c:	68 ff 00 00 00       	push   $0xff
+80103f41:	68 a1 00 00 00       	push   $0xa1
+80103f46:	e8 ba ff ff ff       	call   80103f05 <outb>
+80103f4b:	83 c4 08             	add    $0x8,%esp
+}
+80103f4e:	90                   	nop
+80103f4f:	c9                   	leave  
+80103f50:	c3                   	ret    
+
+80103f51 <pipealloc>:
+  int writeopen;  // write fd is still open
+};
+
+int
+pipealloc(struct file **f0, struct file **f1)
+{
+80103f51:	f3 0f 1e fb          	endbr32 
+80103f55:	55                   	push   %ebp
+80103f56:	89 e5                	mov    %esp,%ebp
+80103f58:	83 ec 18             	sub    $0x18,%esp
+  struct pipe *p;
+
+  p = 0;
+80103f5b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  *f0 = *f1 = 0;
+80103f62:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103f65:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+80103f6b:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103f6e:	8b 10                	mov    (%eax),%edx
+80103f70:	8b 45 08             	mov    0x8(%ebp),%eax
+80103f73:	89 10                	mov    %edx,(%eax)
+  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+80103f75:	e8 e2 d0 ff ff       	call   8010105c <filealloc>
+80103f7a:	8b 55 08             	mov    0x8(%ebp),%edx
+80103f7d:	89 02                	mov    %eax,(%edx)
+80103f7f:	8b 45 08             	mov    0x8(%ebp),%eax
+80103f82:	8b 00                	mov    (%eax),%eax
+80103f84:	85 c0                	test   %eax,%eax
+80103f86:	0f 84 c8 00 00 00    	je     80104054 <pipealloc+0x103>
+80103f8c:	e8 cb d0 ff ff       	call   8010105c <filealloc>
+80103f91:	8b 55 0c             	mov    0xc(%ebp),%edx
+80103f94:	89 02                	mov    %eax,(%edx)
+80103f96:	8b 45 0c             	mov    0xc(%ebp),%eax
+80103f99:	8b 00                	mov    (%eax),%eax
+80103f9b:	85 c0                	test   %eax,%eax
+80103f9d:	0f 84 b1 00 00 00    	je     80104054 <pipealloc+0x103>
+    goto bad;
+  if((p = (struct pipe*)kalloc()) == 0)
+80103fa3:	e8 ea ed ff ff       	call   80102d92 <kalloc>
+80103fa8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80103fab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80103faf:	0f 84 a2 00 00 00    	je     80104057 <pipealloc+0x106>
+    goto bad;
+  p->readopen = 1;
+80103fb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103fb8:	c7 80 3c 02 00 00 01 	movl   $0x1,0x23c(%eax)
+80103fbf:	00 00 00 
+  p->writeopen = 1;
+80103fc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103fc5:	c7 80 40 02 00 00 01 	movl   $0x1,0x240(%eax)
+80103fcc:	00 00 00 
+  p->nwrite = 0;
+80103fcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103fd2:	c7 80 38 02 00 00 00 	movl   $0x0,0x238(%eax)
+80103fd9:	00 00 00 
+  p->nread = 0;
+80103fdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103fdf:	c7 80 34 02 00 00 00 	movl   $0x0,0x234(%eax)
+80103fe6:	00 00 00 
+  initlock(&p->lock, "pipe");
+80103fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80103fec:	83 ec 08             	sub    $0x8,%esp
+80103fef:	68 13 90 10 80       	push   $0x80109013
+80103ff4:	50                   	push   %eax
+80103ff5:	e8 5c 17 00 00       	call   80105756 <initlock>
+80103ffa:	83 c4 10             	add    $0x10,%esp
+  (*f0)->type = FD_PIPE;
+80103ffd:	8b 45 08             	mov    0x8(%ebp),%eax
+80104000:	8b 00                	mov    (%eax),%eax
+80104002:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f0)->readable = 1;
+80104008:	8b 45 08             	mov    0x8(%ebp),%eax
+8010400b:	8b 00                	mov    (%eax),%eax
+8010400d:	c6 40 08 01          	movb   $0x1,0x8(%eax)
+  (*f0)->writable = 0;
+80104011:	8b 45 08             	mov    0x8(%ebp),%eax
+80104014:	8b 00                	mov    (%eax),%eax
+80104016:	c6 40 09 00          	movb   $0x0,0x9(%eax)
+  (*f0)->pipe = p;
+8010401a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010401d:	8b 00                	mov    (%eax),%eax
+8010401f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104022:	89 50 0c             	mov    %edx,0xc(%eax)
+  (*f1)->type = FD_PIPE;
+80104025:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104028:	8b 00                	mov    (%eax),%eax
+8010402a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  (*f1)->readable = 0;
+80104030:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104033:	8b 00                	mov    (%eax),%eax
+80104035:	c6 40 08 00          	movb   $0x0,0x8(%eax)
+  (*f1)->writable = 1;
+80104039:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010403c:	8b 00                	mov    (%eax),%eax
+8010403e:	c6 40 09 01          	movb   $0x1,0x9(%eax)
+  (*f1)->pipe = p;
+80104042:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104045:	8b 00                	mov    (%eax),%eax
+80104047:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010404a:	89 50 0c             	mov    %edx,0xc(%eax)
+  return 0;
+8010404d:	b8 00 00 00 00       	mov    $0x0,%eax
+80104052:	eb 51                	jmp    801040a5 <pipealloc+0x154>
+    goto bad;
+80104054:	90                   	nop
+80104055:	eb 01                	jmp    80104058 <pipealloc+0x107>
+    goto bad;
+80104057:	90                   	nop
+
+//PAGEBREAK: 20
+ bad:
+  if(p)
+80104058:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010405c:	74 0e                	je     8010406c <pipealloc+0x11b>
+    kfree((char*)p);
+8010405e:	83 ec 0c             	sub    $0xc,%esp
+80104061:	ff 75 f4             	pushl  -0xc(%ebp)
+80104064:	e8 8b ec ff ff       	call   80102cf4 <kfree>
+80104069:	83 c4 10             	add    $0x10,%esp
+  if(*f0)
+8010406c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010406f:	8b 00                	mov    (%eax),%eax
+80104071:	85 c0                	test   %eax,%eax
+80104073:	74 11                	je     80104086 <pipealloc+0x135>
+    fileclose(*f0);
+80104075:	8b 45 08             	mov    0x8(%ebp),%eax
+80104078:	8b 00                	mov    (%eax),%eax
+8010407a:	83 ec 0c             	sub    $0xc,%esp
+8010407d:	50                   	push   %eax
+8010407e:	e8 9f d0 ff ff       	call   80101122 <fileclose>
+80104083:	83 c4 10             	add    $0x10,%esp
+  if(*f1)
+80104086:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104089:	8b 00                	mov    (%eax),%eax
+8010408b:	85 c0                	test   %eax,%eax
+8010408d:	74 11                	je     801040a0 <pipealloc+0x14f>
+    fileclose(*f1);
+8010408f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104092:	8b 00                	mov    (%eax),%eax
+80104094:	83 ec 0c             	sub    $0xc,%esp
+80104097:	50                   	push   %eax
+80104098:	e8 85 d0 ff ff       	call   80101122 <fileclose>
+8010409d:	83 c4 10             	add    $0x10,%esp
+  return -1;
+801040a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+801040a5:	c9                   	leave  
+801040a6:	c3                   	ret    
+
+801040a7 <pipeclose>:
+
+void
+pipeclose(struct pipe *p, int writable)
+{
+801040a7:	f3 0f 1e fb          	endbr32 
+801040ab:	55                   	push   %ebp
+801040ac:	89 e5                	mov    %esp,%ebp
+801040ae:	83 ec 08             	sub    $0x8,%esp
+  acquire(&p->lock);
+801040b1:	8b 45 08             	mov    0x8(%ebp),%eax
+801040b4:	83 ec 0c             	sub    $0xc,%esp
+801040b7:	50                   	push   %eax
+801040b8:	e8 bf 16 00 00       	call   8010577c <acquire>
+801040bd:	83 c4 10             	add    $0x10,%esp
+  if(writable){
+801040c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+801040c4:	74 23                	je     801040e9 <pipeclose+0x42>
+    p->writeopen = 0;
+801040c6:	8b 45 08             	mov    0x8(%ebp),%eax
+801040c9:	c7 80 40 02 00 00 00 	movl   $0x0,0x240(%eax)
+801040d0:	00 00 00 
+    wakeup(&p->nread);
+801040d3:	8b 45 08             	mov    0x8(%ebp),%eax
+801040d6:	05 34 02 00 00       	add    $0x234,%eax
+801040db:	83 ec 0c             	sub    $0xc,%esp
+801040de:	50                   	push   %eax
+801040df:	e8 6c 11 00 00       	call   80105250 <wakeup>
+801040e4:	83 c4 10             	add    $0x10,%esp
+801040e7:	eb 21                	jmp    8010410a <pipeclose+0x63>
+  } else {
+    p->readopen = 0;
+801040e9:	8b 45 08             	mov    0x8(%ebp),%eax
+801040ec:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%eax)
+801040f3:	00 00 00 
+    wakeup(&p->nwrite);
+801040f6:	8b 45 08             	mov    0x8(%ebp),%eax
+801040f9:	05 38 02 00 00       	add    $0x238,%eax
+801040fe:	83 ec 0c             	sub    $0xc,%esp
+80104101:	50                   	push   %eax
+80104102:	e8 49 11 00 00       	call   80105250 <wakeup>
+80104107:	83 c4 10             	add    $0x10,%esp
+  }
+  if(p->readopen == 0 && p->writeopen == 0){
+8010410a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010410d:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
+80104113:	85 c0                	test   %eax,%eax
+80104115:	75 2c                	jne    80104143 <pipeclose+0x9c>
+80104117:	8b 45 08             	mov    0x8(%ebp),%eax
+8010411a:	8b 80 40 02 00 00    	mov    0x240(%eax),%eax
+80104120:	85 c0                	test   %eax,%eax
+80104122:	75 1f                	jne    80104143 <pipeclose+0x9c>
+    release(&p->lock);
+80104124:	8b 45 08             	mov    0x8(%ebp),%eax
+80104127:	83 ec 0c             	sub    $0xc,%esp
+8010412a:	50                   	push   %eax
+8010412b:	e8 be 16 00 00       	call   801057ee <release>
+80104130:	83 c4 10             	add    $0x10,%esp
+    kfree((char*)p);
+80104133:	83 ec 0c             	sub    $0xc,%esp
+80104136:	ff 75 08             	pushl  0x8(%ebp)
+80104139:	e8 b6 eb ff ff       	call   80102cf4 <kfree>
+8010413e:	83 c4 10             	add    $0x10,%esp
+80104141:	eb 10                	jmp    80104153 <pipeclose+0xac>
+  } else
+    release(&p->lock);
+80104143:	8b 45 08             	mov    0x8(%ebp),%eax
+80104146:	83 ec 0c             	sub    $0xc,%esp
+80104149:	50                   	push   %eax
+8010414a:	e8 9f 16 00 00       	call   801057ee <release>
+8010414f:	83 c4 10             	add    $0x10,%esp
+}
+80104152:	90                   	nop
+80104153:	90                   	nop
+80104154:	c9                   	leave  
+80104155:	c3                   	ret    
+
+80104156 <pipewrite>:
+
+//PAGEBREAK: 40
+int
+pipewrite(struct pipe *p, char *addr, int n)
+{
+80104156:	f3 0f 1e fb          	endbr32 
+8010415a:	55                   	push   %ebp
+8010415b:	89 e5                	mov    %esp,%ebp
+8010415d:	53                   	push   %ebx
+8010415e:	83 ec 14             	sub    $0x14,%esp
+  int i;
+
+  acquire(&p->lock);
+80104161:	8b 45 08             	mov    0x8(%ebp),%eax
+80104164:	83 ec 0c             	sub    $0xc,%esp
+80104167:	50                   	push   %eax
+80104168:	e8 0f 16 00 00       	call   8010577c <acquire>
+8010416d:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < n; i++){
+80104170:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80104177:	e9 ad 00 00 00       	jmp    80104229 <pipewrite+0xd3>
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+      if(p->readopen == 0 || myproc()->killed){
+8010417c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010417f:	8b 80 3c 02 00 00    	mov    0x23c(%eax),%eax
+80104185:	85 c0                	test   %eax,%eax
+80104187:	74 0c                	je     80104195 <pipewrite+0x3f>
+80104189:	e8 1b 04 00 00       	call   801045a9 <myproc>
+8010418e:	8b 40 34             	mov    0x34(%eax),%eax
+80104191:	85 c0                	test   %eax,%eax
+80104193:	74 19                	je     801041ae <pipewrite+0x58>
+        release(&p->lock);
+80104195:	8b 45 08             	mov    0x8(%ebp),%eax
+80104198:	83 ec 0c             	sub    $0xc,%esp
+8010419b:	50                   	push   %eax
+8010419c:	e8 4d 16 00 00       	call   801057ee <release>
+801041a1:	83 c4 10             	add    $0x10,%esp
+        return -1;
+801041a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801041a9:	e9 a9 00 00 00       	jmp    80104257 <pipewrite+0x101>
+      }
+      wakeup(&p->nread);
+801041ae:	8b 45 08             	mov    0x8(%ebp),%eax
+801041b1:	05 34 02 00 00       	add    $0x234,%eax
+801041b6:	83 ec 0c             	sub    $0xc,%esp
+801041b9:	50                   	push   %eax
+801041ba:	e8 91 10 00 00       	call   80105250 <wakeup>
+801041bf:	83 c4 10             	add    $0x10,%esp
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+801041c2:	8b 45 08             	mov    0x8(%ebp),%eax
+801041c5:	8b 55 08             	mov    0x8(%ebp),%edx
+801041c8:	81 c2 38 02 00 00    	add    $0x238,%edx
+801041ce:	83 ec 08             	sub    $0x8,%esp
+801041d1:	50                   	push   %eax
+801041d2:	52                   	push   %edx
+801041d3:	e8 86 0f 00 00       	call   8010515e <sleep>
+801041d8:	83 c4 10             	add    $0x10,%esp
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+801041db:	8b 45 08             	mov    0x8(%ebp),%eax
+801041de:	8b 90 38 02 00 00    	mov    0x238(%eax),%edx
+801041e4:	8b 45 08             	mov    0x8(%ebp),%eax
+801041e7:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
+801041ed:	05 00 02 00 00       	add    $0x200,%eax
+801041f2:	39 c2                	cmp    %eax,%edx
+801041f4:	74 86                	je     8010417c <pipewrite+0x26>
+    }
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+801041f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801041f9:	8b 45 0c             	mov    0xc(%ebp),%eax
+801041fc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+801041ff:	8b 45 08             	mov    0x8(%ebp),%eax
+80104202:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
+80104208:	8d 48 01             	lea    0x1(%eax),%ecx
+8010420b:	8b 55 08             	mov    0x8(%ebp),%edx
+8010420e:	89 8a 38 02 00 00    	mov    %ecx,0x238(%edx)
+80104214:	25 ff 01 00 00       	and    $0x1ff,%eax
+80104219:	89 c1                	mov    %eax,%ecx
+8010421b:	0f b6 13             	movzbl (%ebx),%edx
+8010421e:	8b 45 08             	mov    0x8(%ebp),%eax
+80104221:	88 54 08 34          	mov    %dl,0x34(%eax,%ecx,1)
+  for(i = 0; i < n; i++){
+80104225:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80104229:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010422c:	3b 45 10             	cmp    0x10(%ebp),%eax
+8010422f:	7c aa                	jl     801041db <pipewrite+0x85>
+  }
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+80104231:	8b 45 08             	mov    0x8(%ebp),%eax
+80104234:	05 34 02 00 00       	add    $0x234,%eax
+80104239:	83 ec 0c             	sub    $0xc,%esp
+8010423c:	50                   	push   %eax
+8010423d:	e8 0e 10 00 00       	call   80105250 <wakeup>
+80104242:	83 c4 10             	add    $0x10,%esp
+  release(&p->lock);
+80104245:	8b 45 08             	mov    0x8(%ebp),%eax
+80104248:	83 ec 0c             	sub    $0xc,%esp
+8010424b:	50                   	push   %eax
+8010424c:	e8 9d 15 00 00       	call   801057ee <release>
+80104251:	83 c4 10             	add    $0x10,%esp
+  return n;
+80104254:	8b 45 10             	mov    0x10(%ebp),%eax
+}
+80104257:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+8010425a:	c9                   	leave  
+8010425b:	c3                   	ret    
+
+8010425c <piperead>:
+
+int
+piperead(struct pipe *p, char *addr, int n)
+{
+8010425c:	f3 0f 1e fb          	endbr32 
+80104260:	55                   	push   %ebp
+80104261:	89 e5                	mov    %esp,%ebp
+80104263:	83 ec 18             	sub    $0x18,%esp
+  int i;
+
+  acquire(&p->lock);
+80104266:	8b 45 08             	mov    0x8(%ebp),%eax
+80104269:	83 ec 0c             	sub    $0xc,%esp
+8010426c:	50                   	push   %eax
+8010426d:	e8 0a 15 00 00       	call   8010577c <acquire>
+80104272:	83 c4 10             	add    $0x10,%esp
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+80104275:	eb 3e                	jmp    801042b5 <piperead+0x59>
+    if(myproc()->killed){
+80104277:	e8 2d 03 00 00       	call   801045a9 <myproc>
+8010427c:	8b 40 34             	mov    0x34(%eax),%eax
+8010427f:	85 c0                	test   %eax,%eax
+80104281:	74 19                	je     8010429c <piperead+0x40>
+      release(&p->lock);
+80104283:	8b 45 08             	mov    0x8(%ebp),%eax
+80104286:	83 ec 0c             	sub    $0xc,%esp
+80104289:	50                   	push   %eax
+8010428a:	e8 5f 15 00 00       	call   801057ee <release>
+8010428f:	83 c4 10             	add    $0x10,%esp
+      return -1;
+80104292:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104297:	e9 be 00 00 00       	jmp    8010435a <piperead+0xfe>
+    }
+    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+8010429c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010429f:	8b 55 08             	mov    0x8(%ebp),%edx
+801042a2:	81 c2 34 02 00 00    	add    $0x234,%edx
+801042a8:	83 ec 08             	sub    $0x8,%esp
+801042ab:	50                   	push   %eax
+801042ac:	52                   	push   %edx
+801042ad:	e8 ac 0e 00 00       	call   8010515e <sleep>
+801042b2:	83 c4 10             	add    $0x10,%esp
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+801042b5:	8b 45 08             	mov    0x8(%ebp),%eax
+801042b8:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
+801042be:	8b 45 08             	mov    0x8(%ebp),%eax
+801042c1:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
+801042c7:	39 c2                	cmp    %eax,%edx
+801042c9:	75 0d                	jne    801042d8 <piperead+0x7c>
+801042cb:	8b 45 08             	mov    0x8(%ebp),%eax
+801042ce:	8b 80 40 02 00 00    	mov    0x240(%eax),%eax
+801042d4:	85 c0                	test   %eax,%eax
+801042d6:	75 9f                	jne    80104277 <piperead+0x1b>
+  }
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+801042d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801042df:	eb 48                	jmp    80104329 <piperead+0xcd>
+    if(p->nread == p->nwrite)
+801042e1:	8b 45 08             	mov    0x8(%ebp),%eax
+801042e4:	8b 90 34 02 00 00    	mov    0x234(%eax),%edx
+801042ea:	8b 45 08             	mov    0x8(%ebp),%eax
+801042ed:	8b 80 38 02 00 00    	mov    0x238(%eax),%eax
+801042f3:	39 c2                	cmp    %eax,%edx
+801042f5:	74 3c                	je     80104333 <piperead+0xd7>
+      break;
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+801042f7:	8b 45 08             	mov    0x8(%ebp),%eax
+801042fa:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
+80104300:	8d 48 01             	lea    0x1(%eax),%ecx
+80104303:	8b 55 08             	mov    0x8(%ebp),%edx
+80104306:	89 8a 34 02 00 00    	mov    %ecx,0x234(%edx)
+8010430c:	25 ff 01 00 00       	and    $0x1ff,%eax
+80104311:	89 c1                	mov    %eax,%ecx
+80104313:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104316:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104319:	01 c2                	add    %eax,%edx
+8010431b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010431e:	0f b6 44 08 34       	movzbl 0x34(%eax,%ecx,1),%eax
+80104323:	88 02                	mov    %al,(%edx)
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+80104325:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80104329:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010432c:	3b 45 10             	cmp    0x10(%ebp),%eax
+8010432f:	7c b0                	jl     801042e1 <piperead+0x85>
+80104331:	eb 01                	jmp    80104334 <piperead+0xd8>
+      break;
+80104333:	90                   	nop
+  }
+  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+80104334:	8b 45 08             	mov    0x8(%ebp),%eax
+80104337:	05 38 02 00 00       	add    $0x238,%eax
+8010433c:	83 ec 0c             	sub    $0xc,%esp
+8010433f:	50                   	push   %eax
+80104340:	e8 0b 0f 00 00       	call   80105250 <wakeup>
+80104345:	83 c4 10             	add    $0x10,%esp
+  release(&p->lock);
+80104348:	8b 45 08             	mov    0x8(%ebp),%eax
+8010434b:	83 ec 0c             	sub    $0xc,%esp
+8010434e:	50                   	push   %eax
+8010434f:	e8 9a 14 00 00       	call   801057ee <release>
+80104354:	83 c4 10             	add    $0x10,%esp
+  return i;
+80104357:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+8010435a:	c9                   	leave  
+8010435b:	c3                   	ret    
+
+8010435c <readeflags>:
+{
+8010435c:	55                   	push   %ebp
+8010435d:	89 e5                	mov    %esp,%ebp
+8010435f:	83 ec 10             	sub    $0x10,%esp
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+80104362:	9c                   	pushf  
+80104363:	58                   	pop    %eax
+80104364:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  return eflags;
+80104367:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+8010436a:	c9                   	leave  
+8010436b:	c3                   	ret    
+
+8010436c <sti>:
+{
+8010436c:	55                   	push   %ebp
+8010436d:	89 e5                	mov    %esp,%ebp
+  asm volatile("sti");
+8010436f:	fb                   	sti    
+}
+80104370:	90                   	nop
+80104371:	5d                   	pop    %ebp
+80104372:	c3                   	ret    
+
+80104373 <sys_cps>:
+
+static void wakeup1(void *chan);
+
+
+// this is a handmade function
+int sys_cps(void){
+80104373:	f3 0f 1e fb          	endbr32 
+80104377:	55                   	push   %ebp
+80104378:	89 e5                	mov    %esp,%ebp
+8010437a:	83 ec 18             	sub    $0x18,%esp
+  struct proc* p;
+
+  // // Enables interrupts on this process
+  sti();
+8010437d:	e8 ea ff ff ff       	call   8010436c <sti>
+
+  acquire(&ptable.lock);
+80104382:	83 ec 0c             	sub    $0xc,%esp
+80104385:	68 c0 4d 11 80       	push   $0x80114dc0
+8010438a:	e8 ed 13 00 00       	call   8010577c <acquire>
+8010438f:	83 c4 10             	add    $0x10,%esp
+
+  int cnt_unused = 0;
+80104392:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  cprintf("Process Table:-\n");
+80104399:	83 ec 0c             	sub    $0xc,%esp
+8010439c:	68 18 90 10 80       	push   $0x80109018
+801043a1:	e8 72 c0 ff ff       	call   80100418 <cprintf>
+801043a6:	83 c4 10             	add    $0x10,%esp
+  cprintf("S.no. \t name \t pid \t state \t priority \n");
+801043a9:	83 ec 0c             	sub    $0xc,%esp
+801043ac:	68 2c 90 10 80       	push   $0x8010902c
+801043b1:	e8 62 c0 ff ff       	call   80100418 <cprintf>
+801043b6:	83 c4 10             	add    $0x10,%esp
+  for(int i = 0; i<NPROC ; i++){
+801043b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+801043c0:	e9 f3 00 00 00       	jmp    801044b8 <sys_cps+0x145>
+  p = &ptable.proc[i];
+801043c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801043c8:	69 c0 9c 00 00 00    	imul   $0x9c,%eax,%eax
+801043ce:	83 c0 30             	add    $0x30,%eax
+801043d1:	05 c0 4d 11 80       	add    $0x80114dc0,%eax
+801043d6:	83 c0 04             	add    $0x4,%eax
+801043d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(p->state == SLEEPING){
+801043dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801043df:	8b 40 20             	mov    0x20(%eax),%eax
+801043e2:	83 f8 02             	cmp    $0x2,%eax
+801043e5:	75 2d                	jne    80104414 <sys_cps+0xa1>
+      cprintf("%d \t %s \t %d \t SLEEPING \t %d \n",i ,p->name, p->pid, p->priority);
+801043e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801043ea:	8b 88 8c 00 00 00    	mov    0x8c(%eax),%ecx
+801043f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801043f3:	8b 50 10             	mov    0x10(%eax),%edx
+801043f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801043f9:	83 ec 0c             	sub    $0xc,%esp
+801043fc:	51                   	push   %ecx
+801043fd:	52                   	push   %edx
+801043fe:	50                   	push   %eax
+801043ff:	ff 75 f0             	pushl  -0x10(%ebp)
+80104402:	68 54 90 10 80       	push   $0x80109054
+80104407:	e8 0c c0 ff ff       	call   80100418 <cprintf>
+8010440c:	83 c4 20             	add    $0x20,%esp
+8010440f:	e9 a0 00 00 00       	jmp    801044b4 <sys_cps+0x141>
+    }else if(p->state == RUNNING){
+80104414:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104417:	8b 40 20             	mov    0x20(%eax),%eax
+8010441a:	83 f8 04             	cmp    $0x4,%eax
+8010441d:	75 2a                	jne    80104449 <sys_cps+0xd6>
+      cprintf("%d \t %s \t %d \t RUNNING \t %d \n",i ,p->name, p->pid, p->priority);
+8010441f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104422:	8b 88 8c 00 00 00    	mov    0x8c(%eax),%ecx
+80104428:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010442b:	8b 50 10             	mov    0x10(%eax),%edx
+8010442e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104431:	83 ec 0c             	sub    $0xc,%esp
+80104434:	51                   	push   %ecx
+80104435:	52                   	push   %edx
+80104436:	50                   	push   %eax
+80104437:	ff 75 f0             	pushl  -0x10(%ebp)
+8010443a:	68 73 90 10 80       	push   $0x80109073
+8010443f:	e8 d4 bf ff ff       	call   80100418 <cprintf>
+80104444:	83 c4 20             	add    $0x20,%esp
+80104447:	eb 6b                	jmp    801044b4 <sys_cps+0x141>
+    }else if(p->state == RUNNABLE){
+80104449:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010444c:	8b 40 20             	mov    0x20(%eax),%eax
+8010444f:	83 f8 03             	cmp    $0x3,%eax
+80104452:	75 2a                	jne    8010447e <sys_cps+0x10b>
+      cprintf("%d \t %s \t %d \t RUNNABLE \t %d \n",i ,p->name, p->pid, p->priority);
+80104454:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104457:	8b 88 8c 00 00 00    	mov    0x8c(%eax),%ecx
+8010445d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104460:	8b 50 10             	mov    0x10(%eax),%edx
+80104463:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104466:	83 ec 0c             	sub    $0xc,%esp
+80104469:	51                   	push   %ecx
+8010446a:	52                   	push   %edx
+8010446b:	50                   	push   %eax
+8010446c:	ff 75 f0             	pushl  -0x10(%ebp)
+8010446f:	68 94 90 10 80       	push   $0x80109094
+80104474:	e8 9f bf ff ff       	call   80100418 <cprintf>
+80104479:	83 c4 20             	add    $0x20,%esp
+8010447c:	eb 36                	jmp    801044b4 <sys_cps+0x141>
+    }else if(p->state == UNUSED){
+8010447e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104481:	8b 40 20             	mov    0x20(%eax),%eax
+80104484:	85 c0                	test   %eax,%eax
+80104486:	75 2c                	jne    801044b4 <sys_cps+0x141>
+      cprintf("%d \t %s \t %d \t UNUSED \t %d \n",i ,p->name, p->pid, p->priority);
+80104488:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010448b:	8b 88 8c 00 00 00    	mov    0x8c(%eax),%ecx
+80104491:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104494:	8b 50 10             	mov    0x10(%eax),%edx
+80104497:	8b 45 ec             	mov    -0x14(%ebp),%eax
+8010449a:	83 ec 0c             	sub    $0xc,%esp
+8010449d:	51                   	push   %ecx
+8010449e:	52                   	push   %edx
+8010449f:	50                   	push   %eax
+801044a0:	ff 75 f0             	pushl  -0x10(%ebp)
+801044a3:	68 b3 90 10 80       	push   $0x801090b3
+801044a8:	e8 6b bf ff ff       	call   80100418 <cprintf>
+801044ad:	83 c4 20             	add    $0x20,%esp
+      cnt_unused++;
+801044b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  for(int i = 0; i<NPROC ; i++){
+801044b4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+801044b8:	83 7d f0 3f          	cmpl   $0x3f,-0x10(%ebp)
+801044bc:	0f 8e 03 ff ff ff    	jle    801043c5 <sys_cps+0x52>
+    }
+  }
+  cprintf("Total unused processes: %d\n",cnt_unused);
+801044c2:	83 ec 08             	sub    $0x8,%esp
+801044c5:	ff 75 f4             	pushl  -0xc(%ebp)
+801044c8:	68 d0 90 10 80       	push   $0x801090d0
+801044cd:	e8 46 bf ff ff       	call   80100418 <cprintf>
+801044d2:	83 c4 10             	add    $0x10,%esp
+  release(&ptable.lock);
+801044d5:	83 ec 0c             	sub    $0xc,%esp
+801044d8:	68 c0 4d 11 80       	push   $0x80114dc0
+801044dd:	e8 0c 13 00 00       	call   801057ee <release>
+801044e2:	83 c4 10             	add    $0x10,%esp
+
+  return(1);
+801044e5:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+801044ea:	c9                   	leave  
+801044eb:	c3                   	ret    
+
+801044ec <pinit>:
+
+void
+pinit(void)
+{
+801044ec:	f3 0f 1e fb          	endbr32 
+801044f0:	55                   	push   %ebp
+801044f1:	89 e5                	mov    %esp,%ebp
+801044f3:	83 ec 08             	sub    $0x8,%esp
+  initlock(&ptable.lock, "ptable");
+801044f6:	83 ec 08             	sub    $0x8,%esp
+801044f9:	68 ec 90 10 80       	push   $0x801090ec
+801044fe:	68 c0 4d 11 80       	push   $0x80114dc0
+80104503:	e8 4e 12 00 00       	call   80105756 <initlock>
+80104508:	83 c4 10             	add    $0x10,%esp
+}
+8010450b:	90                   	nop
+8010450c:	c9                   	leave  
+8010450d:	c3                   	ret    
+
+8010450e <cpuid>:
+
+// Must be called with interrupts disabled
+int
+cpuid() {
+8010450e:	f3 0f 1e fb          	endbr32 
+80104512:	55                   	push   %ebp
+80104513:	89 e5                	mov    %esp,%ebp
+80104515:	83 ec 08             	sub    $0x8,%esp
+  return mycpu()-cpus;
+80104518:	e8 10 00 00 00       	call   8010452d <mycpu>
+8010451d:	2d 20 48 11 80       	sub    $0x80114820,%eax
+80104522:	c1 f8 04             	sar    $0x4,%eax
+80104525:	69 c0 a3 8b 2e ba    	imul   $0xba2e8ba3,%eax,%eax
+}
+8010452b:	c9                   	leave  
+8010452c:	c3                   	ret    
+
+8010452d <mycpu>:
+
+// Must be called with interrupts disabled to avoid the caller being
+// rescheduled between reading lapicid and running through the loop.
+struct cpu*
+mycpu(void)
+{
+8010452d:	f3 0f 1e fb          	endbr32 
+80104531:	55                   	push   %ebp
+80104532:	89 e5                	mov    %esp,%ebp
+80104534:	83 ec 18             	sub    $0x18,%esp
+  int apicid, i;
+  
+  if(readeflags()&FL_IF)
+80104537:	e8 20 fe ff ff       	call   8010435c <readeflags>
+8010453c:	25 00 02 00 00       	and    $0x200,%eax
+80104541:	85 c0                	test   %eax,%eax
+80104543:	74 0d                	je     80104552 <mycpu+0x25>
+    panic("mycpu called with interrupts enabled\n");
+80104545:	83 ec 0c             	sub    $0xc,%esp
+80104548:	68 f4 90 10 80       	push   $0x801090f4
+8010454d:	e8 7f c0 ff ff       	call   801005d1 <panic>
+  
+  apicid = lapicid();
+80104552:	e8 a8 eb ff ff       	call   801030ff <lapicid>
+80104557:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+  // a reverse map, or reserve a register to store &cpus[i].
+  for (i = 0; i < ncpu; ++i) {
+8010455a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80104561:	eb 2d                	jmp    80104590 <mycpu+0x63>
+    if (cpus[i].apicid == apicid)
+80104563:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104566:	69 c0 b0 00 00 00    	imul   $0xb0,%eax,%eax
+8010456c:	05 20 48 11 80       	add    $0x80114820,%eax
+80104571:	0f b6 00             	movzbl (%eax),%eax
+80104574:	0f b6 c0             	movzbl %al,%eax
+80104577:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+8010457a:	75 10                	jne    8010458c <mycpu+0x5f>
+      return &cpus[i];
+8010457c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010457f:	69 c0 b0 00 00 00    	imul   $0xb0,%eax,%eax
+80104585:	05 20 48 11 80       	add    $0x80114820,%eax
+8010458a:	eb 1b                	jmp    801045a7 <mycpu+0x7a>
+  for (i = 0; i < ncpu; ++i) {
+8010458c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80104590:	a1 a0 4d 11 80       	mov    0x80114da0,%eax
+80104595:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+80104598:	7c c9                	jl     80104563 <mycpu+0x36>
+  }
+  panic("unknown apicid\n");
+8010459a:	83 ec 0c             	sub    $0xc,%esp
+8010459d:	68 1a 91 10 80       	push   $0x8010911a
+801045a2:	e8 2a c0 ff ff       	call   801005d1 <panic>
+}
+801045a7:	c9                   	leave  
+801045a8:	c3                   	ret    
+
+801045a9 <myproc>:
+
+// Disable interrupts so that we are not rescheduled
+// while reading proc from the cpu structure
+struct proc*
+myproc(void) {
+801045a9:	f3 0f 1e fb          	endbr32 
+801045ad:	55                   	push   %ebp
+801045ae:	89 e5                	mov    %esp,%ebp
+801045b0:	83 ec 18             	sub    $0x18,%esp
+  struct cpu *c;
+  struct proc *p;
+  pushcli();
+801045b3:	e8 50 13 00 00       	call   80105908 <pushcli>
+  c = mycpu();
+801045b8:	e8 70 ff ff ff       	call   8010452d <mycpu>
+801045bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  p = c->proc;
+801045c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801045c3:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
+801045c9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  popcli();
+801045cc:	e8 88 13 00 00       	call   80105959 <popcli>
+  return p;
+801045d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+801045d4:	c9                   	leave  
+801045d5:	c3                   	ret    
+
+801045d6 <allocproc>:
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+801045d6:	f3 0f 1e fb          	endbr32 
+801045da:	55                   	push   %ebp
+801045db:	89 e5                	mov    %esp,%ebp
+801045dd:	83 ec 18             	sub    $0x18,%esp
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+801045e0:	83 ec 0c             	sub    $0xc,%esp
+801045e3:	68 c0 4d 11 80       	push   $0x80114dc0
+801045e8:	e8 8f 11 00 00       	call   8010577c <acquire>
+801045ed:	83 c4 10             	add    $0x10,%esp
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+801045f0:	c7 45 f4 f4 4d 11 80 	movl   $0x80114df4,-0xc(%ebp)
+801045f7:	eb 11                	jmp    8010460a <allocproc+0x34>
+    if(p->state == UNUSED)
+801045f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801045fc:	8b 40 20             	mov    0x20(%eax),%eax
+801045ff:	85 c0                	test   %eax,%eax
+80104601:	74 2a                	je     8010462d <allocproc+0x57>
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80104603:	81 45 f4 9c 00 00 00 	addl   $0x9c,-0xc(%ebp)
+8010460a:	81 7d f4 f4 74 11 80 	cmpl   $0x801174f4,-0xc(%ebp)
+80104611:	72 e6                	jb     801045f9 <allocproc+0x23>
+      goto found;
+  release(&ptable.lock);
+80104613:	83 ec 0c             	sub    $0xc,%esp
+80104616:	68 c0 4d 11 80       	push   $0x80114dc0
+8010461b:	e8 ce 11 00 00       	call   801057ee <release>
+80104620:	83 c4 10             	add    $0x10,%esp
+  return 0;
+80104623:	b8 00 00 00 00       	mov    $0x0,%eax
+80104628:	e9 46 01 00 00       	jmp    80104773 <allocproc+0x19d>
+      goto found;
+8010462d:	90                   	nop
+8010462e:	f3 0f 1e fb          	endbr32 
+
+found:
+  p->state = EMBRYO;
+80104632:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104635:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%eax)
+  p->pid = nextpid++;
+8010463c:	a1 00 c0 10 80       	mov    0x8010c000,%eax
+80104641:	8d 50 01             	lea    0x1(%eax),%edx
+80104644:	89 15 00 c0 10 80    	mov    %edx,0x8010c000
+8010464a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010464d:	89 42 10             	mov    %eax,0x10(%edx)
+  p->ctime = ticks;
+80104650:	8b 15 40 7d 11 80    	mov    0x80117d40,%edx
+80104656:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104659:	89 50 7c             	mov    %edx,0x7c(%eax)
+  p->retime = 0;
+8010465c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010465f:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
+80104666:	00 00 00 
+  p->rutime = 0;
+80104669:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010466c:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
+80104673:	00 00 00 
+  p->stime = 0;
+80104676:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104679:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
+80104680:	00 00 00 
+  p->priority = 2;
+80104683:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104686:	c7 80 8c 00 00 00 02 	movl   $0x2,0x8c(%eax)
+8010468d:	00 00 00 
+  p->fake[0] = '*';
+80104690:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104693:	c6 80 94 00 00 00 2a 	movb   $0x2a,0x94(%eax)
+  p->fake[1] = '*';
+8010469a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010469d:	c6 80 95 00 00 00 2a 	movb   $0x2a,0x95(%eax)
+  p->fake[2] = '*';
+801046a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801046a7:	c6 80 96 00 00 00 2a 	movb   $0x2a,0x96(%eax)
+  p->fake[3] = '*';
+801046ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801046b1:	c6 80 97 00 00 00 2a 	movb   $0x2a,0x97(%eax)
+  p->fake[4] = '*';
+801046b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801046bb:	c6 80 98 00 00 00 2a 	movb   $0x2a,0x98(%eax)
+  p->fake[5] = '*';
+801046c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801046c5:	c6 80 99 00 00 00 2a 	movb   $0x2a,0x99(%eax)
+  p->fake[6] = '*';
+801046cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801046cf:	c6 80 9a 00 00 00 2a 	movb   $0x2a,0x9a(%eax)
+  p->fake[7] = '*';
+801046d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801046d9:	c6 80 9b 00 00 00 2a 	movb   $0x2a,0x9b(%eax)
+  release(&ptable.lock);
+801046e0:	83 ec 0c             	sub    $0xc,%esp
+801046e3:	68 c0 4d 11 80       	push   $0x80114dc0
+801046e8:	e8 01 11 00 00       	call   801057ee <release>
+801046ed:	83 c4 10             	add    $0x10,%esp
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+801046f0:	e8 9d e6 ff ff       	call   80102d92 <kalloc>
+801046f5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801046f8:	89 42 1c             	mov    %eax,0x1c(%edx)
+801046fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801046fe:	8b 40 1c             	mov    0x1c(%eax),%eax
+80104701:	85 c0                	test   %eax,%eax
+80104703:	75 11                	jne    80104716 <allocproc+0x140>
+    p->state = UNUSED;
+80104705:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104708:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
+    return 0;
+8010470f:	b8 00 00 00 00       	mov    $0x0,%eax
+80104714:	eb 5d                	jmp    80104773 <allocproc+0x19d>
+  }
+  sp = p->kstack + KSTACKSIZE;
+80104716:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104719:	8b 40 1c             	mov    0x1c(%eax),%eax
+8010471c:	05 00 10 00 00       	add    $0x1000,%eax
+80104721:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+80104724:	83 6d f0 4c          	subl   $0x4c,-0x10(%ebp)
+  p->tf = (struct trapframe*)sp;
+80104728:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010472b:	8b 55 f0             	mov    -0x10(%ebp),%edx
+8010472e:	89 50 28             	mov    %edx,0x28(%eax)
+
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+80104731:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
+  *(uint*)sp = (uint)trapret;
+80104735:	ba ec 6e 10 80       	mov    $0x80106eec,%edx
+8010473a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010473d:	89 10                	mov    %edx,(%eax)
+
+  sp -= sizeof *p->context;
+8010473f:	83 6d f0 14          	subl   $0x14,-0x10(%ebp)
+  p->context = (struct context*)sp;
+80104743:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104746:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104749:	89 50 2c             	mov    %edx,0x2c(%eax)
+  memset(p->context, 0, sizeof *p->context);
+8010474c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010474f:	8b 40 2c             	mov    0x2c(%eax),%eax
+80104752:	83 ec 04             	sub    $0x4,%esp
+80104755:	6a 14                	push   $0x14
+80104757:	6a 00                	push   $0x0
+80104759:	50                   	push   %eax
+8010475a:	e8 bc 12 00 00       	call   80105a1b <memset>
+8010475f:	83 c4 10             	add    $0x10,%esp
+  p->context->eip = (uint)forkret;
+80104762:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104765:	8b 40 2c             	mov    0x2c(%eax),%eax
+80104768:	ba 14 51 10 80       	mov    $0x80105114,%edx
+8010476d:	89 50 10             	mov    %edx,0x10(%eax)
+
+  return p;
+80104770:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80104773:	c9                   	leave  
+80104774:	c3                   	ret    
+
+80104775 <userinit>:
+
+//PAGEBREAK: 32
+// Set up first user process.
+void
+userinit(void)
+{
+80104775:	f3 0f 1e fb          	endbr32 
+80104779:	55                   	push   %ebp
+8010477a:	89 e5                	mov    %esp,%ebp
+8010477c:	83 ec 18             	sub    $0x18,%esp
+  struct proc *p;
+  extern char _binary_initcode_start[], _binary_initcode_size[];
+
+  p = allocproc();
+8010477f:	e8 52 fe ff ff       	call   801045d6 <allocproc>
+80104784:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  
+  initproc = p;
+80104787:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010478a:	a3 44 c6 10 80       	mov    %eax,0x8010c644
+  if((p->pgdir = setupkvm()) == 0)
+8010478f:	e8 e5 3c 00 00       	call   80108479 <setupkvm>
+80104794:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104797:	89 42 18             	mov    %eax,0x18(%edx)
+8010479a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010479d:	8b 40 18             	mov    0x18(%eax),%eax
+801047a0:	85 c0                	test   %eax,%eax
+801047a2:	75 0d                	jne    801047b1 <userinit+0x3c>
+    panic("userinit: out of memory?");
+801047a4:	83 ec 0c             	sub    $0xc,%esp
+801047a7:	68 2a 91 10 80       	push   $0x8010912a
+801047ac:	e8 20 be ff ff       	call   801005d1 <panic>
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+801047b1:	ba 2c 00 00 00       	mov    $0x2c,%edx
+801047b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801047b9:	8b 40 18             	mov    0x18(%eax),%eax
+801047bc:	83 ec 04             	sub    $0x4,%esp
+801047bf:	52                   	push   %edx
+801047c0:	68 e0 c4 10 80       	push   $0x8010c4e0
+801047c5:	50                   	push   %eax
+801047c6:	e8 27 3f 00 00       	call   801086f2 <inituvm>
+801047cb:	83 c4 10             	add    $0x10,%esp
+  p->sz = PGSIZE;
+801047ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801047d1:	c7 40 14 00 10 00 00 	movl   $0x1000,0x14(%eax)
+  memset(p->tf, 0, sizeof(*p->tf));
+801047d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801047db:	8b 40 28             	mov    0x28(%eax),%eax
+801047de:	83 ec 04             	sub    $0x4,%esp
+801047e1:	6a 4c                	push   $0x4c
+801047e3:	6a 00                	push   $0x0
+801047e5:	50                   	push   %eax
+801047e6:	e8 30 12 00 00       	call   80105a1b <memset>
+801047eb:	83 c4 10             	add    $0x10,%esp
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+801047ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801047f1:	8b 40 28             	mov    0x28(%eax),%eax
+801047f4:	66 c7 40 3c 1b 00    	movw   $0x1b,0x3c(%eax)
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+801047fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801047fd:	8b 40 28             	mov    0x28(%eax),%eax
+80104800:	66 c7 40 2c 23 00    	movw   $0x23,0x2c(%eax)
+  p->tf->es = p->tf->ds;
+80104806:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104809:	8b 50 28             	mov    0x28(%eax),%edx
+8010480c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010480f:	8b 40 28             	mov    0x28(%eax),%eax
+80104812:	0f b7 52 2c          	movzwl 0x2c(%edx),%edx
+80104816:	66 89 50 28          	mov    %dx,0x28(%eax)
+  p->tf->ss = p->tf->ds;
+8010481a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010481d:	8b 50 28             	mov    0x28(%eax),%edx
+80104820:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104823:	8b 40 28             	mov    0x28(%eax),%eax
+80104826:	0f b7 52 2c          	movzwl 0x2c(%edx),%edx
+8010482a:	66 89 50 48          	mov    %dx,0x48(%eax)
+  p->tf->eflags = FL_IF;
+8010482e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104831:	8b 40 28             	mov    0x28(%eax),%eax
+80104834:	c7 40 40 00 02 00 00 	movl   $0x200,0x40(%eax)
+  p->tf->esp = PGSIZE;
+8010483b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010483e:	8b 40 28             	mov    0x28(%eax),%eax
+80104841:	c7 40 44 00 10 00 00 	movl   $0x1000,0x44(%eax)
+  p->tf->eip = 0;  // beginning of initcode.S
+80104848:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010484b:	8b 40 28             	mov    0x28(%eax),%eax
+8010484e:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+80104855:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104858:	83 ec 04             	sub    $0x4,%esp
+8010485b:	6a 10                	push   $0x10
+8010485d:	68 43 91 10 80       	push   $0x80109143
+80104862:	50                   	push   %eax
+80104863:	e8 ce 13 00 00       	call   80105c36 <safestrcpy>
+80104868:	83 c4 10             	add    $0x10,%esp
+  p->cwd = namei("/");
+8010486b:	83 ec 0c             	sub    $0xc,%esp
+8010486e:	68 4c 91 10 80       	push   $0x8010914c
+80104873:	e8 95 dd ff ff       	call   8010260d <namei>
+80104878:	83 c4 10             	add    $0x10,%esp
+8010487b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+8010487e:	89 42 78             	mov    %eax,0x78(%edx)
+
+  // this assignment to p->state lets other cores
+  // run this process. the acquire forces the above
+  // writes to be visible, and the lock is also needed
+  // because the assignment might not be atomic.
+  acquire(&ptable.lock);
+80104881:	83 ec 0c             	sub    $0xc,%esp
+80104884:	68 c0 4d 11 80       	push   $0x80114dc0
+80104889:	e8 ee 0e 00 00       	call   8010577c <acquire>
+8010488e:	83 c4 10             	add    $0x10,%esp
+
+  p->state = RUNNABLE;
+80104891:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104894:	c7 40 20 03 00 00 00 	movl   $0x3,0x20(%eax)
+
+  release(&ptable.lock);
+8010489b:	83 ec 0c             	sub    $0xc,%esp
+8010489e:	68 c0 4d 11 80       	push   $0x80114dc0
+801048a3:	e8 46 0f 00 00       	call   801057ee <release>
+801048a8:	83 c4 10             	add    $0x10,%esp
+}
+801048ab:	90                   	nop
+801048ac:	c9                   	leave  
+801048ad:	c3                   	ret    
+
+801048ae <growproc>:
+
+// Grow current process's memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+801048ae:	f3 0f 1e fb          	endbr32 
+801048b2:	55                   	push   %ebp
+801048b3:	89 e5                	mov    %esp,%ebp
+801048b5:	83 ec 18             	sub    $0x18,%esp
+  uint sz;
+  struct proc *curproc = myproc();
+801048b8:	e8 ec fc ff ff       	call   801045a9 <myproc>
+801048bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  sz = curproc->sz;
+801048c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801048c3:	8b 40 14             	mov    0x14(%eax),%eax
+801048c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(n > 0){
+801048c9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+801048cd:	7e 2e                	jle    801048fd <growproc+0x4f>
+    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+801048cf:	8b 55 08             	mov    0x8(%ebp),%edx
+801048d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801048d5:	01 c2                	add    %eax,%edx
+801048d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801048da:	8b 40 18             	mov    0x18(%eax),%eax
+801048dd:	83 ec 04             	sub    $0x4,%esp
+801048e0:	52                   	push   %edx
+801048e1:	ff 75 f4             	pushl  -0xc(%ebp)
+801048e4:	50                   	push   %eax
+801048e5:	e8 4d 3f 00 00       	call   80108837 <allocuvm>
+801048ea:	83 c4 10             	add    $0x10,%esp
+801048ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801048f0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801048f4:	75 3b                	jne    80104931 <growproc+0x83>
+      return -1;
+801048f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801048fb:	eb 50                	jmp    8010494d <growproc+0x9f>
+  } else if(n < 0){
+801048fd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80104901:	79 2e                	jns    80104931 <growproc+0x83>
+    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+80104903:	8b 55 08             	mov    0x8(%ebp),%edx
+80104906:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104909:	01 c2                	add    %eax,%edx
+8010490b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010490e:	8b 40 18             	mov    0x18(%eax),%eax
+80104911:	83 ec 04             	sub    $0x4,%esp
+80104914:	52                   	push   %edx
+80104915:	ff 75 f4             	pushl  -0xc(%ebp)
+80104918:	50                   	push   %eax
+80104919:	e8 22 40 00 00       	call   80108940 <deallocuvm>
+8010491e:	83 c4 10             	add    $0x10,%esp
+80104921:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80104924:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80104928:	75 07                	jne    80104931 <growproc+0x83>
+      return -1;
+8010492a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010492f:	eb 1c                	jmp    8010494d <growproc+0x9f>
+  }
+  curproc->sz = sz;
+80104931:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104934:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104937:	89 50 14             	mov    %edx,0x14(%eax)
+  switchuvm(curproc);
+8010493a:	83 ec 0c             	sub    $0xc,%esp
+8010493d:	ff 75 f0             	pushl  -0x10(%ebp)
+80104940:	e8 0a 3c 00 00       	call   8010854f <switchuvm>
+80104945:	83 c4 10             	add    $0x10,%esp
+  return 0;
+80104948:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+8010494d:	c9                   	leave  
+8010494e:	c3                   	ret    
+
+8010494f <fork>:
+// Create a new process copying p as the parent.
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+int
+fork(void)
+{
+8010494f:	f3 0f 1e fb          	endbr32 
+80104953:	55                   	push   %ebp
+80104954:	89 e5                	mov    %esp,%ebp
+80104956:	57                   	push   %edi
+80104957:	56                   	push   %esi
+80104958:	53                   	push   %ebx
+80104959:	83 ec 1c             	sub    $0x1c,%esp
+  int i, pid;
+  struct proc *np;
+  struct proc *curproc = myproc();
+8010495c:	e8 48 fc ff ff       	call   801045a9 <myproc>
+80104961:	89 45 e0             	mov    %eax,-0x20(%ebp)
+
+  // Allocate process.
+  if((np = allocproc()) == 0){
+80104964:	e8 6d fc ff ff       	call   801045d6 <allocproc>
+80104969:	89 45 dc             	mov    %eax,-0x24(%ebp)
+8010496c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+80104970:	75 0a                	jne    8010497c <fork+0x2d>
+    return -1;
+80104972:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104977:	e9 57 01 00 00       	jmp    80104ad3 <fork+0x184>
+  }
+
+  // Copy process state from proc.
+  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+8010497c:	8b 45 e0             	mov    -0x20(%ebp),%eax
+8010497f:	8b 50 14             	mov    0x14(%eax),%edx
+80104982:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104985:	8b 40 18             	mov    0x18(%eax),%eax
+80104988:	83 ec 08             	sub    $0x8,%esp
+8010498b:	52                   	push   %edx
+8010498c:	50                   	push   %eax
+8010498d:	e8 58 41 00 00       	call   80108aea <copyuvm>
+80104992:	83 c4 10             	add    $0x10,%esp
+80104995:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80104998:	89 42 18             	mov    %eax,0x18(%edx)
+8010499b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+8010499e:	8b 40 18             	mov    0x18(%eax),%eax
+801049a1:	85 c0                	test   %eax,%eax
+801049a3:	75 30                	jne    801049d5 <fork+0x86>
+    kfree(np->kstack);
+801049a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
+801049a8:	8b 40 1c             	mov    0x1c(%eax),%eax
+801049ab:	83 ec 0c             	sub    $0xc,%esp
+801049ae:	50                   	push   %eax
+801049af:	e8 40 e3 ff ff       	call   80102cf4 <kfree>
+801049b4:	83 c4 10             	add    $0x10,%esp
+    np->kstack = 0;
+801049b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
+801049ba:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
+    np->state = UNUSED;
+801049c1:	8b 45 dc             	mov    -0x24(%ebp),%eax
+801049c4:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
+    return -1;
+801049cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801049d0:	e9 fe 00 00 00       	jmp    80104ad3 <fork+0x184>
+  }
+  np->sz = curproc->sz;
+801049d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801049d8:	8b 50 14             	mov    0x14(%eax),%edx
+801049db:	8b 45 dc             	mov    -0x24(%ebp),%eax
+801049de:	89 50 14             	mov    %edx,0x14(%eax)
+  np->parent = curproc;
+801049e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
+801049e4:	8b 55 e0             	mov    -0x20(%ebp),%edx
+801049e7:	89 50 24             	mov    %edx,0x24(%eax)
+  *np->tf = *curproc->tf;
+801049ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
+801049ed:	8b 48 28             	mov    0x28(%eax),%ecx
+801049f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
+801049f3:	8b 40 28             	mov    0x28(%eax),%eax
+801049f6:	89 c2                	mov    %eax,%edx
+801049f8:	89 cb                	mov    %ecx,%ebx
+801049fa:	b8 13 00 00 00       	mov    $0x13,%eax
+801049ff:	89 d7                	mov    %edx,%edi
+80104a01:	89 de                	mov    %ebx,%esi
+80104a03:	89 c1                	mov    %eax,%ecx
+80104a05:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  np->priority = curproc->priority;
+80104a07:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104a0a:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
+80104a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80104a13:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
+
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+80104a19:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80104a1c:	8b 40 28             	mov    0x28(%eax),%eax
+80104a1f:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
+
+  for(i = 0; i < NOFILE; i++)
+80104a26:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+80104a2d:	eb 3b                	jmp    80104a6a <fork+0x11b>
+    if(curproc->ofile[i])
+80104a2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104a32:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80104a35:	83 c2 0c             	add    $0xc,%edx
+80104a38:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80104a3c:	85 c0                	test   %eax,%eax
+80104a3e:	74 26                	je     80104a66 <fork+0x117>
+      np->ofile[i] = filedup(curproc->ofile[i]);
+80104a40:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104a43:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80104a46:	83 c2 0c             	add    $0xc,%edx
+80104a49:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80104a4d:	83 ec 0c             	sub    $0xc,%esp
+80104a50:	50                   	push   %eax
+80104a51:	e8 77 c6 ff ff       	call   801010cd <filedup>
+80104a56:	83 c4 10             	add    $0x10,%esp
+80104a59:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80104a5c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+80104a5f:	83 c1 0c             	add    $0xc,%ecx
+80104a62:	89 44 8a 08          	mov    %eax,0x8(%edx,%ecx,4)
+  for(i = 0; i < NOFILE; i++)
+80104a66:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
+80104a6a:	83 7d e4 0f          	cmpl   $0xf,-0x1c(%ebp)
+80104a6e:	7e bf                	jle    80104a2f <fork+0xe0>
+  np->cwd = idup(curproc->cwd);
+80104a70:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80104a73:	8b 40 78             	mov    0x78(%eax),%eax
+80104a76:	83 ec 0c             	sub    $0xc,%esp
+80104a79:	50                   	push   %eax
+80104a7a:	e8 e5 cf ff ff       	call   80101a64 <idup>
+80104a7f:	83 c4 10             	add    $0x10,%esp
+80104a82:	8b 55 dc             	mov    -0x24(%ebp),%edx
+80104a85:	89 42 78             	mov    %eax,0x78(%edx)
+
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+80104a88:	8b 55 e0             	mov    -0x20(%ebp),%edx
+80104a8b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80104a8e:	83 ec 04             	sub    $0x4,%esp
+80104a91:	6a 10                	push   $0x10
+80104a93:	52                   	push   %edx
+80104a94:	50                   	push   %eax
+80104a95:	e8 9c 11 00 00       	call   80105c36 <safestrcpy>
+80104a9a:	83 c4 10             	add    $0x10,%esp
+
+  pid = np->pid;
+80104a9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80104aa0:	8b 40 10             	mov    0x10(%eax),%eax
+80104aa3:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+  acquire(&ptable.lock);
+80104aa6:	83 ec 0c             	sub    $0xc,%esp
+80104aa9:	68 c0 4d 11 80       	push   $0x80114dc0
+80104aae:	e8 c9 0c 00 00       	call   8010577c <acquire>
+80104ab3:	83 c4 10             	add    $0x10,%esp
+
+  np->state = RUNNABLE;
+80104ab6:	8b 45 dc             	mov    -0x24(%ebp),%eax
+80104ab9:	c7 40 20 03 00 00 00 	movl   $0x3,0x20(%eax)
+
+  release(&ptable.lock);
+80104ac0:	83 ec 0c             	sub    $0xc,%esp
+80104ac3:	68 c0 4d 11 80       	push   $0x80114dc0
+80104ac8:	e8 21 0d 00 00       	call   801057ee <release>
+80104acd:	83 c4 10             	add    $0x10,%esp
+
+  return pid;
+80104ad0:	8b 45 d8             	mov    -0x28(%ebp),%eax
+}
+80104ad3:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80104ad6:	5b                   	pop    %ebx
+80104ad7:	5e                   	pop    %esi
+80104ad8:	5f                   	pop    %edi
+80104ad9:	5d                   	pop    %ebp
+80104ada:	c3                   	ret    
+
+80104adb <exit>:
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait() to find out it exited.
+void
+exit(void)
+{
+80104adb:	f3 0f 1e fb          	endbr32 
+80104adf:	55                   	push   %ebp
+80104ae0:	89 e5                	mov    %esp,%ebp
+80104ae2:	83 ec 18             	sub    $0x18,%esp
+  struct proc *curproc = myproc();
+80104ae5:	e8 bf fa ff ff       	call   801045a9 <myproc>
+80104aea:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  struct proc *p;
+  int fd;
+
+  if(curproc == initproc)
+80104aed:	a1 44 c6 10 80       	mov    0x8010c644,%eax
+80104af2:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+80104af5:	75 0d                	jne    80104b04 <exit+0x29>
+    panic("init exiting");
+80104af7:	83 ec 0c             	sub    $0xc,%esp
+80104afa:	68 4e 91 10 80       	push   $0x8010914e
+80104aff:	e8 cd ba ff ff       	call   801005d1 <panic>
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+80104b04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+80104b0b:	eb 3f                	jmp    80104b4c <exit+0x71>
+    if(curproc->ofile[fd]){
+80104b0d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104b10:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104b13:	83 c2 0c             	add    $0xc,%edx
+80104b16:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80104b1a:	85 c0                	test   %eax,%eax
+80104b1c:	74 2a                	je     80104b48 <exit+0x6d>
+      fileclose(curproc->ofile[fd]);
+80104b1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104b21:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104b24:	83 c2 0c             	add    $0xc,%edx
+80104b27:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80104b2b:	83 ec 0c             	sub    $0xc,%esp
+80104b2e:	50                   	push   %eax
+80104b2f:	e8 ee c5 ff ff       	call   80101122 <fileclose>
+80104b34:	83 c4 10             	add    $0x10,%esp
+      curproc->ofile[fd] = 0;
+80104b37:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104b3a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104b3d:	83 c2 0c             	add    $0xc,%edx
+80104b40:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
+80104b47:	00 
+  for(fd = 0; fd < NOFILE; fd++){
+80104b48:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+80104b4c:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
+80104b50:	7e bb                	jle    80104b0d <exit+0x32>
+    }
+  }
+
+  begin_op();
+80104b52:	e8 1a eb ff ff       	call   80103671 <begin_op>
+  iput(curproc->cwd);
+80104b57:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104b5a:	8b 40 78             	mov    0x78(%eax),%eax
+80104b5d:	83 ec 0c             	sub    $0xc,%esp
+80104b60:	50                   	push   %eax
+80104b61:	e8 a5 d0 ff ff       	call   80101c0b <iput>
+80104b66:	83 c4 10             	add    $0x10,%esp
+  end_op();
+80104b69:	e8 93 eb ff ff       	call   80103701 <end_op>
+  curproc->cwd = 0;
+80104b6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104b71:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
+
+  acquire(&ptable.lock);
+80104b78:	83 ec 0c             	sub    $0xc,%esp
+80104b7b:	68 c0 4d 11 80       	push   $0x80114dc0
+80104b80:	e8 f7 0b 00 00       	call   8010577c <acquire>
+80104b85:	83 c4 10             	add    $0x10,%esp
+
+  // Parent might be sleeping in wait().
+  wakeup1(curproc->parent);
+80104b88:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104b8b:	8b 40 24             	mov    0x24(%eax),%eax
+80104b8e:	83 ec 0c             	sub    $0xc,%esp
+80104b91:	50                   	push   %eax
+80104b92:	e8 72 06 00 00       	call   80105209 <wakeup1>
+80104b97:	83 c4 10             	add    $0x10,%esp
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104b9a:	c7 45 f4 f4 4d 11 80 	movl   $0x80114df4,-0xc(%ebp)
+80104ba1:	eb 3a                	jmp    80104bdd <exit+0x102>
+    if(p->parent == curproc){
+80104ba3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104ba6:	8b 40 24             	mov    0x24(%eax),%eax
+80104ba9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+80104bac:	75 28                	jne    80104bd6 <exit+0xfb>
+      p->parent = initproc;
+80104bae:	8b 15 44 c6 10 80    	mov    0x8010c644,%edx
+80104bb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104bb7:	89 50 24             	mov    %edx,0x24(%eax)
+      if(p->state == ZOMBIE)
+80104bba:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104bbd:	8b 40 20             	mov    0x20(%eax),%eax
+80104bc0:	83 f8 05             	cmp    $0x5,%eax
+80104bc3:	75 11                	jne    80104bd6 <exit+0xfb>
+        wakeup1(initproc);
+80104bc5:	a1 44 c6 10 80       	mov    0x8010c644,%eax
+80104bca:	83 ec 0c             	sub    $0xc,%esp
+80104bcd:	50                   	push   %eax
+80104bce:	e8 36 06 00 00       	call   80105209 <wakeup1>
+80104bd3:	83 c4 10             	add    $0x10,%esp
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104bd6:	81 45 f4 9c 00 00 00 	addl   $0x9c,-0xc(%ebp)
+80104bdd:	81 7d f4 f4 74 11 80 	cmpl   $0x801174f4,-0xc(%ebp)
+80104be4:	72 bd                	jb     80104ba3 <exit+0xc8>
+    }
+  }
+
+  // Jump into the scheduler, never to return.
+  curproc->state = ZOMBIE;
+80104be6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104be9:	c7 40 20 05 00 00 00 	movl   $0x5,0x20(%eax)
+  sched();
+80104bf0:	e8 62 04 00 00       	call   80105057 <sched>
+  panic("zombie exit");
+80104bf5:	83 ec 0c             	sub    $0xc,%esp
+80104bf8:	68 5b 91 10 80       	push   $0x8010915b
+80104bfd:	e8 cf b9 ff ff       	call   801005d1 <panic>
+
+80104c02 <wait>:
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait(void)
+{
+80104c02:	f3 0f 1e fb          	endbr32 
+80104c06:	55                   	push   %ebp
+80104c07:	89 e5                	mov    %esp,%ebp
+80104c09:	83 ec 18             	sub    $0x18,%esp
+  struct proc *p;
+  int havekids, pid;
+  struct proc *curproc = myproc();
+80104c0c:	e8 98 f9 ff ff       	call   801045a9 <myproc>
+80104c11:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  
+  acquire(&ptable.lock);
+80104c14:	83 ec 0c             	sub    $0xc,%esp
+80104c17:	68 c0 4d 11 80       	push   $0x80114dc0
+80104c1c:	e8 5b 0b 00 00       	call   8010577c <acquire>
+80104c21:	83 c4 10             	add    $0x10,%esp
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+80104c24:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104c2b:	c7 45 f4 f4 4d 11 80 	movl   $0x80114df4,-0xc(%ebp)
+80104c32:	e9 a3 00 00 00       	jmp    80104cda <wait+0xd8>
+      if(p->parent != curproc)
+80104c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c3a:	8b 40 24             	mov    0x24(%eax),%eax
+80104c3d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+80104c40:	0f 85 8c 00 00 00    	jne    80104cd2 <wait+0xd0>
+        continue;
+      havekids = 1;
+80104c46:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+      if(p->state == ZOMBIE){
+80104c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c50:	8b 40 20             	mov    0x20(%eax),%eax
+80104c53:	83 f8 05             	cmp    $0x5,%eax
+80104c56:	75 7b                	jne    80104cd3 <wait+0xd1>
+        // Found one.
+        pid = p->pid;
+80104c58:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c5b:	8b 40 10             	mov    0x10(%eax),%eax
+80104c5e:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        kfree(p->kstack);
+80104c61:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c64:	8b 40 1c             	mov    0x1c(%eax),%eax
+80104c67:	83 ec 0c             	sub    $0xc,%esp
+80104c6a:	50                   	push   %eax
+80104c6b:	e8 84 e0 ff ff       	call   80102cf4 <kfree>
+80104c70:	83 c4 10             	add    $0x10,%esp
+        p->kstack = 0;
+80104c73:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c76:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
+        freevm(p->pgdir);
+80104c7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c80:	8b 40 18             	mov    0x18(%eax),%eax
+80104c83:	83 ec 0c             	sub    $0xc,%esp
+80104c86:	50                   	push   %eax
+80104c87:	e8 7c 3d 00 00       	call   80108a08 <freevm>
+80104c8c:	83 c4 10             	add    $0x10,%esp
+        p->pid = 0;
+80104c8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c92:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
+        p->parent = 0;
+80104c99:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104c9c:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
+        p->name[0] = 0;
+80104ca3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104ca6:	c6 00 00             	movb   $0x0,(%eax)
+        p->killed = 0;
+80104ca9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104cac:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
+        p->state = UNUSED;
+80104cb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104cb6:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
+        release(&ptable.lock);
+80104cbd:	83 ec 0c             	sub    $0xc,%esp
+80104cc0:	68 c0 4d 11 80       	push   $0x80114dc0
+80104cc5:	e8 24 0b 00 00       	call   801057ee <release>
+80104cca:	83 c4 10             	add    $0x10,%esp
+        return pid;
+80104ccd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80104cd0:	eb 54                	jmp    80104d26 <wait+0x124>
+        continue;
+80104cd2:	90                   	nop
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104cd3:	81 45 f4 9c 00 00 00 	addl   $0x9c,-0xc(%ebp)
+80104cda:	81 7d f4 f4 74 11 80 	cmpl   $0x801174f4,-0xc(%ebp)
+80104ce1:	0f 82 50 ff ff ff    	jb     80104c37 <wait+0x35>
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || curproc->killed){
+80104ce7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80104ceb:	74 0a                	je     80104cf7 <wait+0xf5>
+80104ced:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104cf0:	8b 40 34             	mov    0x34(%eax),%eax
+80104cf3:	85 c0                	test   %eax,%eax
+80104cf5:	74 17                	je     80104d0e <wait+0x10c>
+      release(&ptable.lock);
+80104cf7:	83 ec 0c             	sub    $0xc,%esp
+80104cfa:	68 c0 4d 11 80       	push   $0x80114dc0
+80104cff:	e8 ea 0a 00 00       	call   801057ee <release>
+80104d04:	83 c4 10             	add    $0x10,%esp
+      return -1;
+80104d07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104d0c:	eb 18                	jmp    80104d26 <wait+0x124>
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+80104d0e:	83 ec 08             	sub    $0x8,%esp
+80104d11:	68 c0 4d 11 80       	push   $0x80114dc0
+80104d16:	ff 75 ec             	pushl  -0x14(%ebp)
+80104d19:	e8 40 04 00 00       	call   8010515e <sleep>
+80104d1e:	83 c4 10             	add    $0x10,%esp
+    havekids = 0;
+80104d21:	e9 fe fe ff ff       	jmp    80104c24 <wait+0x22>
+  }
+}
+80104d26:	c9                   	leave  
+80104d27:	c3                   	ret    
+
+80104d28 <wait2>:
+
+int wait2(int *retime, int *rutime, int *stime) {
+80104d28:	f3 0f 1e fb          	endbr32 
+80104d2c:	55                   	push   %ebp
+80104d2d:	89 e5                	mov    %esp,%ebp
+80104d2f:	83 ec 18             	sub    $0x18,%esp
+  struct proc *p;
+  int havekids, pid;
+  struct proc* proc = myproc();
+80104d32:	e8 72 f8 ff ff       	call   801045a9 <myproc>
+80104d37:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+  acquire(&ptable.lock);
+80104d3a:	83 ec 0c             	sub    $0xc,%esp
+80104d3d:	68 c0 4d 11 80       	push   $0x80114dc0
+80104d42:	e8 35 0a 00 00       	call   8010577c <acquire>
+80104d47:	83 c4 10             	add    $0x10,%esp
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+80104d4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104d51:	c7 45 f4 f4 4d 11 80 	movl   $0x80114df4,-0xc(%ebp)
+80104d58:	e9 0f 01 00 00       	jmp    80104e6c <wait2+0x144>
+      if(p->parent != proc) continue;
+80104d5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104d60:	8b 40 24             	mov    0x24(%eax),%eax
+80104d63:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+80104d66:	0f 85 f8 00 00 00    	jne    80104e64 <wait2+0x13c>
+      havekids = 1;
+80104d6c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+      if(p->state == ZOMBIE){
+80104d73:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104d76:	8b 40 20             	mov    0x20(%eax),%eax
+80104d79:	83 f8 05             	cmp    $0x5,%eax
+80104d7c:	0f 85 e3 00 00 00    	jne    80104e65 <wait2+0x13d>
+        // Found one.
+        *retime = p->retime;
+80104d82:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104d85:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
+80104d8b:	8b 45 08             	mov    0x8(%ebp),%eax
+80104d8e:	89 10                	mov    %edx,(%eax)
+        *rutime = p->rutime;
+80104d90:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104d93:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
+80104d99:	8b 45 0c             	mov    0xc(%ebp),%eax
+80104d9c:	89 10                	mov    %edx,(%eax)
+        *stime = p->stime;
+80104d9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104da1:	8b 90 80 00 00 00    	mov    0x80(%eax),%edx
+80104da7:	8b 45 10             	mov    0x10(%ebp),%eax
+80104daa:	89 10                	mov    %edx,(%eax)
+        pid = p->pid;
+80104dac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104daf:	8b 40 10             	mov    0x10(%eax),%eax
+80104db2:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        kfree(p->kstack);
+80104db5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104db8:	8b 40 1c             	mov    0x1c(%eax),%eax
+80104dbb:	83 ec 0c             	sub    $0xc,%esp
+80104dbe:	50                   	push   %eax
+80104dbf:	e8 30 df ff ff       	call   80102cf4 <kfree>
+80104dc4:	83 c4 10             	add    $0x10,%esp
+        p->kstack = 0;
+80104dc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104dca:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
+        freevm(p->pgdir);
+80104dd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104dd4:	8b 40 18             	mov    0x18(%eax),%eax
+80104dd7:	83 ec 0c             	sub    $0xc,%esp
+80104dda:	50                   	push   %eax
+80104ddb:	e8 28 3c 00 00       	call   80108a08 <freevm>
+80104de0:	83 c4 10             	add    $0x10,%esp
+        p->state = UNUSED;
+80104de3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104de6:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
+        p->pid = 0;
+80104ded:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104df0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
+        p->parent = 0;
+80104df7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104dfa:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
+        p->name[0] = 0;
+80104e01:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e04:	c6 00 00             	movb   $0x0,(%eax)
+        p->killed = 0;
+80104e07:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e0a:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
+        p->ctime = 0;
+80104e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e14:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
+        p->retime = 0;
+80104e1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e1e:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%eax)
+80104e25:	00 00 00 
+        p->rutime = 0;
+80104e28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e2b:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
+80104e32:	00 00 00 
+        p->stime = 0;
+80104e35:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e38:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
+80104e3f:	00 00 00 
+        p->priority = 0;
+80104e42:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e45:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
+80104e4c:	00 00 00 
+        release(&ptable.lock);
+80104e4f:	83 ec 0c             	sub    $0xc,%esp
+80104e52:	68 c0 4d 11 80       	push   $0x80114dc0
+80104e57:	e8 92 09 00 00       	call   801057ee <release>
+80104e5c:	83 c4 10             	add    $0x10,%esp
+        return pid;
+80104e5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80104e62:	eb 61                	jmp    80104ec5 <wait2+0x19d>
+      if(p->parent != proc) continue;
+80104e64:	90                   	nop
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104e65:	81 45 f4 9c 00 00 00 	addl   $0x9c,-0xc(%ebp)
+80104e6c:	81 7d f4 f4 74 11 80 	cmpl   $0x801174f4,-0xc(%ebp)
+80104e73:	0f 82 e4 fe ff ff    	jb     80104d5d <wait2+0x35>
+      }
+    }
+
+p->priority = 2;
+80104e79:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104e7c:	c7 80 8c 00 00 00 02 	movl   $0x2,0x8c(%eax)
+80104e83:	00 00 00 
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+80104e86:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80104e8a:	74 0a                	je     80104e96 <wait2+0x16e>
+80104e8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80104e8f:	8b 40 34             	mov    0x34(%eax),%eax
+80104e92:	85 c0                	test   %eax,%eax
+80104e94:	74 17                	je     80104ead <wait2+0x185>
+      release(&ptable.lock);
+80104e96:	83 ec 0c             	sub    $0xc,%esp
+80104e99:	68 c0 4d 11 80       	push   $0x80114dc0
+80104e9e:	e8 4b 09 00 00       	call   801057ee <release>
+80104ea3:	83 c4 10             	add    $0x10,%esp
+      return -1;
+80104ea6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104eab:	eb 18                	jmp    80104ec5 <wait2+0x19d>
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+80104ead:	83 ec 08             	sub    $0x8,%esp
+80104eb0:	68 c0 4d 11 80       	push   $0x80114dc0
+80104eb5:	ff 75 ec             	pushl  -0x14(%ebp)
+80104eb8:	e8 a1 02 00 00       	call   8010515e <sleep>
+80104ebd:	83 c4 10             	add    $0x10,%esp
+    havekids = 0;
+80104ec0:	e9 85 fe ff ff       	jmp    80104d4a <wait2+0x22>
+  }
+}
+80104ec5:	c9                   	leave  
+80104ec6:	c3                   	ret    
+
+80104ec7 <sys_wait2>:
+
+
+int sys_wait2(void) {
+80104ec7:	f3 0f 1e fb          	endbr32 
+80104ecb:	55                   	push   %ebp
+80104ecc:	89 e5                	mov    %esp,%ebp
+80104ece:	83 ec 18             	sub    $0x18,%esp
+  int *retime, *rutime, *stime;
+  if (argptr(0, (void*)&retime, sizeof(retime)) < 0)
+80104ed1:	83 ec 04             	sub    $0x4,%esp
+80104ed4:	6a 04                	push   $0x4
+80104ed6:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80104ed9:	50                   	push   %eax
+80104eda:	6a 00                	push   $0x0
+80104edc:	e8 c3 0e 00 00       	call   80105da4 <argptr>
+80104ee1:	83 c4 10             	add    $0x10,%esp
+80104ee4:	85 c0                	test   %eax,%eax
+80104ee6:	79 07                	jns    80104eef <sys_wait2+0x28>
+    return -1;
+80104ee8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104eed:	eb 53                	jmp    80104f42 <sys_wait2+0x7b>
+  if (argptr(1, (void*)&rutime, sizeof(retime)) < 0)
+80104eef:	83 ec 04             	sub    $0x4,%esp
+80104ef2:	6a 04                	push   $0x4
+80104ef4:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80104ef7:	50                   	push   %eax
+80104ef8:	6a 01                	push   $0x1
+80104efa:	e8 a5 0e 00 00       	call   80105da4 <argptr>
+80104eff:	83 c4 10             	add    $0x10,%esp
+80104f02:	85 c0                	test   %eax,%eax
+80104f04:	79 07                	jns    80104f0d <sys_wait2+0x46>
+    return -1;
+80104f06:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104f0b:	eb 35                	jmp    80104f42 <sys_wait2+0x7b>
+  if (argptr(2, (void*)&stime, sizeof(stime)) < 0)
+80104f0d:	83 ec 04             	sub    $0x4,%esp
+80104f10:	6a 04                	push   $0x4
+80104f12:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80104f15:	50                   	push   %eax
+80104f16:	6a 02                	push   $0x2
+80104f18:	e8 87 0e 00 00       	call   80105da4 <argptr>
+80104f1d:	83 c4 10             	add    $0x10,%esp
+80104f20:	85 c0                	test   %eax,%eax
+80104f22:	79 07                	jns    80104f2b <sys_wait2+0x64>
+    return -1;
+80104f24:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80104f29:	eb 17                	jmp    80104f42 <sys_wait2+0x7b>
+  return wait2(retime, rutime, stime);
+80104f2b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+80104f2e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104f34:	83 ec 04             	sub    $0x4,%esp
+80104f37:	51                   	push   %ecx
+80104f38:	52                   	push   %edx
+80104f39:	50                   	push   %eax
+80104f3a:	e8 e9 fd ff ff       	call   80104d28 <wait2>
+80104f3f:	83 c4 10             	add    $0x10,%esp
+}
+80104f42:	c9                   	leave  
+80104f43:	c3                   	ret    
+
+80104f44 <scheduler>:
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+void
+scheduler(void)
+{
+80104f44:	f3 0f 1e fb          	endbr32 
+80104f48:	55                   	push   %ebp
+80104f49:	89 e5                	mov    %esp,%ebp
+80104f4b:	83 ec 18             	sub    $0x18,%esp
+  struct cpu *cpu = mycpu();
+80104f4e:	e8 da f5 ff ff       	call   8010452d <mycpu>
+80104f53:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  cpu->proc = 0;
+80104f56:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104f59:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
+80104f60:	00 00 00 
+
+  struct proc *p;
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+80104f63:	e8 04 f4 ff ff       	call   8010436c <sti>
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+80104f68:	83 ec 0c             	sub    $0xc,%esp
+80104f6b:	68 c0 4d 11 80       	push   $0x80114dc0
+80104f70:	e8 07 08 00 00       	call   8010577c <acquire>
+80104f75:	83 c4 10             	add    $0x10,%esp
+
+
+    // the differnt options for scheduling policies, chosen during compilation
+    #ifdef DEFAULT
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104f78:	c7 45 f4 f4 4d 11 80 	movl   $0x80114df4,-0xc(%ebp)
+80104f7f:	eb 64                	jmp    80104fe5 <scheduler+0xa1>
+      if(p->state != RUNNABLE)
+80104f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104f84:	8b 40 20             	mov    0x20(%eax),%eax
+80104f87:	83 f8 03             	cmp    $0x3,%eax
+80104f8a:	75 51                	jne    80104fdd <scheduler+0x99>
+        continue;
+
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+      cpu->proc = p;
+80104f8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104f8f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80104f92:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
+      switchuvm(p);
+80104f98:	83 ec 0c             	sub    $0xc,%esp
+80104f9b:	ff 75 f4             	pushl  -0xc(%ebp)
+80104f9e:	e8 ac 35 00 00       	call   8010854f <switchuvm>
+80104fa3:	83 c4 10             	add    $0x10,%esp
+      p->state = RUNNING;
+80104fa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104fa9:	c7 40 20 04 00 00 00 	movl   $0x4,0x20(%eax)
+      swtch(&(cpu->scheduler), p->context);
+80104fb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80104fb3:	8b 40 2c             	mov    0x2c(%eax),%eax
+80104fb6:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80104fb9:	83 c2 04             	add    $0x4,%edx
+80104fbc:	83 ec 08             	sub    $0x8,%esp
+80104fbf:	50                   	push   %eax
+80104fc0:	52                   	push   %edx
+80104fc1:	e8 e9 0c 00 00       	call   80105caf <swtch>
+80104fc6:	83 c4 10             	add    $0x10,%esp
+      switchkvm();
+80104fc9:	e8 64 35 00 00       	call   80108532 <switchkvm>
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      cpu->proc = 0;
+80104fce:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80104fd1:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
+80104fd8:	00 00 00 
+80104fdb:	eb 01                	jmp    80104fde <scheduler+0x9a>
+        continue;
+80104fdd:	90                   	nop
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80104fde:	81 45 f4 9c 00 00 00 	addl   $0x9c,-0xc(%ebp)
+80104fe5:	81 7d f4 f4 74 11 80 	cmpl   $0x801174f4,-0xc(%ebp)
+80104fec:	72 93                	jb     80104f81 <scheduler+0x3d>
+    cpu->proc = 0;
+    #endif
+    #endif
+    #endif
+    #endif
+    release(&ptable.lock);
+80104fee:	83 ec 0c             	sub    $0xc,%esp
+80104ff1:	68 c0 4d 11 80       	push   $0x80114dc0
+80104ff6:	e8 f3 07 00 00       	call   801057ee <release>
+80104ffb:	83 c4 10             	add    $0x10,%esp
+    sti();
+80104ffe:	e9 60 ff ff ff       	jmp    80104f63 <scheduler+0x1f>
+
+80105003 <sys_yield>:
+  }
+}
+*/
+
+
+int sys_yield(void){
+80105003:	f3 0f 1e fb          	endbr32 
+80105007:	55                   	push   %ebp
+80105008:	89 e5                	mov    %esp,%ebp
+8010500a:	83 ec 08             	sub    $0x8,%esp
+  yield();
+8010500d:	e8 07 00 00 00       	call   80105019 <yield>
+  return(0);
+80105012:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105017:	c9                   	leave  
+80105018:	c3                   	ret    
+
+80105019 <yield>:
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+80105019:	f3 0f 1e fb          	endbr32 
+8010501d:	55                   	push   %ebp
+8010501e:	89 e5                	mov    %esp,%ebp
+80105020:	83 ec 08             	sub    $0x8,%esp
+  acquire(&ptable.lock);  //DOC: yieldlock
+80105023:	83 ec 0c             	sub    $0xc,%esp
+80105026:	68 c0 4d 11 80       	push   $0x80114dc0
+8010502b:	e8 4c 07 00 00       	call   8010577c <acquire>
+80105030:	83 c4 10             	add    $0x10,%esp
+  myproc()->state = RUNNABLE;
+80105033:	e8 71 f5 ff ff       	call   801045a9 <myproc>
+80105038:	c7 40 20 03 00 00 00 	movl   $0x3,0x20(%eax)
+  sched();
+8010503f:	e8 13 00 00 00       	call   80105057 <sched>
+  release(&ptable.lock);
+80105044:	83 ec 0c             	sub    $0xc,%esp
+80105047:	68 c0 4d 11 80       	push   $0x80114dc0
+8010504c:	e8 9d 07 00 00       	call   801057ee <release>
+80105051:	83 c4 10             	add    $0x10,%esp
+}
+80105054:	90                   	nop
+80105055:	c9                   	leave  
+80105056:	c3                   	ret    
+
+80105057 <sched>:
+// be proc->intena and proc->ncli, but that would
+// break in the few places where a lock is held but
+// there's no process.
+void
+sched(void)
+{
+80105057:	f3 0f 1e fb          	endbr32 
+8010505b:	55                   	push   %ebp
+8010505c:	89 e5                	mov    %esp,%ebp
+8010505e:	83 ec 18             	sub    $0x18,%esp
+  int intena;
+  struct proc *p = myproc();
+80105061:	e8 43 f5 ff ff       	call   801045a9 <myproc>
+80105066:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+  if(!holding(&ptable.lock))
+80105069:	83 ec 0c             	sub    $0xc,%esp
+8010506c:	68 c0 4d 11 80       	push   $0x80114dc0
+80105071:	e8 4d 08 00 00       	call   801058c3 <holding>
+80105076:	83 c4 10             	add    $0x10,%esp
+80105079:	85 c0                	test   %eax,%eax
+8010507b:	75 0d                	jne    8010508a <sched+0x33>
+    panic("sched ptable.lock");
+8010507d:	83 ec 0c             	sub    $0xc,%esp
+80105080:	68 67 91 10 80       	push   $0x80109167
+80105085:	e8 47 b5 ff ff       	call   801005d1 <panic>
+  if(mycpu()->ncli != 1)
+8010508a:	e8 9e f4 ff ff       	call   8010452d <mycpu>
+8010508f:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
+80105095:	83 f8 01             	cmp    $0x1,%eax
+80105098:	74 0d                	je     801050a7 <sched+0x50>
+    panic("sched locks");
+8010509a:	83 ec 0c             	sub    $0xc,%esp
+8010509d:	68 79 91 10 80       	push   $0x80109179
+801050a2:	e8 2a b5 ff ff       	call   801005d1 <panic>
+  if(p->state == RUNNING)
+801050a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801050aa:	8b 40 20             	mov    0x20(%eax),%eax
+801050ad:	83 f8 04             	cmp    $0x4,%eax
+801050b0:	75 0d                	jne    801050bf <sched+0x68>
+    panic("sched running");
+801050b2:	83 ec 0c             	sub    $0xc,%esp
+801050b5:	68 85 91 10 80       	push   $0x80109185
+801050ba:	e8 12 b5 ff ff       	call   801005d1 <panic>
+  if(readeflags()&FL_IF)
+801050bf:	e8 98 f2 ff ff       	call   8010435c <readeflags>
+801050c4:	25 00 02 00 00       	and    $0x200,%eax
+801050c9:	85 c0                	test   %eax,%eax
+801050cb:	74 0d                	je     801050da <sched+0x83>
+    panic("sched interruptible");
+801050cd:	83 ec 0c             	sub    $0xc,%esp
+801050d0:	68 93 91 10 80       	push   $0x80109193
+801050d5:	e8 f7 b4 ff ff       	call   801005d1 <panic>
+  intena = mycpu()->intena;
+801050da:	e8 4e f4 ff ff       	call   8010452d <mycpu>
+801050df:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
+801050e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  swtch(&p->context, mycpu()->scheduler);
+801050e8:	e8 40 f4 ff ff       	call   8010452d <mycpu>
+801050ed:	8b 40 04             	mov    0x4(%eax),%eax
+801050f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+801050f3:	83 c2 2c             	add    $0x2c,%edx
+801050f6:	83 ec 08             	sub    $0x8,%esp
+801050f9:	50                   	push   %eax
+801050fa:	52                   	push   %edx
+801050fb:	e8 af 0b 00 00       	call   80105caf <swtch>
+80105100:	83 c4 10             	add    $0x10,%esp
+  mycpu()->intena = intena;
+80105103:	e8 25 f4 ff ff       	call   8010452d <mycpu>
+80105108:	8b 55 f0             	mov    -0x10(%ebp),%edx
+8010510b:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
+}
+80105111:	90                   	nop
+80105112:	c9                   	leave  
+80105113:	c3                   	ret    
+
+80105114 <forkret>:
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+80105114:	f3 0f 1e fb          	endbr32 
+80105118:	55                   	push   %ebp
+80105119:	89 e5                	mov    %esp,%ebp
+8010511b:	83 ec 08             	sub    $0x8,%esp
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+8010511e:	83 ec 0c             	sub    $0xc,%esp
+80105121:	68 c0 4d 11 80       	push   $0x80114dc0
+80105126:	e8 c3 06 00 00       	call   801057ee <release>
+8010512b:	83 c4 10             	add    $0x10,%esp
+
+  if (first) {
+8010512e:	a1 04 c0 10 80       	mov    0x8010c004,%eax
+80105133:	85 c0                	test   %eax,%eax
+80105135:	74 24                	je     8010515b <forkret+0x47>
+    // Some initialization functions must be run in the context
+    // of a regular process (e.g., they call sleep), and thus cannot
+    // be run from main().
+    first = 0;
+80105137:	c7 05 04 c0 10 80 00 	movl   $0x0,0x8010c004
+8010513e:	00 00 00 
+    iinit(ROOTDEV);
+80105141:	83 ec 0c             	sub    $0xc,%esp
+80105144:	6a 01                	push   $0x1
+80105146:	e8 d1 c5 ff ff       	call   8010171c <iinit>
+8010514b:	83 c4 10             	add    $0x10,%esp
+    initlog(ROOTDEV);
+8010514e:	83 ec 0c             	sub    $0xc,%esp
+80105151:	6a 01                	push   $0x1
+80105153:	e8 e6 e2 ff ff       	call   8010343e <initlog>
+80105158:	83 c4 10             	add    $0x10,%esp
+  }
+
+  // Return to "caller", actually trapret (see allocproc).
+}
+8010515b:	90                   	nop
+8010515c:	c9                   	leave  
+8010515d:	c3                   	ret    
+
+8010515e <sleep>:
+
+// Atomically release lock and sleep on chan.
+// Reacquires lock when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+8010515e:	f3 0f 1e fb          	endbr32 
+80105162:	55                   	push   %ebp
+80105163:	89 e5                	mov    %esp,%ebp
+80105165:	83 ec 18             	sub    $0x18,%esp
+  struct proc *p = myproc();
+80105168:	e8 3c f4 ff ff       	call   801045a9 <myproc>
+8010516d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  
+  if(p == 0)
+80105170:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105174:	75 0d                	jne    80105183 <sleep+0x25>
+    panic("sleep");
+80105176:	83 ec 0c             	sub    $0xc,%esp
+80105179:	68 a7 91 10 80       	push   $0x801091a7
+8010517e:	e8 4e b4 ff ff       	call   801005d1 <panic>
+
+  if(lk == 0)
+80105183:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+80105187:	75 0d                	jne    80105196 <sleep+0x38>
+    panic("sleep without lk");
+80105189:	83 ec 0c             	sub    $0xc,%esp
+8010518c:	68 ad 91 10 80       	push   $0x801091ad
+80105191:	e8 3b b4 ff ff       	call   801005d1 <panic>
+  // change p->state and then call sched.
+  // Once we hold ptable.lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup runs with ptable.lock locked),
+  // so it's okay to release lk.
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+80105196:	81 7d 0c c0 4d 11 80 	cmpl   $0x80114dc0,0xc(%ebp)
+8010519d:	74 1e                	je     801051bd <sleep+0x5f>
+    acquire(&ptable.lock);  //DOC: sleeplock1
+8010519f:	83 ec 0c             	sub    $0xc,%esp
+801051a2:	68 c0 4d 11 80       	push   $0x80114dc0
+801051a7:	e8 d0 05 00 00       	call   8010577c <acquire>
+801051ac:	83 c4 10             	add    $0x10,%esp
+    release(lk);
+801051af:	83 ec 0c             	sub    $0xc,%esp
+801051b2:	ff 75 0c             	pushl  0xc(%ebp)
+801051b5:	e8 34 06 00 00       	call   801057ee <release>
+801051ba:	83 c4 10             	add    $0x10,%esp
+  }
+  // Go to sleep.
+  p->chan = chan;
+801051bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801051c0:	8b 55 08             	mov    0x8(%ebp),%edx
+801051c3:	89 50 30             	mov    %edx,0x30(%eax)
+  p->state = SLEEPING;
+801051c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801051c9:	c7 40 20 02 00 00 00 	movl   $0x2,0x20(%eax)
+
+  sched();
+801051d0:	e8 82 fe ff ff       	call   80105057 <sched>
+
+  // Tidy up.
+  p->chan = 0;
+801051d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801051d8:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
+
+  // Reacquire original lock.
+  if(lk != &ptable.lock){  //DOC: sleeplock2
+801051df:	81 7d 0c c0 4d 11 80 	cmpl   $0x80114dc0,0xc(%ebp)
+801051e6:	74 1e                	je     80105206 <sleep+0xa8>
+    release(&ptable.lock);
+801051e8:	83 ec 0c             	sub    $0xc,%esp
+801051eb:	68 c0 4d 11 80       	push   $0x80114dc0
+801051f0:	e8 f9 05 00 00       	call   801057ee <release>
+801051f5:	83 c4 10             	add    $0x10,%esp
+    acquire(lk);
+801051f8:	83 ec 0c             	sub    $0xc,%esp
+801051fb:	ff 75 0c             	pushl  0xc(%ebp)
+801051fe:	e8 79 05 00 00       	call   8010577c <acquire>
+80105203:	83 c4 10             	add    $0x10,%esp
+  }
+}
+80105206:	90                   	nop
+80105207:	c9                   	leave  
+80105208:	c3                   	ret    
+
+80105209 <wakeup1>:
+//PAGEBREAK!
+// Wake up all processes sleeping on chan.
+// The ptable lock must be held.
+static void
+wakeup1(void *chan)
+{
+80105209:	f3 0f 1e fb          	endbr32 
+8010520d:	55                   	push   %ebp
+8010520e:	89 e5                	mov    %esp,%ebp
+80105210:	83 ec 10             	sub    $0x10,%esp
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+80105213:	c7 45 fc f4 4d 11 80 	movl   $0x80114df4,-0x4(%ebp)
+8010521a:	eb 27                	jmp    80105243 <wakeup1+0x3a>
+    if(p->state == SLEEPING && p->chan == chan)
+8010521c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010521f:	8b 40 20             	mov    0x20(%eax),%eax
+80105222:	83 f8 02             	cmp    $0x2,%eax
+80105225:	75 15                	jne    8010523c <wakeup1+0x33>
+80105227:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010522a:	8b 40 30             	mov    0x30(%eax),%eax
+8010522d:	39 45 08             	cmp    %eax,0x8(%ebp)
+80105230:	75 0a                	jne    8010523c <wakeup1+0x33>
+      p->state = RUNNABLE;
+80105232:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105235:	c7 40 20 03 00 00 00 	movl   $0x3,0x20(%eax)
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+8010523c:	81 45 fc 9c 00 00 00 	addl   $0x9c,-0x4(%ebp)
+80105243:	81 7d fc f4 74 11 80 	cmpl   $0x801174f4,-0x4(%ebp)
+8010524a:	72 d0                	jb     8010521c <wakeup1+0x13>
+}
+8010524c:	90                   	nop
+8010524d:	90                   	nop
+8010524e:	c9                   	leave  
+8010524f:	c3                   	ret    
+
+80105250 <wakeup>:
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+80105250:	f3 0f 1e fb          	endbr32 
+80105254:	55                   	push   %ebp
+80105255:	89 e5                	mov    %esp,%ebp
+80105257:	83 ec 08             	sub    $0x8,%esp
+  acquire(&ptable.lock);
+8010525a:	83 ec 0c             	sub    $0xc,%esp
+8010525d:	68 c0 4d 11 80       	push   $0x80114dc0
+80105262:	e8 15 05 00 00       	call   8010577c <acquire>
+80105267:	83 c4 10             	add    $0x10,%esp
+  wakeup1(chan);
+8010526a:	83 ec 0c             	sub    $0xc,%esp
+8010526d:	ff 75 08             	pushl  0x8(%ebp)
+80105270:	e8 94 ff ff ff       	call   80105209 <wakeup1>
+80105275:	83 c4 10             	add    $0x10,%esp
+  release(&ptable.lock);
+80105278:	83 ec 0c             	sub    $0xc,%esp
+8010527b:	68 c0 4d 11 80       	push   $0x80114dc0
+80105280:	e8 69 05 00 00       	call   801057ee <release>
+80105285:	83 c4 10             	add    $0x10,%esp
+}
+80105288:	90                   	nop
+80105289:	c9                   	leave  
+8010528a:	c3                   	ret    
+
+8010528b <kill>:
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+8010528b:	f3 0f 1e fb          	endbr32 
+8010528f:	55                   	push   %ebp
+80105290:	89 e5                	mov    %esp,%ebp
+80105292:	83 ec 18             	sub    $0x18,%esp
+  struct proc *p;
+
+  acquire(&ptable.lock);
+80105295:	83 ec 0c             	sub    $0xc,%esp
+80105298:	68 c0 4d 11 80       	push   $0x80114dc0
+8010529d:	e8 da 04 00 00       	call   8010577c <acquire>
+801052a2:	83 c4 10             	add    $0x10,%esp
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+801052a5:	c7 45 f4 f4 4d 11 80 	movl   $0x80114df4,-0xc(%ebp)
+801052ac:	eb 48                	jmp    801052f6 <kill+0x6b>
+    if(p->pid == pid){
+801052ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801052b1:	8b 40 10             	mov    0x10(%eax),%eax
+801052b4:	39 45 08             	cmp    %eax,0x8(%ebp)
+801052b7:	75 36                	jne    801052ef <kill+0x64>
+      p->killed = 1;
+801052b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801052bc:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+801052c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801052c6:	8b 40 20             	mov    0x20(%eax),%eax
+801052c9:	83 f8 02             	cmp    $0x2,%eax
+801052cc:	75 0a                	jne    801052d8 <kill+0x4d>
+        p->state = RUNNABLE;
+801052ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801052d1:	c7 40 20 03 00 00 00 	movl   $0x3,0x20(%eax)
+      release(&ptable.lock);
+801052d8:	83 ec 0c             	sub    $0xc,%esp
+801052db:	68 c0 4d 11 80       	push   $0x80114dc0
+801052e0:	e8 09 05 00 00       	call   801057ee <release>
+801052e5:	83 c4 10             	add    $0x10,%esp
+      return 0;
+801052e8:	b8 00 00 00 00       	mov    $0x0,%eax
+801052ed:	eb 25                	jmp    80105314 <kill+0x89>
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+801052ef:	81 45 f4 9c 00 00 00 	addl   $0x9c,-0xc(%ebp)
+801052f6:	81 7d f4 f4 74 11 80 	cmpl   $0x801174f4,-0xc(%ebp)
+801052fd:	72 af                	jb     801052ae <kill+0x23>
+    }
+  }
+  release(&ptable.lock);
+801052ff:	83 ec 0c             	sub    $0xc,%esp
+80105302:	68 c0 4d 11 80       	push   $0x80114dc0
+80105307:	e8 e2 04 00 00       	call   801057ee <release>
+8010530c:	83 c4 10             	add    $0x10,%esp
+  return -1;
+8010530f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105314:	c9                   	leave  
+80105315:	c3                   	ret    
+
+80105316 <procdump>:
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+80105316:	f3 0f 1e fb          	endbr32 
+8010531a:	55                   	push   %ebp
+8010531b:	89 e5                	mov    %esp,%ebp
+8010531d:	83 ec 48             	sub    $0x48,%esp
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80105320:	c7 45 f0 f4 4d 11 80 	movl   $0x80114df4,-0x10(%ebp)
+80105327:	e9 d7 00 00 00       	jmp    80105403 <procdump+0xed>
+    if(p->state == UNUSED)
+8010532c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010532f:	8b 40 20             	mov    0x20(%eax),%eax
+80105332:	85 c0                	test   %eax,%eax
+80105334:	0f 84 c1 00 00 00    	je     801053fb <procdump+0xe5>
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+8010533a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010533d:	8b 40 20             	mov    0x20(%eax),%eax
+80105340:	83 f8 05             	cmp    $0x5,%eax
+80105343:	77 23                	ja     80105368 <procdump+0x52>
+80105345:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105348:	8b 40 20             	mov    0x20(%eax),%eax
+8010534b:	8b 04 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%eax
+80105352:	85 c0                	test   %eax,%eax
+80105354:	74 12                	je     80105368 <procdump+0x52>
+      state = states[p->state];
+80105356:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105359:	8b 40 20             	mov    0x20(%eax),%eax
+8010535c:	8b 04 85 08 c0 10 80 	mov    -0x7fef3ff8(,%eax,4),%eax
+80105363:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80105366:	eb 07                	jmp    8010536f <procdump+0x59>
+    else
+      state = "???";
+80105368:	c7 45 ec be 91 10 80 	movl   $0x801091be,-0x14(%ebp)
+    cprintf("%d %s %s", p->pid, state, p->name);
+8010536f:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80105372:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105375:	8b 40 10             	mov    0x10(%eax),%eax
+80105378:	52                   	push   %edx
+80105379:	ff 75 ec             	pushl  -0x14(%ebp)
+8010537c:	50                   	push   %eax
+8010537d:	68 c2 91 10 80       	push   $0x801091c2
+80105382:	e8 91 b0 ff ff       	call   80100418 <cprintf>
+80105387:	83 c4 10             	add    $0x10,%esp
+    if(p->state == SLEEPING){
+8010538a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010538d:	8b 40 20             	mov    0x20(%eax),%eax
+80105390:	83 f8 02             	cmp    $0x2,%eax
+80105393:	75 54                	jne    801053e9 <procdump+0xd3>
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+80105395:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105398:	8b 40 2c             	mov    0x2c(%eax),%eax
+8010539b:	8b 40 0c             	mov    0xc(%eax),%eax
+8010539e:	83 c0 08             	add    $0x8,%eax
+801053a1:	89 c2                	mov    %eax,%edx
+801053a3:	83 ec 08             	sub    $0x8,%esp
+801053a6:	8d 45 c4             	lea    -0x3c(%ebp),%eax
+801053a9:	50                   	push   %eax
+801053aa:	52                   	push   %edx
+801053ab:	e8 94 04 00 00       	call   80105844 <getcallerpcs>
+801053b0:	83 c4 10             	add    $0x10,%esp
+      for(i=0; i<10 && pc[i] != 0; i++)
+801053b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+801053ba:	eb 1c                	jmp    801053d8 <procdump+0xc2>
+        cprintf(" %p", pc[i]);
+801053bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801053bf:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
+801053c3:	83 ec 08             	sub    $0x8,%esp
+801053c6:	50                   	push   %eax
+801053c7:	68 cb 91 10 80       	push   $0x801091cb
+801053cc:	e8 47 b0 ff ff       	call   80100418 <cprintf>
+801053d1:	83 c4 10             	add    $0x10,%esp
+      for(i=0; i<10 && pc[i] != 0; i++)
+801053d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+801053d8:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+801053dc:	7f 0b                	jg     801053e9 <procdump+0xd3>
+801053de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801053e1:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
+801053e5:	85 c0                	test   %eax,%eax
+801053e7:	75 d3                	jne    801053bc <procdump+0xa6>
+    }
+    cprintf("\n");
+801053e9:	83 ec 0c             	sub    $0xc,%esp
+801053ec:	68 cf 91 10 80       	push   $0x801091cf
+801053f1:	e8 22 b0 ff ff       	call   80100418 <cprintf>
+801053f6:	83 c4 10             	add    $0x10,%esp
+801053f9:	eb 01                	jmp    801053fc <procdump+0xe6>
+      continue;
+801053fb:	90                   	nop
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+801053fc:	81 45 f0 9c 00 00 00 	addl   $0x9c,-0x10(%ebp)
+80105403:	81 7d f0 f4 74 11 80 	cmpl   $0x801174f4,-0x10(%ebp)
+8010540a:	0f 82 1c ff ff ff    	jb     8010532c <procdump+0x16>
+  }
+}
+80105410:	90                   	nop
+80105411:	90                   	nop
+80105412:	c9                   	leave  
+80105413:	c3                   	ret    
+
+80105414 <updatestatistics>:
+
+
+void updatestatistics(void) {
+80105414:	f3 0f 1e fb          	endbr32 
+80105418:	55                   	push   %ebp
+80105419:	89 e5                	mov    %esp,%ebp
+8010541b:	83 ec 18             	sub    $0x18,%esp
+  struct proc *p;
+  acquire(&ptable.lock);
+8010541e:	83 ec 0c             	sub    $0xc,%esp
+80105421:	68 c0 4d 11 80       	push   $0x80114dc0
+80105426:	e8 51 03 00 00       	call   8010577c <acquire>
+8010542b:	83 c4 10             	add    $0x10,%esp
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+8010542e:	c7 45 f4 f4 4d 11 80 	movl   $0x80114df4,-0xc(%ebp)
+80105435:	eb 67                	jmp    8010549e <updatestatistics+0x8a>
+    switch(p->state) {
+80105437:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010543a:	8b 40 20             	mov    0x20(%eax),%eax
+8010543d:	83 f8 04             	cmp    $0x4,%eax
+80105440:	74 3f                	je     80105481 <updatestatistics+0x6d>
+80105442:	83 f8 04             	cmp    $0x4,%eax
+80105445:	77 50                	ja     80105497 <updatestatistics+0x83>
+80105447:	83 f8 02             	cmp    $0x2,%eax
+8010544a:	74 07                	je     80105453 <updatestatistics+0x3f>
+8010544c:	83 f8 03             	cmp    $0x3,%eax
+8010544f:	74 19                	je     8010546a <updatestatistics+0x56>
+80105451:	eb 44                	jmp    80105497 <updatestatistics+0x83>
+      case SLEEPING:
+        p->stime++;
+80105453:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105456:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
+8010545c:	8d 50 01             	lea    0x1(%eax),%edx
+8010545f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105462:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
+        break;
+80105468:	eb 2d                	jmp    80105497 <updatestatistics+0x83>
+      case RUNNABLE:
+        p->retime++;
+8010546a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010546d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
+80105473:	8d 50 01             	lea    0x1(%eax),%edx
+80105476:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105479:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
+        break;
+8010547f:	eb 16                	jmp    80105497 <updatestatistics+0x83>
+      case RUNNING:
+        p->rutime++;
+80105481:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105484:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
+8010548a:	8d 50 01             	lea    0x1(%eax),%edx
+8010548d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105490:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
+        break;
+80105496:	90                   	nop
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+80105497:	81 45 f4 9c 00 00 00 	addl   $0x9c,-0xc(%ebp)
+8010549e:	81 7d f4 f4 74 11 80 	cmpl   $0x801174f4,-0xc(%ebp)
+801054a5:	72 90                	jb     80105437 <updatestatistics+0x23>
+      default:
+        ;
+    }
+  }
+  release(&ptable.lock);
+801054a7:	83 ec 0c             	sub    $0xc,%esp
+801054aa:	68 c0 4d 11 80       	push   $0x80114dc0
+801054af:	e8 3a 03 00 00       	call   801057ee <release>
+801054b4:	83 c4 10             	add    $0x10,%esp
+}
+801054b7:	90                   	nop
+801054b8:	c9                   	leave  
+801054b9:	c3                   	ret    
+
+801054ba <set_prio>:
+
+
+int set_prio(int priority) {
+801054ba:	f3 0f 1e fb          	endbr32 
+801054be:	55                   	push   %ebp
+801054bf:	89 e5                	mov    %esp,%ebp
+801054c1:	83 ec 08             	sub    $0x8,%esp
+  if (priority < 1 || priority > 3)
+801054c4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+801054c8:	7e 06                	jle    801054d0 <set_prio+0x16>
+801054ca:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
+801054ce:	7e 07                	jle    801054d7 <set_prio+0x1d>
+    return -1;
+801054d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801054d5:	eb 33                	jmp    8010550a <set_prio+0x50>
+  acquire(&ptable.lock);
+801054d7:	83 ec 0c             	sub    $0xc,%esp
+801054da:	68 c0 4d 11 80       	push   $0x80114dc0
+801054df:	e8 98 02 00 00       	call   8010577c <acquire>
+801054e4:	83 c4 10             	add    $0x10,%esp
+  myproc()->priority = priority;
+801054e7:	e8 bd f0 ff ff       	call   801045a9 <myproc>
+801054ec:	8b 55 08             	mov    0x8(%ebp),%edx
+801054ef:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
+  release(&ptable.lock);
+801054f5:	83 ec 0c             	sub    $0xc,%esp
+801054f8:	68 c0 4d 11 80       	push   $0x80114dc0
+801054fd:	e8 ec 02 00 00       	call   801057ee <release>
+80105502:	83 c4 10             	add    $0x10,%esp
+  return 0;
+80105505:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+8010550a:	c9                   	leave  
+8010550b:	c3                   	ret    
+
+8010550c <sys_set_prio>:
+
+int sys_set_prio(void) {
+8010550c:	f3 0f 1e fb          	endbr32 
+80105510:	55                   	push   %ebp
+80105511:	89 e5                	mov    %esp,%ebp
+80105513:	83 ec 18             	sub    $0x18,%esp
+  int priority;
+  argint(0, &priority);
+80105516:	83 ec 08             	sub    $0x8,%esp
+80105519:	8d 45 f4             	lea    -0xc(%ebp),%eax
+8010551c:	50                   	push   %eax
+8010551d:	6a 00                	push   $0x0
+8010551f:	e8 4f 08 00 00       	call   80105d73 <argint>
+80105524:	83 c4 10             	add    $0x10,%esp
+  return set_prio(priority);
+80105527:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010552a:	83 ec 0c             	sub    $0xc,%esp
+8010552d:	50                   	push   %eax
+8010552e:	e8 87 ff ff ff       	call   801054ba <set_prio>
+80105533:	83 c4 10             	add    $0x10,%esp
+}
+80105536:	c9                   	leave  
+80105537:	c3                   	ret    
+
+80105538 <decpriority>:
+
+void decpriority(void) {
+80105538:	f3 0f 1e fb          	endbr32 
+8010553c:	55                   	push   %ebp
+8010553d:	89 e5                	mov    %esp,%ebp
+8010553f:	83 ec 18             	sub    $0x18,%esp
+  // acquire(&ptable.lock);
+  struct proc* proc = myproc();
+80105542:	e8 62 f0 ff ff       	call   801045a9 <myproc>
+80105547:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  proc->priority = proc->priority == 1 ? 1 : proc->priority - 1;
+8010554a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010554d:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
+80105553:	83 f8 01             	cmp    $0x1,%eax
+80105556:	74 0e                	je     80105566 <decpriority+0x2e>
+80105558:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010555b:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
+80105561:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105564:	eb 05                	jmp    8010556b <decpriority+0x33>
+80105566:	ba 01 00 00 00       	mov    $0x1,%edx
+8010556b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010556e:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
+  // release(&ptable.lock);
+}
+80105574:	90                   	nop
+80105575:	c9                   	leave  
+80105576:	c3                   	ret    
+
+80105577 <inctickcounter>:
+
+int inctickcounter() {
+80105577:	f3 0f 1e fb          	endbr32 
+8010557b:	55                   	push   %ebp
+8010557c:	89 e5                	mov    %esp,%ebp
+8010557e:	83 ec 18             	sub    $0x18,%esp
+  int res;
+  acquire(&ptable.lock);
+80105581:	83 ec 0c             	sub    $0xc,%esp
+80105584:	68 c0 4d 11 80       	push   $0x80114dc0
+80105589:	e8 ee 01 00 00       	call   8010577c <acquire>
+8010558e:	83 c4 10             	add    $0x10,%esp
+  res = ++myproc()->tickcounter;
+80105591:	e8 13 f0 ff ff       	call   801045a9 <myproc>
+80105596:	8b 90 90 00 00 00    	mov    0x90(%eax),%edx
+8010559c:	83 c2 01             	add    $0x1,%edx
+8010559f:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
+801055a5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
+801055ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  release(&ptable.lock);
+801055ae:	83 ec 0c             	sub    $0xc,%esp
+801055b1:	68 c0 4d 11 80       	push   $0x80114dc0
+801055b6:	e8 33 02 00 00       	call   801057ee <release>
+801055bb:	83 c4 10             	add    $0x10,%esp
+  return res;
+801055be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+801055c1:	c9                   	leave  
+801055c2:	c3                   	ret    
+
+801055c3 <initsleeplock>:
+#include "spinlock.h"
+#include "sleeplock.h"
+
+void
+initsleeplock(struct sleeplock *lk, char *name)
+{
+801055c3:	f3 0f 1e fb          	endbr32 
+801055c7:	55                   	push   %ebp
+801055c8:	89 e5                	mov    %esp,%ebp
+801055ca:	83 ec 08             	sub    $0x8,%esp
+  initlock(&lk->lk, "sleep lock");
+801055cd:	8b 45 08             	mov    0x8(%ebp),%eax
+801055d0:	83 c0 04             	add    $0x4,%eax
+801055d3:	83 ec 08             	sub    $0x8,%esp
+801055d6:	68 fb 91 10 80       	push   $0x801091fb
+801055db:	50                   	push   %eax
+801055dc:	e8 75 01 00 00       	call   80105756 <initlock>
+801055e1:	83 c4 10             	add    $0x10,%esp
+  lk->name = name;
+801055e4:	8b 45 08             	mov    0x8(%ebp),%eax
+801055e7:	8b 55 0c             	mov    0xc(%ebp),%edx
+801055ea:	89 50 38             	mov    %edx,0x38(%eax)
+  lk->locked = 0;
+801055ed:	8b 45 08             	mov    0x8(%ebp),%eax
+801055f0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  lk->pid = 0;
+801055f6:	8b 45 08             	mov    0x8(%ebp),%eax
+801055f9:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
+}
+80105600:	90                   	nop
+80105601:	c9                   	leave  
+80105602:	c3                   	ret    
+
+80105603 <acquiresleep>:
+
+void
+acquiresleep(struct sleeplock *lk)
+{
+80105603:	f3 0f 1e fb          	endbr32 
+80105607:	55                   	push   %ebp
+80105608:	89 e5                	mov    %esp,%ebp
+8010560a:	83 ec 08             	sub    $0x8,%esp
+  acquire(&lk->lk);
+8010560d:	8b 45 08             	mov    0x8(%ebp),%eax
+80105610:	83 c0 04             	add    $0x4,%eax
+80105613:	83 ec 0c             	sub    $0xc,%esp
+80105616:	50                   	push   %eax
+80105617:	e8 60 01 00 00       	call   8010577c <acquire>
+8010561c:	83 c4 10             	add    $0x10,%esp
+  while (lk->locked) {
+8010561f:	eb 15                	jmp    80105636 <acquiresleep+0x33>
+    sleep(lk, &lk->lk);
+80105621:	8b 45 08             	mov    0x8(%ebp),%eax
+80105624:	83 c0 04             	add    $0x4,%eax
+80105627:	83 ec 08             	sub    $0x8,%esp
+8010562a:	50                   	push   %eax
+8010562b:	ff 75 08             	pushl  0x8(%ebp)
+8010562e:	e8 2b fb ff ff       	call   8010515e <sleep>
+80105633:	83 c4 10             	add    $0x10,%esp
+  while (lk->locked) {
+80105636:	8b 45 08             	mov    0x8(%ebp),%eax
+80105639:	8b 00                	mov    (%eax),%eax
+8010563b:	85 c0                	test   %eax,%eax
+8010563d:	75 e2                	jne    80105621 <acquiresleep+0x1e>
+  }
+  lk->locked = 1;
+8010563f:	8b 45 08             	mov    0x8(%ebp),%eax
+80105642:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  lk->pid = myproc()->pid;
+80105648:	e8 5c ef ff ff       	call   801045a9 <myproc>
+8010564d:	8b 50 10             	mov    0x10(%eax),%edx
+80105650:	8b 45 08             	mov    0x8(%ebp),%eax
+80105653:	89 50 3c             	mov    %edx,0x3c(%eax)
+  release(&lk->lk);
+80105656:	8b 45 08             	mov    0x8(%ebp),%eax
+80105659:	83 c0 04             	add    $0x4,%eax
+8010565c:	83 ec 0c             	sub    $0xc,%esp
+8010565f:	50                   	push   %eax
+80105660:	e8 89 01 00 00       	call   801057ee <release>
+80105665:	83 c4 10             	add    $0x10,%esp
+}
+80105668:	90                   	nop
+80105669:	c9                   	leave  
+8010566a:	c3                   	ret    
+
+8010566b <releasesleep>:
+
+void
+releasesleep(struct sleeplock *lk)
+{
+8010566b:	f3 0f 1e fb          	endbr32 
+8010566f:	55                   	push   %ebp
+80105670:	89 e5                	mov    %esp,%ebp
+80105672:	83 ec 08             	sub    $0x8,%esp
+  acquire(&lk->lk);
+80105675:	8b 45 08             	mov    0x8(%ebp),%eax
+80105678:	83 c0 04             	add    $0x4,%eax
+8010567b:	83 ec 0c             	sub    $0xc,%esp
+8010567e:	50                   	push   %eax
+8010567f:	e8 f8 00 00 00       	call   8010577c <acquire>
+80105684:	83 c4 10             	add    $0x10,%esp
+  lk->locked = 0;
+80105687:	8b 45 08             	mov    0x8(%ebp),%eax
+8010568a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  lk->pid = 0;
+80105690:	8b 45 08             	mov    0x8(%ebp),%eax
+80105693:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
+  wakeup(lk);
+8010569a:	83 ec 0c             	sub    $0xc,%esp
+8010569d:	ff 75 08             	pushl  0x8(%ebp)
+801056a0:	e8 ab fb ff ff       	call   80105250 <wakeup>
+801056a5:	83 c4 10             	add    $0x10,%esp
+  release(&lk->lk);
+801056a8:	8b 45 08             	mov    0x8(%ebp),%eax
+801056ab:	83 c0 04             	add    $0x4,%eax
+801056ae:	83 ec 0c             	sub    $0xc,%esp
+801056b1:	50                   	push   %eax
+801056b2:	e8 37 01 00 00       	call   801057ee <release>
+801056b7:	83 c4 10             	add    $0x10,%esp
+}
+801056ba:	90                   	nop
+801056bb:	c9                   	leave  
+801056bc:	c3                   	ret    
+
+801056bd <holdingsleep>:
+
+int
+holdingsleep(struct sleeplock *lk)
+{
+801056bd:	f3 0f 1e fb          	endbr32 
+801056c1:	55                   	push   %ebp
+801056c2:	89 e5                	mov    %esp,%ebp
+801056c4:	53                   	push   %ebx
+801056c5:	83 ec 14             	sub    $0x14,%esp
+  int r;
+  
+  acquire(&lk->lk);
+801056c8:	8b 45 08             	mov    0x8(%ebp),%eax
+801056cb:	83 c0 04             	add    $0x4,%eax
+801056ce:	83 ec 0c             	sub    $0xc,%esp
+801056d1:	50                   	push   %eax
+801056d2:	e8 a5 00 00 00       	call   8010577c <acquire>
+801056d7:	83 c4 10             	add    $0x10,%esp
+  r = lk->locked && (lk->pid == myproc()->pid);
+801056da:	8b 45 08             	mov    0x8(%ebp),%eax
+801056dd:	8b 00                	mov    (%eax),%eax
+801056df:	85 c0                	test   %eax,%eax
+801056e1:	74 19                	je     801056fc <holdingsleep+0x3f>
+801056e3:	8b 45 08             	mov    0x8(%ebp),%eax
+801056e6:	8b 58 3c             	mov    0x3c(%eax),%ebx
+801056e9:	e8 bb ee ff ff       	call   801045a9 <myproc>
+801056ee:	8b 40 10             	mov    0x10(%eax),%eax
+801056f1:	39 c3                	cmp    %eax,%ebx
+801056f3:	75 07                	jne    801056fc <holdingsleep+0x3f>
+801056f5:	b8 01 00 00 00       	mov    $0x1,%eax
+801056fa:	eb 05                	jmp    80105701 <holdingsleep+0x44>
+801056fc:	b8 00 00 00 00       	mov    $0x0,%eax
+80105701:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  release(&lk->lk);
+80105704:	8b 45 08             	mov    0x8(%ebp),%eax
+80105707:	83 c0 04             	add    $0x4,%eax
+8010570a:	83 ec 0c             	sub    $0xc,%esp
+8010570d:	50                   	push   %eax
+8010570e:	e8 db 00 00 00       	call   801057ee <release>
+80105713:	83 c4 10             	add    $0x10,%esp
+  return r;
+80105716:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80105719:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+8010571c:	c9                   	leave  
+8010571d:	c3                   	ret    
+
+8010571e <readeflags>:
+{
+8010571e:	55                   	push   %ebp
+8010571f:	89 e5                	mov    %esp,%ebp
+80105721:	83 ec 10             	sub    $0x10,%esp
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+80105724:	9c                   	pushf  
+80105725:	58                   	pop    %eax
+80105726:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  return eflags;
+80105729:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+8010572c:	c9                   	leave  
+8010572d:	c3                   	ret    
+
+8010572e <cli>:
+{
+8010572e:	55                   	push   %ebp
+8010572f:	89 e5                	mov    %esp,%ebp
+  asm volatile("cli");
+80105731:	fa                   	cli    
+}
+80105732:	90                   	nop
+80105733:	5d                   	pop    %ebp
+80105734:	c3                   	ret    
+
+80105735 <sti>:
+{
+80105735:	55                   	push   %ebp
+80105736:	89 e5                	mov    %esp,%ebp
+  asm volatile("sti");
+80105738:	fb                   	sti    
+}
+80105739:	90                   	nop
+8010573a:	5d                   	pop    %ebp
+8010573b:	c3                   	ret    
+
+8010573c <xchg>:
+{
+8010573c:	55                   	push   %ebp
+8010573d:	89 e5                	mov    %esp,%ebp
+8010573f:	83 ec 10             	sub    $0x10,%esp
+  asm volatile("lock; xchgl %0, %1" :
+80105742:	8b 55 08             	mov    0x8(%ebp),%edx
+80105745:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105748:	8b 4d 08             	mov    0x8(%ebp),%ecx
+8010574b:	f0 87 02             	lock xchg %eax,(%edx)
+8010574e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  return result;
+80105751:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+80105754:	c9                   	leave  
+80105755:	c3                   	ret    
+
+80105756 <initlock>:
+#include "proc.h"
+#include "spinlock.h"
+
+void
+initlock(struct spinlock *lk, char *name)
+{
+80105756:	f3 0f 1e fb          	endbr32 
+8010575a:	55                   	push   %ebp
+8010575b:	89 e5                	mov    %esp,%ebp
+  lk->name = name;
+8010575d:	8b 45 08             	mov    0x8(%ebp),%eax
+80105760:	8b 55 0c             	mov    0xc(%ebp),%edx
+80105763:	89 50 04             	mov    %edx,0x4(%eax)
+  lk->locked = 0;
+80105766:	8b 45 08             	mov    0x8(%ebp),%eax
+80105769:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  lk->cpu = 0;
+8010576f:	8b 45 08             	mov    0x8(%ebp),%eax
+80105772:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+}
+80105779:	90                   	nop
+8010577a:	5d                   	pop    %ebp
+8010577b:	c3                   	ret    
+
+8010577c <acquire>:
+// Loops (spins) until the lock is acquired.
+// Holding a lock for a long time may cause
+// other CPUs to waste time spinning to acquire it.
+void
+acquire(struct spinlock *lk)
+{
+8010577c:	f3 0f 1e fb          	endbr32 
+80105780:	55                   	push   %ebp
+80105781:	89 e5                	mov    %esp,%ebp
+80105783:	53                   	push   %ebx
+80105784:	83 ec 04             	sub    $0x4,%esp
+  pushcli(); // disable interrupts to avoid deadlock.
+80105787:	e8 7c 01 00 00       	call   80105908 <pushcli>
+  if(holding(lk))
+8010578c:	8b 45 08             	mov    0x8(%ebp),%eax
+8010578f:	83 ec 0c             	sub    $0xc,%esp
+80105792:	50                   	push   %eax
+80105793:	e8 2b 01 00 00       	call   801058c3 <holding>
+80105798:	83 c4 10             	add    $0x10,%esp
+8010579b:	85 c0                	test   %eax,%eax
+8010579d:	74 0d                	je     801057ac <acquire+0x30>
+    panic("acquire");
+8010579f:	83 ec 0c             	sub    $0xc,%esp
+801057a2:	68 06 92 10 80       	push   $0x80109206
+801057a7:	e8 25 ae ff ff       	call   801005d1 <panic>
+
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+801057ac:	90                   	nop
+801057ad:	8b 45 08             	mov    0x8(%ebp),%eax
+801057b0:	83 ec 08             	sub    $0x8,%esp
+801057b3:	6a 01                	push   $0x1
+801057b5:	50                   	push   %eax
+801057b6:	e8 81 ff ff ff       	call   8010573c <xchg>
+801057bb:	83 c4 10             	add    $0x10,%esp
+801057be:	85 c0                	test   %eax,%eax
+801057c0:	75 eb                	jne    801057ad <acquire+0x31>
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+801057c2:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+
+  // Record info about lock acquisition for debugging.
+  lk->cpu = mycpu();
+801057c7:	8b 5d 08             	mov    0x8(%ebp),%ebx
+801057ca:	e8 5e ed ff ff       	call   8010452d <mycpu>
+801057cf:	89 43 08             	mov    %eax,0x8(%ebx)
+  getcallerpcs(&lk, lk->pcs);
+801057d2:	8b 45 08             	mov    0x8(%ebp),%eax
+801057d5:	83 c0 0c             	add    $0xc,%eax
+801057d8:	83 ec 08             	sub    $0x8,%esp
+801057db:	50                   	push   %eax
+801057dc:	8d 45 08             	lea    0x8(%ebp),%eax
+801057df:	50                   	push   %eax
+801057e0:	e8 5f 00 00 00       	call   80105844 <getcallerpcs>
+801057e5:	83 c4 10             	add    $0x10,%esp
+}
+801057e8:	90                   	nop
+801057e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+801057ec:	c9                   	leave  
+801057ed:	c3                   	ret    
+
+801057ee <release>:
+
+// Release the lock.
+void
+release(struct spinlock *lk)
+{
+801057ee:	f3 0f 1e fb          	endbr32 
+801057f2:	55                   	push   %ebp
+801057f3:	89 e5                	mov    %esp,%ebp
+801057f5:	83 ec 08             	sub    $0x8,%esp
+  if(!holding(lk))
+801057f8:	83 ec 0c             	sub    $0xc,%esp
+801057fb:	ff 75 08             	pushl  0x8(%ebp)
+801057fe:	e8 c0 00 00 00       	call   801058c3 <holding>
+80105803:	83 c4 10             	add    $0x10,%esp
+80105806:	85 c0                	test   %eax,%eax
+80105808:	75 0d                	jne    80105817 <release+0x29>
+    panic("release");
+8010580a:	83 ec 0c             	sub    $0xc,%esp
+8010580d:	68 0e 92 10 80       	push   $0x8010920e
+80105812:	e8 ba ad ff ff       	call   801005d1 <panic>
+
+  lk->pcs[0] = 0;
+80105817:	8b 45 08             	mov    0x8(%ebp),%eax
+8010581a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+  lk->cpu = 0;
+80105821:	8b 45 08             	mov    0x8(%ebp),%eax
+80105824:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that all the stores in the critical
+  // section are visible to other cores before the lock is released.
+  // Both the C compiler and the hardware may re-order loads and
+  // stores; __sync_synchronize() tells them both not to.
+  __sync_synchronize();
+8010582b:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+80105830:	8b 45 08             	mov    0x8(%ebp),%eax
+80105833:	8b 55 08             	mov    0x8(%ebp),%edx
+80105836:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+
+  popcli();
+8010583c:	e8 18 01 00 00       	call   80105959 <popcli>
+}
+80105841:	90                   	nop
+80105842:	c9                   	leave  
+80105843:	c3                   	ret    
+
+80105844 <getcallerpcs>:
+
+// Record the current call stack in pcs[] by following the %ebp chain.
+void
+getcallerpcs(void *v, uint pcs[])
+{
+80105844:	f3 0f 1e fb          	endbr32 
+80105848:	55                   	push   %ebp
+80105849:	89 e5                	mov    %esp,%ebp
+8010584b:	83 ec 10             	sub    $0x10,%esp
+  uint *ebp;
+  int i;
+
+  ebp = (uint*)v - 2;
+8010584e:	8b 45 08             	mov    0x8(%ebp),%eax
+80105851:	83 e8 08             	sub    $0x8,%eax
+80105854:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  for(i = 0; i < 10; i++){
+80105857:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+8010585e:	eb 38                	jmp    80105898 <getcallerpcs+0x54>
+    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+80105860:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+80105864:	74 53                	je     801058b9 <getcallerpcs+0x75>
+80105866:	81 7d fc ff ff ff 7f 	cmpl   $0x7fffffff,-0x4(%ebp)
+8010586d:	76 4a                	jbe    801058b9 <getcallerpcs+0x75>
+8010586f:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%ebp)
+80105873:	74 44                	je     801058b9 <getcallerpcs+0x75>
+      break;
+    pcs[i] = ebp[1];     // saved %eip
+80105875:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80105878:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+8010587f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105882:	01 c2                	add    %eax,%edx
+80105884:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105887:	8b 40 04             	mov    0x4(%eax),%eax
+8010588a:	89 02                	mov    %eax,(%edx)
+    ebp = (uint*)ebp[0]; // saved %ebp
+8010588c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+8010588f:	8b 00                	mov    (%eax),%eax
+80105891:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  for(i = 0; i < 10; i++){
+80105894:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+80105898:	83 7d f8 09          	cmpl   $0x9,-0x8(%ebp)
+8010589c:	7e c2                	jle    80105860 <getcallerpcs+0x1c>
+  }
+  for(; i < 10; i++)
+8010589e:	eb 19                	jmp    801058b9 <getcallerpcs+0x75>
+    pcs[i] = 0;
+801058a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+801058a3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+801058aa:	8b 45 0c             	mov    0xc(%ebp),%eax
+801058ad:	01 d0                	add    %edx,%eax
+801058af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  for(; i < 10; i++)
+801058b5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+801058b9:	83 7d f8 09          	cmpl   $0x9,-0x8(%ebp)
+801058bd:	7e e1                	jle    801058a0 <getcallerpcs+0x5c>
+}
+801058bf:	90                   	nop
+801058c0:	90                   	nop
+801058c1:	c9                   	leave  
+801058c2:	c3                   	ret    
+
+801058c3 <holding>:
+
+// Check whether this cpu is holding the lock.
+int
+holding(struct spinlock *lock)
+{
+801058c3:	f3 0f 1e fb          	endbr32 
+801058c7:	55                   	push   %ebp
+801058c8:	89 e5                	mov    %esp,%ebp
+801058ca:	53                   	push   %ebx
+801058cb:	83 ec 14             	sub    $0x14,%esp
+  int r;
+  pushcli();
+801058ce:	e8 35 00 00 00       	call   80105908 <pushcli>
+  r = lock->locked && lock->cpu == mycpu();
+801058d3:	8b 45 08             	mov    0x8(%ebp),%eax
+801058d6:	8b 00                	mov    (%eax),%eax
+801058d8:	85 c0                	test   %eax,%eax
+801058da:	74 16                	je     801058f2 <holding+0x2f>
+801058dc:	8b 45 08             	mov    0x8(%ebp),%eax
+801058df:	8b 58 08             	mov    0x8(%eax),%ebx
+801058e2:	e8 46 ec ff ff       	call   8010452d <mycpu>
+801058e7:	39 c3                	cmp    %eax,%ebx
+801058e9:	75 07                	jne    801058f2 <holding+0x2f>
+801058eb:	b8 01 00 00 00       	mov    $0x1,%eax
+801058f0:	eb 05                	jmp    801058f7 <holding+0x34>
+801058f2:	b8 00 00 00 00       	mov    $0x0,%eax
+801058f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  popcli();
+801058fa:	e8 5a 00 00 00       	call   80105959 <popcli>
+  return r;
+801058ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80105902:	83 c4 14             	add    $0x14,%esp
+80105905:	5b                   	pop    %ebx
+80105906:	5d                   	pop    %ebp
+80105907:	c3                   	ret    
+
+80105908 <pushcli>:
+// it takes two popcli to undo two pushcli.  Also, if interrupts
+// are off, then pushcli, popcli leaves them off.
+
+void
+pushcli(void)
+{
+80105908:	f3 0f 1e fb          	endbr32 
+8010590c:	55                   	push   %ebp
+8010590d:	89 e5                	mov    %esp,%ebp
+8010590f:	83 ec 18             	sub    $0x18,%esp
+  int eflags;
+
+  eflags = readeflags();
+80105912:	e8 07 fe ff ff       	call   8010571e <readeflags>
+80105917:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  cli();
+8010591a:	e8 0f fe ff ff       	call   8010572e <cli>
+  if(mycpu()->ncli == 0)
+8010591f:	e8 09 ec ff ff       	call   8010452d <mycpu>
+80105924:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
+8010592a:	85 c0                	test   %eax,%eax
+8010592c:	75 14                	jne    80105942 <pushcli+0x3a>
+    mycpu()->intena = eflags & FL_IF;
+8010592e:	e8 fa eb ff ff       	call   8010452d <mycpu>
+80105933:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80105936:	81 e2 00 02 00 00    	and    $0x200,%edx
+8010593c:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
+  mycpu()->ncli += 1;
+80105942:	e8 e6 eb ff ff       	call   8010452d <mycpu>
+80105947:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
+8010594d:	83 c2 01             	add    $0x1,%edx
+80105950:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
+}
+80105956:	90                   	nop
+80105957:	c9                   	leave  
+80105958:	c3                   	ret    
+
+80105959 <popcli>:
+
+void
+popcli(void)
+{
+80105959:	f3 0f 1e fb          	endbr32 
+8010595d:	55                   	push   %ebp
+8010595e:	89 e5                	mov    %esp,%ebp
+80105960:	83 ec 08             	sub    $0x8,%esp
+  if(readeflags()&FL_IF)
+80105963:	e8 b6 fd ff ff       	call   8010571e <readeflags>
+80105968:	25 00 02 00 00       	and    $0x200,%eax
+8010596d:	85 c0                	test   %eax,%eax
+8010596f:	74 0d                	je     8010597e <popcli+0x25>
+    panic("popcli - interruptible");
+80105971:	83 ec 0c             	sub    $0xc,%esp
+80105974:	68 16 92 10 80       	push   $0x80109216
+80105979:	e8 53 ac ff ff       	call   801005d1 <panic>
+  if(--mycpu()->ncli < 0)
+8010597e:	e8 aa eb ff ff       	call   8010452d <mycpu>
+80105983:	8b 90 a4 00 00 00    	mov    0xa4(%eax),%edx
+80105989:	83 ea 01             	sub    $0x1,%edx
+8010598c:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
+80105992:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
+80105998:	85 c0                	test   %eax,%eax
+8010599a:	79 0d                	jns    801059a9 <popcli+0x50>
+    panic("popcli");
+8010599c:	83 ec 0c             	sub    $0xc,%esp
+8010599f:	68 2d 92 10 80       	push   $0x8010922d
+801059a4:	e8 28 ac ff ff       	call   801005d1 <panic>
+  if(mycpu()->ncli == 0 && mycpu()->intena)
+801059a9:	e8 7f eb ff ff       	call   8010452d <mycpu>
+801059ae:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
+801059b4:	85 c0                	test   %eax,%eax
+801059b6:	75 14                	jne    801059cc <popcli+0x73>
+801059b8:	e8 70 eb ff ff       	call   8010452d <mycpu>
+801059bd:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
+801059c3:	85 c0                	test   %eax,%eax
+801059c5:	74 05                	je     801059cc <popcli+0x73>
+    sti();
+801059c7:	e8 69 fd ff ff       	call   80105735 <sti>
+}
+801059cc:	90                   	nop
+801059cd:	c9                   	leave  
+801059ce:	c3                   	ret    
+
+801059cf <stosb>:
+{
+801059cf:	55                   	push   %ebp
+801059d0:	89 e5                	mov    %esp,%ebp
+801059d2:	57                   	push   %edi
+801059d3:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+801059d4:	8b 4d 08             	mov    0x8(%ebp),%ecx
+801059d7:	8b 55 10             	mov    0x10(%ebp),%edx
+801059da:	8b 45 0c             	mov    0xc(%ebp),%eax
+801059dd:	89 cb                	mov    %ecx,%ebx
+801059df:	89 df                	mov    %ebx,%edi
+801059e1:	89 d1                	mov    %edx,%ecx
+801059e3:	fc                   	cld    
+801059e4:	f3 aa                	rep stos %al,%es:(%edi)
+801059e6:	89 ca                	mov    %ecx,%edx
+801059e8:	89 fb                	mov    %edi,%ebx
+801059ea:	89 5d 08             	mov    %ebx,0x8(%ebp)
+801059ed:	89 55 10             	mov    %edx,0x10(%ebp)
+}
+801059f0:	90                   	nop
+801059f1:	5b                   	pop    %ebx
+801059f2:	5f                   	pop    %edi
+801059f3:	5d                   	pop    %ebp
+801059f4:	c3                   	ret    
+
+801059f5 <stosl>:
+{
+801059f5:	55                   	push   %ebp
+801059f6:	89 e5                	mov    %esp,%ebp
+801059f8:	57                   	push   %edi
+801059f9:	53                   	push   %ebx
+  asm volatile("cld; rep stosl" :
+801059fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
+801059fd:	8b 55 10             	mov    0x10(%ebp),%edx
+80105a00:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105a03:	89 cb                	mov    %ecx,%ebx
+80105a05:	89 df                	mov    %ebx,%edi
+80105a07:	89 d1                	mov    %edx,%ecx
+80105a09:	fc                   	cld    
+80105a0a:	f3 ab                	rep stos %eax,%es:(%edi)
+80105a0c:	89 ca                	mov    %ecx,%edx
+80105a0e:	89 fb                	mov    %edi,%ebx
+80105a10:	89 5d 08             	mov    %ebx,0x8(%ebp)
+80105a13:	89 55 10             	mov    %edx,0x10(%ebp)
+}
+80105a16:	90                   	nop
+80105a17:	5b                   	pop    %ebx
+80105a18:	5f                   	pop    %edi
+80105a19:	5d                   	pop    %ebp
+80105a1a:	c3                   	ret    
+
+80105a1b <memset>:
+#include "types.h"
+#include "x86.h"
+
+void*
+memset(void *dst, int c, uint n)
+{
+80105a1b:	f3 0f 1e fb          	endbr32 
+80105a1f:	55                   	push   %ebp
+80105a20:	89 e5                	mov    %esp,%ebp
+  if ((int)dst%4 == 0 && n%4 == 0){
+80105a22:	8b 45 08             	mov    0x8(%ebp),%eax
+80105a25:	83 e0 03             	and    $0x3,%eax
+80105a28:	85 c0                	test   %eax,%eax
+80105a2a:	75 43                	jne    80105a6f <memset+0x54>
+80105a2c:	8b 45 10             	mov    0x10(%ebp),%eax
+80105a2f:	83 e0 03             	and    $0x3,%eax
+80105a32:	85 c0                	test   %eax,%eax
+80105a34:	75 39                	jne    80105a6f <memset+0x54>
+    c &= 0xFF;
+80105a36:	81 65 0c ff 00 00 00 	andl   $0xff,0xc(%ebp)
+    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+80105a3d:	8b 45 10             	mov    0x10(%ebp),%eax
+80105a40:	c1 e8 02             	shr    $0x2,%eax
+80105a43:	89 c1                	mov    %eax,%ecx
+80105a45:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105a48:	c1 e0 18             	shl    $0x18,%eax
+80105a4b:	89 c2                	mov    %eax,%edx
+80105a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105a50:	c1 e0 10             	shl    $0x10,%eax
+80105a53:	09 c2                	or     %eax,%edx
+80105a55:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105a58:	c1 e0 08             	shl    $0x8,%eax
+80105a5b:	09 d0                	or     %edx,%eax
+80105a5d:	0b 45 0c             	or     0xc(%ebp),%eax
+80105a60:	51                   	push   %ecx
+80105a61:	50                   	push   %eax
+80105a62:	ff 75 08             	pushl  0x8(%ebp)
+80105a65:	e8 8b ff ff ff       	call   801059f5 <stosl>
+80105a6a:	83 c4 0c             	add    $0xc,%esp
+80105a6d:	eb 12                	jmp    80105a81 <memset+0x66>
+  } else
+    stosb(dst, c, n);
+80105a6f:	8b 45 10             	mov    0x10(%ebp),%eax
+80105a72:	50                   	push   %eax
+80105a73:	ff 75 0c             	pushl  0xc(%ebp)
+80105a76:	ff 75 08             	pushl  0x8(%ebp)
+80105a79:	e8 51 ff ff ff       	call   801059cf <stosb>
+80105a7e:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+80105a81:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+80105a84:	c9                   	leave  
+80105a85:	c3                   	ret    
+
+80105a86 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, uint n)
+{
+80105a86:	f3 0f 1e fb          	endbr32 
+80105a8a:	55                   	push   %ebp
+80105a8b:	89 e5                	mov    %esp,%ebp
+80105a8d:	83 ec 10             	sub    $0x10,%esp
+  const uchar *s1, *s2;
+
+  s1 = v1;
+80105a90:	8b 45 08             	mov    0x8(%ebp),%eax
+80105a93:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  s2 = v2;
+80105a96:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105a99:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0){
+80105a9c:	eb 30                	jmp    80105ace <memcmp+0x48>
+    if(*s1 != *s2)
+80105a9e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105aa1:	0f b6 10             	movzbl (%eax),%edx
+80105aa4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80105aa7:	0f b6 00             	movzbl (%eax),%eax
+80105aaa:	38 c2                	cmp    %al,%dl
+80105aac:	74 18                	je     80105ac6 <memcmp+0x40>
+      return *s1 - *s2;
+80105aae:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105ab1:	0f b6 00             	movzbl (%eax),%eax
+80105ab4:	0f b6 d0             	movzbl %al,%edx
+80105ab7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80105aba:	0f b6 00             	movzbl (%eax),%eax
+80105abd:	0f b6 c0             	movzbl %al,%eax
+80105ac0:	29 c2                	sub    %eax,%edx
+80105ac2:	89 d0                	mov    %edx,%eax
+80105ac4:	eb 1a                	jmp    80105ae0 <memcmp+0x5a>
+    s1++, s2++;
+80105ac6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+80105aca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+  while(n-- > 0){
+80105ace:	8b 45 10             	mov    0x10(%ebp),%eax
+80105ad1:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105ad4:	89 55 10             	mov    %edx,0x10(%ebp)
+80105ad7:	85 c0                	test   %eax,%eax
+80105ad9:	75 c3                	jne    80105a9e <memcmp+0x18>
+  }
+
+  return 0;
+80105adb:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105ae0:	c9                   	leave  
+80105ae1:	c3                   	ret    
+
+80105ae2 <memmove>:
+
+void*
+memmove(void *dst, const void *src, uint n)
+{
+80105ae2:	f3 0f 1e fb          	endbr32 
+80105ae6:	55                   	push   %ebp
+80105ae7:	89 e5                	mov    %esp,%ebp
+80105ae9:	83 ec 10             	sub    $0x10,%esp
+  const char *s;
+  char *d;
+
+  s = src;
+80105aec:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105aef:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  d = dst;
+80105af2:	8b 45 08             	mov    0x8(%ebp),%eax
+80105af5:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  if(s < d && s + n > d){
+80105af8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105afb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+80105afe:	73 54                	jae    80105b54 <memmove+0x72>
+80105b00:	8b 55 fc             	mov    -0x4(%ebp),%edx
+80105b03:	8b 45 10             	mov    0x10(%ebp),%eax
+80105b06:	01 d0                	add    %edx,%eax
+80105b08:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+80105b0b:	73 47                	jae    80105b54 <memmove+0x72>
+    s += n;
+80105b0d:	8b 45 10             	mov    0x10(%ebp),%eax
+80105b10:	01 45 fc             	add    %eax,-0x4(%ebp)
+    d += n;
+80105b13:	8b 45 10             	mov    0x10(%ebp),%eax
+80105b16:	01 45 f8             	add    %eax,-0x8(%ebp)
+    while(n-- > 0)
+80105b19:	eb 13                	jmp    80105b2e <memmove+0x4c>
+      *--d = *--s;
+80105b1b:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
+80105b1f:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
+80105b23:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105b26:	0f b6 10             	movzbl (%eax),%edx
+80105b29:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80105b2c:	88 10                	mov    %dl,(%eax)
+    while(n-- > 0)
+80105b2e:	8b 45 10             	mov    0x10(%ebp),%eax
+80105b31:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105b34:	89 55 10             	mov    %edx,0x10(%ebp)
+80105b37:	85 c0                	test   %eax,%eax
+80105b39:	75 e0                	jne    80105b1b <memmove+0x39>
+  if(s < d && s + n > d){
+80105b3b:	eb 24                	jmp    80105b61 <memmove+0x7f>
+  } else
+    while(n-- > 0)
+      *d++ = *s++;
+80105b3d:	8b 55 fc             	mov    -0x4(%ebp),%edx
+80105b40:	8d 42 01             	lea    0x1(%edx),%eax
+80105b43:	89 45 fc             	mov    %eax,-0x4(%ebp)
+80105b46:	8b 45 f8             	mov    -0x8(%ebp),%eax
+80105b49:	8d 48 01             	lea    0x1(%eax),%ecx
+80105b4c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
+80105b4f:	0f b6 12             	movzbl (%edx),%edx
+80105b52:	88 10                	mov    %dl,(%eax)
+    while(n-- > 0)
+80105b54:	8b 45 10             	mov    0x10(%ebp),%eax
+80105b57:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105b5a:	89 55 10             	mov    %edx,0x10(%ebp)
+80105b5d:	85 c0                	test   %eax,%eax
+80105b5f:	75 dc                	jne    80105b3d <memmove+0x5b>
+
+  return dst;
+80105b61:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+80105b64:	c9                   	leave  
+80105b65:	c3                   	ret    
+
+80105b66 <memcpy>:
+
+// memcpy exists to placate GCC.  Use memmove.
+void*
+memcpy(void *dst, const void *src, uint n)
+{
+80105b66:	f3 0f 1e fb          	endbr32 
+80105b6a:	55                   	push   %ebp
+80105b6b:	89 e5                	mov    %esp,%ebp
+  return memmove(dst, src, n);
+80105b6d:	ff 75 10             	pushl  0x10(%ebp)
+80105b70:	ff 75 0c             	pushl  0xc(%ebp)
+80105b73:	ff 75 08             	pushl  0x8(%ebp)
+80105b76:	e8 67 ff ff ff       	call   80105ae2 <memmove>
+80105b7b:	83 c4 0c             	add    $0xc,%esp
+}
+80105b7e:	c9                   	leave  
+80105b7f:	c3                   	ret    
+
+80105b80 <strncmp>:
+
+int
+strncmp(const char *p, const char *q, uint n)
+{
+80105b80:	f3 0f 1e fb          	endbr32 
+80105b84:	55                   	push   %ebp
+80105b85:	89 e5                	mov    %esp,%ebp
+  while(n > 0 && *p && *p == *q)
+80105b87:	eb 0c                	jmp    80105b95 <strncmp+0x15>
+    n--, p++, q++;
+80105b89:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+80105b8d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+80105b91:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(n > 0 && *p && *p == *q)
+80105b95:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80105b99:	74 1a                	je     80105bb5 <strncmp+0x35>
+80105b9b:	8b 45 08             	mov    0x8(%ebp),%eax
+80105b9e:	0f b6 00             	movzbl (%eax),%eax
+80105ba1:	84 c0                	test   %al,%al
+80105ba3:	74 10                	je     80105bb5 <strncmp+0x35>
+80105ba5:	8b 45 08             	mov    0x8(%ebp),%eax
+80105ba8:	0f b6 10             	movzbl (%eax),%edx
+80105bab:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105bae:	0f b6 00             	movzbl (%eax),%eax
+80105bb1:	38 c2                	cmp    %al,%dl
+80105bb3:	74 d4                	je     80105b89 <strncmp+0x9>
+  if(n == 0)
+80105bb5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80105bb9:	75 07                	jne    80105bc2 <strncmp+0x42>
+    return 0;
+80105bbb:	b8 00 00 00 00       	mov    $0x0,%eax
+80105bc0:	eb 16                	jmp    80105bd8 <strncmp+0x58>
+  return (uchar)*p - (uchar)*q;
+80105bc2:	8b 45 08             	mov    0x8(%ebp),%eax
+80105bc5:	0f b6 00             	movzbl (%eax),%eax
+80105bc8:	0f b6 d0             	movzbl %al,%edx
+80105bcb:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105bce:	0f b6 00             	movzbl (%eax),%eax
+80105bd1:	0f b6 c0             	movzbl %al,%eax
+80105bd4:	29 c2                	sub    %eax,%edx
+80105bd6:	89 d0                	mov    %edx,%eax
+}
+80105bd8:	5d                   	pop    %ebp
+80105bd9:	c3                   	ret    
+
+80105bda <strncpy>:
+
+char*
+strncpy(char *s, const char *t, int n)
+{
+80105bda:	f3 0f 1e fb          	endbr32 
+80105bde:	55                   	push   %ebp
+80105bdf:	89 e5                	mov    %esp,%ebp
+80105be1:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+80105be4:	8b 45 08             	mov    0x8(%ebp),%eax
+80105be7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while(n-- > 0 && (*s++ = *t++) != 0)
+80105bea:	90                   	nop
+80105beb:	8b 45 10             	mov    0x10(%ebp),%eax
+80105bee:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105bf1:	89 55 10             	mov    %edx,0x10(%ebp)
+80105bf4:	85 c0                	test   %eax,%eax
+80105bf6:	7e 2c                	jle    80105c24 <strncpy+0x4a>
+80105bf8:	8b 55 0c             	mov    0xc(%ebp),%edx
+80105bfb:	8d 42 01             	lea    0x1(%edx),%eax
+80105bfe:	89 45 0c             	mov    %eax,0xc(%ebp)
+80105c01:	8b 45 08             	mov    0x8(%ebp),%eax
+80105c04:	8d 48 01             	lea    0x1(%eax),%ecx
+80105c07:	89 4d 08             	mov    %ecx,0x8(%ebp)
+80105c0a:	0f b6 12             	movzbl (%edx),%edx
+80105c0d:	88 10                	mov    %dl,(%eax)
+80105c0f:	0f b6 00             	movzbl (%eax),%eax
+80105c12:	84 c0                	test   %al,%al
+80105c14:	75 d5                	jne    80105beb <strncpy+0x11>
+    ;
+  while(n-- > 0)
+80105c16:	eb 0c                	jmp    80105c24 <strncpy+0x4a>
+    *s++ = 0;
+80105c18:	8b 45 08             	mov    0x8(%ebp),%eax
+80105c1b:	8d 50 01             	lea    0x1(%eax),%edx
+80105c1e:	89 55 08             	mov    %edx,0x8(%ebp)
+80105c21:	c6 00 00             	movb   $0x0,(%eax)
+  while(n-- > 0)
+80105c24:	8b 45 10             	mov    0x10(%ebp),%eax
+80105c27:	8d 50 ff             	lea    -0x1(%eax),%edx
+80105c2a:	89 55 10             	mov    %edx,0x10(%ebp)
+80105c2d:	85 c0                	test   %eax,%eax
+80105c2f:	7f e7                	jg     80105c18 <strncpy+0x3e>
+  return os;
+80105c31:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+80105c34:	c9                   	leave  
+80105c35:	c3                   	ret    
+
+80105c36 <safestrcpy>:
+
+// Like strncpy but guaranteed to NUL-terminate.
+char*
+safestrcpy(char *s, const char *t, int n)
+{
+80105c36:	f3 0f 1e fb          	endbr32 
+80105c3a:	55                   	push   %ebp
+80105c3b:	89 e5                	mov    %esp,%ebp
+80105c3d:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+80105c40:	8b 45 08             	mov    0x8(%ebp),%eax
+80105c43:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  if(n <= 0)
+80105c46:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80105c4a:	7f 05                	jg     80105c51 <safestrcpy+0x1b>
+    return os;
+80105c4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+80105c4f:	eb 31                	jmp    80105c82 <safestrcpy+0x4c>
+  while(--n > 0 && (*s++ = *t++) != 0)
+80105c51:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+80105c55:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80105c59:	7e 1e                	jle    80105c79 <safestrcpy+0x43>
+80105c5b:	8b 55 0c             	mov    0xc(%ebp),%edx
+80105c5e:	8d 42 01             	lea    0x1(%edx),%eax
+80105c61:	89 45 0c             	mov    %eax,0xc(%ebp)
+80105c64:	8b 45 08             	mov    0x8(%ebp),%eax
+80105c67:	8d 48 01             	lea    0x1(%eax),%ecx
+80105c6a:	89 4d 08             	mov    %ecx,0x8(%ebp)
+80105c6d:	0f b6 12             	movzbl (%edx),%edx
+80105c70:	88 10                	mov    %dl,(%eax)
+80105c72:	0f b6 00             	movzbl (%eax),%eax
+80105c75:	84 c0                	test   %al,%al
+80105c77:	75 d8                	jne    80105c51 <safestrcpy+0x1b>
+    ;
+  *s = 0;
+80105c79:	8b 45 08             	mov    0x8(%ebp),%eax
+80105c7c:	c6 00 00             	movb   $0x0,(%eax)
+  return os;
+80105c7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+80105c82:	c9                   	leave  
+80105c83:	c3                   	ret    
+
+80105c84 <strlen>:
+
+int
+strlen(const char *s)
+{
+80105c84:	f3 0f 1e fb          	endbr32 
+80105c88:	55                   	push   %ebp
+80105c89:	89 e5                	mov    %esp,%ebp
+80105c8b:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+80105c8e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+80105c95:	eb 04                	jmp    80105c9b <strlen+0x17>
+80105c97:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+80105c9b:	8b 55 fc             	mov    -0x4(%ebp),%edx
+80105c9e:	8b 45 08             	mov    0x8(%ebp),%eax
+80105ca1:	01 d0                	add    %edx,%eax
+80105ca3:	0f b6 00             	movzbl (%eax),%eax
+80105ca6:	84 c0                	test   %al,%al
+80105ca8:	75 ed                	jne    80105c97 <strlen+0x13>
+    ;
+  return n;
+80105caa:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+80105cad:	c9                   	leave  
+80105cae:	c3                   	ret    
+
+80105caf <swtch>:
+# a struct context, and save its address in *old.
+# Switch stacks to new and pop previously-saved registers.
+
+.globl swtch
+swtch:
+  movl 4(%esp), %eax
+80105caf:	8b 44 24 04          	mov    0x4(%esp),%eax
+  movl 8(%esp), %edx
+80105cb3:	8b 54 24 08          	mov    0x8(%esp),%edx
+
+  # Save old callee-saved registers
+  pushl %ebp
+80105cb7:	55                   	push   %ebp
+  pushl %ebx
+80105cb8:	53                   	push   %ebx
+  pushl %esi
+80105cb9:	56                   	push   %esi
+  pushl %edi
+80105cba:	57                   	push   %edi
+
+  # Switch stacks
+  movl %esp, (%eax)
+80105cbb:	89 20                	mov    %esp,(%eax)
+  movl %edx, %esp
+80105cbd:	89 d4                	mov    %edx,%esp
+
+  # Load new callee-saved registers
+  popl %edi
+80105cbf:	5f                   	pop    %edi
+  popl %esi
+80105cc0:	5e                   	pop    %esi
+  popl %ebx
+80105cc1:	5b                   	pop    %ebx
+  popl %ebp
+80105cc2:	5d                   	pop    %ebp
+  ret
+80105cc3:	c3                   	ret    
+
+80105cc4 <fetchint>:
+// to a saved program counter, and then the first argument.
+
+// Fetch the int at addr from the current process.
+int
+fetchint(uint addr, int *ip)
+{
+80105cc4:	f3 0f 1e fb          	endbr32 
+80105cc8:	55                   	push   %ebp
+80105cc9:	89 e5                	mov    %esp,%ebp
+80105ccb:	83 ec 18             	sub    $0x18,%esp
+  struct proc *curproc = myproc();
+80105cce:	e8 d6 e8 ff ff       	call   801045a9 <myproc>
+80105cd3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+  if(addr >= curproc->sz || addr+4 > curproc->sz)
+80105cd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105cd9:	8b 40 14             	mov    0x14(%eax),%eax
+80105cdc:	39 45 08             	cmp    %eax,0x8(%ebp)
+80105cdf:	73 10                	jae    80105cf1 <fetchint+0x2d>
+80105ce1:	8b 45 08             	mov    0x8(%ebp),%eax
+80105ce4:	8d 50 04             	lea    0x4(%eax),%edx
+80105ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105cea:	8b 40 14             	mov    0x14(%eax),%eax
+80105ced:	39 c2                	cmp    %eax,%edx
+80105cef:	76 07                	jbe    80105cf8 <fetchint+0x34>
+    return -1;
+80105cf1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105cf6:	eb 0f                	jmp    80105d07 <fetchint+0x43>
+  *ip = *(int*)(addr);
+80105cf8:	8b 45 08             	mov    0x8(%ebp),%eax
+80105cfb:	8b 10                	mov    (%eax),%edx
+80105cfd:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105d00:	89 10                	mov    %edx,(%eax)
+  return 0;
+80105d02:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105d07:	c9                   	leave  
+80105d08:	c3                   	ret    
+
+80105d09 <fetchstr>:
+// Fetch the nul-terminated string at addr from the current process.
+// Doesn't actually copy the string - just sets *pp to point at it.
+// Returns length of string, not including nul.
+int
+fetchstr(uint addr, char **pp)
+{
+80105d09:	f3 0f 1e fb          	endbr32 
+80105d0d:	55                   	push   %ebp
+80105d0e:	89 e5                	mov    %esp,%ebp
+80105d10:	83 ec 18             	sub    $0x18,%esp
+  char *s, *ep;
+  struct proc *curproc = myproc();
+80105d13:	e8 91 e8 ff ff       	call   801045a9 <myproc>
+80105d18:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  if(addr >= curproc->sz)
+80105d1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105d1e:	8b 40 14             	mov    0x14(%eax),%eax
+80105d21:	39 45 08             	cmp    %eax,0x8(%ebp)
+80105d24:	72 07                	jb     80105d2d <fetchstr+0x24>
+    return -1;
+80105d26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105d2b:	eb 44                	jmp    80105d71 <fetchstr+0x68>
+  *pp = (char*)addr;
+80105d2d:	8b 55 08             	mov    0x8(%ebp),%edx
+80105d30:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105d33:	89 10                	mov    %edx,(%eax)
+  ep = (char*)curproc->sz;
+80105d35:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105d38:	8b 40 14             	mov    0x14(%eax),%eax
+80105d3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  for(s = *pp; s < ep; s++){
+80105d3e:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105d41:	8b 00                	mov    (%eax),%eax
+80105d43:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105d46:	eb 1c                	jmp    80105d64 <fetchstr+0x5b>
+    if(*s == 0)
+80105d48:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105d4b:	0f b6 00             	movzbl (%eax),%eax
+80105d4e:	84 c0                	test   %al,%al
+80105d50:	75 0e                	jne    80105d60 <fetchstr+0x57>
+      return s - *pp;
+80105d52:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105d55:	8b 00                	mov    (%eax),%eax
+80105d57:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80105d5a:	29 c2                	sub    %eax,%edx
+80105d5c:	89 d0                	mov    %edx,%eax
+80105d5e:	eb 11                	jmp    80105d71 <fetchstr+0x68>
+  for(s = *pp; s < ep; s++){
+80105d60:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80105d64:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105d67:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+80105d6a:	72 dc                	jb     80105d48 <fetchstr+0x3f>
+  }
+  return -1;
+80105d6c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105d71:	c9                   	leave  
+80105d72:	c3                   	ret    
+
+80105d73 <argint>:
+
+// Fetch the nth 32-bit system call argument.
+int
+argint(int n, int *ip)
+{
+80105d73:	f3 0f 1e fb          	endbr32 
+80105d77:	55                   	push   %ebp
+80105d78:	89 e5                	mov    %esp,%ebp
+80105d7a:	83 ec 08             	sub    $0x8,%esp
+  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+80105d7d:	e8 27 e8 ff ff       	call   801045a9 <myproc>
+80105d82:	8b 40 28             	mov    0x28(%eax),%eax
+80105d85:	8b 40 44             	mov    0x44(%eax),%eax
+80105d88:	8b 55 08             	mov    0x8(%ebp),%edx
+80105d8b:	c1 e2 02             	shl    $0x2,%edx
+80105d8e:	01 d0                	add    %edx,%eax
+80105d90:	83 c0 04             	add    $0x4,%eax
+80105d93:	83 ec 08             	sub    $0x8,%esp
+80105d96:	ff 75 0c             	pushl  0xc(%ebp)
+80105d99:	50                   	push   %eax
+80105d9a:	e8 25 ff ff ff       	call   80105cc4 <fetchint>
+80105d9f:	83 c4 10             	add    $0x10,%esp
+}
+80105da2:	c9                   	leave  
+80105da3:	c3                   	ret    
+
+80105da4 <argptr>:
+// Fetch the nth word-sized system call argument as a pointer
+// to a block of memory of size bytes.  Check that the pointer
+// lies within the process address space.
+int
+argptr(int n, char **pp, int size)
+{
+80105da4:	f3 0f 1e fb          	endbr32 
+80105da8:	55                   	push   %ebp
+80105da9:	89 e5                	mov    %esp,%ebp
+80105dab:	83 ec 18             	sub    $0x18,%esp
+  int i;
+  struct proc *curproc = myproc();
+80105dae:	e8 f6 e7 ff ff       	call   801045a9 <myproc>
+80105db3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 
+  if(argint(n, &i) < 0)
+80105db6:	83 ec 08             	sub    $0x8,%esp
+80105db9:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105dbc:	50                   	push   %eax
+80105dbd:	ff 75 08             	pushl  0x8(%ebp)
+80105dc0:	e8 ae ff ff ff       	call   80105d73 <argint>
+80105dc5:	83 c4 10             	add    $0x10,%esp
+80105dc8:	85 c0                	test   %eax,%eax
+80105dca:	79 07                	jns    80105dd3 <argptr+0x2f>
+    return -1;
+80105dcc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105dd1:	eb 3d                	jmp    80105e10 <argptr+0x6c>
+  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+80105dd3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80105dd7:	78 21                	js     80105dfa <argptr+0x56>
+80105dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105ddc:	8b 40 14             	mov    0x14(%eax),%eax
+80105ddf:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80105de2:	39 d0                	cmp    %edx,%eax
+80105de4:	76 14                	jbe    80105dfa <argptr+0x56>
+80105de6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105de9:	89 c2                	mov    %eax,%edx
+80105deb:	8b 45 10             	mov    0x10(%ebp),%eax
+80105dee:	01 c2                	add    %eax,%edx
+80105df0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105df3:	8b 40 14             	mov    0x14(%eax),%eax
+80105df6:	39 c2                	cmp    %eax,%edx
+80105df8:	76 07                	jbe    80105e01 <argptr+0x5d>
+    return -1;
+80105dfa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105dff:	eb 0f                	jmp    80105e10 <argptr+0x6c>
+  *pp = (char*)i;
+80105e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e04:	89 c2                	mov    %eax,%edx
+80105e06:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105e09:	89 10                	mov    %edx,(%eax)
+  return 0;
+80105e0b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105e10:	c9                   	leave  
+80105e11:	c3                   	ret    
+
+80105e12 <argstr>:
+// Check that the pointer is valid and the string is nul-terminated.
+// (There is no shared writable memory, so the string can't change
+// between this check and being used by the kernel.)
+int
+argstr(int n, char **pp)
+{
+80105e12:	f3 0f 1e fb          	endbr32 
+80105e16:	55                   	push   %ebp
+80105e17:	89 e5                	mov    %esp,%ebp
+80105e19:	83 ec 18             	sub    $0x18,%esp
+  int addr;
+  if(argint(n, &addr) < 0)
+80105e1c:	83 ec 08             	sub    $0x8,%esp
+80105e1f:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80105e22:	50                   	push   %eax
+80105e23:	ff 75 08             	pushl  0x8(%ebp)
+80105e26:	e8 48 ff ff ff       	call   80105d73 <argint>
+80105e2b:	83 c4 10             	add    $0x10,%esp
+80105e2e:	85 c0                	test   %eax,%eax
+80105e30:	79 07                	jns    80105e39 <argstr+0x27>
+    return -1;
+80105e32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105e37:	eb 12                	jmp    80105e4b <argstr+0x39>
+  return fetchstr(addr, pp);
+80105e39:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105e3c:	83 ec 08             	sub    $0x8,%esp
+80105e3f:	ff 75 0c             	pushl  0xc(%ebp)
+80105e42:	50                   	push   %eax
+80105e43:	e8 c1 fe ff ff       	call   80105d09 <fetchstr>
+80105e48:	83 c4 10             	add    $0x10,%esp
+}
+80105e4b:	c9                   	leave  
+80105e4c:	c3                   	ret    
+
+80105e4d <syscall>:
+[SYS_set_prio] sys_set_prio,
+};
+
+void
+syscall(void)
+{
+80105e4d:	f3 0f 1e fb          	endbr32 
+80105e51:	55                   	push   %ebp
+80105e52:	89 e5                	mov    %esp,%ebp
+80105e54:	83 ec 18             	sub    $0x18,%esp
+  int num;
+  struct proc *curproc = myproc();
+80105e57:	e8 4d e7 ff ff       	call   801045a9 <myproc>
+80105e5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+
+  num = curproc->tf->eax;
+80105e5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105e62:	8b 40 28             	mov    0x28(%eax),%eax
+80105e65:	8b 40 1c             	mov    0x1c(%eax),%eax
+80105e68:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+80105e6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80105e6f:	7e 2f                	jle    80105ea0 <syscall+0x53>
+80105e71:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e74:	83 f8 1a             	cmp    $0x1a,%eax
+80105e77:	77 27                	ja     80105ea0 <syscall+0x53>
+80105e79:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e7c:	8b 04 85 20 c0 10 80 	mov    -0x7fef3fe0(,%eax,4),%eax
+80105e83:	85 c0                	test   %eax,%eax
+80105e85:	74 19                	je     80105ea0 <syscall+0x53>
+    curproc->tf->eax = syscalls[num]();
+80105e87:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105e8a:	8b 04 85 20 c0 10 80 	mov    -0x7fef3fe0(,%eax,4),%eax
+80105e91:	ff d0                	call   *%eax
+80105e93:	89 c2                	mov    %eax,%edx
+80105e95:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105e98:	8b 40 28             	mov    0x28(%eax),%eax
+80105e9b:	89 50 1c             	mov    %edx,0x1c(%eax)
+80105e9e:	eb 29                	jmp    80105ec9 <syscall+0x7c>
+  } else {
+    cprintf("%d %s: unknown sys call %d\n",
+            curproc->pid, curproc->name, num);
+80105ea0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    cprintf("%d %s: unknown sys call %d\n",
+80105ea3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105ea6:	8b 40 10             	mov    0x10(%eax),%eax
+80105ea9:	ff 75 f0             	pushl  -0x10(%ebp)
+80105eac:	52                   	push   %edx
+80105ead:	50                   	push   %eax
+80105eae:	68 34 92 10 80       	push   $0x80109234
+80105eb3:	e8 60 a5 ff ff       	call   80100418 <cprintf>
+80105eb8:	83 c4 10             	add    $0x10,%esp
+    curproc->tf->eax = -1;
+80105ebb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105ebe:	8b 40 28             	mov    0x28(%eax),%eax
+80105ec1:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%eax)
+  }
+}
+80105ec8:	90                   	nop
+80105ec9:	90                   	nop
+80105eca:	c9                   	leave  
+80105ecb:	c3                   	ret    
+
+80105ecc <argfd>:
+
+// Fetch the nth word-sized system call argument as a file descriptor
+// and return both the descriptor and the corresponding struct file.
+static int
+argfd(int n, int *pfd, struct file **pf)
+{
+80105ecc:	f3 0f 1e fb          	endbr32 
+80105ed0:	55                   	push   %ebp
+80105ed1:	89 e5                	mov    %esp,%ebp
+80105ed3:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  struct file *f;
+
+  if(argint(n, &fd) < 0)
+80105ed6:	83 ec 08             	sub    $0x8,%esp
+80105ed9:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105edc:	50                   	push   %eax
+80105edd:	ff 75 08             	pushl  0x8(%ebp)
+80105ee0:	e8 8e fe ff ff       	call   80105d73 <argint>
+80105ee5:	83 c4 10             	add    $0x10,%esp
+80105ee8:	85 c0                	test   %eax,%eax
+80105eea:	79 07                	jns    80105ef3 <argfd+0x27>
+    return -1;
+80105eec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105ef1:	eb 4f                	jmp    80105f42 <argfd+0x76>
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+80105ef3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105ef6:	85 c0                	test   %eax,%eax
+80105ef8:	78 20                	js     80105f1a <argfd+0x4e>
+80105efa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105efd:	83 f8 0f             	cmp    $0xf,%eax
+80105f00:	7f 18                	jg     80105f1a <argfd+0x4e>
+80105f02:	e8 a2 e6 ff ff       	call   801045a9 <myproc>
+80105f07:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80105f0a:	83 c2 0c             	add    $0xc,%edx
+80105f0d:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80105f11:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105f14:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105f18:	75 07                	jne    80105f21 <argfd+0x55>
+    return -1;
+80105f1a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105f1f:	eb 21                	jmp    80105f42 <argfd+0x76>
+  if(pfd)
+80105f21:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+80105f25:	74 08                	je     80105f2f <argfd+0x63>
+    *pfd = fd;
+80105f27:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80105f2a:	8b 45 0c             	mov    0xc(%ebp),%eax
+80105f2d:	89 10                	mov    %edx,(%eax)
+  if(pf)
+80105f2f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+80105f33:	74 08                	je     80105f3d <argfd+0x71>
+    *pf = f;
+80105f35:	8b 45 10             	mov    0x10(%ebp),%eax
+80105f38:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80105f3b:	89 10                	mov    %edx,(%eax)
+  return 0;
+80105f3d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80105f42:	c9                   	leave  
+80105f43:	c3                   	ret    
+
+80105f44 <fdalloc>:
+
+// Allocate a file descriptor for the given file.
+// Takes over file reference from caller on success.
+static int
+fdalloc(struct file *f)
+{
+80105f44:	f3 0f 1e fb          	endbr32 
+80105f48:	55                   	push   %ebp
+80105f49:	89 e5                	mov    %esp,%ebp
+80105f4b:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  struct proc *curproc = myproc();
+80105f4e:	e8 56 e6 ff ff       	call   801045a9 <myproc>
+80105f53:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+  for(fd = 0; fd < NOFILE; fd++){
+80105f56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80105f5d:	eb 2a                	jmp    80105f89 <fdalloc+0x45>
+    if(curproc->ofile[fd] == 0){
+80105f5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105f62:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80105f65:	83 c2 0c             	add    $0xc,%edx
+80105f68:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
+80105f6c:	85 c0                	test   %eax,%eax
+80105f6e:	75 15                	jne    80105f85 <fdalloc+0x41>
+      curproc->ofile[fd] = f;
+80105f70:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105f73:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80105f76:	8d 4a 0c             	lea    0xc(%edx),%ecx
+80105f79:	8b 55 08             	mov    0x8(%ebp),%edx
+80105f7c:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
+      return fd;
+80105f80:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80105f83:	eb 0f                	jmp    80105f94 <fdalloc+0x50>
+  for(fd = 0; fd < NOFILE; fd++){
+80105f85:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80105f89:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+80105f8d:	7e d0                	jle    80105f5f <fdalloc+0x1b>
+    }
+  }
+  return -1;
+80105f8f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+80105f94:	c9                   	leave  
+80105f95:	c3                   	ret    
+
+80105f96 <sys_dup>:
+
+int
+sys_dup(void)
+{
+80105f96:	f3 0f 1e fb          	endbr32 
+80105f9a:	55                   	push   %ebp
+80105f9b:	89 e5                	mov    %esp,%ebp
+80105f9d:	83 ec 18             	sub    $0x18,%esp
+  struct file *f;
+  int fd;
+
+  if(argfd(0, 0, &f) < 0)
+80105fa0:	83 ec 04             	sub    $0x4,%esp
+80105fa3:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80105fa6:	50                   	push   %eax
+80105fa7:	6a 00                	push   $0x0
+80105fa9:	6a 00                	push   $0x0
+80105fab:	e8 1c ff ff ff       	call   80105ecc <argfd>
+80105fb0:	83 c4 10             	add    $0x10,%esp
+80105fb3:	85 c0                	test   %eax,%eax
+80105fb5:	79 07                	jns    80105fbe <sys_dup+0x28>
+    return -1;
+80105fb7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105fbc:	eb 31                	jmp    80105fef <sys_dup+0x59>
+  if((fd=fdalloc(f)) < 0)
+80105fbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105fc1:	83 ec 0c             	sub    $0xc,%esp
+80105fc4:	50                   	push   %eax
+80105fc5:	e8 7a ff ff ff       	call   80105f44 <fdalloc>
+80105fca:	83 c4 10             	add    $0x10,%esp
+80105fcd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80105fd0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80105fd4:	79 07                	jns    80105fdd <sys_dup+0x47>
+    return -1;
+80105fd6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80105fdb:	eb 12                	jmp    80105fef <sys_dup+0x59>
+  filedup(f);
+80105fdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80105fe0:	83 ec 0c             	sub    $0xc,%esp
+80105fe3:	50                   	push   %eax
+80105fe4:	e8 e4 b0 ff ff       	call   801010cd <filedup>
+80105fe9:	83 c4 10             	add    $0x10,%esp
+  return fd;
+80105fec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80105fef:	c9                   	leave  
+80105ff0:	c3                   	ret    
+
+80105ff1 <sys_read>:
+
+int
+sys_read(void)
+{
+80105ff1:	f3 0f 1e fb          	endbr32 
+80105ff5:	55                   	push   %ebp
+80105ff6:	89 e5                	mov    %esp,%ebp
+80105ff8:	83 ec 18             	sub    $0x18,%esp
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+80105ffb:	83 ec 04             	sub    $0x4,%esp
+80105ffe:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80106001:	50                   	push   %eax
+80106002:	6a 00                	push   $0x0
+80106004:	6a 00                	push   $0x0
+80106006:	e8 c1 fe ff ff       	call   80105ecc <argfd>
+8010600b:	83 c4 10             	add    $0x10,%esp
+8010600e:	85 c0                	test   %eax,%eax
+80106010:	78 2e                	js     80106040 <sys_read+0x4f>
+80106012:	83 ec 08             	sub    $0x8,%esp
+80106015:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80106018:	50                   	push   %eax
+80106019:	6a 02                	push   $0x2
+8010601b:	e8 53 fd ff ff       	call   80105d73 <argint>
+80106020:	83 c4 10             	add    $0x10,%esp
+80106023:	85 c0                	test   %eax,%eax
+80106025:	78 19                	js     80106040 <sys_read+0x4f>
+80106027:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010602a:	83 ec 04             	sub    $0x4,%esp
+8010602d:	50                   	push   %eax
+8010602e:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80106031:	50                   	push   %eax
+80106032:	6a 01                	push   $0x1
+80106034:	e8 6b fd ff ff       	call   80105da4 <argptr>
+80106039:	83 c4 10             	add    $0x10,%esp
+8010603c:	85 c0                	test   %eax,%eax
+8010603e:	79 07                	jns    80106047 <sys_read+0x56>
+    return -1;
+80106040:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106045:	eb 17                	jmp    8010605e <sys_read+0x6d>
+  return fileread(f, p, n);
+80106047:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+8010604a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+8010604d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106050:	83 ec 04             	sub    $0x4,%esp
+80106053:	51                   	push   %ecx
+80106054:	52                   	push   %edx
+80106055:	50                   	push   %eax
+80106056:	e8 0e b2 ff ff       	call   80101269 <fileread>
+8010605b:	83 c4 10             	add    $0x10,%esp
+}
+8010605e:	c9                   	leave  
+8010605f:	c3                   	ret    
+
+80106060 <sys_write>:
+
+int
+sys_write(void)
+{
+80106060:	f3 0f 1e fb          	endbr32 
+80106064:	55                   	push   %ebp
+80106065:	89 e5                	mov    %esp,%ebp
+80106067:	83 ec 18             	sub    $0x18,%esp
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+8010606a:	83 ec 04             	sub    $0x4,%esp
+8010606d:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80106070:	50                   	push   %eax
+80106071:	6a 00                	push   $0x0
+80106073:	6a 00                	push   $0x0
+80106075:	e8 52 fe ff ff       	call   80105ecc <argfd>
+8010607a:	83 c4 10             	add    $0x10,%esp
+8010607d:	85 c0                	test   %eax,%eax
+8010607f:	78 2e                	js     801060af <sys_write+0x4f>
+80106081:	83 ec 08             	sub    $0x8,%esp
+80106084:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80106087:	50                   	push   %eax
+80106088:	6a 02                	push   $0x2
+8010608a:	e8 e4 fc ff ff       	call   80105d73 <argint>
+8010608f:	83 c4 10             	add    $0x10,%esp
+80106092:	85 c0                	test   %eax,%eax
+80106094:	78 19                	js     801060af <sys_write+0x4f>
+80106096:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106099:	83 ec 04             	sub    $0x4,%esp
+8010609c:	50                   	push   %eax
+8010609d:	8d 45 ec             	lea    -0x14(%ebp),%eax
+801060a0:	50                   	push   %eax
+801060a1:	6a 01                	push   $0x1
+801060a3:	e8 fc fc ff ff       	call   80105da4 <argptr>
+801060a8:	83 c4 10             	add    $0x10,%esp
+801060ab:	85 c0                	test   %eax,%eax
+801060ad:	79 07                	jns    801060b6 <sys_write+0x56>
+    return -1;
+801060af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801060b4:	eb 17                	jmp    801060cd <sys_write+0x6d>
+  return filewrite(f, p, n);
+801060b6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+801060b9:	8b 55 ec             	mov    -0x14(%ebp),%edx
+801060bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801060bf:	83 ec 04             	sub    $0x4,%esp
+801060c2:	51                   	push   %ecx
+801060c3:	52                   	push   %edx
+801060c4:	50                   	push   %eax
+801060c5:	e8 5b b2 ff ff       	call   80101325 <filewrite>
+801060ca:	83 c4 10             	add    $0x10,%esp
+}
+801060cd:	c9                   	leave  
+801060ce:	c3                   	ret    
+
+801060cf <sys_close>:
+
+int
+sys_close(void)
+{
+801060cf:	f3 0f 1e fb          	endbr32 
+801060d3:	55                   	push   %ebp
+801060d4:	89 e5                	mov    %esp,%ebp
+801060d6:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  struct file *f;
+
+  if(argfd(0, &fd, &f) < 0)
+801060d9:	83 ec 04             	sub    $0x4,%esp
+801060dc:	8d 45 f0             	lea    -0x10(%ebp),%eax
+801060df:	50                   	push   %eax
+801060e0:	8d 45 f4             	lea    -0xc(%ebp),%eax
+801060e3:	50                   	push   %eax
+801060e4:	6a 00                	push   $0x0
+801060e6:	e8 e1 fd ff ff       	call   80105ecc <argfd>
+801060eb:	83 c4 10             	add    $0x10,%esp
+801060ee:	85 c0                	test   %eax,%eax
+801060f0:	79 07                	jns    801060f9 <sys_close+0x2a>
+    return -1;
+801060f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801060f7:	eb 27                	jmp    80106120 <sys_close+0x51>
+  myproc()->ofile[fd] = 0;
+801060f9:	e8 ab e4 ff ff       	call   801045a9 <myproc>
+801060fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106101:	83 c2 0c             	add    $0xc,%edx
+80106104:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
+8010610b:	00 
+  fileclose(f);
+8010610c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010610f:	83 ec 0c             	sub    $0xc,%esp
+80106112:	50                   	push   %eax
+80106113:	e8 0a b0 ff ff       	call   80101122 <fileclose>
+80106118:	83 c4 10             	add    $0x10,%esp
+  return 0;
+8010611b:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106120:	c9                   	leave  
+80106121:	c3                   	ret    
+
+80106122 <sys_fstat>:
+
+int
+sys_fstat(void)
+{
+80106122:	f3 0f 1e fb          	endbr32 
+80106126:	55                   	push   %ebp
+80106127:	89 e5                	mov    %esp,%ebp
+80106129:	83 ec 18             	sub    $0x18,%esp
+  struct file *f;
+  struct stat *st;
+
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+8010612c:	83 ec 04             	sub    $0x4,%esp
+8010612f:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80106132:	50                   	push   %eax
+80106133:	6a 00                	push   $0x0
+80106135:	6a 00                	push   $0x0
+80106137:	e8 90 fd ff ff       	call   80105ecc <argfd>
+8010613c:	83 c4 10             	add    $0x10,%esp
+8010613f:	85 c0                	test   %eax,%eax
+80106141:	78 17                	js     8010615a <sys_fstat+0x38>
+80106143:	83 ec 04             	sub    $0x4,%esp
+80106146:	6a 14                	push   $0x14
+80106148:	8d 45 f0             	lea    -0x10(%ebp),%eax
+8010614b:	50                   	push   %eax
+8010614c:	6a 01                	push   $0x1
+8010614e:	e8 51 fc ff ff       	call   80105da4 <argptr>
+80106153:	83 c4 10             	add    $0x10,%esp
+80106156:	85 c0                	test   %eax,%eax
+80106158:	79 07                	jns    80106161 <sys_fstat+0x3f>
+    return -1;
+8010615a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010615f:	eb 13                	jmp    80106174 <sys_fstat+0x52>
+  return filestat(f, st);
+80106161:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80106164:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106167:	83 ec 08             	sub    $0x8,%esp
+8010616a:	52                   	push   %edx
+8010616b:	50                   	push   %eax
+8010616c:	e8 9d b0 ff ff       	call   8010120e <filestat>
+80106171:	83 c4 10             	add    $0x10,%esp
+}
+80106174:	c9                   	leave  
+80106175:	c3                   	ret    
+
+80106176 <sys_link>:
+
+// Create the path new as a link to the same inode as old.
+int
+sys_link(void)
+{
+80106176:	f3 0f 1e fb          	endbr32 
+8010617a:	55                   	push   %ebp
+8010617b:	89 e5                	mov    %esp,%ebp
+8010617d:	83 ec 28             	sub    $0x28,%esp
+  char name[DIRSIZ], *new, *old;
+  struct inode *dp, *ip;
+
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+80106180:	83 ec 08             	sub    $0x8,%esp
+80106183:	8d 45 d8             	lea    -0x28(%ebp),%eax
+80106186:	50                   	push   %eax
+80106187:	6a 00                	push   $0x0
+80106189:	e8 84 fc ff ff       	call   80105e12 <argstr>
+8010618e:	83 c4 10             	add    $0x10,%esp
+80106191:	85 c0                	test   %eax,%eax
+80106193:	78 15                	js     801061aa <sys_link+0x34>
+80106195:	83 ec 08             	sub    $0x8,%esp
+80106198:	8d 45 dc             	lea    -0x24(%ebp),%eax
+8010619b:	50                   	push   %eax
+8010619c:	6a 01                	push   $0x1
+8010619e:	e8 6f fc ff ff       	call   80105e12 <argstr>
+801061a3:	83 c4 10             	add    $0x10,%esp
+801061a6:	85 c0                	test   %eax,%eax
+801061a8:	79 0a                	jns    801061b4 <sys_link+0x3e>
+    return -1;
+801061aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801061af:	e9 68 01 00 00       	jmp    8010631c <sys_link+0x1a6>
+
+  begin_op();
+801061b4:	e8 b8 d4 ff ff       	call   80103671 <begin_op>
+  if((ip = namei(old)) == 0){
+801061b9:	8b 45 d8             	mov    -0x28(%ebp),%eax
+801061bc:	83 ec 0c             	sub    $0xc,%esp
+801061bf:	50                   	push   %eax
+801061c0:	e8 48 c4 ff ff       	call   8010260d <namei>
+801061c5:	83 c4 10             	add    $0x10,%esp
+801061c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801061cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801061cf:	75 0f                	jne    801061e0 <sys_link+0x6a>
+    end_op();
+801061d1:	e8 2b d5 ff ff       	call   80103701 <end_op>
+    return -1;
+801061d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801061db:	e9 3c 01 00 00       	jmp    8010631c <sys_link+0x1a6>
+  }
+
+  ilock(ip);
+801061e0:	83 ec 0c             	sub    $0xc,%esp
+801061e3:	ff 75 f4             	pushl  -0xc(%ebp)
+801061e6:	e8 b7 b8 ff ff       	call   80101aa2 <ilock>
+801061eb:	83 c4 10             	add    $0x10,%esp
+  if(ip->type == T_DIR){
+801061ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801061f1:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+801061f5:	66 83 f8 01          	cmp    $0x1,%ax
+801061f9:	75 1d                	jne    80106218 <sys_link+0xa2>
+    iunlockput(ip);
+801061fb:	83 ec 0c             	sub    $0xc,%esp
+801061fe:	ff 75 f4             	pushl  -0xc(%ebp)
+80106201:	e8 d9 ba ff ff       	call   80101cdf <iunlockput>
+80106206:	83 c4 10             	add    $0x10,%esp
+    end_op();
+80106209:	e8 f3 d4 ff ff       	call   80103701 <end_op>
+    return -1;
+8010620e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106213:	e9 04 01 00 00       	jmp    8010631c <sys_link+0x1a6>
+  }
+
+  ip->nlink++;
+80106218:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010621b:	0f b7 40 56          	movzwl 0x56(%eax),%eax
+8010621f:	83 c0 01             	add    $0x1,%eax
+80106222:	89 c2                	mov    %eax,%edx
+80106224:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106227:	66 89 50 56          	mov    %dx,0x56(%eax)
+  iupdate(ip);
+8010622b:	83 ec 0c             	sub    $0xc,%esp
+8010622e:	ff 75 f4             	pushl  -0xc(%ebp)
+80106231:	e8 83 b6 ff ff       	call   801018b9 <iupdate>
+80106236:	83 c4 10             	add    $0x10,%esp
+  iunlock(ip);
+80106239:	83 ec 0c             	sub    $0xc,%esp
+8010623c:	ff 75 f4             	pushl  -0xc(%ebp)
+8010623f:	e8 75 b9 ff ff       	call   80101bb9 <iunlock>
+80106244:	83 c4 10             	add    $0x10,%esp
+
+  if((dp = nameiparent(new, name)) == 0)
+80106247:	8b 45 dc             	mov    -0x24(%ebp),%eax
+8010624a:	83 ec 08             	sub    $0x8,%esp
+8010624d:	8d 55 e2             	lea    -0x1e(%ebp),%edx
+80106250:	52                   	push   %edx
+80106251:	50                   	push   %eax
+80106252:	e8 d6 c3 ff ff       	call   8010262d <nameiparent>
+80106257:	83 c4 10             	add    $0x10,%esp
+8010625a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+8010625d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80106261:	74 71                	je     801062d4 <sys_link+0x15e>
+    goto bad;
+  ilock(dp);
+80106263:	83 ec 0c             	sub    $0xc,%esp
+80106266:	ff 75 f0             	pushl  -0x10(%ebp)
+80106269:	e8 34 b8 ff ff       	call   80101aa2 <ilock>
+8010626e:	83 c4 10             	add    $0x10,%esp
+  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+80106271:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106274:	8b 10                	mov    (%eax),%edx
+80106276:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106279:	8b 00                	mov    (%eax),%eax
+8010627b:	39 c2                	cmp    %eax,%edx
+8010627d:	75 1d                	jne    8010629c <sys_link+0x126>
+8010627f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106282:	8b 40 04             	mov    0x4(%eax),%eax
+80106285:	83 ec 04             	sub    $0x4,%esp
+80106288:	50                   	push   %eax
+80106289:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+8010628c:	50                   	push   %eax
+8010628d:	ff 75 f0             	pushl  -0x10(%ebp)
+80106290:	e8 d5 c0 ff ff       	call   8010236a <dirlink>
+80106295:	83 c4 10             	add    $0x10,%esp
+80106298:	85 c0                	test   %eax,%eax
+8010629a:	79 10                	jns    801062ac <sys_link+0x136>
+    iunlockput(dp);
+8010629c:	83 ec 0c             	sub    $0xc,%esp
+8010629f:	ff 75 f0             	pushl  -0x10(%ebp)
+801062a2:	e8 38 ba ff ff       	call   80101cdf <iunlockput>
+801062a7:	83 c4 10             	add    $0x10,%esp
+    goto bad;
+801062aa:	eb 29                	jmp    801062d5 <sys_link+0x15f>
+  }
+  iunlockput(dp);
+801062ac:	83 ec 0c             	sub    $0xc,%esp
+801062af:	ff 75 f0             	pushl  -0x10(%ebp)
+801062b2:	e8 28 ba ff ff       	call   80101cdf <iunlockput>
+801062b7:	83 c4 10             	add    $0x10,%esp
+  iput(ip);
+801062ba:	83 ec 0c             	sub    $0xc,%esp
+801062bd:	ff 75 f4             	pushl  -0xc(%ebp)
+801062c0:	e8 46 b9 ff ff       	call   80101c0b <iput>
+801062c5:	83 c4 10             	add    $0x10,%esp
+
+  end_op();
+801062c8:	e8 34 d4 ff ff       	call   80103701 <end_op>
+
+  return 0;
+801062cd:	b8 00 00 00 00       	mov    $0x0,%eax
+801062d2:	eb 48                	jmp    8010631c <sys_link+0x1a6>
+    goto bad;
+801062d4:	90                   	nop
+
+bad:
+  ilock(ip);
+801062d5:	83 ec 0c             	sub    $0xc,%esp
+801062d8:	ff 75 f4             	pushl  -0xc(%ebp)
+801062db:	e8 c2 b7 ff ff       	call   80101aa2 <ilock>
+801062e0:	83 c4 10             	add    $0x10,%esp
+  ip->nlink--;
+801062e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801062e6:	0f b7 40 56          	movzwl 0x56(%eax),%eax
+801062ea:	83 e8 01             	sub    $0x1,%eax
+801062ed:	89 c2                	mov    %eax,%edx
+801062ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801062f2:	66 89 50 56          	mov    %dx,0x56(%eax)
+  iupdate(ip);
+801062f6:	83 ec 0c             	sub    $0xc,%esp
+801062f9:	ff 75 f4             	pushl  -0xc(%ebp)
+801062fc:	e8 b8 b5 ff ff       	call   801018b9 <iupdate>
+80106301:	83 c4 10             	add    $0x10,%esp
+  iunlockput(ip);
+80106304:	83 ec 0c             	sub    $0xc,%esp
+80106307:	ff 75 f4             	pushl  -0xc(%ebp)
+8010630a:	e8 d0 b9 ff ff       	call   80101cdf <iunlockput>
+8010630f:	83 c4 10             	add    $0x10,%esp
+  end_op();
+80106312:	e8 ea d3 ff ff       	call   80103701 <end_op>
+  return -1;
+80106317:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+8010631c:	c9                   	leave  
+8010631d:	c3                   	ret    
+
+8010631e <isdirempty>:
+
+// Is the directory dp empty except for "." and ".." ?
+static int
+isdirempty(struct inode *dp)
+{
+8010631e:	f3 0f 1e fb          	endbr32 
+80106322:	55                   	push   %ebp
+80106323:	89 e5                	mov    %esp,%ebp
+80106325:	83 ec 28             	sub    $0x28,%esp
+  int off;
+  struct dirent de;
+
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+80106328:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%ebp)
+8010632f:	eb 40                	jmp    80106371 <isdirempty+0x53>
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+80106331:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106334:	6a 10                	push   $0x10
+80106336:	50                   	push   %eax
+80106337:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+8010633a:	50                   	push   %eax
+8010633b:	ff 75 08             	pushl  0x8(%ebp)
+8010633e:	e8 67 bc ff ff       	call   80101faa <readi>
+80106343:	83 c4 10             	add    $0x10,%esp
+80106346:	83 f8 10             	cmp    $0x10,%eax
+80106349:	74 0d                	je     80106358 <isdirempty+0x3a>
+      panic("isdirempty: readi");
+8010634b:	83 ec 0c             	sub    $0xc,%esp
+8010634e:	68 50 92 10 80       	push   $0x80109250
+80106353:	e8 79 a2 ff ff       	call   801005d1 <panic>
+    if(de.inum != 0)
+80106358:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
+8010635c:	66 85 c0             	test   %ax,%ax
+8010635f:	74 07                	je     80106368 <isdirempty+0x4a>
+      return 0;
+80106361:	b8 00 00 00 00       	mov    $0x0,%eax
+80106366:	eb 1b                	jmp    80106383 <isdirempty+0x65>
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+80106368:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010636b:	83 c0 10             	add    $0x10,%eax
+8010636e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80106371:	8b 45 08             	mov    0x8(%ebp),%eax
+80106374:	8b 50 58             	mov    0x58(%eax),%edx
+80106377:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010637a:	39 c2                	cmp    %eax,%edx
+8010637c:	77 b3                	ja     80106331 <isdirempty+0x13>
+  }
+  return 1;
+8010637e:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+80106383:	c9                   	leave  
+80106384:	c3                   	ret    
+
+80106385 <sys_unlink>:
+
+//PAGEBREAK!
+int
+sys_unlink(void)
+{
+80106385:	f3 0f 1e fb          	endbr32 
+80106389:	55                   	push   %ebp
+8010638a:	89 e5                	mov    %esp,%ebp
+8010638c:	83 ec 38             	sub    $0x38,%esp
+  struct inode *ip, *dp;
+  struct dirent de;
+  char name[DIRSIZ], *path;
+  uint off;
+
+  if(argstr(0, &path) < 0)
+8010638f:	83 ec 08             	sub    $0x8,%esp
+80106392:	8d 45 cc             	lea    -0x34(%ebp),%eax
+80106395:	50                   	push   %eax
+80106396:	6a 00                	push   $0x0
+80106398:	e8 75 fa ff ff       	call   80105e12 <argstr>
+8010639d:	83 c4 10             	add    $0x10,%esp
+801063a0:	85 c0                	test   %eax,%eax
+801063a2:	79 0a                	jns    801063ae <sys_unlink+0x29>
+    return -1;
+801063a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801063a9:	e9 bf 01 00 00       	jmp    8010656d <sys_unlink+0x1e8>
+
+  begin_op();
+801063ae:	e8 be d2 ff ff       	call   80103671 <begin_op>
+  if((dp = nameiparent(path, name)) == 0){
+801063b3:	8b 45 cc             	mov    -0x34(%ebp),%eax
+801063b6:	83 ec 08             	sub    $0x8,%esp
+801063b9:	8d 55 d2             	lea    -0x2e(%ebp),%edx
+801063bc:	52                   	push   %edx
+801063bd:	50                   	push   %eax
+801063be:	e8 6a c2 ff ff       	call   8010262d <nameiparent>
+801063c3:	83 c4 10             	add    $0x10,%esp
+801063c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801063c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801063cd:	75 0f                	jne    801063de <sys_unlink+0x59>
+    end_op();
+801063cf:	e8 2d d3 ff ff       	call   80103701 <end_op>
+    return -1;
+801063d4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801063d9:	e9 8f 01 00 00       	jmp    8010656d <sys_unlink+0x1e8>
+  }
+
+  ilock(dp);
+801063de:	83 ec 0c             	sub    $0xc,%esp
+801063e1:	ff 75 f4             	pushl  -0xc(%ebp)
+801063e4:	e8 b9 b6 ff ff       	call   80101aa2 <ilock>
+801063e9:	83 c4 10             	add    $0x10,%esp
+
+  // Cannot unlink "." or "..".
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+801063ec:	83 ec 08             	sub    $0x8,%esp
+801063ef:	68 62 92 10 80       	push   $0x80109262
+801063f4:	8d 45 d2             	lea    -0x2e(%ebp),%eax
+801063f7:	50                   	push   %eax
+801063f8:	e8 90 be ff ff       	call   8010228d <namecmp>
+801063fd:	83 c4 10             	add    $0x10,%esp
+80106400:	85 c0                	test   %eax,%eax
+80106402:	0f 84 49 01 00 00    	je     80106551 <sys_unlink+0x1cc>
+80106408:	83 ec 08             	sub    $0x8,%esp
+8010640b:	68 64 92 10 80       	push   $0x80109264
+80106410:	8d 45 d2             	lea    -0x2e(%ebp),%eax
+80106413:	50                   	push   %eax
+80106414:	e8 74 be ff ff       	call   8010228d <namecmp>
+80106419:	83 c4 10             	add    $0x10,%esp
+8010641c:	85 c0                	test   %eax,%eax
+8010641e:	0f 84 2d 01 00 00    	je     80106551 <sys_unlink+0x1cc>
+    goto bad;
+
+  if((ip = dirlookup(dp, name, &off)) == 0)
+80106424:	83 ec 04             	sub    $0x4,%esp
+80106427:	8d 45 c8             	lea    -0x38(%ebp),%eax
+8010642a:	50                   	push   %eax
+8010642b:	8d 45 d2             	lea    -0x2e(%ebp),%eax
+8010642e:	50                   	push   %eax
+8010642f:	ff 75 f4             	pushl  -0xc(%ebp)
+80106432:	e8 75 be ff ff       	call   801022ac <dirlookup>
+80106437:	83 c4 10             	add    $0x10,%esp
+8010643a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+8010643d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80106441:	0f 84 0d 01 00 00    	je     80106554 <sys_unlink+0x1cf>
+    goto bad;
+  ilock(ip);
+80106447:	83 ec 0c             	sub    $0xc,%esp
+8010644a:	ff 75 f0             	pushl  -0x10(%ebp)
+8010644d:	e8 50 b6 ff ff       	call   80101aa2 <ilock>
+80106452:	83 c4 10             	add    $0x10,%esp
+
+  if(ip->nlink < 1)
+80106455:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106458:	0f b7 40 56          	movzwl 0x56(%eax),%eax
+8010645c:	66 85 c0             	test   %ax,%ax
+8010645f:	7f 0d                	jg     8010646e <sys_unlink+0xe9>
+    panic("unlink: nlink < 1");
+80106461:	83 ec 0c             	sub    $0xc,%esp
+80106464:	68 67 92 10 80       	push   $0x80109267
+80106469:	e8 63 a1 ff ff       	call   801005d1 <panic>
+  if(ip->type == T_DIR && !isdirempty(ip)){
+8010646e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106471:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+80106475:	66 83 f8 01          	cmp    $0x1,%ax
+80106479:	75 25                	jne    801064a0 <sys_unlink+0x11b>
+8010647b:	83 ec 0c             	sub    $0xc,%esp
+8010647e:	ff 75 f0             	pushl  -0x10(%ebp)
+80106481:	e8 98 fe ff ff       	call   8010631e <isdirempty>
+80106486:	83 c4 10             	add    $0x10,%esp
+80106489:	85 c0                	test   %eax,%eax
+8010648b:	75 13                	jne    801064a0 <sys_unlink+0x11b>
+    iunlockput(ip);
+8010648d:	83 ec 0c             	sub    $0xc,%esp
+80106490:	ff 75 f0             	pushl  -0x10(%ebp)
+80106493:	e8 47 b8 ff ff       	call   80101cdf <iunlockput>
+80106498:	83 c4 10             	add    $0x10,%esp
+    goto bad;
+8010649b:	e9 b5 00 00 00       	jmp    80106555 <sys_unlink+0x1d0>
+  }
+
+  memset(&de, 0, sizeof(de));
+801064a0:	83 ec 04             	sub    $0x4,%esp
+801064a3:	6a 10                	push   $0x10
+801064a5:	6a 00                	push   $0x0
+801064a7:	8d 45 e0             	lea    -0x20(%ebp),%eax
+801064aa:	50                   	push   %eax
+801064ab:	e8 6b f5 ff ff       	call   80105a1b <memset>
+801064b0:	83 c4 10             	add    $0x10,%esp
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+801064b3:	8b 45 c8             	mov    -0x38(%ebp),%eax
+801064b6:	6a 10                	push   $0x10
+801064b8:	50                   	push   %eax
+801064b9:	8d 45 e0             	lea    -0x20(%ebp),%eax
+801064bc:	50                   	push   %eax
+801064bd:	ff 75 f4             	pushl  -0xc(%ebp)
+801064c0:	e8 3e bc ff ff       	call   80102103 <writei>
+801064c5:	83 c4 10             	add    $0x10,%esp
+801064c8:	83 f8 10             	cmp    $0x10,%eax
+801064cb:	74 0d                	je     801064da <sys_unlink+0x155>
+    panic("unlink: writei");
+801064cd:	83 ec 0c             	sub    $0xc,%esp
+801064d0:	68 79 92 10 80       	push   $0x80109279
+801064d5:	e8 f7 a0 ff ff       	call   801005d1 <panic>
+  if(ip->type == T_DIR){
+801064da:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801064dd:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+801064e1:	66 83 f8 01          	cmp    $0x1,%ax
+801064e5:	75 21                	jne    80106508 <sys_unlink+0x183>
+    dp->nlink--;
+801064e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801064ea:	0f b7 40 56          	movzwl 0x56(%eax),%eax
+801064ee:	83 e8 01             	sub    $0x1,%eax
+801064f1:	89 c2                	mov    %eax,%edx
+801064f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801064f6:	66 89 50 56          	mov    %dx,0x56(%eax)
+    iupdate(dp);
+801064fa:	83 ec 0c             	sub    $0xc,%esp
+801064fd:	ff 75 f4             	pushl  -0xc(%ebp)
+80106500:	e8 b4 b3 ff ff       	call   801018b9 <iupdate>
+80106505:	83 c4 10             	add    $0x10,%esp
+  }
+  iunlockput(dp);
+80106508:	83 ec 0c             	sub    $0xc,%esp
+8010650b:	ff 75 f4             	pushl  -0xc(%ebp)
+8010650e:	e8 cc b7 ff ff       	call   80101cdf <iunlockput>
+80106513:	83 c4 10             	add    $0x10,%esp
+
+  ip->nlink--;
+80106516:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106519:	0f b7 40 56          	movzwl 0x56(%eax),%eax
+8010651d:	83 e8 01             	sub    $0x1,%eax
+80106520:	89 c2                	mov    %eax,%edx
+80106522:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106525:	66 89 50 56          	mov    %dx,0x56(%eax)
+  iupdate(ip);
+80106529:	83 ec 0c             	sub    $0xc,%esp
+8010652c:	ff 75 f0             	pushl  -0x10(%ebp)
+8010652f:	e8 85 b3 ff ff       	call   801018b9 <iupdate>
+80106534:	83 c4 10             	add    $0x10,%esp
+  iunlockput(ip);
+80106537:	83 ec 0c             	sub    $0xc,%esp
+8010653a:	ff 75 f0             	pushl  -0x10(%ebp)
+8010653d:	e8 9d b7 ff ff       	call   80101cdf <iunlockput>
+80106542:	83 c4 10             	add    $0x10,%esp
+
+  end_op();
+80106545:	e8 b7 d1 ff ff       	call   80103701 <end_op>
+
+  return 0;
+8010654a:	b8 00 00 00 00       	mov    $0x0,%eax
+8010654f:	eb 1c                	jmp    8010656d <sys_unlink+0x1e8>
+    goto bad;
+80106551:	90                   	nop
+80106552:	eb 01                	jmp    80106555 <sys_unlink+0x1d0>
+    goto bad;
+80106554:	90                   	nop
+
+bad:
+  iunlockput(dp);
+80106555:	83 ec 0c             	sub    $0xc,%esp
+80106558:	ff 75 f4             	pushl  -0xc(%ebp)
+8010655b:	e8 7f b7 ff ff       	call   80101cdf <iunlockput>
+80106560:	83 c4 10             	add    $0x10,%esp
+  end_op();
+80106563:	e8 99 d1 ff ff       	call   80103701 <end_op>
+  return -1;
+80106568:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+}
+8010656d:	c9                   	leave  
+8010656e:	c3                   	ret    
+
+8010656f <create>:
+
+static struct inode*
+create(char *path, short type, short major, short minor)
+{
+8010656f:	f3 0f 1e fb          	endbr32 
+80106573:	55                   	push   %ebp
+80106574:	89 e5                	mov    %esp,%ebp
+80106576:	83 ec 38             	sub    $0x38,%esp
+80106579:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+8010657c:	8b 55 10             	mov    0x10(%ebp),%edx
+8010657f:	8b 45 14             	mov    0x14(%ebp),%eax
+80106582:	66 89 4d d4          	mov    %cx,-0x2c(%ebp)
+80106586:	66 89 55 d0          	mov    %dx,-0x30(%ebp)
+8010658a:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+8010658e:	83 ec 08             	sub    $0x8,%esp
+80106591:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+80106594:	50                   	push   %eax
+80106595:	ff 75 08             	pushl  0x8(%ebp)
+80106598:	e8 90 c0 ff ff       	call   8010262d <nameiparent>
+8010659d:	83 c4 10             	add    $0x10,%esp
+801065a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801065a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801065a7:	75 0a                	jne    801065b3 <create+0x44>
+    return 0;
+801065a9:	b8 00 00 00 00       	mov    $0x0,%eax
+801065ae:	e9 8e 01 00 00       	jmp    80106741 <create+0x1d2>
+  ilock(dp);
+801065b3:	83 ec 0c             	sub    $0xc,%esp
+801065b6:	ff 75 f4             	pushl  -0xc(%ebp)
+801065b9:	e8 e4 b4 ff ff       	call   80101aa2 <ilock>
+801065be:	83 c4 10             	add    $0x10,%esp
+
+  if((ip = dirlookup(dp, name, 0)) != 0){
+801065c1:	83 ec 04             	sub    $0x4,%esp
+801065c4:	6a 00                	push   $0x0
+801065c6:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+801065c9:	50                   	push   %eax
+801065ca:	ff 75 f4             	pushl  -0xc(%ebp)
+801065cd:	e8 da bc ff ff       	call   801022ac <dirlookup>
+801065d2:	83 c4 10             	add    $0x10,%esp
+801065d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+801065d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+801065dc:	74 50                	je     8010662e <create+0xbf>
+    iunlockput(dp);
+801065de:	83 ec 0c             	sub    $0xc,%esp
+801065e1:	ff 75 f4             	pushl  -0xc(%ebp)
+801065e4:	e8 f6 b6 ff ff       	call   80101cdf <iunlockput>
+801065e9:	83 c4 10             	add    $0x10,%esp
+    ilock(ip);
+801065ec:	83 ec 0c             	sub    $0xc,%esp
+801065ef:	ff 75 f0             	pushl  -0x10(%ebp)
+801065f2:	e8 ab b4 ff ff       	call   80101aa2 <ilock>
+801065f7:	83 c4 10             	add    $0x10,%esp
+    if(type == T_FILE && ip->type == T_FILE)
+801065fa:	66 83 7d d4 02       	cmpw   $0x2,-0x2c(%ebp)
+801065ff:	75 15                	jne    80106616 <create+0xa7>
+80106601:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106604:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+80106608:	66 83 f8 02          	cmp    $0x2,%ax
+8010660c:	75 08                	jne    80106616 <create+0xa7>
+      return ip;
+8010660e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106611:	e9 2b 01 00 00       	jmp    80106741 <create+0x1d2>
+    iunlockput(ip);
+80106616:	83 ec 0c             	sub    $0xc,%esp
+80106619:	ff 75 f0             	pushl  -0x10(%ebp)
+8010661c:	e8 be b6 ff ff       	call   80101cdf <iunlockput>
+80106621:	83 c4 10             	add    $0x10,%esp
+    return 0;
+80106624:	b8 00 00 00 00       	mov    $0x0,%eax
+80106629:	e9 13 01 00 00       	jmp    80106741 <create+0x1d2>
+  }
+
+  if((ip = ialloc(dp->dev, type)) == 0)
+8010662e:	0f bf 55 d4          	movswl -0x2c(%ebp),%edx
+80106632:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106635:	8b 00                	mov    (%eax),%eax
+80106637:	83 ec 08             	sub    $0x8,%esp
+8010663a:	52                   	push   %edx
+8010663b:	50                   	push   %eax
+8010663c:	e8 9d b1 ff ff       	call   801017de <ialloc>
+80106641:	83 c4 10             	add    $0x10,%esp
+80106644:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80106647:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+8010664b:	75 0d                	jne    8010665a <create+0xeb>
+    panic("create: ialloc");
+8010664d:	83 ec 0c             	sub    $0xc,%esp
+80106650:	68 88 92 10 80       	push   $0x80109288
+80106655:	e8 77 9f ff ff       	call   801005d1 <panic>
+
+  ilock(ip);
+8010665a:	83 ec 0c             	sub    $0xc,%esp
+8010665d:	ff 75 f0             	pushl  -0x10(%ebp)
+80106660:	e8 3d b4 ff ff       	call   80101aa2 <ilock>
+80106665:	83 c4 10             	add    $0x10,%esp
+  ip->major = major;
+80106668:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010666b:	0f b7 55 d0          	movzwl -0x30(%ebp),%edx
+8010666f:	66 89 50 52          	mov    %dx,0x52(%eax)
+  ip->minor = minor;
+80106673:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106676:	0f b7 55 cc          	movzwl -0x34(%ebp),%edx
+8010667a:	66 89 50 54          	mov    %dx,0x54(%eax)
+  ip->nlink = 1;
+8010667e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106681:	66 c7 40 56 01 00    	movw   $0x1,0x56(%eax)
+  iupdate(ip);
+80106687:	83 ec 0c             	sub    $0xc,%esp
+8010668a:	ff 75 f0             	pushl  -0x10(%ebp)
+8010668d:	e8 27 b2 ff ff       	call   801018b9 <iupdate>
+80106692:	83 c4 10             	add    $0x10,%esp
+
+  if(type == T_DIR){  // Create . and .. entries.
+80106695:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%ebp)
+8010669a:	75 6a                	jne    80106706 <create+0x197>
+    dp->nlink++;  // for ".."
+8010669c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010669f:	0f b7 40 56          	movzwl 0x56(%eax),%eax
+801066a3:	83 c0 01             	add    $0x1,%eax
+801066a6:	89 c2                	mov    %eax,%edx
+801066a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801066ab:	66 89 50 56          	mov    %dx,0x56(%eax)
+    iupdate(dp);
+801066af:	83 ec 0c             	sub    $0xc,%esp
+801066b2:	ff 75 f4             	pushl  -0xc(%ebp)
+801066b5:	e8 ff b1 ff ff       	call   801018b9 <iupdate>
+801066ba:	83 c4 10             	add    $0x10,%esp
+    // No ip->nlink++ for ".": avoid cyclic ref count.
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+801066bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801066c0:	8b 40 04             	mov    0x4(%eax),%eax
+801066c3:	83 ec 04             	sub    $0x4,%esp
+801066c6:	50                   	push   %eax
+801066c7:	68 62 92 10 80       	push   $0x80109262
+801066cc:	ff 75 f0             	pushl  -0x10(%ebp)
+801066cf:	e8 96 bc ff ff       	call   8010236a <dirlink>
+801066d4:	83 c4 10             	add    $0x10,%esp
+801066d7:	85 c0                	test   %eax,%eax
+801066d9:	78 1e                	js     801066f9 <create+0x18a>
+801066db:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801066de:	8b 40 04             	mov    0x4(%eax),%eax
+801066e1:	83 ec 04             	sub    $0x4,%esp
+801066e4:	50                   	push   %eax
+801066e5:	68 64 92 10 80       	push   $0x80109264
+801066ea:	ff 75 f0             	pushl  -0x10(%ebp)
+801066ed:	e8 78 bc ff ff       	call   8010236a <dirlink>
+801066f2:	83 c4 10             	add    $0x10,%esp
+801066f5:	85 c0                	test   %eax,%eax
+801066f7:	79 0d                	jns    80106706 <create+0x197>
+      panic("create dots");
+801066f9:	83 ec 0c             	sub    $0xc,%esp
+801066fc:	68 97 92 10 80       	push   $0x80109297
+80106701:	e8 cb 9e ff ff       	call   801005d1 <panic>
+  }
+
+  if(dirlink(dp, name, ip->inum) < 0)
+80106706:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106709:	8b 40 04             	mov    0x4(%eax),%eax
+8010670c:	83 ec 04             	sub    $0x4,%esp
+8010670f:	50                   	push   %eax
+80106710:	8d 45 e2             	lea    -0x1e(%ebp),%eax
+80106713:	50                   	push   %eax
+80106714:	ff 75 f4             	pushl  -0xc(%ebp)
+80106717:	e8 4e bc ff ff       	call   8010236a <dirlink>
+8010671c:	83 c4 10             	add    $0x10,%esp
+8010671f:	85 c0                	test   %eax,%eax
+80106721:	79 0d                	jns    80106730 <create+0x1c1>
+    panic("create: dirlink");
+80106723:	83 ec 0c             	sub    $0xc,%esp
+80106726:	68 a3 92 10 80       	push   $0x801092a3
+8010672b:	e8 a1 9e ff ff       	call   801005d1 <panic>
+
+  iunlockput(dp);
+80106730:	83 ec 0c             	sub    $0xc,%esp
+80106733:	ff 75 f4             	pushl  -0xc(%ebp)
+80106736:	e8 a4 b5 ff ff       	call   80101cdf <iunlockput>
+8010673b:	83 c4 10             	add    $0x10,%esp
+
+  return ip;
+8010673e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+80106741:	c9                   	leave  
+80106742:	c3                   	ret    
+
+80106743 <sys_open>:
+
+int
+sys_open(void)
+{
+80106743:	f3 0f 1e fb          	endbr32 
+80106747:	55                   	push   %ebp
+80106748:	89 e5                	mov    %esp,%ebp
+8010674a:	83 ec 28             	sub    $0x28,%esp
+  char *path;
+  int fd, omode;
+  struct file *f;
+  struct inode *ip;
+
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+8010674d:	83 ec 08             	sub    $0x8,%esp
+80106750:	8d 45 e8             	lea    -0x18(%ebp),%eax
+80106753:	50                   	push   %eax
+80106754:	6a 00                	push   $0x0
+80106756:	e8 b7 f6 ff ff       	call   80105e12 <argstr>
+8010675b:	83 c4 10             	add    $0x10,%esp
+8010675e:	85 c0                	test   %eax,%eax
+80106760:	78 15                	js     80106777 <sys_open+0x34>
+80106762:	83 ec 08             	sub    $0x8,%esp
+80106765:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80106768:	50                   	push   %eax
+80106769:	6a 01                	push   $0x1
+8010676b:	e8 03 f6 ff ff       	call   80105d73 <argint>
+80106770:	83 c4 10             	add    $0x10,%esp
+80106773:	85 c0                	test   %eax,%eax
+80106775:	79 0a                	jns    80106781 <sys_open+0x3e>
+    return -1;
+80106777:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010677c:	e9 61 01 00 00       	jmp    801068e2 <sys_open+0x19f>
+
+  begin_op();
+80106781:	e8 eb ce ff ff       	call   80103671 <begin_op>
+
+  if(omode & O_CREATE){
+80106786:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106789:	25 00 02 00 00       	and    $0x200,%eax
+8010678e:	85 c0                	test   %eax,%eax
+80106790:	74 2a                	je     801067bc <sys_open+0x79>
+    ip = create(path, T_FILE, 0, 0);
+80106792:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80106795:	6a 00                	push   $0x0
+80106797:	6a 00                	push   $0x0
+80106799:	6a 02                	push   $0x2
+8010679b:	50                   	push   %eax
+8010679c:	e8 ce fd ff ff       	call   8010656f <create>
+801067a1:	83 c4 10             	add    $0x10,%esp
+801067a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(ip == 0){
+801067a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801067ab:	75 75                	jne    80106822 <sys_open+0xdf>
+      end_op();
+801067ad:	e8 4f cf ff ff       	call   80103701 <end_op>
+      return -1;
+801067b2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801067b7:	e9 26 01 00 00       	jmp    801068e2 <sys_open+0x19f>
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+801067bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
+801067bf:	83 ec 0c             	sub    $0xc,%esp
+801067c2:	50                   	push   %eax
+801067c3:	e8 45 be ff ff       	call   8010260d <namei>
+801067c8:	83 c4 10             	add    $0x10,%esp
+801067cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801067ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801067d2:	75 0f                	jne    801067e3 <sys_open+0xa0>
+      end_op();
+801067d4:	e8 28 cf ff ff       	call   80103701 <end_op>
+      return -1;
+801067d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801067de:	e9 ff 00 00 00       	jmp    801068e2 <sys_open+0x19f>
+    }
+    ilock(ip);
+801067e3:	83 ec 0c             	sub    $0xc,%esp
+801067e6:	ff 75 f4             	pushl  -0xc(%ebp)
+801067e9:	e8 b4 b2 ff ff       	call   80101aa2 <ilock>
+801067ee:	83 c4 10             	add    $0x10,%esp
+    if(ip->type == T_DIR && omode != O_RDONLY){
+801067f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801067f4:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+801067f8:	66 83 f8 01          	cmp    $0x1,%ax
+801067fc:	75 24                	jne    80106822 <sys_open+0xdf>
+801067fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106801:	85 c0                	test   %eax,%eax
+80106803:	74 1d                	je     80106822 <sys_open+0xdf>
+      iunlockput(ip);
+80106805:	83 ec 0c             	sub    $0xc,%esp
+80106808:	ff 75 f4             	pushl  -0xc(%ebp)
+8010680b:	e8 cf b4 ff ff       	call   80101cdf <iunlockput>
+80106810:	83 c4 10             	add    $0x10,%esp
+      end_op();
+80106813:	e8 e9 ce ff ff       	call   80103701 <end_op>
+      return -1;
+80106818:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010681d:	e9 c0 00 00 00       	jmp    801068e2 <sys_open+0x19f>
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+80106822:	e8 35 a8 ff ff       	call   8010105c <filealloc>
+80106827:	89 45 f0             	mov    %eax,-0x10(%ebp)
+8010682a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+8010682e:	74 17                	je     80106847 <sys_open+0x104>
+80106830:	83 ec 0c             	sub    $0xc,%esp
+80106833:	ff 75 f0             	pushl  -0x10(%ebp)
+80106836:	e8 09 f7 ff ff       	call   80105f44 <fdalloc>
+8010683b:	83 c4 10             	add    $0x10,%esp
+8010683e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80106841:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80106845:	79 2e                	jns    80106875 <sys_open+0x132>
+    if(f)
+80106847:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+8010684b:	74 0e                	je     8010685b <sys_open+0x118>
+      fileclose(f);
+8010684d:	83 ec 0c             	sub    $0xc,%esp
+80106850:	ff 75 f0             	pushl  -0x10(%ebp)
+80106853:	e8 ca a8 ff ff       	call   80101122 <fileclose>
+80106858:	83 c4 10             	add    $0x10,%esp
+    iunlockput(ip);
+8010685b:	83 ec 0c             	sub    $0xc,%esp
+8010685e:	ff 75 f4             	pushl  -0xc(%ebp)
+80106861:	e8 79 b4 ff ff       	call   80101cdf <iunlockput>
+80106866:	83 c4 10             	add    $0x10,%esp
+    end_op();
+80106869:	e8 93 ce ff ff       	call   80103701 <end_op>
+    return -1;
+8010686e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106873:	eb 6d                	jmp    801068e2 <sys_open+0x19f>
+  }
+  iunlock(ip);
+80106875:	83 ec 0c             	sub    $0xc,%esp
+80106878:	ff 75 f4             	pushl  -0xc(%ebp)
+8010687b:	e8 39 b3 ff ff       	call   80101bb9 <iunlock>
+80106880:	83 c4 10             	add    $0x10,%esp
+  end_op();
+80106883:	e8 79 ce ff ff       	call   80103701 <end_op>
+
+  f->type = FD_INODE;
+80106888:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010688b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
+  f->ip = ip;
+80106891:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106894:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106897:	89 50 10             	mov    %edx,0x10(%eax)
+  f->off = 0;
+8010689a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010689d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+  f->readable = !(omode & O_WRONLY);
+801068a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801068a7:	83 e0 01             	and    $0x1,%eax
+801068aa:	85 c0                	test   %eax,%eax
+801068ac:	0f 94 c0             	sete   %al
+801068af:	89 c2                	mov    %eax,%edx
+801068b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801068b4:	88 50 08             	mov    %dl,0x8(%eax)
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+801068b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801068ba:	83 e0 01             	and    $0x1,%eax
+801068bd:	85 c0                	test   %eax,%eax
+801068bf:	75 0a                	jne    801068cb <sys_open+0x188>
+801068c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+801068c4:	83 e0 02             	and    $0x2,%eax
+801068c7:	85 c0                	test   %eax,%eax
+801068c9:	74 07                	je     801068d2 <sys_open+0x18f>
+801068cb:	b8 01 00 00 00       	mov    $0x1,%eax
+801068d0:	eb 05                	jmp    801068d7 <sys_open+0x194>
+801068d2:	b8 00 00 00 00       	mov    $0x0,%eax
+801068d7:	89 c2                	mov    %eax,%edx
+801068d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801068dc:	88 50 09             	mov    %dl,0x9(%eax)
+  return fd;
+801068df:	8b 45 ec             	mov    -0x14(%ebp),%eax
+}
+801068e2:	c9                   	leave  
+801068e3:	c3                   	ret    
+
+801068e4 <sys_mkdir>:
+
+int
+sys_mkdir(void)
+{
+801068e4:	f3 0f 1e fb          	endbr32 
+801068e8:	55                   	push   %ebp
+801068e9:	89 e5                	mov    %esp,%ebp
+801068eb:	83 ec 18             	sub    $0x18,%esp
+  char *path;
+  struct inode *ip;
+
+  begin_op();
+801068ee:	e8 7e cd ff ff       	call   80103671 <begin_op>
+  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+801068f3:	83 ec 08             	sub    $0x8,%esp
+801068f6:	8d 45 f0             	lea    -0x10(%ebp),%eax
+801068f9:	50                   	push   %eax
+801068fa:	6a 00                	push   $0x0
+801068fc:	e8 11 f5 ff ff       	call   80105e12 <argstr>
+80106901:	83 c4 10             	add    $0x10,%esp
+80106904:	85 c0                	test   %eax,%eax
+80106906:	78 1b                	js     80106923 <sys_mkdir+0x3f>
+80106908:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010690b:	6a 00                	push   $0x0
+8010690d:	6a 00                	push   $0x0
+8010690f:	6a 01                	push   $0x1
+80106911:	50                   	push   %eax
+80106912:	e8 58 fc ff ff       	call   8010656f <create>
+80106917:	83 c4 10             	add    $0x10,%esp
+8010691a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+8010691d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80106921:	75 0c                	jne    8010692f <sys_mkdir+0x4b>
+    end_op();
+80106923:	e8 d9 cd ff ff       	call   80103701 <end_op>
+    return -1;
+80106928:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010692d:	eb 18                	jmp    80106947 <sys_mkdir+0x63>
+  }
+  iunlockput(ip);
+8010692f:	83 ec 0c             	sub    $0xc,%esp
+80106932:	ff 75 f4             	pushl  -0xc(%ebp)
+80106935:	e8 a5 b3 ff ff       	call   80101cdf <iunlockput>
+8010693a:	83 c4 10             	add    $0x10,%esp
+  end_op();
+8010693d:	e8 bf cd ff ff       	call   80103701 <end_op>
+  return 0;
+80106942:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106947:	c9                   	leave  
+80106948:	c3                   	ret    
+
+80106949 <sys_mknod>:
+
+int
+sys_mknod(void)
+{
+80106949:	f3 0f 1e fb          	endbr32 
+8010694d:	55                   	push   %ebp
+8010694e:	89 e5                	mov    %esp,%ebp
+80106950:	83 ec 18             	sub    $0x18,%esp
+  struct inode *ip;
+  char *path;
+  int major, minor;
+
+  begin_op();
+80106953:	e8 19 cd ff ff       	call   80103671 <begin_op>
+  if((argstr(0, &path)) < 0 ||
+80106958:	83 ec 08             	sub    $0x8,%esp
+8010695b:	8d 45 f0             	lea    -0x10(%ebp),%eax
+8010695e:	50                   	push   %eax
+8010695f:	6a 00                	push   $0x0
+80106961:	e8 ac f4 ff ff       	call   80105e12 <argstr>
+80106966:	83 c4 10             	add    $0x10,%esp
+80106969:	85 c0                	test   %eax,%eax
+8010696b:	78 4f                	js     801069bc <sys_mknod+0x73>
+     argint(1, &major) < 0 ||
+8010696d:	83 ec 08             	sub    $0x8,%esp
+80106970:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80106973:	50                   	push   %eax
+80106974:	6a 01                	push   $0x1
+80106976:	e8 f8 f3 ff ff       	call   80105d73 <argint>
+8010697b:	83 c4 10             	add    $0x10,%esp
+  if((argstr(0, &path)) < 0 ||
+8010697e:	85 c0                	test   %eax,%eax
+80106980:	78 3a                	js     801069bc <sys_mknod+0x73>
+     argint(2, &minor) < 0 ||
+80106982:	83 ec 08             	sub    $0x8,%esp
+80106985:	8d 45 e8             	lea    -0x18(%ebp),%eax
+80106988:	50                   	push   %eax
+80106989:	6a 02                	push   $0x2
+8010698b:	e8 e3 f3 ff ff       	call   80105d73 <argint>
+80106990:	83 c4 10             	add    $0x10,%esp
+     argint(1, &major) < 0 ||
+80106993:	85 c0                	test   %eax,%eax
+80106995:	78 25                	js     801069bc <sys_mknod+0x73>
+     (ip = create(path, T_DEV, major, minor)) == 0){
+80106997:	8b 45 e8             	mov    -0x18(%ebp),%eax
+8010699a:	0f bf c8             	movswl %ax,%ecx
+8010699d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801069a0:	0f bf d0             	movswl %ax,%edx
+801069a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801069a6:	51                   	push   %ecx
+801069a7:	52                   	push   %edx
+801069a8:	6a 03                	push   $0x3
+801069aa:	50                   	push   %eax
+801069ab:	e8 bf fb ff ff       	call   8010656f <create>
+801069b0:	83 c4 10             	add    $0x10,%esp
+801069b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+     argint(2, &minor) < 0 ||
+801069b6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+801069ba:	75 0c                	jne    801069c8 <sys_mknod+0x7f>
+    end_op();
+801069bc:	e8 40 cd ff ff       	call   80103701 <end_op>
+    return -1;
+801069c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801069c6:	eb 18                	jmp    801069e0 <sys_mknod+0x97>
+  }
+  iunlockput(ip);
+801069c8:	83 ec 0c             	sub    $0xc,%esp
+801069cb:	ff 75 f4             	pushl  -0xc(%ebp)
+801069ce:	e8 0c b3 ff ff       	call   80101cdf <iunlockput>
+801069d3:	83 c4 10             	add    $0x10,%esp
+  end_op();
+801069d6:	e8 26 cd ff ff       	call   80103701 <end_op>
+  return 0;
+801069db:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+801069e0:	c9                   	leave  
+801069e1:	c3                   	ret    
+
+801069e2 <sys_chdir>:
+
+int
+sys_chdir(void)
+{
+801069e2:	f3 0f 1e fb          	endbr32 
+801069e6:	55                   	push   %ebp
+801069e7:	89 e5                	mov    %esp,%ebp
+801069e9:	83 ec 18             	sub    $0x18,%esp
+  char *path;
+  struct inode *ip;
+  struct proc *curproc = myproc();
+801069ec:	e8 b8 db ff ff       	call   801045a9 <myproc>
+801069f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  
+  begin_op();
+801069f4:	e8 78 cc ff ff       	call   80103671 <begin_op>
+  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+801069f9:	83 ec 08             	sub    $0x8,%esp
+801069fc:	8d 45 ec             	lea    -0x14(%ebp),%eax
+801069ff:	50                   	push   %eax
+80106a00:	6a 00                	push   $0x0
+80106a02:	e8 0b f4 ff ff       	call   80105e12 <argstr>
+80106a07:	83 c4 10             	add    $0x10,%esp
+80106a0a:	85 c0                	test   %eax,%eax
+80106a0c:	78 18                	js     80106a26 <sys_chdir+0x44>
+80106a0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80106a11:	83 ec 0c             	sub    $0xc,%esp
+80106a14:	50                   	push   %eax
+80106a15:	e8 f3 bb ff ff       	call   8010260d <namei>
+80106a1a:	83 c4 10             	add    $0x10,%esp
+80106a1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80106a20:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80106a24:	75 0c                	jne    80106a32 <sys_chdir+0x50>
+    end_op();
+80106a26:	e8 d6 cc ff ff       	call   80103701 <end_op>
+    return -1;
+80106a2b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106a30:	eb 68                	jmp    80106a9a <sys_chdir+0xb8>
+  }
+  ilock(ip);
+80106a32:	83 ec 0c             	sub    $0xc,%esp
+80106a35:	ff 75 f0             	pushl  -0x10(%ebp)
+80106a38:	e8 65 b0 ff ff       	call   80101aa2 <ilock>
+80106a3d:	83 c4 10             	add    $0x10,%esp
+  if(ip->type != T_DIR){
+80106a40:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106a43:	0f b7 40 50          	movzwl 0x50(%eax),%eax
+80106a47:	66 83 f8 01          	cmp    $0x1,%ax
+80106a4b:	74 1a                	je     80106a67 <sys_chdir+0x85>
+    iunlockput(ip);
+80106a4d:	83 ec 0c             	sub    $0xc,%esp
+80106a50:	ff 75 f0             	pushl  -0x10(%ebp)
+80106a53:	e8 87 b2 ff ff       	call   80101cdf <iunlockput>
+80106a58:	83 c4 10             	add    $0x10,%esp
+    end_op();
+80106a5b:	e8 a1 cc ff ff       	call   80103701 <end_op>
+    return -1;
+80106a60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106a65:	eb 33                	jmp    80106a9a <sys_chdir+0xb8>
+  }
+  iunlock(ip);
+80106a67:	83 ec 0c             	sub    $0xc,%esp
+80106a6a:	ff 75 f0             	pushl  -0x10(%ebp)
+80106a6d:	e8 47 b1 ff ff       	call   80101bb9 <iunlock>
+80106a72:	83 c4 10             	add    $0x10,%esp
+  iput(curproc->cwd);
+80106a75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106a78:	8b 40 78             	mov    0x78(%eax),%eax
+80106a7b:	83 ec 0c             	sub    $0xc,%esp
+80106a7e:	50                   	push   %eax
+80106a7f:	e8 87 b1 ff ff       	call   80101c0b <iput>
+80106a84:	83 c4 10             	add    $0x10,%esp
+  end_op();
+80106a87:	e8 75 cc ff ff       	call   80103701 <end_op>
+  curproc->cwd = ip;
+80106a8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106a8f:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80106a92:	89 50 78             	mov    %edx,0x78(%eax)
+  return 0;
+80106a95:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106a9a:	c9                   	leave  
+80106a9b:	c3                   	ret    
+
+80106a9c <sys_exec>:
+
+int
+sys_exec(void)
+{
+80106a9c:	f3 0f 1e fb          	endbr32 
+80106aa0:	55                   	push   %ebp
+80106aa1:	89 e5                	mov    %esp,%ebp
+80106aa3:	81 ec 98 00 00 00    	sub    $0x98,%esp
+  char *path, *argv[MAXARG];
+  int i;
+  uint uargv, uarg;
+
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+80106aa9:	83 ec 08             	sub    $0x8,%esp
+80106aac:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80106aaf:	50                   	push   %eax
+80106ab0:	6a 00                	push   $0x0
+80106ab2:	e8 5b f3 ff ff       	call   80105e12 <argstr>
+80106ab7:	83 c4 10             	add    $0x10,%esp
+80106aba:	85 c0                	test   %eax,%eax
+80106abc:	78 18                	js     80106ad6 <sys_exec+0x3a>
+80106abe:	83 ec 08             	sub    $0x8,%esp
+80106ac1:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
+80106ac7:	50                   	push   %eax
+80106ac8:	6a 01                	push   $0x1
+80106aca:	e8 a4 f2 ff ff       	call   80105d73 <argint>
+80106acf:	83 c4 10             	add    $0x10,%esp
+80106ad2:	85 c0                	test   %eax,%eax
+80106ad4:	79 0a                	jns    80106ae0 <sys_exec+0x44>
+    return -1;
+80106ad6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106adb:	e9 c6 00 00 00       	jmp    80106ba6 <sys_exec+0x10a>
+  }
+  memset(argv, 0, sizeof(argv));
+80106ae0:	83 ec 04             	sub    $0x4,%esp
+80106ae3:	68 80 00 00 00       	push   $0x80
+80106ae8:	6a 00                	push   $0x0
+80106aea:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
+80106af0:	50                   	push   %eax
+80106af1:	e8 25 ef ff ff       	call   80105a1b <memset>
+80106af6:	83 c4 10             	add    $0x10,%esp
+  for(i=0;; i++){
+80106af9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if(i >= NELEM(argv))
+80106b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106b03:	83 f8 1f             	cmp    $0x1f,%eax
+80106b06:	76 0a                	jbe    80106b12 <sys_exec+0x76>
+      return -1;
+80106b08:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106b0d:	e9 94 00 00 00       	jmp    80106ba6 <sys_exec+0x10a>
+    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+80106b12:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106b15:	c1 e0 02             	shl    $0x2,%eax
+80106b18:	89 c2                	mov    %eax,%edx
+80106b1a:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
+80106b20:	01 c2                	add    %eax,%edx
+80106b22:	83 ec 08             	sub    $0x8,%esp
+80106b25:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
+80106b2b:	50                   	push   %eax
+80106b2c:	52                   	push   %edx
+80106b2d:	e8 92 f1 ff ff       	call   80105cc4 <fetchint>
+80106b32:	83 c4 10             	add    $0x10,%esp
+80106b35:	85 c0                	test   %eax,%eax
+80106b37:	79 07                	jns    80106b40 <sys_exec+0xa4>
+      return -1;
+80106b39:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106b3e:	eb 66                	jmp    80106ba6 <sys_exec+0x10a>
+    if(uarg == 0){
+80106b40:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
+80106b46:	85 c0                	test   %eax,%eax
+80106b48:	75 27                	jne    80106b71 <sys_exec+0xd5>
+      argv[i] = 0;
+80106b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106b4d:	c7 84 85 70 ff ff ff 	movl   $0x0,-0x90(%ebp,%eax,4)
+80106b54:	00 00 00 00 
+      break;
+80106b58:	90                   	nop
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+      return -1;
+  }
+  return exec(path, argv);
+80106b59:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106b5c:	83 ec 08             	sub    $0x8,%esp
+80106b5f:	8d 95 70 ff ff ff    	lea    -0x90(%ebp),%edx
+80106b65:	52                   	push   %edx
+80106b66:	50                   	push   %eax
+80106b67:	e8 8d a0 ff ff       	call   80100bf9 <exec>
+80106b6c:	83 c4 10             	add    $0x10,%esp
+80106b6f:	eb 35                	jmp    80106ba6 <sys_exec+0x10a>
+    if(fetchstr(uarg, &argv[i]) < 0)
+80106b71:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
+80106b77:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106b7a:	c1 e2 02             	shl    $0x2,%edx
+80106b7d:	01 c2                	add    %eax,%edx
+80106b7f:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
+80106b85:	83 ec 08             	sub    $0x8,%esp
+80106b88:	52                   	push   %edx
+80106b89:	50                   	push   %eax
+80106b8a:	e8 7a f1 ff ff       	call   80105d09 <fetchstr>
+80106b8f:	83 c4 10             	add    $0x10,%esp
+80106b92:	85 c0                	test   %eax,%eax
+80106b94:	79 07                	jns    80106b9d <sys_exec+0x101>
+      return -1;
+80106b96:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106b9b:	eb 09                	jmp    80106ba6 <sys_exec+0x10a>
+  for(i=0;; i++){
+80106b9d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(i >= NELEM(argv))
+80106ba1:	e9 5a ff ff ff       	jmp    80106b00 <sys_exec+0x64>
+  
+}
+80106ba6:	c9                   	leave  
+80106ba7:	c3                   	ret    
+
+80106ba8 <sys_pipe>:
+
+int
+sys_pipe(void)
+{
+80106ba8:	f3 0f 1e fb          	endbr32 
+80106bac:	55                   	push   %ebp
+80106bad:	89 e5                	mov    %esp,%ebp
+80106baf:	83 ec 28             	sub    $0x28,%esp
+  int *fd;
+  struct file *rf, *wf;
+  int fd0, fd1;
+
+  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+80106bb2:	83 ec 04             	sub    $0x4,%esp
+80106bb5:	6a 08                	push   $0x8
+80106bb7:	8d 45 ec             	lea    -0x14(%ebp),%eax
+80106bba:	50                   	push   %eax
+80106bbb:	6a 00                	push   $0x0
+80106bbd:	e8 e2 f1 ff ff       	call   80105da4 <argptr>
+80106bc2:	83 c4 10             	add    $0x10,%esp
+80106bc5:	85 c0                	test   %eax,%eax
+80106bc7:	79 0a                	jns    80106bd3 <sys_pipe+0x2b>
+    return -1;
+80106bc9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106bce:	e9 ae 00 00 00       	jmp    80106c81 <sys_pipe+0xd9>
+  if(pipealloc(&rf, &wf) < 0)
+80106bd3:	83 ec 08             	sub    $0x8,%esp
+80106bd6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80106bd9:	50                   	push   %eax
+80106bda:	8d 45 e8             	lea    -0x18(%ebp),%eax
+80106bdd:	50                   	push   %eax
+80106bde:	e8 6e d3 ff ff       	call   80103f51 <pipealloc>
+80106be3:	83 c4 10             	add    $0x10,%esp
+80106be6:	85 c0                	test   %eax,%eax
+80106be8:	79 0a                	jns    80106bf4 <sys_pipe+0x4c>
+    return -1;
+80106bea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106bef:	e9 8d 00 00 00       	jmp    80106c81 <sys_pipe+0xd9>
+  fd0 = -1;
+80106bf4:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+80106bfb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80106bfe:	83 ec 0c             	sub    $0xc,%esp
+80106c01:	50                   	push   %eax
+80106c02:	e8 3d f3 ff ff       	call   80105f44 <fdalloc>
+80106c07:	83 c4 10             	add    $0x10,%esp
+80106c0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80106c0d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80106c11:	78 18                	js     80106c2b <sys_pipe+0x83>
+80106c13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106c16:	83 ec 0c             	sub    $0xc,%esp
+80106c19:	50                   	push   %eax
+80106c1a:	e8 25 f3 ff ff       	call   80105f44 <fdalloc>
+80106c1f:	83 c4 10             	add    $0x10,%esp
+80106c22:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80106c25:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80106c29:	79 3e                	jns    80106c69 <sys_pipe+0xc1>
+    if(fd0 >= 0)
+80106c2b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80106c2f:	78 13                	js     80106c44 <sys_pipe+0x9c>
+      myproc()->ofile[fd0] = 0;
+80106c31:	e8 73 d9 ff ff       	call   801045a9 <myproc>
+80106c36:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106c39:	83 c2 0c             	add    $0xc,%edx
+80106c3c:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
+80106c43:	00 
+    fileclose(rf);
+80106c44:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80106c47:	83 ec 0c             	sub    $0xc,%esp
+80106c4a:	50                   	push   %eax
+80106c4b:	e8 d2 a4 ff ff       	call   80101122 <fileclose>
+80106c50:	83 c4 10             	add    $0x10,%esp
+    fileclose(wf);
+80106c53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106c56:	83 ec 0c             	sub    $0xc,%esp
+80106c59:	50                   	push   %eax
+80106c5a:	e8 c3 a4 ff ff       	call   80101122 <fileclose>
+80106c5f:	83 c4 10             	add    $0x10,%esp
+    return -1;
+80106c62:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106c67:	eb 18                	jmp    80106c81 <sys_pipe+0xd9>
+  }
+  fd[0] = fd0;
+80106c69:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80106c6c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106c6f:	89 10                	mov    %edx,(%eax)
+  fd[1] = fd1;
+80106c71:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80106c74:	8d 50 04             	lea    0x4(%eax),%edx
+80106c77:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106c7a:	89 02                	mov    %eax,(%edx)
+  return 0;
+80106c7c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106c81:	c9                   	leave  
+80106c82:	c3                   	ret    
+
+80106c83 <sys_fork>:
+#include "proc.h"
+
+
+int
+sys_fork(void)
+{
+80106c83:	f3 0f 1e fb          	endbr32 
+80106c87:	55                   	push   %ebp
+80106c88:	89 e5                	mov    %esp,%ebp
+80106c8a:	83 ec 08             	sub    $0x8,%esp
+  return fork();
+80106c8d:	e8 bd dc ff ff       	call   8010494f <fork>
+}
+80106c92:	c9                   	leave  
+80106c93:	c3                   	ret    
+
+80106c94 <sys_exit>:
+
+int
+sys_exit(void)
+{
+80106c94:	f3 0f 1e fb          	endbr32 
+80106c98:	55                   	push   %ebp
+80106c99:	89 e5                	mov    %esp,%ebp
+80106c9b:	83 ec 08             	sub    $0x8,%esp
+  exit();
+80106c9e:	e8 38 de ff ff       	call   80104adb <exit>
+  return 0;  // not reached
+80106ca3:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106ca8:	c9                   	leave  
+80106ca9:	c3                   	ret    
+
+80106caa <sys_wait>:
+
+int
+sys_wait(void)
+{
+80106caa:	f3 0f 1e fb          	endbr32 
+80106cae:	55                   	push   %ebp
+80106caf:	89 e5                	mov    %esp,%ebp
+80106cb1:	83 ec 08             	sub    $0x8,%esp
+  return wait();
+80106cb4:	e8 49 df ff ff       	call   80104c02 <wait>
+}
+80106cb9:	c9                   	leave  
+80106cba:	c3                   	ret    
+
+80106cbb <sys_kill>:
+
+int
+sys_kill(void)
+{
+80106cbb:	f3 0f 1e fb          	endbr32 
+80106cbf:	55                   	push   %ebp
+80106cc0:	89 e5                	mov    %esp,%ebp
+80106cc2:	83 ec 18             	sub    $0x18,%esp
+  int pid;
+
+  if(argint(0, &pid) < 0)
+80106cc5:	83 ec 08             	sub    $0x8,%esp
+80106cc8:	8d 45 f4             	lea    -0xc(%ebp),%eax
+80106ccb:	50                   	push   %eax
+80106ccc:	6a 00                	push   $0x0
+80106cce:	e8 a0 f0 ff ff       	call   80105d73 <argint>
+80106cd3:	83 c4 10             	add    $0x10,%esp
+80106cd6:	85 c0                	test   %eax,%eax
+80106cd8:	79 07                	jns    80106ce1 <sys_kill+0x26>
+    return -1;
+80106cda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106cdf:	eb 0f                	jmp    80106cf0 <sys_kill+0x35>
+  return kill(pid);
+80106ce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106ce4:	83 ec 0c             	sub    $0xc,%esp
+80106ce7:	50                   	push   %eax
+80106ce8:	e8 9e e5 ff ff       	call   8010528b <kill>
+80106ced:	83 c4 10             	add    $0x10,%esp
+}
+80106cf0:	c9                   	leave  
+80106cf1:	c3                   	ret    
+
+80106cf2 <sys_getpid>:
+
+
+int
+sys_getpid(void)
+{
+80106cf2:	f3 0f 1e fb          	endbr32 
+80106cf6:	55                   	push   %ebp
+80106cf7:	89 e5                	mov    %esp,%ebp
+80106cf9:	83 ec 08             	sub    $0x8,%esp
+  return myproc()->pid;
+80106cfc:	e8 a8 d8 ff ff       	call   801045a9 <myproc>
+80106d01:	8b 40 10             	mov    0x10(%eax),%eax
+}
+80106d04:	c9                   	leave  
+80106d05:	c3                   	ret    
+
+80106d06 <sys_sbrk>:
+
+int
+sys_sbrk(void)
+{
+80106d06:	f3 0f 1e fb          	endbr32 
+80106d0a:	55                   	push   %ebp
+80106d0b:	89 e5                	mov    %esp,%ebp
+80106d0d:	83 ec 18             	sub    $0x18,%esp
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+80106d10:	83 ec 08             	sub    $0x8,%esp
+80106d13:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80106d16:	50                   	push   %eax
+80106d17:	6a 00                	push   $0x0
+80106d19:	e8 55 f0 ff ff       	call   80105d73 <argint>
+80106d1e:	83 c4 10             	add    $0x10,%esp
+80106d21:	85 c0                	test   %eax,%eax
+80106d23:	79 07                	jns    80106d2c <sys_sbrk+0x26>
+    return -1;
+80106d25:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106d2a:	eb 28                	jmp    80106d54 <sys_sbrk+0x4e>
+  addr = myproc()->sz;
+80106d2c:	e8 78 d8 ff ff       	call   801045a9 <myproc>
+80106d31:	8b 40 14             	mov    0x14(%eax),%eax
+80106d34:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(growproc(n) < 0)
+80106d37:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106d3a:	83 ec 0c             	sub    $0xc,%esp
+80106d3d:	50                   	push   %eax
+80106d3e:	e8 6b db ff ff       	call   801048ae <growproc>
+80106d43:	83 c4 10             	add    $0x10,%esp
+80106d46:	85 c0                	test   %eax,%eax
+80106d48:	79 07                	jns    80106d51 <sys_sbrk+0x4b>
+    return -1;
+80106d4a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106d4f:	eb 03                	jmp    80106d54 <sys_sbrk+0x4e>
+  return addr;
+80106d51:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80106d54:	c9                   	leave  
+80106d55:	c3                   	ret    
+
+80106d56 <sys_sleep>:
+
+int
+sys_sleep(void)
+{
+80106d56:	f3 0f 1e fb          	endbr32 
+80106d5a:	55                   	push   %ebp
+80106d5b:	89 e5                	mov    %esp,%ebp
+80106d5d:	83 ec 18             	sub    $0x18,%esp
+  int n;
+  uint ticks0;
+
+  if(argint(0, &n) < 0)
+80106d60:	83 ec 08             	sub    $0x8,%esp
+80106d63:	8d 45 f0             	lea    -0x10(%ebp),%eax
+80106d66:	50                   	push   %eax
+80106d67:	6a 00                	push   $0x0
+80106d69:	e8 05 f0 ff ff       	call   80105d73 <argint>
+80106d6e:	83 c4 10             	add    $0x10,%esp
+80106d71:	85 c0                	test   %eax,%eax
+80106d73:	79 07                	jns    80106d7c <sys_sleep+0x26>
+    return -1;
+80106d75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106d7a:	eb 76                	jmp    80106df2 <sys_sleep+0x9c>
+  acquire(&tickslock);
+80106d7c:	83 ec 0c             	sub    $0xc,%esp
+80106d7f:	68 00 75 11 80       	push   $0x80117500
+80106d84:	e8 f3 e9 ff ff       	call   8010577c <acquire>
+80106d89:	83 c4 10             	add    $0x10,%esp
+  ticks0 = ticks;
+80106d8c:	a1 40 7d 11 80       	mov    0x80117d40,%eax
+80106d91:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(ticks - ticks0 < n){
+80106d94:	eb 38                	jmp    80106dce <sys_sleep+0x78>
+    if(myproc()->killed){
+80106d96:	e8 0e d8 ff ff       	call   801045a9 <myproc>
+80106d9b:	8b 40 34             	mov    0x34(%eax),%eax
+80106d9e:	85 c0                	test   %eax,%eax
+80106da0:	74 17                	je     80106db9 <sys_sleep+0x63>
+      release(&tickslock);
+80106da2:	83 ec 0c             	sub    $0xc,%esp
+80106da5:	68 00 75 11 80       	push   $0x80117500
+80106daa:	e8 3f ea ff ff       	call   801057ee <release>
+80106daf:	83 c4 10             	add    $0x10,%esp
+      return -1;
+80106db2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106db7:	eb 39                	jmp    80106df2 <sys_sleep+0x9c>
+    }
+    sleep(&ticks, &tickslock);
+80106db9:	83 ec 08             	sub    $0x8,%esp
+80106dbc:	68 00 75 11 80       	push   $0x80117500
+80106dc1:	68 40 7d 11 80       	push   $0x80117d40
+80106dc6:	e8 93 e3 ff ff       	call   8010515e <sleep>
+80106dcb:	83 c4 10             	add    $0x10,%esp
+  while(ticks - ticks0 < n){
+80106dce:	a1 40 7d 11 80       	mov    0x80117d40,%eax
+80106dd3:	2b 45 f4             	sub    -0xc(%ebp),%eax
+80106dd6:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80106dd9:	39 d0                	cmp    %edx,%eax
+80106ddb:	72 b9                	jb     80106d96 <sys_sleep+0x40>
+  }
+  release(&tickslock);
+80106ddd:	83 ec 0c             	sub    $0xc,%esp
+80106de0:	68 00 75 11 80       	push   $0x80117500
+80106de5:	e8 04 ea ff ff       	call   801057ee <release>
+80106dea:	83 c4 10             	add    $0x10,%esp
+  return 0;
+80106ded:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80106df2:	c9                   	leave  
+80106df3:	c3                   	ret    
+
+80106df4 <sys_uptime>:
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+80106df4:	f3 0f 1e fb          	endbr32 
+80106df8:	55                   	push   %ebp
+80106df9:	89 e5                	mov    %esp,%ebp
+80106dfb:	83 ec 18             	sub    $0x18,%esp
+  uint xticks;
+
+  acquire(&tickslock);
+80106dfe:	83 ec 0c             	sub    $0xc,%esp
+80106e01:	68 00 75 11 80       	push   $0x80117500
+80106e06:	e8 71 e9 ff ff       	call   8010577c <acquire>
+80106e0b:	83 c4 10             	add    $0x10,%esp
+  xticks = ticks;
+80106e0e:	a1 40 7d 11 80       	mov    0x80117d40,%eax
+80106e13:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  release(&tickslock);
+80106e16:	83 ec 0c             	sub    $0xc,%esp
+80106e19:	68 00 75 11 80       	push   $0x80117500
+80106e1e:	e8 cb e9 ff ff       	call   801057ee <release>
+80106e23:	83 c4 10             	add    $0x10,%esp
+  return xticks;
+80106e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+80106e29:	c9                   	leave  
+80106e2a:	c3                   	ret    
+
+80106e2b <sys_draw>:
+
+int sys_draw(void)
+{
+80106e2b:	f3 0f 1e fb          	endbr32 
+80106e2f:	55                   	push   %ebp
+80106e30:	89 e5                	mov    %esp,%ebp
+80106e32:	83 ec 28             	sub    $0x28,%esp
+  char *buffer;
+  int size;
+  char *wolf = "               \t\t\t,ood8888booo,\n\
+80106e35:	c7 45 ec b4 92 10 80 	movl   $0x801092b4,-0x14(%ebp)
+                    `Y  b      8o  $$o      d  b        b   $o\n\
+                     8   '$     8$,,$\"      $   $o      '$o$$\n\
+                      $o$$P\"                 $$o$\n\n";
+  // Fetch the 1st 32 bit call argument and assign it to the variable size i.e.the max-size of the buffer
+  // Return -1 if an invalid address is accessed
+  if (argint(1, &size) == -1)
+80106e3c:	83 ec 08             	sub    $0x8,%esp
+80106e3f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+80106e42:	50                   	push   %eax
+80106e43:	6a 01                	push   $0x1
+80106e45:	e8 29 ef ff ff       	call   80105d73 <argint>
+80106e4a:	83 c4 10             	add    $0x10,%esp
+80106e4d:	83 f8 ff             	cmp    $0xffffffff,%eax
+80106e50:	75 07                	jne    80106e59 <sys_draw+0x2e>
+  {
+    return -1;
+80106e52:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106e57:	eb 79                	jmp    80106ed2 <sys_draw+0xa7>
+  }
+  // Fetch the 0th word-sized system call argument as a pointer
+  // to a block of memory of size bytes.Check that the pointer
+  // lies within the process address space if it does not then return -1.
+  if (argptr(0, (char **)&buffer, size) == -1)
+80106e59:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106e5c:	83 ec 04             	sub    $0x4,%esp
+80106e5f:	50                   	push   %eax
+80106e60:	8d 45 e8             	lea    -0x18(%ebp),%eax
+80106e63:	50                   	push   %eax
+80106e64:	6a 00                	push   $0x0
+80106e66:	e8 39 ef ff ff       	call   80105da4 <argptr>
+80106e6b:	83 c4 10             	add    $0x10,%esp
+80106e6e:	83 f8 ff             	cmp    $0xffffffff,%eax
+80106e71:	75 07                	jne    80106e7a <sys_draw+0x4f>
+  {
+    return -1;
+80106e73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106e78:	eb 58                	jmp    80106ed2 <sys_draw+0xa7>
+  }
+  //Find the size of the wolfie picture;
+  int wolfsize = 0;
+80106e7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  while (wolf[wolfsize] != '\0')
+80106e81:	eb 04                	jmp    80106e87 <sys_draw+0x5c>
+  {
+    wolfsize++;
+80106e83:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  while (wolf[wolfsize] != '\0')
+80106e87:	8b 55 f4             	mov    -0xc(%ebp),%edx
+80106e8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80106e8d:	01 d0                	add    %edx,%eax
+80106e8f:	0f b6 00             	movzbl (%eax),%eax
+80106e92:	84 c0                	test   %al,%al
+80106e94:	75 ed                	jne    80106e83 <sys_draw+0x58>
+  }
+  if (wolfsize > size)
+80106e96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+80106e99:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+80106e9c:	7e 07                	jle    80106ea5 <sys_draw+0x7a>
+  {
+    //If the size of wolfie picture is greater than max size of the buffer return -1
+    return -1;
+80106e9e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80106ea3:	eb 2d                	jmp    80106ed2 <sys_draw+0xa7>
+  }
+  //copy the wolfie picture to the buffer
+  for (int i = 0; i < wolfsize; i++)
+80106ea5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+80106eac:	eb 19                	jmp    80106ec7 <sys_draw+0x9c>
+  {
+    buffer[i] = wolf[i];
+80106eae:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80106eb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80106eb4:	01 d0                	add    %edx,%eax
+80106eb6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+80106eb9:	8b 55 f0             	mov    -0x10(%ebp),%edx
+80106ebc:	01 ca                	add    %ecx,%edx
+80106ebe:	0f b6 00             	movzbl (%eax),%eax
+80106ec1:	88 02                	mov    %al,(%edx)
+  for (int i = 0; i < wolfsize; i++)
+80106ec3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+80106ec7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80106eca:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+80106ecd:	7c df                	jl     80106eae <sys_draw+0x83>
+  }
+  //return the size of wolfie pictue
+  return wolfsize;
+80106ecf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106ed2:	c9                   	leave  
+80106ed3:	c3                   	ret    
+
+80106ed4 <alltraps>:
+
+  # vectors.S sends all traps here.
+.globl alltraps
+alltraps:
+  # Build trap frame.
+  pushl %ds
+80106ed4:	1e                   	push   %ds
+  pushl %es
+80106ed5:	06                   	push   %es
+  pushl %fs
+80106ed6:	0f a0                	push   %fs
+  pushl %gs
+80106ed8:	0f a8                	push   %gs
+  pushal
+80106eda:	60                   	pusha  
+  
+  # Set up data segments.
+  movw $(SEG_KDATA<<3), %ax
+80106edb:	66 b8 10 00          	mov    $0x10,%ax
+  movw %ax, %ds
+80106edf:	8e d8                	mov    %eax,%ds
+  movw %ax, %es
+80106ee1:	8e c0                	mov    %eax,%es
+
+  # Call trap(tf), where tf=%esp
+  pushl %esp
+80106ee3:	54                   	push   %esp
+  call trap
+80106ee4:	e8 df 01 00 00       	call   801070c8 <trap>
+  addl $4, %esp
+80106ee9:	83 c4 04             	add    $0x4,%esp
+
+80106eec <trapret>:
+
+  # Return falls through to trapret...
+.globl trapret
+trapret:
+  popal
+80106eec:	61                   	popa   
+  popl %gs
+80106eed:	0f a9                	pop    %gs
+  popl %fs
+80106eef:	0f a1                	pop    %fs
+  popl %es
+80106ef1:	07                   	pop    %es
+  popl %ds
+80106ef2:	1f                   	pop    %ds
+  addl $0x8, %esp  # trapno and errcode
+80106ef3:	83 c4 08             	add    $0x8,%esp
+  iret
+80106ef6:	cf                   	iret   
+
+80106ef7 <lidt>:
+{
+80106ef7:	55                   	push   %ebp
+80106ef8:	89 e5                	mov    %esp,%ebp
+80106efa:	83 ec 10             	sub    $0x10,%esp
+  pd[0] = size-1;
+80106efd:	8b 45 0c             	mov    0xc(%ebp),%eax
+80106f00:	83 e8 01             	sub    $0x1,%eax
+80106f03:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+  pd[1] = (uint)p;
+80106f07:	8b 45 08             	mov    0x8(%ebp),%eax
+80106f0a:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  pd[2] = (uint)p >> 16;
+80106f0e:	8b 45 08             	mov    0x8(%ebp),%eax
+80106f11:	c1 e8 10             	shr    $0x10,%eax
+80106f14:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
+  asm volatile("lidt (%0)" : : "r" (pd));
+80106f18:	8d 45 fa             	lea    -0x6(%ebp),%eax
+80106f1b:	0f 01 18             	lidtl  (%eax)
+}
+80106f1e:	90                   	nop
+80106f1f:	c9                   	leave  
+80106f20:	c3                   	ret    
+
+80106f21 <rcr2>:
+
+static inline uint
+rcr2(void)
+{
+80106f21:	55                   	push   %ebp
+80106f22:	89 e5                	mov    %esp,%ebp
+80106f24:	83 ec 10             	sub    $0x10,%esp
+  uint val;
+  asm volatile("movl %%cr2,%0" : "=r" (val));
+80106f27:	0f 20 d0             	mov    %cr2,%eax
+80106f2a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  return val;
+80106f2d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+80106f30:	c9                   	leave  
+80106f31:	c3                   	ret    
+
+80106f32 <tvinit>:
+extern int inctickcounter(void);
+extern void decpriority(void);
+
+void
+tvinit(void)
+{
+80106f32:	f3 0f 1e fb          	endbr32 
+80106f36:	55                   	push   %ebp
+80106f37:	89 e5                	mov    %esp,%ebp
+80106f39:	83 ec 18             	sub    $0x18,%esp
+  int i;
+
+  for(i = 0; i < 256; i++)
+80106f3c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80106f43:	e9 c3 00 00 00       	jmp    8010700b <tvinit+0xd9>
+    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+80106f48:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106f4b:	8b 04 85 8c c0 10 80 	mov    -0x7fef3f74(,%eax,4),%eax
+80106f52:	89 c2                	mov    %eax,%edx
+80106f54:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106f57:	66 89 14 c5 40 75 11 	mov    %dx,-0x7fee8ac0(,%eax,8)
+80106f5e:	80 
+80106f5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106f62:	66 c7 04 c5 42 75 11 	movw   $0x8,-0x7fee8abe(,%eax,8)
+80106f69:	80 08 00 
+80106f6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106f6f:	0f b6 14 c5 44 75 11 	movzbl -0x7fee8abc(,%eax,8),%edx
+80106f76:	80 
+80106f77:	83 e2 e0             	and    $0xffffffe0,%edx
+80106f7a:	88 14 c5 44 75 11 80 	mov    %dl,-0x7fee8abc(,%eax,8)
+80106f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106f84:	0f b6 14 c5 44 75 11 	movzbl -0x7fee8abc(,%eax,8),%edx
+80106f8b:	80 
+80106f8c:	83 e2 1f             	and    $0x1f,%edx
+80106f8f:	88 14 c5 44 75 11 80 	mov    %dl,-0x7fee8abc(,%eax,8)
+80106f96:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106f99:	0f b6 14 c5 45 75 11 	movzbl -0x7fee8abb(,%eax,8),%edx
+80106fa0:	80 
+80106fa1:	83 e2 f0             	and    $0xfffffff0,%edx
+80106fa4:	83 ca 0e             	or     $0xe,%edx
+80106fa7:	88 14 c5 45 75 11 80 	mov    %dl,-0x7fee8abb(,%eax,8)
+80106fae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106fb1:	0f b6 14 c5 45 75 11 	movzbl -0x7fee8abb(,%eax,8),%edx
+80106fb8:	80 
+80106fb9:	83 e2 ef             	and    $0xffffffef,%edx
+80106fbc:	88 14 c5 45 75 11 80 	mov    %dl,-0x7fee8abb(,%eax,8)
+80106fc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106fc6:	0f b6 14 c5 45 75 11 	movzbl -0x7fee8abb(,%eax,8),%edx
+80106fcd:	80 
+80106fce:	83 e2 9f             	and    $0xffffff9f,%edx
+80106fd1:	88 14 c5 45 75 11 80 	mov    %dl,-0x7fee8abb(,%eax,8)
+80106fd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106fdb:	0f b6 14 c5 45 75 11 	movzbl -0x7fee8abb(,%eax,8),%edx
+80106fe2:	80 
+80106fe3:	83 ca 80             	or     $0xffffff80,%edx
+80106fe6:	88 14 c5 45 75 11 80 	mov    %dl,-0x7fee8abb(,%eax,8)
+80106fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106ff0:	8b 04 85 8c c0 10 80 	mov    -0x7fef3f74(,%eax,4),%eax
+80106ff7:	c1 e8 10             	shr    $0x10,%eax
+80106ffa:	89 c2                	mov    %eax,%edx
+80106ffc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80106fff:	66 89 14 c5 46 75 11 	mov    %dx,-0x7fee8aba(,%eax,8)
+80107006:	80 
+  for(i = 0; i < 256; i++)
+80107007:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+8010700b:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
+80107012:	0f 8e 30 ff ff ff    	jle    80106f48 <tvinit+0x16>
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+80107018:	a1 8c c1 10 80       	mov    0x8010c18c,%eax
+8010701d:	66 a3 40 77 11 80    	mov    %ax,0x80117740
+80107023:	66 c7 05 42 77 11 80 	movw   $0x8,0x80117742
+8010702a:	08 00 
+8010702c:	0f b6 05 44 77 11 80 	movzbl 0x80117744,%eax
+80107033:	83 e0 e0             	and    $0xffffffe0,%eax
+80107036:	a2 44 77 11 80       	mov    %al,0x80117744
+8010703b:	0f b6 05 44 77 11 80 	movzbl 0x80117744,%eax
+80107042:	83 e0 1f             	and    $0x1f,%eax
+80107045:	a2 44 77 11 80       	mov    %al,0x80117744
+8010704a:	0f b6 05 45 77 11 80 	movzbl 0x80117745,%eax
+80107051:	83 c8 0f             	or     $0xf,%eax
+80107054:	a2 45 77 11 80       	mov    %al,0x80117745
+80107059:	0f b6 05 45 77 11 80 	movzbl 0x80117745,%eax
+80107060:	83 e0 ef             	and    $0xffffffef,%eax
+80107063:	a2 45 77 11 80       	mov    %al,0x80117745
+80107068:	0f b6 05 45 77 11 80 	movzbl 0x80117745,%eax
+8010706f:	83 c8 60             	or     $0x60,%eax
+80107072:	a2 45 77 11 80       	mov    %al,0x80117745
+80107077:	0f b6 05 45 77 11 80 	movzbl 0x80117745,%eax
+8010707e:	83 c8 80             	or     $0xffffff80,%eax
+80107081:	a2 45 77 11 80       	mov    %al,0x80117745
+80107086:	a1 8c c1 10 80       	mov    0x8010c18c,%eax
+8010708b:	c1 e8 10             	shr    $0x10,%eax
+8010708e:	66 a3 46 77 11 80    	mov    %ax,0x80117746
+
+  initlock(&tickslock, "time");
+80107094:	83 ec 08             	sub    $0x8,%esp
+80107097:	68 e0 98 10 80       	push   $0x801098e0
+8010709c:	68 00 75 11 80       	push   $0x80117500
+801070a1:	e8 b0 e6 ff ff       	call   80105756 <initlock>
+801070a6:	83 c4 10             	add    $0x10,%esp
+}
+801070a9:	90                   	nop
+801070aa:	c9                   	leave  
+801070ab:	c3                   	ret    
+
+801070ac <idtinit>:
+
+void
+idtinit(void)
+{
+801070ac:	f3 0f 1e fb          	endbr32 
+801070b0:	55                   	push   %ebp
+801070b1:	89 e5                	mov    %esp,%ebp
+  lidt(idt, sizeof(idt));
+801070b3:	68 00 08 00 00       	push   $0x800
+801070b8:	68 40 75 11 80       	push   $0x80117540
+801070bd:	e8 35 fe ff ff       	call   80106ef7 <lidt>
+801070c2:	83 c4 08             	add    $0x8,%esp
+}
+801070c5:	90                   	nop
+801070c6:	c9                   	leave  
+801070c7:	c3                   	ret    
+
+801070c8 <trap>:
+
+//PAGEBREAK: 41
+void
+trap(struct trapframe *tf)
+{
+801070c8:	f3 0f 1e fb          	endbr32 
+801070cc:	55                   	push   %ebp
+801070cd:	89 e5                	mov    %esp,%ebp
+801070cf:	57                   	push   %edi
+801070d0:	56                   	push   %esi
+801070d1:	53                   	push   %ebx
+801070d2:	83 ec 1c             	sub    $0x1c,%esp
+  if(tf->trapno == T_SYSCALL){
+801070d5:	8b 45 08             	mov    0x8(%ebp),%eax
+801070d8:	8b 40 30             	mov    0x30(%eax),%eax
+801070db:	83 f8 40             	cmp    $0x40,%eax
+801070de:	75 3b                	jne    8010711b <trap+0x53>
+    if(myproc()->killed)
+801070e0:	e8 c4 d4 ff ff       	call   801045a9 <myproc>
+801070e5:	8b 40 34             	mov    0x34(%eax),%eax
+801070e8:	85 c0                	test   %eax,%eax
+801070ea:	74 05                	je     801070f1 <trap+0x29>
+      exit();
+801070ec:	e8 ea d9 ff ff       	call   80104adb <exit>
+    myproc()->tf = tf;
+801070f1:	e8 b3 d4 ff ff       	call   801045a9 <myproc>
+801070f6:	8b 55 08             	mov    0x8(%ebp),%edx
+801070f9:	89 50 28             	mov    %edx,0x28(%eax)
+    syscall();
+801070fc:	e8 4c ed ff ff       	call   80105e4d <syscall>
+    if(myproc()->killed)
+80107101:	e8 a3 d4 ff ff       	call   801045a9 <myproc>
+80107106:	8b 40 34             	mov    0x34(%eax),%eax
+80107109:	85 c0                	test   %eax,%eax
+8010710b:	0f 84 22 02 00 00    	je     80107333 <trap+0x26b>
+      exit();
+80107111:	e8 c5 d9 ff ff       	call   80104adb <exit>
+    return;
+80107116:	e9 18 02 00 00       	jmp    80107333 <trap+0x26b>
+  }
+
+  switch(tf->trapno){
+8010711b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010711e:	8b 40 30             	mov    0x30(%eax),%eax
+80107121:	83 e8 20             	sub    $0x20,%eax
+80107124:	83 f8 1f             	cmp    $0x1f,%eax
+80107127:	0f 87 bb 00 00 00    	ja     801071e8 <trap+0x120>
+8010712d:	8b 04 85 88 99 10 80 	mov    -0x7fef6678(,%eax,4),%eax
+80107134:	3e ff e0             	notrack jmp *%eax
+  case T_IRQ0 + IRQ_TIMER:
+    if(cpuid() == 0){
+80107137:	e8 d2 d3 ff ff       	call   8010450e <cpuid>
+8010713c:	85 c0                	test   %eax,%eax
+8010713e:	75 42                	jne    80107182 <trap+0xba>
+      acquire(&tickslock);
+80107140:	83 ec 0c             	sub    $0xc,%esp
+80107143:	68 00 75 11 80       	push   $0x80117500
+80107148:	e8 2f e6 ff ff       	call   8010577c <acquire>
+8010714d:	83 c4 10             	add    $0x10,%esp
+      ticks++;
+80107150:	a1 40 7d 11 80       	mov    0x80117d40,%eax
+80107155:	83 c0 01             	add    $0x1,%eax
+80107158:	a3 40 7d 11 80       	mov    %eax,0x80117d40
+      updatestatistics(); //will update proc statistic every clock tick
+8010715d:	e8 b2 e2 ff ff       	call   80105414 <updatestatistics>
+      wakeup(&ticks);
+80107162:	83 ec 0c             	sub    $0xc,%esp
+80107165:	68 40 7d 11 80       	push   $0x80117d40
+8010716a:	e8 e1 e0 ff ff       	call   80105250 <wakeup>
+8010716f:	83 c4 10             	add    $0x10,%esp
+      release(&tickslock);
+80107172:	83 ec 0c             	sub    $0xc,%esp
+80107175:	68 00 75 11 80       	push   $0x80117500
+8010717a:	e8 6f e6 ff ff       	call   801057ee <release>
+8010717f:	83 c4 10             	add    $0x10,%esp
+    }
+    lapiceoi();
+80107182:	e8 9e bf ff ff       	call   80103125 <lapiceoi>
+    break;
+80107187:	e9 0e 01 00 00       	jmp    8010729a <trap+0x1d2>
+  case T_IRQ0 + IRQ_IDE:
+    ideintr();
+8010718c:	e8 c9 b7 ff ff       	call   8010295a <ideintr>
+    lapiceoi();
+80107191:	e8 8f bf ff ff       	call   80103125 <lapiceoi>
+    break;
+80107196:	e9 ff 00 00 00       	jmp    8010729a <trap+0x1d2>
+  case T_IRQ0 + IRQ_IDE+1:
+    // Bochs generates spurious IDE1 interrupts.
+    break;
+  case T_IRQ0 + IRQ_KBD:
+    kbdintr();
+8010719b:	e8 bb bd ff ff       	call   80102f5b <kbdintr>
+    lapiceoi();
+801071a0:	e8 80 bf ff ff       	call   80103125 <lapiceoi>
+    break;
+801071a5:	e9 f0 00 00 00       	jmp    8010729a <trap+0x1d2>
+  case T_IRQ0 + IRQ_COM1:
+    uartintr();
+801071aa:	e8 66 03 00 00       	call   80107515 <uartintr>
+    lapiceoi();
+801071af:	e8 71 bf ff ff       	call   80103125 <lapiceoi>
+    break;
+801071b4:	e9 e1 00 00 00       	jmp    8010729a <trap+0x1d2>
+  case T_IRQ0 + 7:
+  case T_IRQ0 + IRQ_SPURIOUS:
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+801071b9:	8b 45 08             	mov    0x8(%ebp),%eax
+801071bc:	8b 70 38             	mov    0x38(%eax),%esi
+            cpuid(), tf->cs, tf->eip);
+801071bf:	8b 45 08             	mov    0x8(%ebp),%eax
+801071c2:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+801071c6:	0f b7 d8             	movzwl %ax,%ebx
+801071c9:	e8 40 d3 ff ff       	call   8010450e <cpuid>
+801071ce:	56                   	push   %esi
+801071cf:	53                   	push   %ebx
+801071d0:	50                   	push   %eax
+801071d1:	68 e8 98 10 80       	push   $0x801098e8
+801071d6:	e8 3d 92 ff ff       	call   80100418 <cprintf>
+801071db:	83 c4 10             	add    $0x10,%esp
+    lapiceoi();
+801071de:	e8 42 bf ff ff       	call   80103125 <lapiceoi>
+    break;
+801071e3:	e9 b2 00 00 00       	jmp    8010729a <trap+0x1d2>
+
+  //PAGEBREAK: 13
+  default:
+    if(myproc() == 0 || (tf->cs&3) == 0){
+801071e8:	e8 bc d3 ff ff       	call   801045a9 <myproc>
+801071ed:	85 c0                	test   %eax,%eax
+801071ef:	74 11                	je     80107202 <trap+0x13a>
+801071f1:	8b 45 08             	mov    0x8(%ebp),%eax
+801071f4:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+801071f8:	0f b7 c0             	movzwl %ax,%eax
+801071fb:	83 e0 03             	and    $0x3,%eax
+801071fe:	85 c0                	test   %eax,%eax
+80107200:	75 39                	jne    8010723b <trap+0x173>
+      // In kernel, it must be our mistake.
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+80107202:	e8 1a fd ff ff       	call   80106f21 <rcr2>
+80107207:	89 c3                	mov    %eax,%ebx
+80107209:	8b 45 08             	mov    0x8(%ebp),%eax
+8010720c:	8b 70 38             	mov    0x38(%eax),%esi
+8010720f:	e8 fa d2 ff ff       	call   8010450e <cpuid>
+80107214:	8b 55 08             	mov    0x8(%ebp),%edx
+80107217:	8b 52 30             	mov    0x30(%edx),%edx
+8010721a:	83 ec 0c             	sub    $0xc,%esp
+8010721d:	53                   	push   %ebx
+8010721e:	56                   	push   %esi
+8010721f:	50                   	push   %eax
+80107220:	52                   	push   %edx
+80107221:	68 0c 99 10 80       	push   $0x8010990c
+80107226:	e8 ed 91 ff ff       	call   80100418 <cprintf>
+8010722b:	83 c4 20             	add    $0x20,%esp
+              tf->trapno, cpuid(), tf->eip, rcr2());
+      panic("trap");
+8010722e:	83 ec 0c             	sub    $0xc,%esp
+80107231:	68 3e 99 10 80       	push   $0x8010993e
+80107236:	e8 96 93 ff ff       	call   801005d1 <panic>
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+8010723b:	e8 e1 fc ff ff       	call   80106f21 <rcr2>
+80107240:	89 c6                	mov    %eax,%esi
+80107242:	8b 45 08             	mov    0x8(%ebp),%eax
+80107245:	8b 40 38             	mov    0x38(%eax),%eax
+80107248:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+8010724b:	e8 be d2 ff ff       	call   8010450e <cpuid>
+80107250:	89 c3                	mov    %eax,%ebx
+80107252:	8b 45 08             	mov    0x8(%ebp),%eax
+80107255:	8b 48 34             	mov    0x34(%eax),%ecx
+80107258:	89 4d e0             	mov    %ecx,-0x20(%ebp)
+8010725b:	8b 45 08             	mov    0x8(%ebp),%eax
+8010725e:	8b 78 30             	mov    0x30(%eax),%edi
+            "eip 0x%x addr 0x%x--kill proc\n",
+            myproc()->pid, myproc()->name, tf->trapno,
+80107261:	e8 43 d3 ff ff       	call   801045a9 <myproc>
+80107266:	89 45 dc             	mov    %eax,-0x24(%ebp)
+80107269:	e8 3b d3 ff ff       	call   801045a9 <myproc>
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+8010726e:	8b 40 10             	mov    0x10(%eax),%eax
+80107271:	56                   	push   %esi
+80107272:	ff 75 e4             	pushl  -0x1c(%ebp)
+80107275:	53                   	push   %ebx
+80107276:	ff 75 e0             	pushl  -0x20(%ebp)
+80107279:	57                   	push   %edi
+8010727a:	ff 75 dc             	pushl  -0x24(%ebp)
+8010727d:	50                   	push   %eax
+8010727e:	68 44 99 10 80       	push   $0x80109944
+80107283:	e8 90 91 ff ff       	call   80100418 <cprintf>
+80107288:	83 c4 20             	add    $0x20,%esp
+            tf->err, cpuid(), tf->eip, rcr2());
+    myproc()->killed = 1;
+8010728b:	e8 19 d3 ff ff       	call   801045a9 <myproc>
+80107290:	c7 40 34 01 00 00 00 	movl   $0x1,0x34(%eax)
+80107297:	eb 01                	jmp    8010729a <trap+0x1d2>
+    break;
+80107299:	90                   	nop
+  }
+
+  // Force process exit if it has been killed and is in user space.
+  // (If it is still executing in the kernel, let it keep running
+  // until it gets to the regular system call return.)
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+8010729a:	e8 0a d3 ff ff       	call   801045a9 <myproc>
+8010729f:	85 c0                	test   %eax,%eax
+801072a1:	74 23                	je     801072c6 <trap+0x1fe>
+801072a3:	e8 01 d3 ff ff       	call   801045a9 <myproc>
+801072a8:	8b 40 34             	mov    0x34(%eax),%eax
+801072ab:	85 c0                	test   %eax,%eax
+801072ad:	74 17                	je     801072c6 <trap+0x1fe>
+801072af:	8b 45 08             	mov    0x8(%ebp),%eax
+801072b2:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+801072b6:	0f b7 c0             	movzwl %ax,%eax
+801072b9:	83 e0 03             	and    $0x3,%eax
+801072bc:	83 f8 03             	cmp    $0x3,%eax
+801072bf:	75 05                	jne    801072c6 <trap+0x1fe>
+    exit();
+801072c1:	e8 15 d8 ff ff       	call   80104adb <exit>
+
+#ifdef DEFAULT
+  // Round Robin with time quanta = QUANTA (default = 5)
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if(myproc() && myproc()->state == RUNNING &&
+801072c6:	e8 de d2 ff ff       	call   801045a9 <myproc>
+801072cb:	85 c0                	test   %eax,%eax
+801072cd:	74 36                	je     80107305 <trap+0x23d>
+801072cf:	e8 d5 d2 ff ff       	call   801045a9 <myproc>
+801072d4:	8b 40 20             	mov    0x20(%eax),%eax
+801072d7:	83 f8 04             	cmp    $0x4,%eax
+801072da:	75 29                	jne    80107305 <trap+0x23d>
+     tf->trapno == T_IRQ0+IRQ_TIMER && inctickcounter() == QUANTA){
+801072dc:	8b 45 08             	mov    0x8(%ebp),%eax
+801072df:	8b 40 30             	mov    0x30(%eax),%eax
+  if(myproc() && myproc()->state == RUNNING &&
+801072e2:	83 f8 20             	cmp    $0x20,%eax
+801072e5:	75 1e                	jne    80107305 <trap+0x23d>
+     tf->trapno == T_IRQ0+IRQ_TIMER && inctickcounter() == QUANTA){
+801072e7:	e8 8b e2 ff ff       	call   80105577 <inctickcounter>
+801072ec:	83 f8 0a             	cmp    $0xa,%eax
+801072ef:	75 14                	jne    80107305 <trap+0x23d>
+    myproc()->tickcounter = 0;
+801072f1:	e8 b3 d2 ff ff       	call   801045a9 <myproc>
+801072f6:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
+801072fd:	00 00 00 
+    yield();
+80107300:	e8 14 dd ff ff       	call   80105019 <yield>
+#endif
+#endif
+
+
+  // Check if the process has been killed since we yielded
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+80107305:	e8 9f d2 ff ff       	call   801045a9 <myproc>
+8010730a:	85 c0                	test   %eax,%eax
+8010730c:	74 26                	je     80107334 <trap+0x26c>
+8010730e:	e8 96 d2 ff ff       	call   801045a9 <myproc>
+80107313:	8b 40 34             	mov    0x34(%eax),%eax
+80107316:	85 c0                	test   %eax,%eax
+80107318:	74 1a                	je     80107334 <trap+0x26c>
+8010731a:	8b 45 08             	mov    0x8(%ebp),%eax
+8010731d:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+80107321:	0f b7 c0             	movzwl %ax,%eax
+80107324:	83 e0 03             	and    $0x3,%eax
+80107327:	83 f8 03             	cmp    $0x3,%eax
+8010732a:	75 08                	jne    80107334 <trap+0x26c>
+    exit();
+8010732c:	e8 aa d7 ff ff       	call   80104adb <exit>
+80107331:	eb 01                	jmp    80107334 <trap+0x26c>
+    return;
+80107333:	90                   	nop
+}
+80107334:	8d 65 f4             	lea    -0xc(%ebp),%esp
+80107337:	5b                   	pop    %ebx
+80107338:	5e                   	pop    %esi
+80107339:	5f                   	pop    %edi
+8010733a:	5d                   	pop    %ebp
+8010733b:	c3                   	ret    
+
+8010733c <inb>:
+{
+8010733c:	55                   	push   %ebp
+8010733d:	89 e5                	mov    %esp,%ebp
+8010733f:	83 ec 14             	sub    $0x14,%esp
+80107342:	8b 45 08             	mov    0x8(%ebp),%eax
+80107345:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+80107349:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+8010734d:	89 c2                	mov    %eax,%edx
+8010734f:	ec                   	in     (%dx),%al
+80107350:	88 45 ff             	mov    %al,-0x1(%ebp)
+  return data;
+80107353:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
+}
+80107357:	c9                   	leave  
+80107358:	c3                   	ret    
+
+80107359 <outb>:
+{
+80107359:	55                   	push   %ebp
+8010735a:	89 e5                	mov    %esp,%ebp
+8010735c:	83 ec 08             	sub    $0x8,%esp
+8010735f:	8b 45 08             	mov    0x8(%ebp),%eax
+80107362:	8b 55 0c             	mov    0xc(%ebp),%edx
+80107365:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+80107369:	89 d0                	mov    %edx,%eax
+8010736b:	88 45 f8             	mov    %al,-0x8(%ebp)
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+8010736e:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
+80107372:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
+80107376:	ee                   	out    %al,(%dx)
+}
+80107377:	90                   	nop
+80107378:	c9                   	leave  
+80107379:	c3                   	ret    
+
+8010737a <uartinit>:
+
+static int uart;    // is there a uart?
+
+void
+uartinit(void)
+{
+8010737a:	f3 0f 1e fb          	endbr32 
+8010737e:	55                   	push   %ebp
+8010737f:	89 e5                	mov    %esp,%ebp
+80107381:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+
+  // Turn off the FIFO
+  outb(COM1+2, 0);
+80107384:	6a 00                	push   $0x0
+80107386:	68 fa 03 00 00       	push   $0x3fa
+8010738b:	e8 c9 ff ff ff       	call   80107359 <outb>
+80107390:	83 c4 08             	add    $0x8,%esp
+
+  // 9600 baud, 8 data bits, 1 stop bit, parity off.
+  outb(COM1+3, 0x80);    // Unlock divisor
+80107393:	68 80 00 00 00       	push   $0x80
+80107398:	68 fb 03 00 00       	push   $0x3fb
+8010739d:	e8 b7 ff ff ff       	call   80107359 <outb>
+801073a2:	83 c4 08             	add    $0x8,%esp
+  outb(COM1+0, 115200/9600);
+801073a5:	6a 0c                	push   $0xc
+801073a7:	68 f8 03 00 00       	push   $0x3f8
+801073ac:	e8 a8 ff ff ff       	call   80107359 <outb>
+801073b1:	83 c4 08             	add    $0x8,%esp
+  outb(COM1+1, 0);
+801073b4:	6a 00                	push   $0x0
+801073b6:	68 f9 03 00 00       	push   $0x3f9
+801073bb:	e8 99 ff ff ff       	call   80107359 <outb>
+801073c0:	83 c4 08             	add    $0x8,%esp
+  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
+801073c3:	6a 03                	push   $0x3
+801073c5:	68 fb 03 00 00       	push   $0x3fb
+801073ca:	e8 8a ff ff ff       	call   80107359 <outb>
+801073cf:	83 c4 08             	add    $0x8,%esp
+  outb(COM1+4, 0);
+801073d2:	6a 00                	push   $0x0
+801073d4:	68 fc 03 00 00       	push   $0x3fc
+801073d9:	e8 7b ff ff ff       	call   80107359 <outb>
+801073de:	83 c4 08             	add    $0x8,%esp
+  outb(COM1+1, 0x01);    // Enable receive interrupts.
+801073e1:	6a 01                	push   $0x1
+801073e3:	68 f9 03 00 00       	push   $0x3f9
+801073e8:	e8 6c ff ff ff       	call   80107359 <outb>
+801073ed:	83 c4 08             	add    $0x8,%esp
+
+  // If status is 0xFF, no serial port.
+  if(inb(COM1+5) == 0xFF)
+801073f0:	68 fd 03 00 00       	push   $0x3fd
+801073f5:	e8 42 ff ff ff       	call   8010733c <inb>
+801073fa:	83 c4 04             	add    $0x4,%esp
+801073fd:	3c ff                	cmp    $0xff,%al
+801073ff:	74 61                	je     80107462 <uartinit+0xe8>
+    return;
+  uart = 1;
+80107401:	c7 05 48 c6 10 80 01 	movl   $0x1,0x8010c648
+80107408:	00 00 00 
+
+  // Acknowledge pre-existing interrupt conditions;
+  // enable interrupts.
+  inb(COM1+2);
+8010740b:	68 fa 03 00 00       	push   $0x3fa
+80107410:	e8 27 ff ff ff       	call   8010733c <inb>
+80107415:	83 c4 04             	add    $0x4,%esp
+  inb(COM1+0);
+80107418:	68 f8 03 00 00       	push   $0x3f8
+8010741d:	e8 1a ff ff ff       	call   8010733c <inb>
+80107422:	83 c4 04             	add    $0x4,%esp
+  ioapicenable(IRQ_COM1, 0);
+80107425:	83 ec 08             	sub    $0x8,%esp
+80107428:	6a 00                	push   $0x0
+8010742a:	6a 04                	push   $0x4
+8010742c:	e8 db b7 ff ff       	call   80102c0c <ioapicenable>
+80107431:	83 c4 10             	add    $0x10,%esp
+
+  // Announce that we're here.
+  for(p="xv6...\n"; *p; p++)
+80107434:	c7 45 f4 08 9a 10 80 	movl   $0x80109a08,-0xc(%ebp)
+8010743b:	eb 19                	jmp    80107456 <uartinit+0xdc>
+    uartputc(*p);
+8010743d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107440:	0f b6 00             	movzbl (%eax),%eax
+80107443:	0f be c0             	movsbl %al,%eax
+80107446:	83 ec 0c             	sub    $0xc,%esp
+80107449:	50                   	push   %eax
+8010744a:	e8 16 00 00 00       	call   80107465 <uartputc>
+8010744f:	83 c4 10             	add    $0x10,%esp
+  for(p="xv6...\n"; *p; p++)
+80107452:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80107456:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80107459:	0f b6 00             	movzbl (%eax),%eax
+8010745c:	84 c0                	test   %al,%al
+8010745e:	75 dd                	jne    8010743d <uartinit+0xc3>
+80107460:	eb 01                	jmp    80107463 <uartinit+0xe9>
+    return;
+80107462:	90                   	nop
+}
+80107463:	c9                   	leave  
+80107464:	c3                   	ret    
+
+80107465 <uartputc>:
+
+void
+uartputc(int c)
+{
+80107465:	f3 0f 1e fb          	endbr32 
+80107469:	55                   	push   %ebp
+8010746a:	89 e5                	mov    %esp,%ebp
+8010746c:	83 ec 18             	sub    $0x18,%esp
+  int i;
+
+  if(!uart)
+8010746f:	a1 48 c6 10 80       	mov    0x8010c648,%eax
+80107474:	85 c0                	test   %eax,%eax
+80107476:	74 53                	je     801074cb <uartputc+0x66>
+    return;
+  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+80107478:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+8010747f:	eb 11                	jmp    80107492 <uartputc+0x2d>
+    microdelay(10);
+80107481:	83 ec 0c             	sub    $0xc,%esp
+80107484:	6a 0a                	push   $0xa
+80107486:	e8 b9 bc ff ff       	call   80103144 <microdelay>
+8010748b:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+8010748e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80107492:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
+80107496:	7f 1a                	jg     801074b2 <uartputc+0x4d>
+80107498:	83 ec 0c             	sub    $0xc,%esp
+8010749b:	68 fd 03 00 00       	push   $0x3fd
+801074a0:	e8 97 fe ff ff       	call   8010733c <inb>
+801074a5:	83 c4 10             	add    $0x10,%esp
+801074a8:	0f b6 c0             	movzbl %al,%eax
+801074ab:	83 e0 20             	and    $0x20,%eax
+801074ae:	85 c0                	test   %eax,%eax
+801074b0:	74 cf                	je     80107481 <uartputc+0x1c>
+  outb(COM1+0, c);
+801074b2:	8b 45 08             	mov    0x8(%ebp),%eax
+801074b5:	0f b6 c0             	movzbl %al,%eax
+801074b8:	83 ec 08             	sub    $0x8,%esp
+801074bb:	50                   	push   %eax
+801074bc:	68 f8 03 00 00       	push   $0x3f8
+801074c1:	e8 93 fe ff ff       	call   80107359 <outb>
+801074c6:	83 c4 10             	add    $0x10,%esp
+801074c9:	eb 01                	jmp    801074cc <uartputc+0x67>
+    return;
+801074cb:	90                   	nop
+}
+801074cc:	c9                   	leave  
+801074cd:	c3                   	ret    
+
+801074ce <uartgetc>:
+
+static int
+uartgetc(void)
+{
+801074ce:	f3 0f 1e fb          	endbr32 
+801074d2:	55                   	push   %ebp
+801074d3:	89 e5                	mov    %esp,%ebp
+  if(!uart)
+801074d5:	a1 48 c6 10 80       	mov    0x8010c648,%eax
+801074da:	85 c0                	test   %eax,%eax
+801074dc:	75 07                	jne    801074e5 <uartgetc+0x17>
+    return -1;
+801074de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+801074e3:	eb 2e                	jmp    80107513 <uartgetc+0x45>
+  if(!(inb(COM1+5) & 0x01))
+801074e5:	68 fd 03 00 00       	push   $0x3fd
+801074ea:	e8 4d fe ff ff       	call   8010733c <inb>
+801074ef:	83 c4 04             	add    $0x4,%esp
+801074f2:	0f b6 c0             	movzbl %al,%eax
+801074f5:	83 e0 01             	and    $0x1,%eax
+801074f8:	85 c0                	test   %eax,%eax
+801074fa:	75 07                	jne    80107503 <uartgetc+0x35>
+    return -1;
+801074fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80107501:	eb 10                	jmp    80107513 <uartgetc+0x45>
+  return inb(COM1+0);
+80107503:	68 f8 03 00 00       	push   $0x3f8
+80107508:	e8 2f fe ff ff       	call   8010733c <inb>
+8010750d:	83 c4 04             	add    $0x4,%esp
+80107510:	0f b6 c0             	movzbl %al,%eax
+}
+80107513:	c9                   	leave  
+80107514:	c3                   	ret    
+
+80107515 <uartintr>:
+
+void
+uartintr(void)
+{
+80107515:	f3 0f 1e fb          	endbr32 
+80107519:	55                   	push   %ebp
+8010751a:	89 e5                	mov    %esp,%ebp
+8010751c:	83 ec 08             	sub    $0x8,%esp
+  consoleintr(uartgetc);
+8010751f:	83 ec 0c             	sub    $0xc,%esp
+80107522:	68 ce 74 10 80       	push   $0x801074ce
+80107527:	e8 45 93 ff ff       	call   80100871 <consoleintr>
+8010752c:	83 c4 10             	add    $0x10,%esp
+}
+8010752f:	90                   	nop
+80107530:	c9                   	leave  
+80107531:	c3                   	ret    
+
+80107532 <vector0>:
+# generated by vectors.pl - do not edit
+# handlers
+.globl alltraps
+.globl vector0
+vector0:
+  pushl $0
+80107532:	6a 00                	push   $0x0
+  pushl $0
+80107534:	6a 00                	push   $0x0
+  jmp alltraps
+80107536:	e9 99 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+8010753b <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+8010753b:	6a 00                	push   $0x0
+  pushl $1
+8010753d:	6a 01                	push   $0x1
+  jmp alltraps
+8010753f:	e9 90 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+80107544 <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+80107544:	6a 00                	push   $0x0
+  pushl $2
+80107546:	6a 02                	push   $0x2
+  jmp alltraps
+80107548:	e9 87 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+8010754d <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+8010754d:	6a 00                	push   $0x0
+  pushl $3
+8010754f:	6a 03                	push   $0x3
+  jmp alltraps
+80107551:	e9 7e f9 ff ff       	jmp    80106ed4 <alltraps>
+
+80107556 <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+80107556:	6a 00                	push   $0x0
+  pushl $4
+80107558:	6a 04                	push   $0x4
+  jmp alltraps
+8010755a:	e9 75 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+8010755f <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+8010755f:	6a 00                	push   $0x0
+  pushl $5
+80107561:	6a 05                	push   $0x5
+  jmp alltraps
+80107563:	e9 6c f9 ff ff       	jmp    80106ed4 <alltraps>
+
+80107568 <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+80107568:	6a 00                	push   $0x0
+  pushl $6
+8010756a:	6a 06                	push   $0x6
+  jmp alltraps
+8010756c:	e9 63 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+80107571 <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+80107571:	6a 00                	push   $0x0
+  pushl $7
+80107573:	6a 07                	push   $0x7
+  jmp alltraps
+80107575:	e9 5a f9 ff ff       	jmp    80106ed4 <alltraps>
+
+8010757a <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+8010757a:	6a 08                	push   $0x8
+  jmp alltraps
+8010757c:	e9 53 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+80107581 <vector9>:
+.globl vector9
+vector9:
+  pushl $0
+80107581:	6a 00                	push   $0x0
+  pushl $9
+80107583:	6a 09                	push   $0x9
+  jmp alltraps
+80107585:	e9 4a f9 ff ff       	jmp    80106ed4 <alltraps>
+
+8010758a <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+8010758a:	6a 0a                	push   $0xa
+  jmp alltraps
+8010758c:	e9 43 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+80107591 <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+80107591:	6a 0b                	push   $0xb
+  jmp alltraps
+80107593:	e9 3c f9 ff ff       	jmp    80106ed4 <alltraps>
+
+80107598 <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+80107598:	6a 0c                	push   $0xc
+  jmp alltraps
+8010759a:	e9 35 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+8010759f <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+8010759f:	6a 0d                	push   $0xd
+  jmp alltraps
+801075a1:	e9 2e f9 ff ff       	jmp    80106ed4 <alltraps>
+
+801075a6 <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+801075a6:	6a 0e                	push   $0xe
+  jmp alltraps
+801075a8:	e9 27 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+801075ad <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+801075ad:	6a 00                	push   $0x0
+  pushl $15
+801075af:	6a 0f                	push   $0xf
+  jmp alltraps
+801075b1:	e9 1e f9 ff ff       	jmp    80106ed4 <alltraps>
+
+801075b6 <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+801075b6:	6a 00                	push   $0x0
+  pushl $16
+801075b8:	6a 10                	push   $0x10
+  jmp alltraps
+801075ba:	e9 15 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+801075bf <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+801075bf:	6a 11                	push   $0x11
+  jmp alltraps
+801075c1:	e9 0e f9 ff ff       	jmp    80106ed4 <alltraps>
+
+801075c6 <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+801075c6:	6a 00                	push   $0x0
+  pushl $18
+801075c8:	6a 12                	push   $0x12
+  jmp alltraps
+801075ca:	e9 05 f9 ff ff       	jmp    80106ed4 <alltraps>
+
+801075cf <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+801075cf:	6a 00                	push   $0x0
+  pushl $19
+801075d1:	6a 13                	push   $0x13
+  jmp alltraps
+801075d3:	e9 fc f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801075d8 <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+801075d8:	6a 00                	push   $0x0
+  pushl $20
+801075da:	6a 14                	push   $0x14
+  jmp alltraps
+801075dc:	e9 f3 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801075e1 <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+801075e1:	6a 00                	push   $0x0
+  pushl $21
+801075e3:	6a 15                	push   $0x15
+  jmp alltraps
+801075e5:	e9 ea f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801075ea <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+801075ea:	6a 00                	push   $0x0
+  pushl $22
+801075ec:	6a 16                	push   $0x16
+  jmp alltraps
+801075ee:	e9 e1 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801075f3 <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+801075f3:	6a 00                	push   $0x0
+  pushl $23
+801075f5:	6a 17                	push   $0x17
+  jmp alltraps
+801075f7:	e9 d8 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801075fc <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+801075fc:	6a 00                	push   $0x0
+  pushl $24
+801075fe:	6a 18                	push   $0x18
+  jmp alltraps
+80107600:	e9 cf f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107605 <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+80107605:	6a 00                	push   $0x0
+  pushl $25
+80107607:	6a 19                	push   $0x19
+  jmp alltraps
+80107609:	e9 c6 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+8010760e <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+8010760e:	6a 00                	push   $0x0
+  pushl $26
+80107610:	6a 1a                	push   $0x1a
+  jmp alltraps
+80107612:	e9 bd f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107617 <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+80107617:	6a 00                	push   $0x0
+  pushl $27
+80107619:	6a 1b                	push   $0x1b
+  jmp alltraps
+8010761b:	e9 b4 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107620 <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+80107620:	6a 00                	push   $0x0
+  pushl $28
+80107622:	6a 1c                	push   $0x1c
+  jmp alltraps
+80107624:	e9 ab f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107629 <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+80107629:	6a 00                	push   $0x0
+  pushl $29
+8010762b:	6a 1d                	push   $0x1d
+  jmp alltraps
+8010762d:	e9 a2 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107632 <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+80107632:	6a 00                	push   $0x0
+  pushl $30
+80107634:	6a 1e                	push   $0x1e
+  jmp alltraps
+80107636:	e9 99 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+8010763b <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+8010763b:	6a 00                	push   $0x0
+  pushl $31
+8010763d:	6a 1f                	push   $0x1f
+  jmp alltraps
+8010763f:	e9 90 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107644 <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+80107644:	6a 00                	push   $0x0
+  pushl $32
+80107646:	6a 20                	push   $0x20
+  jmp alltraps
+80107648:	e9 87 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+8010764d <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+8010764d:	6a 00                	push   $0x0
+  pushl $33
+8010764f:	6a 21                	push   $0x21
+  jmp alltraps
+80107651:	e9 7e f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107656 <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+80107656:	6a 00                	push   $0x0
+  pushl $34
+80107658:	6a 22                	push   $0x22
+  jmp alltraps
+8010765a:	e9 75 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+8010765f <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+8010765f:	6a 00                	push   $0x0
+  pushl $35
+80107661:	6a 23                	push   $0x23
+  jmp alltraps
+80107663:	e9 6c f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107668 <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+80107668:	6a 00                	push   $0x0
+  pushl $36
+8010766a:	6a 24                	push   $0x24
+  jmp alltraps
+8010766c:	e9 63 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107671 <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+80107671:	6a 00                	push   $0x0
+  pushl $37
+80107673:	6a 25                	push   $0x25
+  jmp alltraps
+80107675:	e9 5a f8 ff ff       	jmp    80106ed4 <alltraps>
+
+8010767a <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+8010767a:	6a 00                	push   $0x0
+  pushl $38
+8010767c:	6a 26                	push   $0x26
+  jmp alltraps
+8010767e:	e9 51 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107683 <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+80107683:	6a 00                	push   $0x0
+  pushl $39
+80107685:	6a 27                	push   $0x27
+  jmp alltraps
+80107687:	e9 48 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+8010768c <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+8010768c:	6a 00                	push   $0x0
+  pushl $40
+8010768e:	6a 28                	push   $0x28
+  jmp alltraps
+80107690:	e9 3f f8 ff ff       	jmp    80106ed4 <alltraps>
+
+80107695 <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+80107695:	6a 00                	push   $0x0
+  pushl $41
+80107697:	6a 29                	push   $0x29
+  jmp alltraps
+80107699:	e9 36 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+8010769e <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+8010769e:	6a 00                	push   $0x0
+  pushl $42
+801076a0:	6a 2a                	push   $0x2a
+  jmp alltraps
+801076a2:	e9 2d f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801076a7 <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+801076a7:	6a 00                	push   $0x0
+  pushl $43
+801076a9:	6a 2b                	push   $0x2b
+  jmp alltraps
+801076ab:	e9 24 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801076b0 <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+801076b0:	6a 00                	push   $0x0
+  pushl $44
+801076b2:	6a 2c                	push   $0x2c
+  jmp alltraps
+801076b4:	e9 1b f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801076b9 <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+801076b9:	6a 00                	push   $0x0
+  pushl $45
+801076bb:	6a 2d                	push   $0x2d
+  jmp alltraps
+801076bd:	e9 12 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801076c2 <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+801076c2:	6a 00                	push   $0x0
+  pushl $46
+801076c4:	6a 2e                	push   $0x2e
+  jmp alltraps
+801076c6:	e9 09 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801076cb <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+801076cb:	6a 00                	push   $0x0
+  pushl $47
+801076cd:	6a 2f                	push   $0x2f
+  jmp alltraps
+801076cf:	e9 00 f8 ff ff       	jmp    80106ed4 <alltraps>
+
+801076d4 <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+801076d4:	6a 00                	push   $0x0
+  pushl $48
+801076d6:	6a 30                	push   $0x30
+  jmp alltraps
+801076d8:	e9 f7 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801076dd <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+801076dd:	6a 00                	push   $0x0
+  pushl $49
+801076df:	6a 31                	push   $0x31
+  jmp alltraps
+801076e1:	e9 ee f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801076e6 <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+801076e6:	6a 00                	push   $0x0
+  pushl $50
+801076e8:	6a 32                	push   $0x32
+  jmp alltraps
+801076ea:	e9 e5 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801076ef <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+801076ef:	6a 00                	push   $0x0
+  pushl $51
+801076f1:	6a 33                	push   $0x33
+  jmp alltraps
+801076f3:	e9 dc f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801076f8 <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+801076f8:	6a 00                	push   $0x0
+  pushl $52
+801076fa:	6a 34                	push   $0x34
+  jmp alltraps
+801076fc:	e9 d3 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107701 <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+80107701:	6a 00                	push   $0x0
+  pushl $53
+80107703:	6a 35                	push   $0x35
+  jmp alltraps
+80107705:	e9 ca f7 ff ff       	jmp    80106ed4 <alltraps>
+
+8010770a <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+8010770a:	6a 00                	push   $0x0
+  pushl $54
+8010770c:	6a 36                	push   $0x36
+  jmp alltraps
+8010770e:	e9 c1 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107713 <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+80107713:	6a 00                	push   $0x0
+  pushl $55
+80107715:	6a 37                	push   $0x37
+  jmp alltraps
+80107717:	e9 b8 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+8010771c <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+8010771c:	6a 00                	push   $0x0
+  pushl $56
+8010771e:	6a 38                	push   $0x38
+  jmp alltraps
+80107720:	e9 af f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107725 <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+80107725:	6a 00                	push   $0x0
+  pushl $57
+80107727:	6a 39                	push   $0x39
+  jmp alltraps
+80107729:	e9 a6 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+8010772e <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+8010772e:	6a 00                	push   $0x0
+  pushl $58
+80107730:	6a 3a                	push   $0x3a
+  jmp alltraps
+80107732:	e9 9d f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107737 <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+80107737:	6a 00                	push   $0x0
+  pushl $59
+80107739:	6a 3b                	push   $0x3b
+  jmp alltraps
+8010773b:	e9 94 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107740 <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+80107740:	6a 00                	push   $0x0
+  pushl $60
+80107742:	6a 3c                	push   $0x3c
+  jmp alltraps
+80107744:	e9 8b f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107749 <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+80107749:	6a 00                	push   $0x0
+  pushl $61
+8010774b:	6a 3d                	push   $0x3d
+  jmp alltraps
+8010774d:	e9 82 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107752 <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+80107752:	6a 00                	push   $0x0
+  pushl $62
+80107754:	6a 3e                	push   $0x3e
+  jmp alltraps
+80107756:	e9 79 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+8010775b <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+8010775b:	6a 00                	push   $0x0
+  pushl $63
+8010775d:	6a 3f                	push   $0x3f
+  jmp alltraps
+8010775f:	e9 70 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107764 <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+80107764:	6a 00                	push   $0x0
+  pushl $64
+80107766:	6a 40                	push   $0x40
+  jmp alltraps
+80107768:	e9 67 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+8010776d <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+8010776d:	6a 00                	push   $0x0
+  pushl $65
+8010776f:	6a 41                	push   $0x41
+  jmp alltraps
+80107771:	e9 5e f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107776 <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+80107776:	6a 00                	push   $0x0
+  pushl $66
+80107778:	6a 42                	push   $0x42
+  jmp alltraps
+8010777a:	e9 55 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+8010777f <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+8010777f:	6a 00                	push   $0x0
+  pushl $67
+80107781:	6a 43                	push   $0x43
+  jmp alltraps
+80107783:	e9 4c f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107788 <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+80107788:	6a 00                	push   $0x0
+  pushl $68
+8010778a:	6a 44                	push   $0x44
+  jmp alltraps
+8010778c:	e9 43 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+80107791 <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+80107791:	6a 00                	push   $0x0
+  pushl $69
+80107793:	6a 45                	push   $0x45
+  jmp alltraps
+80107795:	e9 3a f7 ff ff       	jmp    80106ed4 <alltraps>
+
+8010779a <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+8010779a:	6a 00                	push   $0x0
+  pushl $70
+8010779c:	6a 46                	push   $0x46
+  jmp alltraps
+8010779e:	e9 31 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801077a3 <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+801077a3:	6a 00                	push   $0x0
+  pushl $71
+801077a5:	6a 47                	push   $0x47
+  jmp alltraps
+801077a7:	e9 28 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801077ac <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+801077ac:	6a 00                	push   $0x0
+  pushl $72
+801077ae:	6a 48                	push   $0x48
+  jmp alltraps
+801077b0:	e9 1f f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801077b5 <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+801077b5:	6a 00                	push   $0x0
+  pushl $73
+801077b7:	6a 49                	push   $0x49
+  jmp alltraps
+801077b9:	e9 16 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801077be <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+801077be:	6a 00                	push   $0x0
+  pushl $74
+801077c0:	6a 4a                	push   $0x4a
+  jmp alltraps
+801077c2:	e9 0d f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801077c7 <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+801077c7:	6a 00                	push   $0x0
+  pushl $75
+801077c9:	6a 4b                	push   $0x4b
+  jmp alltraps
+801077cb:	e9 04 f7 ff ff       	jmp    80106ed4 <alltraps>
+
+801077d0 <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+801077d0:	6a 00                	push   $0x0
+  pushl $76
+801077d2:	6a 4c                	push   $0x4c
+  jmp alltraps
+801077d4:	e9 fb f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801077d9 <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+801077d9:	6a 00                	push   $0x0
+  pushl $77
+801077db:	6a 4d                	push   $0x4d
+  jmp alltraps
+801077dd:	e9 f2 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801077e2 <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+801077e2:	6a 00                	push   $0x0
+  pushl $78
+801077e4:	6a 4e                	push   $0x4e
+  jmp alltraps
+801077e6:	e9 e9 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801077eb <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+801077eb:	6a 00                	push   $0x0
+  pushl $79
+801077ed:	6a 4f                	push   $0x4f
+  jmp alltraps
+801077ef:	e9 e0 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801077f4 <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+801077f4:	6a 00                	push   $0x0
+  pushl $80
+801077f6:	6a 50                	push   $0x50
+  jmp alltraps
+801077f8:	e9 d7 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801077fd <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+801077fd:	6a 00                	push   $0x0
+  pushl $81
+801077ff:	6a 51                	push   $0x51
+  jmp alltraps
+80107801:	e9 ce f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107806 <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+80107806:	6a 00                	push   $0x0
+  pushl $82
+80107808:	6a 52                	push   $0x52
+  jmp alltraps
+8010780a:	e9 c5 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+8010780f <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+8010780f:	6a 00                	push   $0x0
+  pushl $83
+80107811:	6a 53                	push   $0x53
+  jmp alltraps
+80107813:	e9 bc f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107818 <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+80107818:	6a 00                	push   $0x0
+  pushl $84
+8010781a:	6a 54                	push   $0x54
+  jmp alltraps
+8010781c:	e9 b3 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107821 <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+80107821:	6a 00                	push   $0x0
+  pushl $85
+80107823:	6a 55                	push   $0x55
+  jmp alltraps
+80107825:	e9 aa f6 ff ff       	jmp    80106ed4 <alltraps>
+
+8010782a <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+8010782a:	6a 00                	push   $0x0
+  pushl $86
+8010782c:	6a 56                	push   $0x56
+  jmp alltraps
+8010782e:	e9 a1 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107833 <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+80107833:	6a 00                	push   $0x0
+  pushl $87
+80107835:	6a 57                	push   $0x57
+  jmp alltraps
+80107837:	e9 98 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+8010783c <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+8010783c:	6a 00                	push   $0x0
+  pushl $88
+8010783e:	6a 58                	push   $0x58
+  jmp alltraps
+80107840:	e9 8f f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107845 <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+80107845:	6a 00                	push   $0x0
+  pushl $89
+80107847:	6a 59                	push   $0x59
+  jmp alltraps
+80107849:	e9 86 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+8010784e <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+8010784e:	6a 00                	push   $0x0
+  pushl $90
+80107850:	6a 5a                	push   $0x5a
+  jmp alltraps
+80107852:	e9 7d f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107857 <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+80107857:	6a 00                	push   $0x0
+  pushl $91
+80107859:	6a 5b                	push   $0x5b
+  jmp alltraps
+8010785b:	e9 74 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107860 <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+80107860:	6a 00                	push   $0x0
+  pushl $92
+80107862:	6a 5c                	push   $0x5c
+  jmp alltraps
+80107864:	e9 6b f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107869 <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+80107869:	6a 00                	push   $0x0
+  pushl $93
+8010786b:	6a 5d                	push   $0x5d
+  jmp alltraps
+8010786d:	e9 62 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107872 <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+80107872:	6a 00                	push   $0x0
+  pushl $94
+80107874:	6a 5e                	push   $0x5e
+  jmp alltraps
+80107876:	e9 59 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+8010787b <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+8010787b:	6a 00                	push   $0x0
+  pushl $95
+8010787d:	6a 5f                	push   $0x5f
+  jmp alltraps
+8010787f:	e9 50 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107884 <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+80107884:	6a 00                	push   $0x0
+  pushl $96
+80107886:	6a 60                	push   $0x60
+  jmp alltraps
+80107888:	e9 47 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+8010788d <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+8010788d:	6a 00                	push   $0x0
+  pushl $97
+8010788f:	6a 61                	push   $0x61
+  jmp alltraps
+80107891:	e9 3e f6 ff ff       	jmp    80106ed4 <alltraps>
+
+80107896 <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+80107896:	6a 00                	push   $0x0
+  pushl $98
+80107898:	6a 62                	push   $0x62
+  jmp alltraps
+8010789a:	e9 35 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+8010789f <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+8010789f:	6a 00                	push   $0x0
+  pushl $99
+801078a1:	6a 63                	push   $0x63
+  jmp alltraps
+801078a3:	e9 2c f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801078a8 <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+801078a8:	6a 00                	push   $0x0
+  pushl $100
+801078aa:	6a 64                	push   $0x64
+  jmp alltraps
+801078ac:	e9 23 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801078b1 <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+801078b1:	6a 00                	push   $0x0
+  pushl $101
+801078b3:	6a 65                	push   $0x65
+  jmp alltraps
+801078b5:	e9 1a f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801078ba <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+801078ba:	6a 00                	push   $0x0
+  pushl $102
+801078bc:	6a 66                	push   $0x66
+  jmp alltraps
+801078be:	e9 11 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801078c3 <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+801078c3:	6a 00                	push   $0x0
+  pushl $103
+801078c5:	6a 67                	push   $0x67
+  jmp alltraps
+801078c7:	e9 08 f6 ff ff       	jmp    80106ed4 <alltraps>
+
+801078cc <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+801078cc:	6a 00                	push   $0x0
+  pushl $104
+801078ce:	6a 68                	push   $0x68
+  jmp alltraps
+801078d0:	e9 ff f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801078d5 <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+801078d5:	6a 00                	push   $0x0
+  pushl $105
+801078d7:	6a 69                	push   $0x69
+  jmp alltraps
+801078d9:	e9 f6 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801078de <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+801078de:	6a 00                	push   $0x0
+  pushl $106
+801078e0:	6a 6a                	push   $0x6a
+  jmp alltraps
+801078e2:	e9 ed f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801078e7 <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+801078e7:	6a 00                	push   $0x0
+  pushl $107
+801078e9:	6a 6b                	push   $0x6b
+  jmp alltraps
+801078eb:	e9 e4 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801078f0 <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+801078f0:	6a 00                	push   $0x0
+  pushl $108
+801078f2:	6a 6c                	push   $0x6c
+  jmp alltraps
+801078f4:	e9 db f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801078f9 <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+801078f9:	6a 00                	push   $0x0
+  pushl $109
+801078fb:	6a 6d                	push   $0x6d
+  jmp alltraps
+801078fd:	e9 d2 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107902 <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+80107902:	6a 00                	push   $0x0
+  pushl $110
+80107904:	6a 6e                	push   $0x6e
+  jmp alltraps
+80107906:	e9 c9 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+8010790b <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+8010790b:	6a 00                	push   $0x0
+  pushl $111
+8010790d:	6a 6f                	push   $0x6f
+  jmp alltraps
+8010790f:	e9 c0 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107914 <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+80107914:	6a 00                	push   $0x0
+  pushl $112
+80107916:	6a 70                	push   $0x70
+  jmp alltraps
+80107918:	e9 b7 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+8010791d <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+8010791d:	6a 00                	push   $0x0
+  pushl $113
+8010791f:	6a 71                	push   $0x71
+  jmp alltraps
+80107921:	e9 ae f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107926 <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+80107926:	6a 00                	push   $0x0
+  pushl $114
+80107928:	6a 72                	push   $0x72
+  jmp alltraps
+8010792a:	e9 a5 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+8010792f <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+8010792f:	6a 00                	push   $0x0
+  pushl $115
+80107931:	6a 73                	push   $0x73
+  jmp alltraps
+80107933:	e9 9c f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107938 <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+80107938:	6a 00                	push   $0x0
+  pushl $116
+8010793a:	6a 74                	push   $0x74
+  jmp alltraps
+8010793c:	e9 93 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107941 <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+80107941:	6a 00                	push   $0x0
+  pushl $117
+80107943:	6a 75                	push   $0x75
+  jmp alltraps
+80107945:	e9 8a f5 ff ff       	jmp    80106ed4 <alltraps>
+
+8010794a <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+8010794a:	6a 00                	push   $0x0
+  pushl $118
+8010794c:	6a 76                	push   $0x76
+  jmp alltraps
+8010794e:	e9 81 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107953 <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+80107953:	6a 00                	push   $0x0
+  pushl $119
+80107955:	6a 77                	push   $0x77
+  jmp alltraps
+80107957:	e9 78 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+8010795c <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+8010795c:	6a 00                	push   $0x0
+  pushl $120
+8010795e:	6a 78                	push   $0x78
+  jmp alltraps
+80107960:	e9 6f f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107965 <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+80107965:	6a 00                	push   $0x0
+  pushl $121
+80107967:	6a 79                	push   $0x79
+  jmp alltraps
+80107969:	e9 66 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+8010796e <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+8010796e:	6a 00                	push   $0x0
+  pushl $122
+80107970:	6a 7a                	push   $0x7a
+  jmp alltraps
+80107972:	e9 5d f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107977 <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+80107977:	6a 00                	push   $0x0
+  pushl $123
+80107979:	6a 7b                	push   $0x7b
+  jmp alltraps
+8010797b:	e9 54 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107980 <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+80107980:	6a 00                	push   $0x0
+  pushl $124
+80107982:	6a 7c                	push   $0x7c
+  jmp alltraps
+80107984:	e9 4b f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107989 <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+80107989:	6a 00                	push   $0x0
+  pushl $125
+8010798b:	6a 7d                	push   $0x7d
+  jmp alltraps
+8010798d:	e9 42 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+80107992 <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+80107992:	6a 00                	push   $0x0
+  pushl $126
+80107994:	6a 7e                	push   $0x7e
+  jmp alltraps
+80107996:	e9 39 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+8010799b <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+8010799b:	6a 00                	push   $0x0
+  pushl $127
+8010799d:	6a 7f                	push   $0x7f
+  jmp alltraps
+8010799f:	e9 30 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801079a4 <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+801079a4:	6a 00                	push   $0x0
+  pushl $128
+801079a6:	68 80 00 00 00       	push   $0x80
+  jmp alltraps
+801079ab:	e9 24 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801079b0 <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+801079b0:	6a 00                	push   $0x0
+  pushl $129
+801079b2:	68 81 00 00 00       	push   $0x81
+  jmp alltraps
+801079b7:	e9 18 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801079bc <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+801079bc:	6a 00                	push   $0x0
+  pushl $130
+801079be:	68 82 00 00 00       	push   $0x82
+  jmp alltraps
+801079c3:	e9 0c f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801079c8 <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+801079c8:	6a 00                	push   $0x0
+  pushl $131
+801079ca:	68 83 00 00 00       	push   $0x83
+  jmp alltraps
+801079cf:	e9 00 f5 ff ff       	jmp    80106ed4 <alltraps>
+
+801079d4 <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+801079d4:	6a 00                	push   $0x0
+  pushl $132
+801079d6:	68 84 00 00 00       	push   $0x84
+  jmp alltraps
+801079db:	e9 f4 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+801079e0 <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+801079e0:	6a 00                	push   $0x0
+  pushl $133
+801079e2:	68 85 00 00 00       	push   $0x85
+  jmp alltraps
+801079e7:	e9 e8 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+801079ec <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+801079ec:	6a 00                	push   $0x0
+  pushl $134
+801079ee:	68 86 00 00 00       	push   $0x86
+  jmp alltraps
+801079f3:	e9 dc f4 ff ff       	jmp    80106ed4 <alltraps>
+
+801079f8 <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+801079f8:	6a 00                	push   $0x0
+  pushl $135
+801079fa:	68 87 00 00 00       	push   $0x87
+  jmp alltraps
+801079ff:	e9 d0 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a04 <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+80107a04:	6a 00                	push   $0x0
+  pushl $136
+80107a06:	68 88 00 00 00       	push   $0x88
+  jmp alltraps
+80107a0b:	e9 c4 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a10 <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+80107a10:	6a 00                	push   $0x0
+  pushl $137
+80107a12:	68 89 00 00 00       	push   $0x89
+  jmp alltraps
+80107a17:	e9 b8 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a1c <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+80107a1c:	6a 00                	push   $0x0
+  pushl $138
+80107a1e:	68 8a 00 00 00       	push   $0x8a
+  jmp alltraps
+80107a23:	e9 ac f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a28 <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+80107a28:	6a 00                	push   $0x0
+  pushl $139
+80107a2a:	68 8b 00 00 00       	push   $0x8b
+  jmp alltraps
+80107a2f:	e9 a0 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a34 <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+80107a34:	6a 00                	push   $0x0
+  pushl $140
+80107a36:	68 8c 00 00 00       	push   $0x8c
+  jmp alltraps
+80107a3b:	e9 94 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a40 <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+80107a40:	6a 00                	push   $0x0
+  pushl $141
+80107a42:	68 8d 00 00 00       	push   $0x8d
+  jmp alltraps
+80107a47:	e9 88 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a4c <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+80107a4c:	6a 00                	push   $0x0
+  pushl $142
+80107a4e:	68 8e 00 00 00       	push   $0x8e
+  jmp alltraps
+80107a53:	e9 7c f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a58 <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+80107a58:	6a 00                	push   $0x0
+  pushl $143
+80107a5a:	68 8f 00 00 00       	push   $0x8f
+  jmp alltraps
+80107a5f:	e9 70 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a64 <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+80107a64:	6a 00                	push   $0x0
+  pushl $144
+80107a66:	68 90 00 00 00       	push   $0x90
+  jmp alltraps
+80107a6b:	e9 64 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a70 <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+80107a70:	6a 00                	push   $0x0
+  pushl $145
+80107a72:	68 91 00 00 00       	push   $0x91
+  jmp alltraps
+80107a77:	e9 58 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a7c <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+80107a7c:	6a 00                	push   $0x0
+  pushl $146
+80107a7e:	68 92 00 00 00       	push   $0x92
+  jmp alltraps
+80107a83:	e9 4c f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a88 <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+80107a88:	6a 00                	push   $0x0
+  pushl $147
+80107a8a:	68 93 00 00 00       	push   $0x93
+  jmp alltraps
+80107a8f:	e9 40 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107a94 <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+80107a94:	6a 00                	push   $0x0
+  pushl $148
+80107a96:	68 94 00 00 00       	push   $0x94
+  jmp alltraps
+80107a9b:	e9 34 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107aa0 <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+80107aa0:	6a 00                	push   $0x0
+  pushl $149
+80107aa2:	68 95 00 00 00       	push   $0x95
+  jmp alltraps
+80107aa7:	e9 28 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107aac <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+80107aac:	6a 00                	push   $0x0
+  pushl $150
+80107aae:	68 96 00 00 00       	push   $0x96
+  jmp alltraps
+80107ab3:	e9 1c f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ab8 <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+80107ab8:	6a 00                	push   $0x0
+  pushl $151
+80107aba:	68 97 00 00 00       	push   $0x97
+  jmp alltraps
+80107abf:	e9 10 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ac4 <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+80107ac4:	6a 00                	push   $0x0
+  pushl $152
+80107ac6:	68 98 00 00 00       	push   $0x98
+  jmp alltraps
+80107acb:	e9 04 f4 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ad0 <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+80107ad0:	6a 00                	push   $0x0
+  pushl $153
+80107ad2:	68 99 00 00 00       	push   $0x99
+  jmp alltraps
+80107ad7:	e9 f8 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107adc <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+80107adc:	6a 00                	push   $0x0
+  pushl $154
+80107ade:	68 9a 00 00 00       	push   $0x9a
+  jmp alltraps
+80107ae3:	e9 ec f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ae8 <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+80107ae8:	6a 00                	push   $0x0
+  pushl $155
+80107aea:	68 9b 00 00 00       	push   $0x9b
+  jmp alltraps
+80107aef:	e9 e0 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107af4 <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+80107af4:	6a 00                	push   $0x0
+  pushl $156
+80107af6:	68 9c 00 00 00       	push   $0x9c
+  jmp alltraps
+80107afb:	e9 d4 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b00 <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+80107b00:	6a 00                	push   $0x0
+  pushl $157
+80107b02:	68 9d 00 00 00       	push   $0x9d
+  jmp alltraps
+80107b07:	e9 c8 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b0c <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+80107b0c:	6a 00                	push   $0x0
+  pushl $158
+80107b0e:	68 9e 00 00 00       	push   $0x9e
+  jmp alltraps
+80107b13:	e9 bc f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b18 <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+80107b18:	6a 00                	push   $0x0
+  pushl $159
+80107b1a:	68 9f 00 00 00       	push   $0x9f
+  jmp alltraps
+80107b1f:	e9 b0 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b24 <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+80107b24:	6a 00                	push   $0x0
+  pushl $160
+80107b26:	68 a0 00 00 00       	push   $0xa0
+  jmp alltraps
+80107b2b:	e9 a4 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b30 <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+80107b30:	6a 00                	push   $0x0
+  pushl $161
+80107b32:	68 a1 00 00 00       	push   $0xa1
+  jmp alltraps
+80107b37:	e9 98 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b3c <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+80107b3c:	6a 00                	push   $0x0
+  pushl $162
+80107b3e:	68 a2 00 00 00       	push   $0xa2
+  jmp alltraps
+80107b43:	e9 8c f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b48 <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+80107b48:	6a 00                	push   $0x0
+  pushl $163
+80107b4a:	68 a3 00 00 00       	push   $0xa3
+  jmp alltraps
+80107b4f:	e9 80 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b54 <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+80107b54:	6a 00                	push   $0x0
+  pushl $164
+80107b56:	68 a4 00 00 00       	push   $0xa4
+  jmp alltraps
+80107b5b:	e9 74 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b60 <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+80107b60:	6a 00                	push   $0x0
+  pushl $165
+80107b62:	68 a5 00 00 00       	push   $0xa5
+  jmp alltraps
+80107b67:	e9 68 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b6c <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+80107b6c:	6a 00                	push   $0x0
+  pushl $166
+80107b6e:	68 a6 00 00 00       	push   $0xa6
+  jmp alltraps
+80107b73:	e9 5c f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b78 <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+80107b78:	6a 00                	push   $0x0
+  pushl $167
+80107b7a:	68 a7 00 00 00       	push   $0xa7
+  jmp alltraps
+80107b7f:	e9 50 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b84 <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+80107b84:	6a 00                	push   $0x0
+  pushl $168
+80107b86:	68 a8 00 00 00       	push   $0xa8
+  jmp alltraps
+80107b8b:	e9 44 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b90 <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+80107b90:	6a 00                	push   $0x0
+  pushl $169
+80107b92:	68 a9 00 00 00       	push   $0xa9
+  jmp alltraps
+80107b97:	e9 38 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107b9c <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+80107b9c:	6a 00                	push   $0x0
+  pushl $170
+80107b9e:	68 aa 00 00 00       	push   $0xaa
+  jmp alltraps
+80107ba3:	e9 2c f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ba8 <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+80107ba8:	6a 00                	push   $0x0
+  pushl $171
+80107baa:	68 ab 00 00 00       	push   $0xab
+  jmp alltraps
+80107baf:	e9 20 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107bb4 <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+80107bb4:	6a 00                	push   $0x0
+  pushl $172
+80107bb6:	68 ac 00 00 00       	push   $0xac
+  jmp alltraps
+80107bbb:	e9 14 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107bc0 <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+80107bc0:	6a 00                	push   $0x0
+  pushl $173
+80107bc2:	68 ad 00 00 00       	push   $0xad
+  jmp alltraps
+80107bc7:	e9 08 f3 ff ff       	jmp    80106ed4 <alltraps>
+
+80107bcc <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+80107bcc:	6a 00                	push   $0x0
+  pushl $174
+80107bce:	68 ae 00 00 00       	push   $0xae
+  jmp alltraps
+80107bd3:	e9 fc f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107bd8 <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+80107bd8:	6a 00                	push   $0x0
+  pushl $175
+80107bda:	68 af 00 00 00       	push   $0xaf
+  jmp alltraps
+80107bdf:	e9 f0 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107be4 <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+80107be4:	6a 00                	push   $0x0
+  pushl $176
+80107be6:	68 b0 00 00 00       	push   $0xb0
+  jmp alltraps
+80107beb:	e9 e4 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107bf0 <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+80107bf0:	6a 00                	push   $0x0
+  pushl $177
+80107bf2:	68 b1 00 00 00       	push   $0xb1
+  jmp alltraps
+80107bf7:	e9 d8 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107bfc <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+80107bfc:	6a 00                	push   $0x0
+  pushl $178
+80107bfe:	68 b2 00 00 00       	push   $0xb2
+  jmp alltraps
+80107c03:	e9 cc f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c08 <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+80107c08:	6a 00                	push   $0x0
+  pushl $179
+80107c0a:	68 b3 00 00 00       	push   $0xb3
+  jmp alltraps
+80107c0f:	e9 c0 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c14 <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+80107c14:	6a 00                	push   $0x0
+  pushl $180
+80107c16:	68 b4 00 00 00       	push   $0xb4
+  jmp alltraps
+80107c1b:	e9 b4 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c20 <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+80107c20:	6a 00                	push   $0x0
+  pushl $181
+80107c22:	68 b5 00 00 00       	push   $0xb5
+  jmp alltraps
+80107c27:	e9 a8 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c2c <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+80107c2c:	6a 00                	push   $0x0
+  pushl $182
+80107c2e:	68 b6 00 00 00       	push   $0xb6
+  jmp alltraps
+80107c33:	e9 9c f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c38 <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+80107c38:	6a 00                	push   $0x0
+  pushl $183
+80107c3a:	68 b7 00 00 00       	push   $0xb7
+  jmp alltraps
+80107c3f:	e9 90 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c44 <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+80107c44:	6a 00                	push   $0x0
+  pushl $184
+80107c46:	68 b8 00 00 00       	push   $0xb8
+  jmp alltraps
+80107c4b:	e9 84 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c50 <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+80107c50:	6a 00                	push   $0x0
+  pushl $185
+80107c52:	68 b9 00 00 00       	push   $0xb9
+  jmp alltraps
+80107c57:	e9 78 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c5c <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+80107c5c:	6a 00                	push   $0x0
+  pushl $186
+80107c5e:	68 ba 00 00 00       	push   $0xba
+  jmp alltraps
+80107c63:	e9 6c f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c68 <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+80107c68:	6a 00                	push   $0x0
+  pushl $187
+80107c6a:	68 bb 00 00 00       	push   $0xbb
+  jmp alltraps
+80107c6f:	e9 60 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c74 <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+80107c74:	6a 00                	push   $0x0
+  pushl $188
+80107c76:	68 bc 00 00 00       	push   $0xbc
+  jmp alltraps
+80107c7b:	e9 54 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c80 <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+80107c80:	6a 00                	push   $0x0
+  pushl $189
+80107c82:	68 bd 00 00 00       	push   $0xbd
+  jmp alltraps
+80107c87:	e9 48 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c8c <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+80107c8c:	6a 00                	push   $0x0
+  pushl $190
+80107c8e:	68 be 00 00 00       	push   $0xbe
+  jmp alltraps
+80107c93:	e9 3c f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107c98 <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+80107c98:	6a 00                	push   $0x0
+  pushl $191
+80107c9a:	68 bf 00 00 00       	push   $0xbf
+  jmp alltraps
+80107c9f:	e9 30 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ca4 <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+80107ca4:	6a 00                	push   $0x0
+  pushl $192
+80107ca6:	68 c0 00 00 00       	push   $0xc0
+  jmp alltraps
+80107cab:	e9 24 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107cb0 <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+80107cb0:	6a 00                	push   $0x0
+  pushl $193
+80107cb2:	68 c1 00 00 00       	push   $0xc1
+  jmp alltraps
+80107cb7:	e9 18 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107cbc <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+80107cbc:	6a 00                	push   $0x0
+  pushl $194
+80107cbe:	68 c2 00 00 00       	push   $0xc2
+  jmp alltraps
+80107cc3:	e9 0c f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107cc8 <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+80107cc8:	6a 00                	push   $0x0
+  pushl $195
+80107cca:	68 c3 00 00 00       	push   $0xc3
+  jmp alltraps
+80107ccf:	e9 00 f2 ff ff       	jmp    80106ed4 <alltraps>
+
+80107cd4 <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+80107cd4:	6a 00                	push   $0x0
+  pushl $196
+80107cd6:	68 c4 00 00 00       	push   $0xc4
+  jmp alltraps
+80107cdb:	e9 f4 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ce0 <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+80107ce0:	6a 00                	push   $0x0
+  pushl $197
+80107ce2:	68 c5 00 00 00       	push   $0xc5
+  jmp alltraps
+80107ce7:	e9 e8 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107cec <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+80107cec:	6a 00                	push   $0x0
+  pushl $198
+80107cee:	68 c6 00 00 00       	push   $0xc6
+  jmp alltraps
+80107cf3:	e9 dc f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107cf8 <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+80107cf8:	6a 00                	push   $0x0
+  pushl $199
+80107cfa:	68 c7 00 00 00       	push   $0xc7
+  jmp alltraps
+80107cff:	e9 d0 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d04 <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+80107d04:	6a 00                	push   $0x0
+  pushl $200
+80107d06:	68 c8 00 00 00       	push   $0xc8
+  jmp alltraps
+80107d0b:	e9 c4 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d10 <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+80107d10:	6a 00                	push   $0x0
+  pushl $201
+80107d12:	68 c9 00 00 00       	push   $0xc9
+  jmp alltraps
+80107d17:	e9 b8 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d1c <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+80107d1c:	6a 00                	push   $0x0
+  pushl $202
+80107d1e:	68 ca 00 00 00       	push   $0xca
+  jmp alltraps
+80107d23:	e9 ac f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d28 <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+80107d28:	6a 00                	push   $0x0
+  pushl $203
+80107d2a:	68 cb 00 00 00       	push   $0xcb
+  jmp alltraps
+80107d2f:	e9 a0 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d34 <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+80107d34:	6a 00                	push   $0x0
+  pushl $204
+80107d36:	68 cc 00 00 00       	push   $0xcc
+  jmp alltraps
+80107d3b:	e9 94 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d40 <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+80107d40:	6a 00                	push   $0x0
+  pushl $205
+80107d42:	68 cd 00 00 00       	push   $0xcd
+  jmp alltraps
+80107d47:	e9 88 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d4c <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+80107d4c:	6a 00                	push   $0x0
+  pushl $206
+80107d4e:	68 ce 00 00 00       	push   $0xce
+  jmp alltraps
+80107d53:	e9 7c f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d58 <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+80107d58:	6a 00                	push   $0x0
+  pushl $207
+80107d5a:	68 cf 00 00 00       	push   $0xcf
+  jmp alltraps
+80107d5f:	e9 70 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d64 <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+80107d64:	6a 00                	push   $0x0
+  pushl $208
+80107d66:	68 d0 00 00 00       	push   $0xd0
+  jmp alltraps
+80107d6b:	e9 64 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d70 <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+80107d70:	6a 00                	push   $0x0
+  pushl $209
+80107d72:	68 d1 00 00 00       	push   $0xd1
+  jmp alltraps
+80107d77:	e9 58 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d7c <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+80107d7c:	6a 00                	push   $0x0
+  pushl $210
+80107d7e:	68 d2 00 00 00       	push   $0xd2
+  jmp alltraps
+80107d83:	e9 4c f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d88 <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+80107d88:	6a 00                	push   $0x0
+  pushl $211
+80107d8a:	68 d3 00 00 00       	push   $0xd3
+  jmp alltraps
+80107d8f:	e9 40 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107d94 <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+80107d94:	6a 00                	push   $0x0
+  pushl $212
+80107d96:	68 d4 00 00 00       	push   $0xd4
+  jmp alltraps
+80107d9b:	e9 34 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107da0 <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+80107da0:	6a 00                	push   $0x0
+  pushl $213
+80107da2:	68 d5 00 00 00       	push   $0xd5
+  jmp alltraps
+80107da7:	e9 28 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107dac <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+80107dac:	6a 00                	push   $0x0
+  pushl $214
+80107dae:	68 d6 00 00 00       	push   $0xd6
+  jmp alltraps
+80107db3:	e9 1c f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107db8 <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+80107db8:	6a 00                	push   $0x0
+  pushl $215
+80107dba:	68 d7 00 00 00       	push   $0xd7
+  jmp alltraps
+80107dbf:	e9 10 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107dc4 <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+80107dc4:	6a 00                	push   $0x0
+  pushl $216
+80107dc6:	68 d8 00 00 00       	push   $0xd8
+  jmp alltraps
+80107dcb:	e9 04 f1 ff ff       	jmp    80106ed4 <alltraps>
+
+80107dd0 <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+80107dd0:	6a 00                	push   $0x0
+  pushl $217
+80107dd2:	68 d9 00 00 00       	push   $0xd9
+  jmp alltraps
+80107dd7:	e9 f8 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ddc <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+80107ddc:	6a 00                	push   $0x0
+  pushl $218
+80107dde:	68 da 00 00 00       	push   $0xda
+  jmp alltraps
+80107de3:	e9 ec f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107de8 <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+80107de8:	6a 00                	push   $0x0
+  pushl $219
+80107dea:	68 db 00 00 00       	push   $0xdb
+  jmp alltraps
+80107def:	e9 e0 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107df4 <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+80107df4:	6a 00                	push   $0x0
+  pushl $220
+80107df6:	68 dc 00 00 00       	push   $0xdc
+  jmp alltraps
+80107dfb:	e9 d4 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e00 <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+80107e00:	6a 00                	push   $0x0
+  pushl $221
+80107e02:	68 dd 00 00 00       	push   $0xdd
+  jmp alltraps
+80107e07:	e9 c8 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e0c <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+80107e0c:	6a 00                	push   $0x0
+  pushl $222
+80107e0e:	68 de 00 00 00       	push   $0xde
+  jmp alltraps
+80107e13:	e9 bc f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e18 <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+80107e18:	6a 00                	push   $0x0
+  pushl $223
+80107e1a:	68 df 00 00 00       	push   $0xdf
+  jmp alltraps
+80107e1f:	e9 b0 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e24 <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+80107e24:	6a 00                	push   $0x0
+  pushl $224
+80107e26:	68 e0 00 00 00       	push   $0xe0
+  jmp alltraps
+80107e2b:	e9 a4 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e30 <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+80107e30:	6a 00                	push   $0x0
+  pushl $225
+80107e32:	68 e1 00 00 00       	push   $0xe1
+  jmp alltraps
+80107e37:	e9 98 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e3c <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+80107e3c:	6a 00                	push   $0x0
+  pushl $226
+80107e3e:	68 e2 00 00 00       	push   $0xe2
+  jmp alltraps
+80107e43:	e9 8c f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e48 <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+80107e48:	6a 00                	push   $0x0
+  pushl $227
+80107e4a:	68 e3 00 00 00       	push   $0xe3
+  jmp alltraps
+80107e4f:	e9 80 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e54 <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+80107e54:	6a 00                	push   $0x0
+  pushl $228
+80107e56:	68 e4 00 00 00       	push   $0xe4
+  jmp alltraps
+80107e5b:	e9 74 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e60 <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+80107e60:	6a 00                	push   $0x0
+  pushl $229
+80107e62:	68 e5 00 00 00       	push   $0xe5
+  jmp alltraps
+80107e67:	e9 68 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e6c <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+80107e6c:	6a 00                	push   $0x0
+  pushl $230
+80107e6e:	68 e6 00 00 00       	push   $0xe6
+  jmp alltraps
+80107e73:	e9 5c f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e78 <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+80107e78:	6a 00                	push   $0x0
+  pushl $231
+80107e7a:	68 e7 00 00 00       	push   $0xe7
+  jmp alltraps
+80107e7f:	e9 50 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e84 <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+80107e84:	6a 00                	push   $0x0
+  pushl $232
+80107e86:	68 e8 00 00 00       	push   $0xe8
+  jmp alltraps
+80107e8b:	e9 44 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e90 <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+80107e90:	6a 00                	push   $0x0
+  pushl $233
+80107e92:	68 e9 00 00 00       	push   $0xe9
+  jmp alltraps
+80107e97:	e9 38 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107e9c <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+80107e9c:	6a 00                	push   $0x0
+  pushl $234
+80107e9e:	68 ea 00 00 00       	push   $0xea
+  jmp alltraps
+80107ea3:	e9 2c f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ea8 <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+80107ea8:	6a 00                	push   $0x0
+  pushl $235
+80107eaa:	68 eb 00 00 00       	push   $0xeb
+  jmp alltraps
+80107eaf:	e9 20 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107eb4 <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+80107eb4:	6a 00                	push   $0x0
+  pushl $236
+80107eb6:	68 ec 00 00 00       	push   $0xec
+  jmp alltraps
+80107ebb:	e9 14 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ec0 <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+80107ec0:	6a 00                	push   $0x0
+  pushl $237
+80107ec2:	68 ed 00 00 00       	push   $0xed
+  jmp alltraps
+80107ec7:	e9 08 f0 ff ff       	jmp    80106ed4 <alltraps>
+
+80107ecc <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+80107ecc:	6a 00                	push   $0x0
+  pushl $238
+80107ece:	68 ee 00 00 00       	push   $0xee
+  jmp alltraps
+80107ed3:	e9 fc ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107ed8 <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+80107ed8:	6a 00                	push   $0x0
+  pushl $239
+80107eda:	68 ef 00 00 00       	push   $0xef
+  jmp alltraps
+80107edf:	e9 f0 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107ee4 <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+80107ee4:	6a 00                	push   $0x0
+  pushl $240
+80107ee6:	68 f0 00 00 00       	push   $0xf0
+  jmp alltraps
+80107eeb:	e9 e4 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107ef0 <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+80107ef0:	6a 00                	push   $0x0
+  pushl $241
+80107ef2:	68 f1 00 00 00       	push   $0xf1
+  jmp alltraps
+80107ef7:	e9 d8 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107efc <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+80107efc:	6a 00                	push   $0x0
+  pushl $242
+80107efe:	68 f2 00 00 00       	push   $0xf2
+  jmp alltraps
+80107f03:	e9 cc ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f08 <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+80107f08:	6a 00                	push   $0x0
+  pushl $243
+80107f0a:	68 f3 00 00 00       	push   $0xf3
+  jmp alltraps
+80107f0f:	e9 c0 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f14 <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+80107f14:	6a 00                	push   $0x0
+  pushl $244
+80107f16:	68 f4 00 00 00       	push   $0xf4
+  jmp alltraps
+80107f1b:	e9 b4 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f20 <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+80107f20:	6a 00                	push   $0x0
+  pushl $245
+80107f22:	68 f5 00 00 00       	push   $0xf5
+  jmp alltraps
+80107f27:	e9 a8 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f2c <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+80107f2c:	6a 00                	push   $0x0
+  pushl $246
+80107f2e:	68 f6 00 00 00       	push   $0xf6
+  jmp alltraps
+80107f33:	e9 9c ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f38 <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+80107f38:	6a 00                	push   $0x0
+  pushl $247
+80107f3a:	68 f7 00 00 00       	push   $0xf7
+  jmp alltraps
+80107f3f:	e9 90 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f44 <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+80107f44:	6a 00                	push   $0x0
+  pushl $248
+80107f46:	68 f8 00 00 00       	push   $0xf8
+  jmp alltraps
+80107f4b:	e9 84 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f50 <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+80107f50:	6a 00                	push   $0x0
+  pushl $249
+80107f52:	68 f9 00 00 00       	push   $0xf9
+  jmp alltraps
+80107f57:	e9 78 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f5c <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+80107f5c:	6a 00                	push   $0x0
+  pushl $250
+80107f5e:	68 fa 00 00 00       	push   $0xfa
+  jmp alltraps
+80107f63:	e9 6c ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f68 <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+80107f68:	6a 00                	push   $0x0
+  pushl $251
+80107f6a:	68 fb 00 00 00       	push   $0xfb
+  jmp alltraps
+80107f6f:	e9 60 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f74 <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+80107f74:	6a 00                	push   $0x0
+  pushl $252
+80107f76:	68 fc 00 00 00       	push   $0xfc
+  jmp alltraps
+80107f7b:	e9 54 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f80 <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+80107f80:	6a 00                	push   $0x0
+  pushl $253
+80107f82:	68 fd 00 00 00       	push   $0xfd
+  jmp alltraps
+80107f87:	e9 48 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f8c <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+80107f8c:	6a 00                	push   $0x0
+  pushl $254
+80107f8e:	68 fe 00 00 00       	push   $0xfe
+  jmp alltraps
+80107f93:	e9 3c ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107f98 <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+80107f98:	6a 00                	push   $0x0
+  pushl $255
+80107f9a:	68 ff 00 00 00       	push   $0xff
+  jmp alltraps
+80107f9f:	e9 30 ef ff ff       	jmp    80106ed4 <alltraps>
+
+80107fa4 <lgdt>:
+{
+80107fa4:	55                   	push   %ebp
+80107fa5:	89 e5                	mov    %esp,%ebp
+80107fa7:	83 ec 10             	sub    $0x10,%esp
+  pd[0] = size-1;
+80107faa:	8b 45 0c             	mov    0xc(%ebp),%eax
+80107fad:	83 e8 01             	sub    $0x1,%eax
+80107fb0:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+  pd[1] = (uint)p;
+80107fb4:	8b 45 08             	mov    0x8(%ebp),%eax
+80107fb7:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  pd[2] = (uint)p >> 16;
+80107fbb:	8b 45 08             	mov    0x8(%ebp),%eax
+80107fbe:	c1 e8 10             	shr    $0x10,%eax
+80107fc1:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
+  asm volatile("lgdt (%0)" : : "r" (pd));
+80107fc5:	8d 45 fa             	lea    -0x6(%ebp),%eax
+80107fc8:	0f 01 10             	lgdtl  (%eax)
+}
+80107fcb:	90                   	nop
+80107fcc:	c9                   	leave  
+80107fcd:	c3                   	ret    
+
+80107fce <ltr>:
+{
+80107fce:	55                   	push   %ebp
+80107fcf:	89 e5                	mov    %esp,%ebp
+80107fd1:	83 ec 04             	sub    $0x4,%esp
+80107fd4:	8b 45 08             	mov    0x8(%ebp),%eax
+80107fd7:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+  asm volatile("ltr %0" : : "r" (sel));
+80107fdb:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+80107fdf:	0f 00 d8             	ltr    %ax
+}
+80107fe2:	90                   	nop
+80107fe3:	c9                   	leave  
+80107fe4:	c3                   	ret    
+
+80107fe5 <lcr3>:
+
+static inline void
+lcr3(uint val)
+{
+80107fe5:	55                   	push   %ebp
+80107fe6:	89 e5                	mov    %esp,%ebp
+  asm volatile("movl %0,%%cr3" : : "r" (val));
+80107fe8:	8b 45 08             	mov    0x8(%ebp),%eax
+80107feb:	0f 22 d8             	mov    %eax,%cr3
+}
+80107fee:	90                   	nop
+80107fef:	5d                   	pop    %ebp
+80107ff0:	c3                   	ret    
+
+80107ff1 <seginit>:
+
+// Set up CPU's kernel segment descriptors.
+// Run once on entry on each CPU.
+void
+seginit(void)
+{
+80107ff1:	f3 0f 1e fb          	endbr32 
+80107ff5:	55                   	push   %ebp
+80107ff6:	89 e5                	mov    %esp,%ebp
+80107ff8:	83 ec 18             	sub    $0x18,%esp
+
+  // Map "logical" addresses to virtual addresses using identity map.
+  // Cannot share a CODE descriptor for both kernel and user
+  // because it would have to have DPL_USR, but the CPU forbids
+  // an interrupt from CPL=0 to DPL=3.
+  c = &cpus[cpuid()];
+80107ffb:	e8 0e c5 ff ff       	call   8010450e <cpuid>
+80108000:	69 c0 b0 00 00 00    	imul   $0xb0,%eax,%eax
+80108006:	05 20 48 11 80       	add    $0x80114820,%eax
+8010800b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+8010800e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108011:	66 c7 40 78 ff ff    	movw   $0xffff,0x78(%eax)
+80108017:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010801a:	66 c7 40 7a 00 00    	movw   $0x0,0x7a(%eax)
+80108020:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108023:	c6 40 7c 00          	movb   $0x0,0x7c(%eax)
+80108027:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010802a:	0f b6 50 7d          	movzbl 0x7d(%eax),%edx
+8010802e:	83 e2 f0             	and    $0xfffffff0,%edx
+80108031:	83 ca 0a             	or     $0xa,%edx
+80108034:	88 50 7d             	mov    %dl,0x7d(%eax)
+80108037:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010803a:	0f b6 50 7d          	movzbl 0x7d(%eax),%edx
+8010803e:	83 ca 10             	or     $0x10,%edx
+80108041:	88 50 7d             	mov    %dl,0x7d(%eax)
+80108044:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108047:	0f b6 50 7d          	movzbl 0x7d(%eax),%edx
+8010804b:	83 e2 9f             	and    $0xffffff9f,%edx
+8010804e:	88 50 7d             	mov    %dl,0x7d(%eax)
+80108051:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108054:	0f b6 50 7d          	movzbl 0x7d(%eax),%edx
+80108058:	83 ca 80             	or     $0xffffff80,%edx
+8010805b:	88 50 7d             	mov    %dl,0x7d(%eax)
+8010805e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108061:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+80108065:	83 ca 0f             	or     $0xf,%edx
+80108068:	88 50 7e             	mov    %dl,0x7e(%eax)
+8010806b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010806e:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+80108072:	83 e2 ef             	and    $0xffffffef,%edx
+80108075:	88 50 7e             	mov    %dl,0x7e(%eax)
+80108078:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010807b:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+8010807f:	83 e2 df             	and    $0xffffffdf,%edx
+80108082:	88 50 7e             	mov    %dl,0x7e(%eax)
+80108085:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108088:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+8010808c:	83 ca 40             	or     $0x40,%edx
+8010808f:	88 50 7e             	mov    %dl,0x7e(%eax)
+80108092:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108095:	0f b6 50 7e          	movzbl 0x7e(%eax),%edx
+80108099:	83 ca 80             	or     $0xffffff80,%edx
+8010809c:	88 50 7e             	mov    %dl,0x7e(%eax)
+8010809f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801080a2:	c6 40 7f 00          	movb   $0x0,0x7f(%eax)
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+801080a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801080a9:	66 c7 80 80 00 00 00 	movw   $0xffff,0x80(%eax)
+801080b0:	ff ff 
+801080b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801080b5:	66 c7 80 82 00 00 00 	movw   $0x0,0x82(%eax)
+801080bc:	00 00 
+801080be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801080c1:	c6 80 84 00 00 00 00 	movb   $0x0,0x84(%eax)
+801080c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801080cb:	0f b6 90 85 00 00 00 	movzbl 0x85(%eax),%edx
+801080d2:	83 e2 f0             	and    $0xfffffff0,%edx
+801080d5:	83 ca 02             	or     $0x2,%edx
+801080d8:	88 90 85 00 00 00    	mov    %dl,0x85(%eax)
+801080de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801080e1:	0f b6 90 85 00 00 00 	movzbl 0x85(%eax),%edx
+801080e8:	83 ca 10             	or     $0x10,%edx
+801080eb:	88 90 85 00 00 00    	mov    %dl,0x85(%eax)
+801080f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801080f4:	0f b6 90 85 00 00 00 	movzbl 0x85(%eax),%edx
+801080fb:	83 e2 9f             	and    $0xffffff9f,%edx
+801080fe:	88 90 85 00 00 00    	mov    %dl,0x85(%eax)
+80108104:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108107:	0f b6 90 85 00 00 00 	movzbl 0x85(%eax),%edx
+8010810e:	83 ca 80             	or     $0xffffff80,%edx
+80108111:	88 90 85 00 00 00    	mov    %dl,0x85(%eax)
+80108117:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010811a:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+80108121:	83 ca 0f             	or     $0xf,%edx
+80108124:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+8010812a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010812d:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+80108134:	83 e2 ef             	and    $0xffffffef,%edx
+80108137:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+8010813d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108140:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+80108147:	83 e2 df             	and    $0xffffffdf,%edx
+8010814a:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+80108150:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108153:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+8010815a:	83 ca 40             	or     $0x40,%edx
+8010815d:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+80108163:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108166:	0f b6 90 86 00 00 00 	movzbl 0x86(%eax),%edx
+8010816d:	83 ca 80             	or     $0xffffff80,%edx
+80108170:	88 90 86 00 00 00    	mov    %dl,0x86(%eax)
+80108176:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108179:	c6 80 87 00 00 00 00 	movb   $0x0,0x87(%eax)
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+80108180:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108183:	66 c7 80 88 00 00 00 	movw   $0xffff,0x88(%eax)
+8010818a:	ff ff 
+8010818c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010818f:	66 c7 80 8a 00 00 00 	movw   $0x0,0x8a(%eax)
+80108196:	00 00 
+80108198:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010819b:	c6 80 8c 00 00 00 00 	movb   $0x0,0x8c(%eax)
+801081a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801081a5:	0f b6 90 8d 00 00 00 	movzbl 0x8d(%eax),%edx
+801081ac:	83 e2 f0             	and    $0xfffffff0,%edx
+801081af:	83 ca 0a             	or     $0xa,%edx
+801081b2:	88 90 8d 00 00 00    	mov    %dl,0x8d(%eax)
+801081b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801081bb:	0f b6 90 8d 00 00 00 	movzbl 0x8d(%eax),%edx
+801081c2:	83 ca 10             	or     $0x10,%edx
+801081c5:	88 90 8d 00 00 00    	mov    %dl,0x8d(%eax)
+801081cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801081ce:	0f b6 90 8d 00 00 00 	movzbl 0x8d(%eax),%edx
+801081d5:	83 ca 60             	or     $0x60,%edx
+801081d8:	88 90 8d 00 00 00    	mov    %dl,0x8d(%eax)
+801081de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801081e1:	0f b6 90 8d 00 00 00 	movzbl 0x8d(%eax),%edx
+801081e8:	83 ca 80             	or     $0xffffff80,%edx
+801081eb:	88 90 8d 00 00 00    	mov    %dl,0x8d(%eax)
+801081f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801081f4:	0f b6 90 8e 00 00 00 	movzbl 0x8e(%eax),%edx
+801081fb:	83 ca 0f             	or     $0xf,%edx
+801081fe:	88 90 8e 00 00 00    	mov    %dl,0x8e(%eax)
+80108204:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108207:	0f b6 90 8e 00 00 00 	movzbl 0x8e(%eax),%edx
+8010820e:	83 e2 ef             	and    $0xffffffef,%edx
+80108211:	88 90 8e 00 00 00    	mov    %dl,0x8e(%eax)
+80108217:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010821a:	0f b6 90 8e 00 00 00 	movzbl 0x8e(%eax),%edx
+80108221:	83 e2 df             	and    $0xffffffdf,%edx
+80108224:	88 90 8e 00 00 00    	mov    %dl,0x8e(%eax)
+8010822a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010822d:	0f b6 90 8e 00 00 00 	movzbl 0x8e(%eax),%edx
+80108234:	83 ca 40             	or     $0x40,%edx
+80108237:	88 90 8e 00 00 00    	mov    %dl,0x8e(%eax)
+8010823d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108240:	0f b6 90 8e 00 00 00 	movzbl 0x8e(%eax),%edx
+80108247:	83 ca 80             	or     $0xffffff80,%edx
+8010824a:	88 90 8e 00 00 00    	mov    %dl,0x8e(%eax)
+80108250:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108253:	c6 80 8f 00 00 00 00 	movb   $0x0,0x8f(%eax)
+  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+8010825a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010825d:	66 c7 80 90 00 00 00 	movw   $0xffff,0x90(%eax)
+80108264:	ff ff 
+80108266:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108269:	66 c7 80 92 00 00 00 	movw   $0x0,0x92(%eax)
+80108270:	00 00 
+80108272:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108275:	c6 80 94 00 00 00 00 	movb   $0x0,0x94(%eax)
+8010827c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010827f:	0f b6 90 95 00 00 00 	movzbl 0x95(%eax),%edx
+80108286:	83 e2 f0             	and    $0xfffffff0,%edx
+80108289:	83 ca 02             	or     $0x2,%edx
+8010828c:	88 90 95 00 00 00    	mov    %dl,0x95(%eax)
+80108292:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108295:	0f b6 90 95 00 00 00 	movzbl 0x95(%eax),%edx
+8010829c:	83 ca 10             	or     $0x10,%edx
+8010829f:	88 90 95 00 00 00    	mov    %dl,0x95(%eax)
+801082a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801082a8:	0f b6 90 95 00 00 00 	movzbl 0x95(%eax),%edx
+801082af:	83 ca 60             	or     $0x60,%edx
+801082b2:	88 90 95 00 00 00    	mov    %dl,0x95(%eax)
+801082b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801082bb:	0f b6 90 95 00 00 00 	movzbl 0x95(%eax),%edx
+801082c2:	83 ca 80             	or     $0xffffff80,%edx
+801082c5:	88 90 95 00 00 00    	mov    %dl,0x95(%eax)
+801082cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801082ce:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+801082d5:	83 ca 0f             	or     $0xf,%edx
+801082d8:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+801082de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801082e1:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+801082e8:	83 e2 ef             	and    $0xffffffef,%edx
+801082eb:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+801082f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801082f4:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+801082fb:	83 e2 df             	and    $0xffffffdf,%edx
+801082fe:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+80108304:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108307:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+8010830e:	83 ca 40             	or     $0x40,%edx
+80108311:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+80108317:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010831a:	0f b6 90 96 00 00 00 	movzbl 0x96(%eax),%edx
+80108321:	83 ca 80             	or     $0xffffff80,%edx
+80108324:	88 90 96 00 00 00    	mov    %dl,0x96(%eax)
+8010832a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010832d:	c6 80 97 00 00 00 00 	movb   $0x0,0x97(%eax)
+  lgdt(c->gdt, sizeof(c->gdt));
+80108334:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108337:	83 c0 70             	add    $0x70,%eax
+8010833a:	83 ec 08             	sub    $0x8,%esp
+8010833d:	6a 30                	push   $0x30
+8010833f:	50                   	push   %eax
+80108340:	e8 5f fc ff ff       	call   80107fa4 <lgdt>
+80108345:	83 c4 10             	add    $0x10,%esp
+}
+80108348:	90                   	nop
+80108349:	c9                   	leave  
+8010834a:	c3                   	ret    
+
+8010834b <walkpgdir>:
+// Return the address of the PTE in page table pgdir
+// that corresponds to virtual address va.  If alloc!=0,
+// create any required page table pages.
+static pte_t *
+walkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+8010834b:	f3 0f 1e fb          	endbr32 
+8010834f:	55                   	push   %ebp
+80108350:	89 e5                	mov    %esp,%ebp
+80108352:	83 ec 18             	sub    $0x18,%esp
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+80108355:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108358:	c1 e8 16             	shr    $0x16,%eax
+8010835b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80108362:	8b 45 08             	mov    0x8(%ebp),%eax
+80108365:	01 d0                	add    %edx,%eax
+80108367:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(*pde & PTE_P){
+8010836a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+8010836d:	8b 00                	mov    (%eax),%eax
+8010836f:	83 e0 01             	and    $0x1,%eax
+80108372:	85 c0                	test   %eax,%eax
+80108374:	74 14                	je     8010838a <walkpgdir+0x3f>
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+80108376:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108379:	8b 00                	mov    (%eax),%eax
+8010837b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108380:	05 00 00 00 80       	add    $0x80000000,%eax
+80108385:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80108388:	eb 42                	jmp    801083cc <walkpgdir+0x81>
+  } else {
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+8010838a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+8010838e:	74 0e                	je     8010839e <walkpgdir+0x53>
+80108390:	e8 fd a9 ff ff       	call   80102d92 <kalloc>
+80108395:	89 45 f4             	mov    %eax,-0xc(%ebp)
+80108398:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+8010839c:	75 07                	jne    801083a5 <walkpgdir+0x5a>
+      return 0;
+8010839e:	b8 00 00 00 00       	mov    $0x0,%eax
+801083a3:	eb 3e                	jmp    801083e3 <walkpgdir+0x98>
+    // Make sure all those PTE_P bits are zero.
+    memset(pgtab, 0, PGSIZE);
+801083a5:	83 ec 04             	sub    $0x4,%esp
+801083a8:	68 00 10 00 00       	push   $0x1000
+801083ad:	6a 00                	push   $0x0
+801083af:	ff 75 f4             	pushl  -0xc(%ebp)
+801083b2:	e8 64 d6 ff ff       	call   80105a1b <memset>
+801083b7:	83 c4 10             	add    $0x10,%esp
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+801083ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801083bd:	05 00 00 00 80       	add    $0x80000000,%eax
+801083c2:	83 c8 07             	or     $0x7,%eax
+801083c5:	89 c2                	mov    %eax,%edx
+801083c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801083ca:	89 10                	mov    %edx,(%eax)
+  }
+  return &pgtab[PTX(va)];
+801083cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+801083cf:	c1 e8 0c             	shr    $0xc,%eax
+801083d2:	25 ff 03 00 00       	and    $0x3ff,%eax
+801083d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+801083de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801083e1:	01 d0                	add    %edx,%eax
+}
+801083e3:	c9                   	leave  
+801083e4:	c3                   	ret    
+
+801083e5 <mappages>:
+// Create PTEs for virtual addresses starting at va that refer to
+// physical addresses starting at pa. va and size might not
+// be page-aligned.
+static int
+mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+{
+801083e5:	f3 0f 1e fb          	endbr32 
+801083e9:	55                   	push   %ebp
+801083ea:	89 e5                	mov    %esp,%ebp
+801083ec:	83 ec 18             	sub    $0x18,%esp
+  char *a, *last;
+  pte_t *pte;
+
+  a = (char*)PGROUNDDOWN((uint)va);
+801083ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+801083f2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+801083f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+801083fa:	8b 55 0c             	mov    0xc(%ebp),%edx
+801083fd:	8b 45 10             	mov    0x10(%ebp),%eax
+80108400:	01 d0                	add    %edx,%eax
+80108402:	83 e8 01             	sub    $0x1,%eax
+80108405:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+8010840a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(;;){
+    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+8010840d:	83 ec 04             	sub    $0x4,%esp
+80108410:	6a 01                	push   $0x1
+80108412:	ff 75 f4             	pushl  -0xc(%ebp)
+80108415:	ff 75 08             	pushl  0x8(%ebp)
+80108418:	e8 2e ff ff ff       	call   8010834b <walkpgdir>
+8010841d:	83 c4 10             	add    $0x10,%esp
+80108420:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80108423:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80108427:	75 07                	jne    80108430 <mappages+0x4b>
+      return -1;
+80108429:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010842e:	eb 47                	jmp    80108477 <mappages+0x92>
+    if(*pte & PTE_P)
+80108430:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108433:	8b 00                	mov    (%eax),%eax
+80108435:	83 e0 01             	and    $0x1,%eax
+80108438:	85 c0                	test   %eax,%eax
+8010843a:	74 0d                	je     80108449 <mappages+0x64>
+      panic("remap");
+8010843c:	83 ec 0c             	sub    $0xc,%esp
+8010843f:	68 10 9a 10 80       	push   $0x80109a10
+80108444:	e8 88 81 ff ff       	call   801005d1 <panic>
+    *pte = pa | perm | PTE_P;
+80108449:	8b 45 18             	mov    0x18(%ebp),%eax
+8010844c:	0b 45 14             	or     0x14(%ebp),%eax
+8010844f:	83 c8 01             	or     $0x1,%eax
+80108452:	89 c2                	mov    %eax,%edx
+80108454:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108457:	89 10                	mov    %edx,(%eax)
+    if(a == last)
+80108459:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010845c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+8010845f:	74 10                	je     80108471 <mappages+0x8c>
+      break;
+    a += PGSIZE;
+80108461:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+    pa += PGSIZE;
+80108468:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
+    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+8010846f:	eb 9c                	jmp    8010840d <mappages+0x28>
+      break;
+80108471:	90                   	nop
+  }
+  return 0;
+80108472:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80108477:	c9                   	leave  
+80108478:	c3                   	ret    
+
+80108479 <setupkvm>:
+};
+
+// Set up kernel part of a page table.
+pde_t*
+setupkvm(void)
+{
+80108479:	f3 0f 1e fb          	endbr32 
+8010847d:	55                   	push   %ebp
+8010847e:	89 e5                	mov    %esp,%ebp
+80108480:	53                   	push   %ebx
+80108481:	83 ec 14             	sub    $0x14,%esp
+  pde_t *pgdir;
+  struct kmap *k;
+
+  if((pgdir = (pde_t*)kalloc()) == 0)
+80108484:	e8 09 a9 ff ff       	call   80102d92 <kalloc>
+80108489:	89 45 f0             	mov    %eax,-0x10(%ebp)
+8010848c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80108490:	75 07                	jne    80108499 <setupkvm+0x20>
+    return 0;
+80108492:	b8 00 00 00 00       	mov    $0x0,%eax
+80108497:	eb 78                	jmp    80108511 <setupkvm+0x98>
+  memset(pgdir, 0, PGSIZE);
+80108499:	83 ec 04             	sub    $0x4,%esp
+8010849c:	68 00 10 00 00       	push   $0x1000
+801084a1:	6a 00                	push   $0x0
+801084a3:	ff 75 f0             	pushl  -0x10(%ebp)
+801084a6:	e8 70 d5 ff ff       	call   80105a1b <memset>
+801084ab:	83 c4 10             	add    $0x10,%esp
+  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+    panic("PHYSTOP too high");
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+801084ae:	c7 45 f4 a0 c4 10 80 	movl   $0x8010c4a0,-0xc(%ebp)
+801084b5:	eb 4e                	jmp    80108505 <setupkvm+0x8c>
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+801084b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801084ba:	8b 48 0c             	mov    0xc(%eax),%ecx
+                (uint)k->phys_start, k->perm) < 0) {
+801084bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801084c0:	8b 50 04             	mov    0x4(%eax),%edx
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+801084c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801084c6:	8b 58 08             	mov    0x8(%eax),%ebx
+801084c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801084cc:	8b 40 04             	mov    0x4(%eax),%eax
+801084cf:	29 c3                	sub    %eax,%ebx
+801084d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801084d4:	8b 00                	mov    (%eax),%eax
+801084d6:	83 ec 0c             	sub    $0xc,%esp
+801084d9:	51                   	push   %ecx
+801084da:	52                   	push   %edx
+801084db:	53                   	push   %ebx
+801084dc:	50                   	push   %eax
+801084dd:	ff 75 f0             	pushl  -0x10(%ebp)
+801084e0:	e8 00 ff ff ff       	call   801083e5 <mappages>
+801084e5:	83 c4 20             	add    $0x20,%esp
+801084e8:	85 c0                	test   %eax,%eax
+801084ea:	79 15                	jns    80108501 <setupkvm+0x88>
+      freevm(pgdir);
+801084ec:	83 ec 0c             	sub    $0xc,%esp
+801084ef:	ff 75 f0             	pushl  -0x10(%ebp)
+801084f2:	e8 11 05 00 00       	call   80108a08 <freevm>
+801084f7:	83 c4 10             	add    $0x10,%esp
+      return 0;
+801084fa:	b8 00 00 00 00       	mov    $0x0,%eax
+801084ff:	eb 10                	jmp    80108511 <setupkvm+0x98>
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+80108501:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
+80108505:	81 7d f4 e0 c4 10 80 	cmpl   $0x8010c4e0,-0xc(%ebp)
+8010850c:	72 a9                	jb     801084b7 <setupkvm+0x3e>
+    }
+  return pgdir;
+8010850e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+80108511:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+80108514:	c9                   	leave  
+80108515:	c3                   	ret    
+
+80108516 <kvmalloc>:
+
+// Allocate one page table for the machine for the kernel address
+// space for scheduler processes.
+void
+kvmalloc(void)
+{
+80108516:	f3 0f 1e fb          	endbr32 
+8010851a:	55                   	push   %ebp
+8010851b:	89 e5                	mov    %esp,%ebp
+8010851d:	83 ec 08             	sub    $0x8,%esp
+  kpgdir = setupkvm();
+80108520:	e8 54 ff ff ff       	call   80108479 <setupkvm>
+80108525:	a3 44 7d 11 80       	mov    %eax,0x80117d44
+  switchkvm();
+8010852a:	e8 03 00 00 00       	call   80108532 <switchkvm>
+}
+8010852f:	90                   	nop
+80108530:	c9                   	leave  
+80108531:	c3                   	ret    
+
+80108532 <switchkvm>:
+
+// Switch h/w page table register to the kernel-only page table,
+// for when no process is running.
+void
+switchkvm(void)
+{
+80108532:	f3 0f 1e fb          	endbr32 
+80108536:	55                   	push   %ebp
+80108537:	89 e5                	mov    %esp,%ebp
+  lcr3(V2P(kpgdir));   // switch to the kernel page table
+80108539:	a1 44 7d 11 80       	mov    0x80117d44,%eax
+8010853e:	05 00 00 00 80       	add    $0x80000000,%eax
+80108543:	50                   	push   %eax
+80108544:	e8 9c fa ff ff       	call   80107fe5 <lcr3>
+80108549:	83 c4 04             	add    $0x4,%esp
+}
+8010854c:	90                   	nop
+8010854d:	c9                   	leave  
+8010854e:	c3                   	ret    
+
+8010854f <switchuvm>:
+
+// Switch TSS and h/w page table to correspond to process p.
+void
+switchuvm(struct proc *p)
+{
+8010854f:	f3 0f 1e fb          	endbr32 
+80108553:	55                   	push   %ebp
+80108554:	89 e5                	mov    %esp,%ebp
+80108556:	56                   	push   %esi
+80108557:	53                   	push   %ebx
+80108558:	83 ec 10             	sub    $0x10,%esp
+  if(p == 0)
+8010855b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+8010855f:	75 0d                	jne    8010856e <switchuvm+0x1f>
+    panic("switchuvm: no process");
+80108561:	83 ec 0c             	sub    $0xc,%esp
+80108564:	68 16 9a 10 80       	push   $0x80109a16
+80108569:	e8 63 80 ff ff       	call   801005d1 <panic>
+  if(p->kstack == 0)
+8010856e:	8b 45 08             	mov    0x8(%ebp),%eax
+80108571:	8b 40 1c             	mov    0x1c(%eax),%eax
+80108574:	85 c0                	test   %eax,%eax
+80108576:	75 0d                	jne    80108585 <switchuvm+0x36>
+    panic("switchuvm: no kstack");
+80108578:	83 ec 0c             	sub    $0xc,%esp
+8010857b:	68 2c 9a 10 80       	push   $0x80109a2c
+80108580:	e8 4c 80 ff ff       	call   801005d1 <panic>
+  if(p->pgdir == 0)
+80108585:	8b 45 08             	mov    0x8(%ebp),%eax
+80108588:	8b 40 18             	mov    0x18(%eax),%eax
+8010858b:	85 c0                	test   %eax,%eax
+8010858d:	75 0d                	jne    8010859c <switchuvm+0x4d>
+    panic("switchuvm: no pgdir");
+8010858f:	83 ec 0c             	sub    $0xc,%esp
+80108592:	68 41 9a 10 80       	push   $0x80109a41
+80108597:	e8 35 80 ff ff       	call   801005d1 <panic>
+
+  pushcli();
+8010859c:	e8 67 d3 ff ff       	call   80105908 <pushcli>
+  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+801085a1:	e8 87 bf ff ff       	call   8010452d <mycpu>
+801085a6:	89 c3                	mov    %eax,%ebx
+801085a8:	e8 80 bf ff ff       	call   8010452d <mycpu>
+801085ad:	83 c0 08             	add    $0x8,%eax
+801085b0:	89 c6                	mov    %eax,%esi
+801085b2:	e8 76 bf ff ff       	call   8010452d <mycpu>
+801085b7:	83 c0 08             	add    $0x8,%eax
+801085ba:	c1 e8 10             	shr    $0x10,%eax
+801085bd:	88 45 f7             	mov    %al,-0x9(%ebp)
+801085c0:	e8 68 bf ff ff       	call   8010452d <mycpu>
+801085c5:	83 c0 08             	add    $0x8,%eax
+801085c8:	c1 e8 18             	shr    $0x18,%eax
+801085cb:	89 c2                	mov    %eax,%edx
+801085cd:	66 c7 83 98 00 00 00 	movw   $0x67,0x98(%ebx)
+801085d4:	67 00 
+801085d6:	66 89 b3 9a 00 00 00 	mov    %si,0x9a(%ebx)
+801085dd:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+801085e1:	88 83 9c 00 00 00    	mov    %al,0x9c(%ebx)
+801085e7:	0f b6 83 9d 00 00 00 	movzbl 0x9d(%ebx),%eax
+801085ee:	83 e0 f0             	and    $0xfffffff0,%eax
+801085f1:	83 c8 09             	or     $0x9,%eax
+801085f4:	88 83 9d 00 00 00    	mov    %al,0x9d(%ebx)
+801085fa:	0f b6 83 9d 00 00 00 	movzbl 0x9d(%ebx),%eax
+80108601:	83 c8 10             	or     $0x10,%eax
+80108604:	88 83 9d 00 00 00    	mov    %al,0x9d(%ebx)
+8010860a:	0f b6 83 9d 00 00 00 	movzbl 0x9d(%ebx),%eax
+80108611:	83 e0 9f             	and    $0xffffff9f,%eax
+80108614:	88 83 9d 00 00 00    	mov    %al,0x9d(%ebx)
+8010861a:	0f b6 83 9d 00 00 00 	movzbl 0x9d(%ebx),%eax
+80108621:	83 c8 80             	or     $0xffffff80,%eax
+80108624:	88 83 9d 00 00 00    	mov    %al,0x9d(%ebx)
+8010862a:	0f b6 83 9e 00 00 00 	movzbl 0x9e(%ebx),%eax
+80108631:	83 e0 f0             	and    $0xfffffff0,%eax
+80108634:	88 83 9e 00 00 00    	mov    %al,0x9e(%ebx)
+8010863a:	0f b6 83 9e 00 00 00 	movzbl 0x9e(%ebx),%eax
+80108641:	83 e0 ef             	and    $0xffffffef,%eax
+80108644:	88 83 9e 00 00 00    	mov    %al,0x9e(%ebx)
+8010864a:	0f b6 83 9e 00 00 00 	movzbl 0x9e(%ebx),%eax
+80108651:	83 e0 df             	and    $0xffffffdf,%eax
+80108654:	88 83 9e 00 00 00    	mov    %al,0x9e(%ebx)
+8010865a:	0f b6 83 9e 00 00 00 	movzbl 0x9e(%ebx),%eax
+80108661:	83 c8 40             	or     $0x40,%eax
+80108664:	88 83 9e 00 00 00    	mov    %al,0x9e(%ebx)
+8010866a:	0f b6 83 9e 00 00 00 	movzbl 0x9e(%ebx),%eax
+80108671:	83 e0 7f             	and    $0x7f,%eax
+80108674:	88 83 9e 00 00 00    	mov    %al,0x9e(%ebx)
+8010867a:	88 93 9f 00 00 00    	mov    %dl,0x9f(%ebx)
+                                sizeof(mycpu()->ts)-1, 0);
+  mycpu()->gdt[SEG_TSS].s = 0;
+80108680:	e8 a8 be ff ff       	call   8010452d <mycpu>
+80108685:	0f b6 90 9d 00 00 00 	movzbl 0x9d(%eax),%edx
+8010868c:	83 e2 ef             	and    $0xffffffef,%edx
+8010868f:	88 90 9d 00 00 00    	mov    %dl,0x9d(%eax)
+  mycpu()->ts.ss0 = SEG_KDATA << 3;
+80108695:	e8 93 be ff ff       	call   8010452d <mycpu>
+8010869a:	66 c7 40 10 10 00    	movw   $0x10,0x10(%eax)
+  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+801086a0:	8b 45 08             	mov    0x8(%ebp),%eax
+801086a3:	8b 40 1c             	mov    0x1c(%eax),%eax
+801086a6:	89 c3                	mov    %eax,%ebx
+801086a8:	e8 80 be ff ff       	call   8010452d <mycpu>
+801086ad:	8d 93 00 10 00 00    	lea    0x1000(%ebx),%edx
+801086b3:	89 50 0c             	mov    %edx,0xc(%eax)
+  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
+  // forbids I/O instructions (e.g., inb and outb) from user space
+  mycpu()->ts.iomb = (ushort) 0xFFFF;
+801086b6:	e8 72 be ff ff       	call   8010452d <mycpu>
+801086bb:	66 c7 40 6e ff ff    	movw   $0xffff,0x6e(%eax)
+  ltr(SEG_TSS << 3);
+801086c1:	83 ec 0c             	sub    $0xc,%esp
+801086c4:	6a 28                	push   $0x28
+801086c6:	e8 03 f9 ff ff       	call   80107fce <ltr>
+801086cb:	83 c4 10             	add    $0x10,%esp
+  lcr3(V2P(p->pgdir));  // switch to process's address space
+801086ce:	8b 45 08             	mov    0x8(%ebp),%eax
+801086d1:	8b 40 18             	mov    0x18(%eax),%eax
+801086d4:	05 00 00 00 80       	add    $0x80000000,%eax
+801086d9:	83 ec 0c             	sub    $0xc,%esp
+801086dc:	50                   	push   %eax
+801086dd:	e8 03 f9 ff ff       	call   80107fe5 <lcr3>
+801086e2:	83 c4 10             	add    $0x10,%esp
+  popcli();
+801086e5:	e8 6f d2 ff ff       	call   80105959 <popcli>
+}
+801086ea:	90                   	nop
+801086eb:	8d 65 f8             	lea    -0x8(%ebp),%esp
+801086ee:	5b                   	pop    %ebx
+801086ef:	5e                   	pop    %esi
+801086f0:	5d                   	pop    %ebp
+801086f1:	c3                   	ret    
+
+801086f2 <inituvm>:
+
+// Load the initcode into address 0 of pgdir.
+// sz must be less than a page.
+void
+inituvm(pde_t *pgdir, char *init, uint sz)
+{
+801086f2:	f3 0f 1e fb          	endbr32 
+801086f6:	55                   	push   %ebp
+801086f7:	89 e5                	mov    %esp,%ebp
+801086f9:	83 ec 18             	sub    $0x18,%esp
+  char *mem;
+
+  if(sz >= PGSIZE)
+801086fc:	81 7d 10 ff 0f 00 00 	cmpl   $0xfff,0x10(%ebp)
+80108703:	76 0d                	jbe    80108712 <inituvm+0x20>
+    panic("inituvm: more than a page");
+80108705:	83 ec 0c             	sub    $0xc,%esp
+80108708:	68 55 9a 10 80       	push   $0x80109a55
+8010870d:	e8 bf 7e ff ff       	call   801005d1 <panic>
+  mem = kalloc();
+80108712:	e8 7b a6 ff ff       	call   80102d92 <kalloc>
+80108717:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(mem, 0, PGSIZE);
+8010871a:	83 ec 04             	sub    $0x4,%esp
+8010871d:	68 00 10 00 00       	push   $0x1000
+80108722:	6a 00                	push   $0x0
+80108724:	ff 75 f4             	pushl  -0xc(%ebp)
+80108727:	e8 ef d2 ff ff       	call   80105a1b <memset>
+8010872c:	83 c4 10             	add    $0x10,%esp
+  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+8010872f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108732:	05 00 00 00 80       	add    $0x80000000,%eax
+80108737:	83 ec 0c             	sub    $0xc,%esp
+8010873a:	6a 06                	push   $0x6
+8010873c:	50                   	push   %eax
+8010873d:	68 00 10 00 00       	push   $0x1000
+80108742:	6a 00                	push   $0x0
+80108744:	ff 75 08             	pushl  0x8(%ebp)
+80108747:	e8 99 fc ff ff       	call   801083e5 <mappages>
+8010874c:	83 c4 20             	add    $0x20,%esp
+  memmove(mem, init, sz);
+8010874f:	83 ec 04             	sub    $0x4,%esp
+80108752:	ff 75 10             	pushl  0x10(%ebp)
+80108755:	ff 75 0c             	pushl  0xc(%ebp)
+80108758:	ff 75 f4             	pushl  -0xc(%ebp)
+8010875b:	e8 82 d3 ff ff       	call   80105ae2 <memmove>
+80108760:	83 c4 10             	add    $0x10,%esp
+}
+80108763:	90                   	nop
+80108764:	c9                   	leave  
+80108765:	c3                   	ret    
+
+80108766 <loaduvm>:
+
+// Load a program segment into pgdir.  addr must be page-aligned
+// and the pages from addr to addr+sz must already be mapped.
+int
+loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+{
+80108766:	f3 0f 1e fb          	endbr32 
+8010876a:	55                   	push   %ebp
+8010876b:	89 e5                	mov    %esp,%ebp
+8010876d:	83 ec 18             	sub    $0x18,%esp
+  uint i, pa, n;
+  pte_t *pte;
+
+  if((uint) addr % PGSIZE != 0)
+80108770:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108773:	25 ff 0f 00 00       	and    $0xfff,%eax
+80108778:	85 c0                	test   %eax,%eax
+8010877a:	74 0d                	je     80108789 <loaduvm+0x23>
+    panic("loaduvm: addr must be page aligned");
+8010877c:	83 ec 0c             	sub    $0xc,%esp
+8010877f:	68 70 9a 10 80       	push   $0x80109a70
+80108784:	e8 48 7e ff ff       	call   801005d1 <panic>
+  for(i = 0; i < sz; i += PGSIZE){
+80108789:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80108790:	e9 8f 00 00 00       	jmp    80108824 <loaduvm+0xbe>
+    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+80108795:	8b 55 0c             	mov    0xc(%ebp),%edx
+80108798:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010879b:	01 d0                	add    %edx,%eax
+8010879d:	83 ec 04             	sub    $0x4,%esp
+801087a0:	6a 00                	push   $0x0
+801087a2:	50                   	push   %eax
+801087a3:	ff 75 08             	pushl  0x8(%ebp)
+801087a6:	e8 a0 fb ff ff       	call   8010834b <walkpgdir>
+801087ab:	83 c4 10             	add    $0x10,%esp
+801087ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
+801087b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+801087b5:	75 0d                	jne    801087c4 <loaduvm+0x5e>
+      panic("loaduvm: address should exist");
+801087b7:	83 ec 0c             	sub    $0xc,%esp
+801087ba:	68 93 9a 10 80       	push   $0x80109a93
+801087bf:	e8 0d 7e ff ff       	call   801005d1 <panic>
+    pa = PTE_ADDR(*pte);
+801087c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801087c7:	8b 00                	mov    (%eax),%eax
+801087c9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+801087ce:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(sz - i < PGSIZE)
+801087d1:	8b 45 18             	mov    0x18(%ebp),%eax
+801087d4:	2b 45 f4             	sub    -0xc(%ebp),%eax
+801087d7:	3d ff 0f 00 00       	cmp    $0xfff,%eax
+801087dc:	77 0b                	ja     801087e9 <loaduvm+0x83>
+      n = sz - i;
+801087de:	8b 45 18             	mov    0x18(%ebp),%eax
+801087e1:	2b 45 f4             	sub    -0xc(%ebp),%eax
+801087e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+801087e7:	eb 07                	jmp    801087f0 <loaduvm+0x8a>
+    else
+      n = PGSIZE;
+801087e9:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
+    if(readi(ip, P2V(pa), offset+i, n) != n)
+801087f0:	8b 55 14             	mov    0x14(%ebp),%edx
+801087f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801087f6:	01 d0                	add    %edx,%eax
+801087f8:	8b 55 e8             	mov    -0x18(%ebp),%edx
+801087fb:	81 c2 00 00 00 80    	add    $0x80000000,%edx
+80108801:	ff 75 f0             	pushl  -0x10(%ebp)
+80108804:	50                   	push   %eax
+80108805:	52                   	push   %edx
+80108806:	ff 75 10             	pushl  0x10(%ebp)
+80108809:	e8 9c 97 ff ff       	call   80101faa <readi>
+8010880e:	83 c4 10             	add    $0x10,%esp
+80108811:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+80108814:	74 07                	je     8010881d <loaduvm+0xb7>
+      return -1;
+80108816:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+8010881b:	eb 18                	jmp    80108835 <loaduvm+0xcf>
+  for(i = 0; i < sz; i += PGSIZE){
+8010881d:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+80108824:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108827:	3b 45 18             	cmp    0x18(%ebp),%eax
+8010882a:	0f 82 65 ff ff ff    	jb     80108795 <loaduvm+0x2f>
+  }
+  return 0;
+80108830:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80108835:	c9                   	leave  
+80108836:	c3                   	ret    
+
+80108837 <allocuvm>:
+
+// Allocate page tables and physical memory to grow process from oldsz to
+// newsz, which need not be page aligned.  Returns new size or 0 on error.
+int
+allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+{
+80108837:	f3 0f 1e fb          	endbr32 
+8010883b:	55                   	push   %ebp
+8010883c:	89 e5                	mov    %esp,%ebp
+8010883e:	83 ec 18             	sub    $0x18,%esp
+  char *mem;
+  uint a;
+
+  if(newsz >= KERNBASE)
+80108841:	8b 45 10             	mov    0x10(%ebp),%eax
+80108844:	85 c0                	test   %eax,%eax
+80108846:	79 0a                	jns    80108852 <allocuvm+0x1b>
+    return 0;
+80108848:	b8 00 00 00 00       	mov    $0x0,%eax
+8010884d:	e9 ec 00 00 00       	jmp    8010893e <allocuvm+0x107>
+  if(newsz < oldsz)
+80108852:	8b 45 10             	mov    0x10(%ebp),%eax
+80108855:	3b 45 0c             	cmp    0xc(%ebp),%eax
+80108858:	73 08                	jae    80108862 <allocuvm+0x2b>
+    return oldsz;
+8010885a:	8b 45 0c             	mov    0xc(%ebp),%eax
+8010885d:	e9 dc 00 00 00       	jmp    8010893e <allocuvm+0x107>
+
+  a = PGROUNDUP(oldsz);
+80108862:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108865:	05 ff 0f 00 00       	add    $0xfff,%eax
+8010886a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+8010886f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  for(; a < newsz; a += PGSIZE){
+80108872:	e9 b8 00 00 00       	jmp    8010892f <allocuvm+0xf8>
+    mem = kalloc();
+80108877:	e8 16 a5 ff ff       	call   80102d92 <kalloc>
+8010887c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(mem == 0){
+8010887f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80108883:	75 2e                	jne    801088b3 <allocuvm+0x7c>
+      cprintf("allocuvm out of memory\n");
+80108885:	83 ec 0c             	sub    $0xc,%esp
+80108888:	68 b1 9a 10 80       	push   $0x80109ab1
+8010888d:	e8 86 7b ff ff       	call   80100418 <cprintf>
+80108892:	83 c4 10             	add    $0x10,%esp
+      deallocuvm(pgdir, newsz, oldsz);
+80108895:	83 ec 04             	sub    $0x4,%esp
+80108898:	ff 75 0c             	pushl  0xc(%ebp)
+8010889b:	ff 75 10             	pushl  0x10(%ebp)
+8010889e:	ff 75 08             	pushl  0x8(%ebp)
+801088a1:	e8 9a 00 00 00       	call   80108940 <deallocuvm>
+801088a6:	83 c4 10             	add    $0x10,%esp
+      return 0;
+801088a9:	b8 00 00 00 00       	mov    $0x0,%eax
+801088ae:	e9 8b 00 00 00       	jmp    8010893e <allocuvm+0x107>
+    }
+    memset(mem, 0, PGSIZE);
+801088b3:	83 ec 04             	sub    $0x4,%esp
+801088b6:	68 00 10 00 00       	push   $0x1000
+801088bb:	6a 00                	push   $0x0
+801088bd:	ff 75 f0             	pushl  -0x10(%ebp)
+801088c0:	e8 56 d1 ff ff       	call   80105a1b <memset>
+801088c5:	83 c4 10             	add    $0x10,%esp
+    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+801088c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801088cb:	8d 90 00 00 00 80    	lea    -0x80000000(%eax),%edx
+801088d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801088d4:	83 ec 0c             	sub    $0xc,%esp
+801088d7:	6a 06                	push   $0x6
+801088d9:	52                   	push   %edx
+801088da:	68 00 10 00 00       	push   $0x1000
+801088df:	50                   	push   %eax
+801088e0:	ff 75 08             	pushl  0x8(%ebp)
+801088e3:	e8 fd fa ff ff       	call   801083e5 <mappages>
+801088e8:	83 c4 20             	add    $0x20,%esp
+801088eb:	85 c0                	test   %eax,%eax
+801088ed:	79 39                	jns    80108928 <allocuvm+0xf1>
+      cprintf("allocuvm out of memory (2)\n");
+801088ef:	83 ec 0c             	sub    $0xc,%esp
+801088f2:	68 c9 9a 10 80       	push   $0x80109ac9
+801088f7:	e8 1c 7b ff ff       	call   80100418 <cprintf>
+801088fc:	83 c4 10             	add    $0x10,%esp
+      deallocuvm(pgdir, newsz, oldsz);
+801088ff:	83 ec 04             	sub    $0x4,%esp
+80108902:	ff 75 0c             	pushl  0xc(%ebp)
+80108905:	ff 75 10             	pushl  0x10(%ebp)
+80108908:	ff 75 08             	pushl  0x8(%ebp)
+8010890b:	e8 30 00 00 00       	call   80108940 <deallocuvm>
+80108910:	83 c4 10             	add    $0x10,%esp
+      kfree(mem);
+80108913:	83 ec 0c             	sub    $0xc,%esp
+80108916:	ff 75 f0             	pushl  -0x10(%ebp)
+80108919:	e8 d6 a3 ff ff       	call   80102cf4 <kfree>
+8010891e:	83 c4 10             	add    $0x10,%esp
+      return 0;
+80108921:	b8 00 00 00 00       	mov    $0x0,%eax
+80108926:	eb 16                	jmp    8010893e <allocuvm+0x107>
+  for(; a < newsz; a += PGSIZE){
+80108928:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+8010892f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108932:	3b 45 10             	cmp    0x10(%ebp),%eax
+80108935:	0f 82 3c ff ff ff    	jb     80108877 <allocuvm+0x40>
+    }
+  }
+  return newsz;
+8010893b:	8b 45 10             	mov    0x10(%ebp),%eax
+}
+8010893e:	c9                   	leave  
+8010893f:	c3                   	ret    
+
+80108940 <deallocuvm>:
+// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+// need to be less than oldsz.  oldsz can be larger than the actual
+// process size.  Returns the new process size.
+int
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+{
+80108940:	f3 0f 1e fb          	endbr32 
+80108944:	55                   	push   %ebp
+80108945:	89 e5                	mov    %esp,%ebp
+80108947:	83 ec 18             	sub    $0x18,%esp
+  pte_t *pte;
+  uint a, pa;
+
+  if(newsz >= oldsz)
+8010894a:	8b 45 10             	mov    0x10(%ebp),%eax
+8010894d:	3b 45 0c             	cmp    0xc(%ebp),%eax
+80108950:	72 08                	jb     8010895a <deallocuvm+0x1a>
+    return oldsz;
+80108952:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108955:	e9 ac 00 00 00       	jmp    80108a06 <deallocuvm+0xc6>
+
+  a = PGROUNDUP(newsz);
+8010895a:	8b 45 10             	mov    0x10(%ebp),%eax
+8010895d:	05 ff 0f 00 00       	add    $0xfff,%eax
+80108962:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108967:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  for(; a  < oldsz; a += PGSIZE){
+8010896a:	e9 88 00 00 00       	jmp    801089f7 <deallocuvm+0xb7>
+    pte = walkpgdir(pgdir, (char*)a, 0);
+8010896f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108972:	83 ec 04             	sub    $0x4,%esp
+80108975:	6a 00                	push   $0x0
+80108977:	50                   	push   %eax
+80108978:	ff 75 08             	pushl  0x8(%ebp)
+8010897b:	e8 cb f9 ff ff       	call   8010834b <walkpgdir>
+80108980:	83 c4 10             	add    $0x10,%esp
+80108983:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(!pte)
+80108986:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+8010898a:	75 16                	jne    801089a2 <deallocuvm+0x62>
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+8010898c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+8010898f:	c1 e8 16             	shr    $0x16,%eax
+80108992:	83 c0 01             	add    $0x1,%eax
+80108995:	c1 e0 16             	shl    $0x16,%eax
+80108998:	2d 00 10 00 00       	sub    $0x1000,%eax
+8010899d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+801089a0:	eb 4e                	jmp    801089f0 <deallocuvm+0xb0>
+    else if((*pte & PTE_P) != 0){
+801089a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801089a5:	8b 00                	mov    (%eax),%eax
+801089a7:	83 e0 01             	and    $0x1,%eax
+801089aa:	85 c0                	test   %eax,%eax
+801089ac:	74 42                	je     801089f0 <deallocuvm+0xb0>
+      pa = PTE_ADDR(*pte);
+801089ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801089b1:	8b 00                	mov    (%eax),%eax
+801089b3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+801089b8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+      if(pa == 0)
+801089bb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+801089bf:	75 0d                	jne    801089ce <deallocuvm+0x8e>
+        panic("kfree");
+801089c1:	83 ec 0c             	sub    $0xc,%esp
+801089c4:	68 e5 9a 10 80       	push   $0x80109ae5
+801089c9:	e8 03 7c ff ff       	call   801005d1 <panic>
+      char *v = P2V(pa);
+801089ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
+801089d1:	05 00 00 00 80       	add    $0x80000000,%eax
+801089d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      kfree(v);
+801089d9:	83 ec 0c             	sub    $0xc,%esp
+801089dc:	ff 75 e8             	pushl  -0x18(%ebp)
+801089df:	e8 10 a3 ff ff       	call   80102cf4 <kfree>
+801089e4:	83 c4 10             	add    $0x10,%esp
+      *pte = 0;
+801089e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+801089ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+  for(; a  < oldsz; a += PGSIZE){
+801089f0:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+801089f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+801089fa:	3b 45 0c             	cmp    0xc(%ebp),%eax
+801089fd:	0f 82 6c ff ff ff    	jb     8010896f <deallocuvm+0x2f>
+    }
+  }
+  return newsz;
+80108a03:	8b 45 10             	mov    0x10(%ebp),%eax
+}
+80108a06:	c9                   	leave  
+80108a07:	c3                   	ret    
+
+80108a08 <freevm>:
+
+// Free a page table and all the physical memory pages
+// in the user part.
+void
+freevm(pde_t *pgdir)
+{
+80108a08:	f3 0f 1e fb          	endbr32 
+80108a0c:	55                   	push   %ebp
+80108a0d:	89 e5                	mov    %esp,%ebp
+80108a0f:	83 ec 18             	sub    $0x18,%esp
+  uint i;
+
+  if(pgdir == 0)
+80108a12:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+80108a16:	75 0d                	jne    80108a25 <freevm+0x1d>
+    panic("freevm: no pgdir");
+80108a18:	83 ec 0c             	sub    $0xc,%esp
+80108a1b:	68 eb 9a 10 80       	push   $0x80109aeb
+80108a20:	e8 ac 7b ff ff       	call   801005d1 <panic>
+  deallocuvm(pgdir, KERNBASE, 0);
+80108a25:	83 ec 04             	sub    $0x4,%esp
+80108a28:	6a 00                	push   $0x0
+80108a2a:	68 00 00 00 80       	push   $0x80000000
+80108a2f:	ff 75 08             	pushl  0x8(%ebp)
+80108a32:	e8 09 ff ff ff       	call   80108940 <deallocuvm>
+80108a37:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < NPDENTRIES; i++){
+80108a3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80108a41:	eb 48                	jmp    80108a8b <freevm+0x83>
+    if(pgdir[i] & PTE_P){
+80108a43:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108a46:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80108a4d:	8b 45 08             	mov    0x8(%ebp),%eax
+80108a50:	01 d0                	add    %edx,%eax
+80108a52:	8b 00                	mov    (%eax),%eax
+80108a54:	83 e0 01             	and    $0x1,%eax
+80108a57:	85 c0                	test   %eax,%eax
+80108a59:	74 2c                	je     80108a87 <freevm+0x7f>
+      char * v = P2V(PTE_ADDR(pgdir[i]));
+80108a5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108a5e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+80108a65:	8b 45 08             	mov    0x8(%ebp),%eax
+80108a68:	01 d0                	add    %edx,%eax
+80108a6a:	8b 00                	mov    (%eax),%eax
+80108a6c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108a71:	05 00 00 00 80       	add    $0x80000000,%eax
+80108a76:	89 45 f0             	mov    %eax,-0x10(%ebp)
+      kfree(v);
+80108a79:	83 ec 0c             	sub    $0xc,%esp
+80108a7c:	ff 75 f0             	pushl  -0x10(%ebp)
+80108a7f:	e8 70 a2 ff ff       	call   80102cf4 <kfree>
+80108a84:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < NPDENTRIES; i++){
+80108a87:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+80108a8b:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
+80108a92:	76 af                	jbe    80108a43 <freevm+0x3b>
+    }
+  }
+  kfree((char*)pgdir);
+80108a94:	83 ec 0c             	sub    $0xc,%esp
+80108a97:	ff 75 08             	pushl  0x8(%ebp)
+80108a9a:	e8 55 a2 ff ff       	call   80102cf4 <kfree>
+80108a9f:	83 c4 10             	add    $0x10,%esp
+}
+80108aa2:	90                   	nop
+80108aa3:	c9                   	leave  
+80108aa4:	c3                   	ret    
+
+80108aa5 <clearpteu>:
+
+// Clear PTE_U on a page. Used to create an inaccessible
+// page beneath the user stack.
+void
+clearpteu(pde_t *pgdir, char *uva)
+{
+80108aa5:	f3 0f 1e fb          	endbr32 
+80108aa9:	55                   	push   %ebp
+80108aaa:	89 e5                	mov    %esp,%ebp
+80108aac:	83 ec 18             	sub    $0x18,%esp
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+80108aaf:	83 ec 04             	sub    $0x4,%esp
+80108ab2:	6a 00                	push   $0x0
+80108ab4:	ff 75 0c             	pushl  0xc(%ebp)
+80108ab7:	ff 75 08             	pushl  0x8(%ebp)
+80108aba:	e8 8c f8 ff ff       	call   8010834b <walkpgdir>
+80108abf:	83 c4 10             	add    $0x10,%esp
+80108ac2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pte == 0)
+80108ac5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+80108ac9:	75 0d                	jne    80108ad8 <clearpteu+0x33>
+    panic("clearpteu");
+80108acb:	83 ec 0c             	sub    $0xc,%esp
+80108ace:	68 fc 9a 10 80       	push   $0x80109afc
+80108ad3:	e8 f9 7a ff ff       	call   801005d1 <panic>
+  *pte &= ~PTE_U;
+80108ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108adb:	8b 00                	mov    (%eax),%eax
+80108add:	83 e0 fb             	and    $0xfffffffb,%eax
+80108ae0:	89 c2                	mov    %eax,%edx
+80108ae2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108ae5:	89 10                	mov    %edx,(%eax)
+}
+80108ae7:	90                   	nop
+80108ae8:	c9                   	leave  
+80108ae9:	c3                   	ret    
+
+80108aea <copyuvm>:
+
+// Given a parent process's page table, create a copy
+// of it for a child.
+pde_t*
+copyuvm(pde_t *pgdir, uint sz)
+{
+80108aea:	f3 0f 1e fb          	endbr32 
+80108aee:	55                   	push   %ebp
+80108aef:	89 e5                	mov    %esp,%ebp
+80108af1:	83 ec 28             	sub    $0x28,%esp
+  pde_t *d;
+  pte_t *pte;
+  uint pa, i, flags;
+  char *mem;
+
+  if((d = setupkvm()) == 0)
+80108af4:	e8 80 f9 ff ff       	call   80108479 <setupkvm>
+80108af9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+80108afc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+80108b00:	75 0a                	jne    80108b0c <copyuvm+0x22>
+    return 0;
+80108b02:	b8 00 00 00 00       	mov    $0x0,%eax
+80108b07:	e9 f8 00 00 00       	jmp    80108c04 <copyuvm+0x11a>
+  for(i = 0; i < sz; i += PGSIZE){
+80108b0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+80108b13:	e9 c7 00 00 00       	jmp    80108bdf <copyuvm+0xf5>
+    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+80108b18:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108b1b:	83 ec 04             	sub    $0x4,%esp
+80108b1e:	6a 00                	push   $0x0
+80108b20:	50                   	push   %eax
+80108b21:	ff 75 08             	pushl  0x8(%ebp)
+80108b24:	e8 22 f8 ff ff       	call   8010834b <walkpgdir>
+80108b29:	83 c4 10             	add    $0x10,%esp
+80108b2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+80108b2f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+80108b33:	75 0d                	jne    80108b42 <copyuvm+0x58>
+      panic("copyuvm: pte should exist");
+80108b35:	83 ec 0c             	sub    $0xc,%esp
+80108b38:	68 06 9b 10 80       	push   $0x80109b06
+80108b3d:	e8 8f 7a ff ff       	call   801005d1 <panic>
+    if(!(*pte & PTE_P))
+80108b42:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108b45:	8b 00                	mov    (%eax),%eax
+80108b47:	83 e0 01             	and    $0x1,%eax
+80108b4a:	85 c0                	test   %eax,%eax
+80108b4c:	75 0d                	jne    80108b5b <copyuvm+0x71>
+      panic("copyuvm: page not present");
+80108b4e:	83 ec 0c             	sub    $0xc,%esp
+80108b51:	68 20 9b 10 80       	push   $0x80109b20
+80108b56:	e8 76 7a ff ff       	call   801005d1 <panic>
+    pa = PTE_ADDR(*pte);
+80108b5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108b5e:	8b 00                	mov    (%eax),%eax
+80108b60:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108b65:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    flags = PTE_FLAGS(*pte);
+80108b68:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108b6b:	8b 00                	mov    (%eax),%eax
+80108b6d:	25 ff 0f 00 00       	and    $0xfff,%eax
+80108b72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if((mem = kalloc()) == 0)
+80108b75:	e8 18 a2 ff ff       	call   80102d92 <kalloc>
+80108b7a:	89 45 e0             	mov    %eax,-0x20(%ebp)
+80108b7d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+80108b81:	74 6d                	je     80108bf0 <copyuvm+0x106>
+      goto bad;
+    memmove(mem, (char*)P2V(pa), PGSIZE);
+80108b83:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80108b86:	05 00 00 00 80       	add    $0x80000000,%eax
+80108b8b:	83 ec 04             	sub    $0x4,%esp
+80108b8e:	68 00 10 00 00       	push   $0x1000
+80108b93:	50                   	push   %eax
+80108b94:	ff 75 e0             	pushl  -0x20(%ebp)
+80108b97:	e8 46 cf ff ff       	call   80105ae2 <memmove>
+80108b9c:	83 c4 10             	add    $0x10,%esp
+    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
+80108b9f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+80108ba2:	8b 45 e0             	mov    -0x20(%ebp),%eax
+80108ba5:	8d 88 00 00 00 80    	lea    -0x80000000(%eax),%ecx
+80108bab:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108bae:	83 ec 0c             	sub    $0xc,%esp
+80108bb1:	52                   	push   %edx
+80108bb2:	51                   	push   %ecx
+80108bb3:	68 00 10 00 00       	push   $0x1000
+80108bb8:	50                   	push   %eax
+80108bb9:	ff 75 f0             	pushl  -0x10(%ebp)
+80108bbc:	e8 24 f8 ff ff       	call   801083e5 <mappages>
+80108bc1:	83 c4 20             	add    $0x20,%esp
+80108bc4:	85 c0                	test   %eax,%eax
+80108bc6:	79 10                	jns    80108bd8 <copyuvm+0xee>
+      kfree(mem);
+80108bc8:	83 ec 0c             	sub    $0xc,%esp
+80108bcb:	ff 75 e0             	pushl  -0x20(%ebp)
+80108bce:	e8 21 a1 ff ff       	call   80102cf4 <kfree>
+80108bd3:	83 c4 10             	add    $0x10,%esp
+      goto bad;
+80108bd6:	eb 19                	jmp    80108bf1 <copyuvm+0x107>
+  for(i = 0; i < sz; i += PGSIZE){
+80108bd8:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+80108bdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108be2:	3b 45 0c             	cmp    0xc(%ebp),%eax
+80108be5:	0f 82 2d ff ff ff    	jb     80108b18 <copyuvm+0x2e>
+    }
+  }
+  return d;
+80108beb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108bee:	eb 14                	jmp    80108c04 <copyuvm+0x11a>
+      goto bad;
+80108bf0:	90                   	nop
+
+bad:
+  freevm(d);
+80108bf1:	83 ec 0c             	sub    $0xc,%esp
+80108bf4:	ff 75 f0             	pushl  -0x10(%ebp)
+80108bf7:	e8 0c fe ff ff       	call   80108a08 <freevm>
+80108bfc:	83 c4 10             	add    $0x10,%esp
+  return 0;
+80108bff:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80108c04:	c9                   	leave  
+80108c05:	c3                   	ret    
+
+80108c06 <uva2ka>:
+
+//PAGEBREAK!
+// Map user virtual address to kernel address.
+char*
+uva2ka(pde_t *pgdir, char *uva)
+{
+80108c06:	f3 0f 1e fb          	endbr32 
+80108c0a:	55                   	push   %ebp
+80108c0b:	89 e5                	mov    %esp,%ebp
+80108c0d:	83 ec 18             	sub    $0x18,%esp
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+80108c10:	83 ec 04             	sub    $0x4,%esp
+80108c13:	6a 00                	push   $0x0
+80108c15:	ff 75 0c             	pushl  0xc(%ebp)
+80108c18:	ff 75 08             	pushl  0x8(%ebp)
+80108c1b:	e8 2b f7 ff ff       	call   8010834b <walkpgdir>
+80108c20:	83 c4 10             	add    $0x10,%esp
+80108c23:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if((*pte & PTE_P) == 0)
+80108c26:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108c29:	8b 00                	mov    (%eax),%eax
+80108c2b:	83 e0 01             	and    $0x1,%eax
+80108c2e:	85 c0                	test   %eax,%eax
+80108c30:	75 07                	jne    80108c39 <uva2ka+0x33>
+    return 0;
+80108c32:	b8 00 00 00 00       	mov    $0x0,%eax
+80108c37:	eb 22                	jmp    80108c5b <uva2ka+0x55>
+  if((*pte & PTE_U) == 0)
+80108c39:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108c3c:	8b 00                	mov    (%eax),%eax
+80108c3e:	83 e0 04             	and    $0x4,%eax
+80108c41:	85 c0                	test   %eax,%eax
+80108c43:	75 07                	jne    80108c4c <uva2ka+0x46>
+    return 0;
+80108c45:	b8 00 00 00 00       	mov    $0x0,%eax
+80108c4a:	eb 0f                	jmp    80108c5b <uva2ka+0x55>
+  return (char*)P2V(PTE_ADDR(*pte));
+80108c4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+80108c4f:	8b 00                	mov    (%eax),%eax
+80108c51:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108c56:	05 00 00 00 80       	add    $0x80000000,%eax
+}
+80108c5b:	c9                   	leave  
+80108c5c:	c3                   	ret    
+
+80108c5d <copyout>:
+// Copy len bytes from p to user address va in page table pgdir.
+// Most useful when pgdir is not the current page table.
+// uva2ka ensures this only works for PTE_U pages.
+int
+copyout(pde_t *pgdir, uint va, void *p, uint len)
+{
+80108c5d:	f3 0f 1e fb          	endbr32 
+80108c61:	55                   	push   %ebp
+80108c62:	89 e5                	mov    %esp,%ebp
+80108c64:	83 ec 18             	sub    $0x18,%esp
+  char *buf, *pa0;
+  uint n, va0;
+
+  buf = (char*)p;
+80108c67:	8b 45 10             	mov    0x10(%ebp),%eax
+80108c6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(len > 0){
+80108c6d:	eb 7f                	jmp    80108cee <copyout+0x91>
+    va0 = (uint)PGROUNDDOWN(va);
+80108c6f:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108c72:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+80108c77:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    pa0 = uva2ka(pgdir, (char*)va0);
+80108c7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108c7d:	83 ec 08             	sub    $0x8,%esp
+80108c80:	50                   	push   %eax
+80108c81:	ff 75 08             	pushl  0x8(%ebp)
+80108c84:	e8 7d ff ff ff       	call   80108c06 <uva2ka>
+80108c89:	83 c4 10             	add    $0x10,%esp
+80108c8c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(pa0 == 0)
+80108c8f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+80108c93:	75 07                	jne    80108c9c <copyout+0x3f>
+      return -1;
+80108c95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+80108c9a:	eb 61                	jmp    80108cfd <copyout+0xa0>
+    n = PGSIZE - (va - va0);
+80108c9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108c9f:	2b 45 0c             	sub    0xc(%ebp),%eax
+80108ca2:	05 00 10 00 00       	add    $0x1000,%eax
+80108ca7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(n > len)
+80108caa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108cad:	3b 45 14             	cmp    0x14(%ebp),%eax
+80108cb0:	76 06                	jbe    80108cb8 <copyout+0x5b>
+      n = len;
+80108cb2:	8b 45 14             	mov    0x14(%ebp),%eax
+80108cb5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    memmove(pa0 + (va - va0), buf, n);
+80108cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
+80108cbb:	2b 45 ec             	sub    -0x14(%ebp),%eax
+80108cbe:	89 c2                	mov    %eax,%edx
+80108cc0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+80108cc3:	01 d0                	add    %edx,%eax
+80108cc5:	83 ec 04             	sub    $0x4,%esp
+80108cc8:	ff 75 f0             	pushl  -0x10(%ebp)
+80108ccb:	ff 75 f4             	pushl  -0xc(%ebp)
+80108cce:	50                   	push   %eax
+80108ccf:	e8 0e ce ff ff       	call   80105ae2 <memmove>
+80108cd4:	83 c4 10             	add    $0x10,%esp
+    len -= n;
+80108cd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108cda:	29 45 14             	sub    %eax,0x14(%ebp)
+    buf += n;
+80108cdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+80108ce0:	01 45 f4             	add    %eax,-0xc(%ebp)
+    va = va0 + PGSIZE;
+80108ce3:	8b 45 ec             	mov    -0x14(%ebp),%eax
+80108ce6:	05 00 10 00 00       	add    $0x1000,%eax
+80108ceb:	89 45 0c             	mov    %eax,0xc(%ebp)
+  while(len > 0){
+80108cee:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+80108cf2:	0f 85 77 ff ff ff    	jne    80108c6f <copyout+0x12>
+  }
+  return 0;
+80108cf8:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+80108cfd:	c9                   	leave  
+80108cfe:	c3                   	ret    
diff -ruN xv6-public/xv6-public/kernel.ld xv6-public_new/xv6-public/kernel.ld
--- xv6-public/xv6-public/kernel.ld	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kernel.ld	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,64 @@
+/* Simple linker script for the JOS kernel.
+   See the GNU ld 'info' manual ("info ld") to learn the syntax. */
+
+OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
+OUTPUT_ARCH(i386)
+ENTRY(_start)
+
+SECTIONS
+{
+	/* Link the kernel at this address: "." means the current address */
+        /* Must be equal to KERNLINK */
+	. = 0x80100000;
+
+	.text : AT(0x100000) {
+		*(.text .stub .text.* .gnu.linkonce.t.*)
+	}
+
+	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
+
+	.rodata : {
+		*(.rodata .rodata.* .gnu.linkonce.r.*)
+	}
+
+	/* Include debugging information in kernel memory */
+	.stab : {
+		PROVIDE(__STAB_BEGIN__ = .);
+		*(.stab);
+		PROVIDE(__STAB_END__ = .);
+	}
+
+	.stabstr : {
+		PROVIDE(__STABSTR_BEGIN__ = .);
+		*(.stabstr);
+		PROVIDE(__STABSTR_END__ = .);
+	}
+
+	/* Adjust the address for the data segment to the next page */
+	. = ALIGN(0x1000);
+
+	/* Conventionally, Unix linkers provide pseudo-symbols
+	 * etext, edata, and end, at the end of the text, data, and bss.
+	 * For the kernel mapping, we need the address at the beginning
+	 * of the data section, but that's not one of the conventional
+	 * symbols, because the convention started before there was a
+	 * read-only rodata section between text and data. */
+	PROVIDE(data = .);
+
+	/* The data segment */
+	.data : {
+		*(.data)
+	}
+
+	PROVIDE(edata = .);
+
+	.bss : {
+		*(.bss)
+	}
+
+	PROVIDE(end = .);
+
+	/DISCARD/ : {
+		*(.eh_frame .note.GNU-stack)
+	}
+}
diff -ruN xv6-public/xv6-public/kernel.sym xv6-public_new/xv6-public/kernel.sym
--- xv6-public/xv6-public/kernel.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kernel.sym	2021-09-30 23:28:54.000000000 +0530
@@ -0,0 +1,577 @@
+80100000 .text
+80108d00 .rodata
+8010a000 .data
+8010c5a0 .bss
+00000000 .debug_line
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_aranges
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .comment
+00000000 .debug_ranges
+00000000 bio.c
+801000c5 bget
+00000000 console.c
+80100323 inb
+80100340 outb
+80100361 cli
+8010c5a0 panicked
+8010c5c0 cons
+80100368 printint
+8010a004 digits.1584
+80100806 consputc
+8010a000 crt
+80100669 cgaputc
+00000000 exec.c
+00000000 file.c
+00000000 fs.c
+801014ab bzero
+80101503 balloc
+80101653 bfree
+8010197e iget
+80101e2c itrunc
+80101d08 bmap
+80102446 skipelem
+801024ea namex
+00000000 ide.c
+8010264c inb
+80102669 insl
+8010268f outb
+801026b0 outsl
+8010c600 idelock
+8010c634 idequeue
+8010c638 havedisk1
+801026d6 idewait
+801027c4 idestart
+00000000 ioapic.c
+80102b26 ioapicread
+80102b41 ioapicwrite
+00000000 kalloc.c
+00000000 kbd.c
+80102deb inb
+8010a020 shiftcode
+8010a120 togglecode
+8010a220 normalmap
+8010a320 shiftmap
+8010a420 ctlmap
+8010c63c shift.1418
+8010a520 charcode.1419
+00000000 lapic.c
+80102f78 inb
+80102f95 outb
+80102fb6 lapicw
+80103236 cmos_read
+8010326a fill_rtcdate
+00000000 log.c
+8010364b recover_from_log
+8010348f install_trans
+8010354c read_head
+801035c4 write_head
+80103886 commit
+801037c9 write_log
+00000000 main.c
+80103994 xchg
+80103aa6 startothers
+80103a5b mpmain
+80103a3d mpenter
+00000000 mp.c
+80103b6f inb
+80103b8c outb
+80103bad sum
+80103be9 mpsearch1
+80103c56 mpsearch
+80103d16 mpconfig
+00000000 picirq.c
+80103f05 outb
+00000000 pipe.c
+00000000 proc.c
+8010435c readeflags
+8010436c sti
+8010c644 initproc
+801045d6 allocproc
+80105209 wakeup1
+8010c004 first.1659
+8010c008 states.1685
+00000000 sleeplock.c
+00000000 spinlock.c
+8010571e readeflags
+8010572e cli
+80105735 sti
+8010573c xchg
+00000000 string.c
+801059cf stosb
+801059f5 stosl
+00000000 syscall.c
+8010c020 syscalls
+00000000 sysfile.c
+80105ecc argfd
+80105f44 fdalloc
+8010631e isdirempty
+8010656f create
+00000000 sysproc.c
+00000000 trap.c
+80106ef7 lidt
+80106f21 rcr2
+00000000 uart.c
+8010733c inb
+80107359 outb
+8010c648 uart
+801074ce uartgetc
+00000000 vm.c
+80107fa4 lgdt
+80107fce ltr
+80107fe5 lcr3
+8010834b walkpgdir
+801083e5 mappages
+8010c4a0 kmap
+80100a19 consoleread
+80107efc vector242
+80107953 vector119
+8010000c entry
+80107833 vector87
+8010782a vector86
+80105c36 safestrcpy
+801060cf sys_close
+80107f68 vector251
+80107857 vector91
+8010764d vector33
+80107b3c vector162
+80105019 yield
+80114720 log
+801146e0 kmem
+80107da0 vector213
+801078f0 vector108
+8010737a uartinit
+801076a7 vector43
+80103125 lapiceoi
+80107b60 vector165
+80107c50 vector185
+80102b60 ioapicinit
+8010792f vector115
+801054ba set_prio
+80101269 fileread
+8010796e vector122
+80106d06 sys_sbrk
+80114800 ioapicid
+80105003 sys_yield
+80107af4 vector156
+80107f20 vector245
+801146d4 ioapic
+80107c80 vector189
+80107571 vector7
+80107749 vector61
+801075fc vector24
+8010790b vector111
+80107d04 vector200
+8010777f vector67
+80107a1c vector138
+801077be vector74
+80105057 sched
+80105ae2 memmove
+80107725 vector57
+80105e4d syscall
+80107dac vector214
+8010789f vector99
+8010450e cpuid
+80102103 writei
+80107a40 vector141
+80106c83 sys_fork
+8010d660 bcache
+80107bb4 vector172
+80107ef0 vector241
+80105844 getcallerpcs
+801068e4 sys_mkdir
+80107f80 vector253
+8010754d vector3
+80107544 vector2
+8010228d namecmp
+80107e48 vector227
+80107d7c vector210
+80105e12 argstr
+80105414 updatestatistics
+80107e24 vector224
+80107695 vector41
+80100418 cprintf
+801010cd filedup
+8010260d namei
+801075e1 vector21
+80100034 binit
+80107bf0 vector177
+8010794a vector118
+8010779a vector70
+80107791 vector69
+80107ec0 vector237
+80107764 vector64
+80107617 vector27
+801079d4 vector132
+80104373 sys_cps
+80107c5c vector186
+80105ff1 sys_read
+80107dd0 vector217
+80105cc4 fetchint
+8010c640 current_time
+80108479 setupkvm
+80105b66 memcpy
+80108a08 freevm
+8010753b vector1
+80107bfc vector178
+8010767a vector38
+80102cf4 kfree
+80107ecc vector238
+8010452d mycpu
+80101c0b iput
+801079e0 vector133
+801077b5 vector73
+80107a64 vector144
+80107f8c vector254
+80101465 readsb
+8010c000 nextpid
+801078b1 vector101
+80107d88 vector211
+80103dbb mpinit
+80107bcc vector174
+80107f08 vector243
+8010103a fileinit
+80105756 initlock
+801079a4 vector128
+80108c5d copyout
+801077fd vector81
+8010515e sleep
+80103144 microdelay
+8010759f vector13
+801076ef vector51
+801075b6 vector16
+80111fc0 input
+80107ee4 vector240
+8010770a vector54
+801075cf vector19
+80107860 vector92
+80107f14 vector244
+80101f60 stati
+80107a34 vector140
+80106cbb sys_kill
+801076b9 vector45
+801077eb vector79
+801040a7 pipeclose
+80107e60 vector229
+80107b0c vector158
+80106122 sys_fstat
+80100b2d consolewrite
+80107683 vector39
+80107b84 vector168
+80103701 end_op
+8010765f vector35
+80104d28 wait2
+8010791d vector113
+80102cb2 freerange
+80107989 vector125
+80108837 allocuvm
+80106eec trapret
+80107dc4 vector216
+8010775b vector63
+8010760e vector26
+80107cb0 vector193
+80102fdc lapicinit
+80107cd4 vector196
+80107d70 vector209
+80107556 vector4
+80107b9c vector170
+8010c650 stack
+80107a04 vector136
+8010758a vector10
+80107d4c vector206
+80101bb9 iunlock
+80106d56 sys_sleep
+80107f98 vector255
+80107c20 vector181
+80107737 vector59
+80107821 vector85
+80107818 vector84
+80107c38 vector183
+80107b18 vector159
+80107d94 vector212
+80106176 sys_link
+801076cb vector47
+80107e54 vector228
+8010769e vector42
+80107926 vector114
+80108c06 uva2ka
+80107bd8 vector175
+80107a58 vector143
+8010105c filealloc
+80105250 wakeup
+801079bc vector130
+80107f2c vector246
+80107581 vector9
+80107a4c vector142
+801078a8 vector100
+80107d10 vector201
+80108aa5 clearpteu
+801045a9 myproc
+80106f32 tvinit
+80107740 vector60
+801075f3 vector23
+80101a64 idup
+80107eb4 vector236
+80102f5b kbdintr
+8010550c sys_set_prio
+80106743 sys_open
+80107e78 vector231
+80107776 vector66
+80107629 vector29
+80101faa readi
+801079f8 vector135
+80100871 consoleintr
+8010528b kill
+801077d9 vector77
+801017de ialloc
+80107c14 vector180
+80117d44 kpgdir
+80107d64 vector208
+801032d3 cmostime
+80107515 uartintr
+80105538 decpriority
+80107896 vector98
+8010788d vector97
+80107be4 vector176
+80107cbc vector194
+80107644 vector32
+80117d48 end
+80107cf8 vector199
+801079c8 vector131
+80107f74 vector252
+80101325 filewrite
+80107532 vector0
+80105d73 argint
+80100bf9 exec
+80107a70 vector145
+80106060 sys_write
+801057ee release
+80105d09 fetchstr
+801078e7 vector107
+8010768c vector40
+80104c02 wait
+801078ba vector102
+8010b000 entrypgdir
+0010000c _start
+8010771c vector56
+80107788 vector68
+80107568 vector6
+8010c50c _binary_initcode_end
+80100000 multiboot_header
+801079b0 vector129
+80104f44 scheduler
+801022ac dirlookup
+80107ce0 vector197
+80101122 fileclose
+80103671 begin_op
+80107ac4 vector152
+80108516 kvmalloc
+80107e6c vector230
+80105b80 strncmp
+80107671 vector37
+80107d40 vector205
+80107b30 vector161
+80117500 tickslock
+80104156 pipewrite
+80105bda strncpy
+801077a3 vector71
+80108aea copyuvm
+80112060 ftable
+80107b24 vector160
+80105da4 argptr
+80107db8 vector215
+80107b00 vector157
+80105f96 sys_dup
+80107914 vector112
+801005d1 panic
+80105114 forkret
+80107c2c vector182
+80107598 vector12
+80105a86 memcmp
+80102e08 kbdgetc
+801078f9 vector109
+801075d8 vector20
+8010494f fork
+80107701 vector53
+801075c6 vector18
+0000008a _binary_entryother_size
+80114820 cpus
+8010566b releasesleep
+8010787b vector95
+801058c3 holding
+80112a60 sb
+8010577c acquire
+80107e3c vector226
+8010262d nameiparent
+801076dd vector49
+801076b0 vector44
+8011471c lapic
+801077e2 vector78
+80106ed4 alltraps
+80107bc0 vector173
+80107941 vector117
+80107806 vector82
+80107e0c vector222
+8010757a vector8
+80107aa0 vector149
+801018b9 iupdate
+8010a000 data
+80105a1b memset
+80107e84 vector232
+801039ae main
+80108532 switchkvm
+801078de vector106
+80107df4 vector220
+80104ec7 sys_wait2
+8010784e vector90
+80107b48 vector163
+80107e9c vector234
+801038ba log_write
+80105603 acquiresleep
+80106385 sys_unlink
+80107752 vector62
+80107605 vector25
+80107cec vector198
+8010795c vector120
+8010c50c _binary_entryother_start
+80102c4d kinit1
+801076e6 vector50
+801075ad vector15
+80107ab8 vector151
+8010780f vector83
+80107845 vector89
+8010783c vector88
+801070c8 trap
+80106df4 sys_uptime
+80107c08 vector179
+80107656 vector34
+801076c2 vector46
+801079ec vector134
+80107e18 vector223
+80117540 idt
+80107ddc vector218
+801044ec pinit
+80108940 deallocuvm
+80107e30 vector225
+801030ff lapicid
+80107c68 vector187
+801048ae growproc
+801056bd holdingsleep
+80114da0 ncpu
+80107632 vector30
+80104775 userinit
+801001d7 bread
+8010799b vector127
+8010425c piperead
+80105577 inctickcounter
+80117d40 ticks
+80107ca4 vector192
+80107b6c vector166
+80100baa consoleinit
+801077d0 vector76
+801077c7 vector75
+8010295a ideintr
+80107cc8 vector195
+80107aac vector150
+8010772e vector58
+80107f44 vector248
+80107977 vector123
+80107884 vector96
+8010763b vector31
+80107d28 vector203
+80107a28 vector139
+80107ad0 vector153
+80107b54 vector164
+80105316 procdump
+80107965 vector121
+80107465 uartputc
+8010755f vector5
+80107b78 vector167
+80107ae8 vector155
+80107f50 vector249
+80100261 brelse
+80107f5c vector250
+80107980 vector124
+80107902 vector110
+80107d34 vector204
+80101aa2 ilock
+80106a9c sys_exec
+80107a10 vector137
+8010c4e0 _binary_initcode_start
+80105caf swtch
+80107f38 vector247
+801075ea vector22
+80107d1c vector202
+80107ff1 seginit
+80101cdf iunlockput
+801077ac vector72
+80107713 vector55
+80107992 vector126
+8010776d vector65
+80107620 vector28
+8010c596 _binary_entryother_end
+80107b90 vector169
+80100214 bwrite
+80107e90 vector233
+801070ac idtinit
+80104adb exit
+80106caa sys_wait
+80106c94 sys_exit
+8010236a dirlink
+0000002c _binary_initcode_size
+80107a88 vector147
+801055c3 initsleeplock
+8010271f ideinit
+80108766 loaduvm
+801078cc vector104
+80107938 vector116
+80114dc0 ptable
+80102c0c ioapicenable
+80105959 popcli
+8010c08c vectors
+801076f8 vector52
+801075bf vector17
+80107c44 vector184
+80105c84 strlen
+80106ba8 sys_pipe
+8010171c iinit
+80103f26 picinit
+80107d58 vector207
+801086f2 inituvm
+80107c8c vector190
+80107ed8 vector239
+80107872 vector94
+80107869 vector93
+8010343e initlog
+80107c74 vector188
+801076d4 vector48
+80102a33 iderw
+80107de8 vector219
+80107a94 vector148
+80107e00 vector221
+80102d92 kalloc
+80112a00 devsw
+80106cf2 sys_getpid
+80106e2b sys_draw
+801077f4 vector80
+80107ba8 vector171
+80107adc vector154
+80107668 vector36
+80103f51 pipealloc
+80107ea8 vector235
+801078d5 vector105
+801069e2 sys_chdir
+80112a80 icache
+80107a7c vector146
+80107c98 vector191
+801078c3 vector103
+80106949 sys_mknod
+8010314e lapicstartap
+8010854f switchuvm
+80105908 pushcli
+80102c8a kinit2
+80107591 vector11
+801075a6 vector14
+8010120e filestat
diff -ruN xv6-public/xv6-public/kill.asm xv6-public_new/xv6-public/kill.asm
--- xv6-public/xv6-public/kill.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kill.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1171 @@
+
+_kill:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char **argv)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	53                   	push   %ebx
+  12:	51                   	push   %ecx
+  13:	83 ec 10             	sub    $0x10,%esp
+  16:	89 cb                	mov    %ecx,%ebx
+  int i;
+
+  if(argc < 2){
+  18:	83 3b 01             	cmpl   $0x1,(%ebx)
+  1b:	7f 17                	jg     34 <main+0x34>
+    printf(2, "usage: kill pid...\n");
+  1d:	83 ec 08             	sub    $0x8,%esp
+  20:	68 5c 08 00 00       	push   $0x85c
+  25:	6a 02                	push   $0x2
+  27:	e8 69 04 00 00       	call   495 <printf>
+  2c:	83 c4 10             	add    $0x10,%esp
+    exit();
+  2f:	e8 bd 02 00 00       	call   2f1 <exit>
+  }
+  for(i=1; i<argc; i++)
+  34:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+  3b:	eb 2d                	jmp    6a <main+0x6a>
+    kill(atoi(argv[i]));
+  3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  40:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  47:	8b 43 04             	mov    0x4(%ebx),%eax
+  4a:	01 d0                	add    %edx,%eax
+  4c:	8b 00                	mov    (%eax),%eax
+  4e:	83 ec 0c             	sub    $0xc,%esp
+  51:	50                   	push   %eax
+  52:	e8 00 02 00 00       	call   257 <atoi>
+  57:	83 c4 10             	add    $0x10,%esp
+  5a:	83 ec 0c             	sub    $0xc,%esp
+  5d:	50                   	push   %eax
+  5e:	e8 be 02 00 00       	call   321 <kill>
+  63:	83 c4 10             	add    $0x10,%esp
+  for(i=1; i<argc; i++)
+  66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  6d:	3b 03                	cmp    (%ebx),%eax
+  6f:	7c cc                	jl     3d <main+0x3d>
+  exit();
+  71:	e8 7b 02 00 00       	call   2f1 <exit>
+
+00000076 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  76:	55                   	push   %ebp
+  77:	89 e5                	mov    %esp,%ebp
+  79:	57                   	push   %edi
+  7a:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  7b:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  7e:	8b 55 10             	mov    0x10(%ebp),%edx
+  81:	8b 45 0c             	mov    0xc(%ebp),%eax
+  84:	89 cb                	mov    %ecx,%ebx
+  86:	89 df                	mov    %ebx,%edi
+  88:	89 d1                	mov    %edx,%ecx
+  8a:	fc                   	cld    
+  8b:	f3 aa                	rep stos %al,%es:(%edi)
+  8d:	89 ca                	mov    %ecx,%edx
+  8f:	89 fb                	mov    %edi,%ebx
+  91:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  94:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  97:	90                   	nop
+  98:	5b                   	pop    %ebx
+  99:	5f                   	pop    %edi
+  9a:	5d                   	pop    %ebp
+  9b:	c3                   	ret    
+
+0000009c <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  9c:	f3 0f 1e fb          	endbr32 
+  a0:	55                   	push   %ebp
+  a1:	89 e5                	mov    %esp,%ebp
+  a3:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  a6:	8b 45 08             	mov    0x8(%ebp),%eax
+  a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  ac:	90                   	nop
+  ad:	8b 55 0c             	mov    0xc(%ebp),%edx
+  b0:	8d 42 01             	lea    0x1(%edx),%eax
+  b3:	89 45 0c             	mov    %eax,0xc(%ebp)
+  b6:	8b 45 08             	mov    0x8(%ebp),%eax
+  b9:	8d 48 01             	lea    0x1(%eax),%ecx
+  bc:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  bf:	0f b6 12             	movzbl (%edx),%edx
+  c2:	88 10                	mov    %dl,(%eax)
+  c4:	0f b6 00             	movzbl (%eax),%eax
+  c7:	84 c0                	test   %al,%al
+  c9:	75 e2                	jne    ad <strcpy+0x11>
+    ;
+  return os;
+  cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  ce:	c9                   	leave  
+  cf:	c3                   	ret    
+
+000000d0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  d0:	f3 0f 1e fb          	endbr32 
+  d4:	55                   	push   %ebp
+  d5:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  d7:	eb 08                	jmp    e1 <strcmp+0x11>
+    p++, q++;
+  d9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  dd:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+  e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  e4:	0f b6 00             	movzbl (%eax),%eax
+  e7:	84 c0                	test   %al,%al
+  e9:	74 10                	je     fb <strcmp+0x2b>
+  eb:	8b 45 08             	mov    0x8(%ebp),%eax
+  ee:	0f b6 10             	movzbl (%eax),%edx
+  f1:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f4:	0f b6 00             	movzbl (%eax),%eax
+  f7:	38 c2                	cmp    %al,%dl
+  f9:	74 de                	je     d9 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+  fb:	8b 45 08             	mov    0x8(%ebp),%eax
+  fe:	0f b6 00             	movzbl (%eax),%eax
+ 101:	0f b6 d0             	movzbl %al,%edx
+ 104:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 107:	0f b6 00             	movzbl (%eax),%eax
+ 10a:	0f b6 c0             	movzbl %al,%eax
+ 10d:	29 c2                	sub    %eax,%edx
+ 10f:	89 d0                	mov    %edx,%eax
+}
+ 111:	5d                   	pop    %ebp
+ 112:	c3                   	ret    
+
+00000113 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 113:	f3 0f 1e fb          	endbr32 
+ 117:	55                   	push   %ebp
+ 118:	89 e5                	mov    %esp,%ebp
+ 11a:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 11d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 124:	eb 04                	jmp    12a <strlen+0x17>
+ 126:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 12a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 12d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 130:	01 d0                	add    %edx,%eax
+ 132:	0f b6 00             	movzbl (%eax),%eax
+ 135:	84 c0                	test   %al,%al
+ 137:	75 ed                	jne    126 <strlen+0x13>
+    ;
+  return n;
+ 139:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 13c:	c9                   	leave  
+ 13d:	c3                   	ret    
+
+0000013e <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 13e:	f3 0f 1e fb          	endbr32 
+ 142:	55                   	push   %ebp
+ 143:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 145:	8b 45 10             	mov    0x10(%ebp),%eax
+ 148:	50                   	push   %eax
+ 149:	ff 75 0c             	pushl  0xc(%ebp)
+ 14c:	ff 75 08             	pushl  0x8(%ebp)
+ 14f:	e8 22 ff ff ff       	call   76 <stosb>
+ 154:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 157:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 15a:	c9                   	leave  
+ 15b:	c3                   	ret    
+
+0000015c <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 15c:	f3 0f 1e fb          	endbr32 
+ 160:	55                   	push   %ebp
+ 161:	89 e5                	mov    %esp,%ebp
+ 163:	83 ec 04             	sub    $0x4,%esp
+ 166:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 169:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 16c:	eb 14                	jmp    182 <strchr+0x26>
+    if(*s == c)
+ 16e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 171:	0f b6 00             	movzbl (%eax),%eax
+ 174:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 177:	75 05                	jne    17e <strchr+0x22>
+      return (char*)s;
+ 179:	8b 45 08             	mov    0x8(%ebp),%eax
+ 17c:	eb 13                	jmp    191 <strchr+0x35>
+  for(; *s; s++)
+ 17e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 182:	8b 45 08             	mov    0x8(%ebp),%eax
+ 185:	0f b6 00             	movzbl (%eax),%eax
+ 188:	84 c0                	test   %al,%al
+ 18a:	75 e2                	jne    16e <strchr+0x12>
+  return 0;
+ 18c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 191:	c9                   	leave  
+ 192:	c3                   	ret    
+
+00000193 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 193:	f3 0f 1e fb          	endbr32 
+ 197:	55                   	push   %ebp
+ 198:	89 e5                	mov    %esp,%ebp
+ 19a:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 19d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1a4:	eb 42                	jmp    1e8 <gets+0x55>
+    cc = read(0, &c, 1);
+ 1a6:	83 ec 04             	sub    $0x4,%esp
+ 1a9:	6a 01                	push   $0x1
+ 1ab:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1ae:	50                   	push   %eax
+ 1af:	6a 00                	push   $0x0
+ 1b1:	e8 53 01 00 00       	call   309 <read>
+ 1b6:	83 c4 10             	add    $0x10,%esp
+ 1b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1c0:	7e 33                	jle    1f5 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1c5:	8d 50 01             	lea    0x1(%eax),%edx
+ 1c8:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 1cb:	89 c2                	mov    %eax,%edx
+ 1cd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1d0:	01 c2                	add    %eax,%edx
+ 1d2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1d6:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 1d8:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1dc:	3c 0a                	cmp    $0xa,%al
+ 1de:	74 16                	je     1f6 <gets+0x63>
+ 1e0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1e4:	3c 0d                	cmp    $0xd,%al
+ 1e6:	74 0e                	je     1f6 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 1e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1eb:	83 c0 01             	add    $0x1,%eax
+ 1ee:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 1f1:	7f b3                	jg     1a6 <gets+0x13>
+ 1f3:	eb 01                	jmp    1f6 <gets+0x63>
+      break;
+ 1f5:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 1f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1f9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1fc:	01 d0                	add    %edx,%eax
+ 1fe:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 201:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 204:	c9                   	leave  
+ 205:	c3                   	ret    
+
+00000206 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 206:	f3 0f 1e fb          	endbr32 
+ 20a:	55                   	push   %ebp
+ 20b:	89 e5                	mov    %esp,%ebp
+ 20d:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 210:	83 ec 08             	sub    $0x8,%esp
+ 213:	6a 00                	push   $0x0
+ 215:	ff 75 08             	pushl  0x8(%ebp)
+ 218:	e8 14 01 00 00       	call   331 <open>
+ 21d:	83 c4 10             	add    $0x10,%esp
+ 220:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 223:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 227:	79 07                	jns    230 <stat+0x2a>
+    return -1;
+ 229:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 22e:	eb 25                	jmp    255 <stat+0x4f>
+  r = fstat(fd, st);
+ 230:	83 ec 08             	sub    $0x8,%esp
+ 233:	ff 75 0c             	pushl  0xc(%ebp)
+ 236:	ff 75 f4             	pushl  -0xc(%ebp)
+ 239:	e8 0b 01 00 00       	call   349 <fstat>
+ 23e:	83 c4 10             	add    $0x10,%esp
+ 241:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 244:	83 ec 0c             	sub    $0xc,%esp
+ 247:	ff 75 f4             	pushl  -0xc(%ebp)
+ 24a:	e8 ca 00 00 00       	call   319 <close>
+ 24f:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 252:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 255:	c9                   	leave  
+ 256:	c3                   	ret    
+
+00000257 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 257:	f3 0f 1e fb          	endbr32 
+ 25b:	55                   	push   %ebp
+ 25c:	89 e5                	mov    %esp,%ebp
+ 25e:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 261:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 268:	eb 25                	jmp    28f <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 26a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 26d:	89 d0                	mov    %edx,%eax
+ 26f:	c1 e0 02             	shl    $0x2,%eax
+ 272:	01 d0                	add    %edx,%eax
+ 274:	01 c0                	add    %eax,%eax
+ 276:	89 c1                	mov    %eax,%ecx
+ 278:	8b 45 08             	mov    0x8(%ebp),%eax
+ 27b:	8d 50 01             	lea    0x1(%eax),%edx
+ 27e:	89 55 08             	mov    %edx,0x8(%ebp)
+ 281:	0f b6 00             	movzbl (%eax),%eax
+ 284:	0f be c0             	movsbl %al,%eax
+ 287:	01 c8                	add    %ecx,%eax
+ 289:	83 e8 30             	sub    $0x30,%eax
+ 28c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 28f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 292:	0f b6 00             	movzbl (%eax),%eax
+ 295:	3c 2f                	cmp    $0x2f,%al
+ 297:	7e 0a                	jle    2a3 <atoi+0x4c>
+ 299:	8b 45 08             	mov    0x8(%ebp),%eax
+ 29c:	0f b6 00             	movzbl (%eax),%eax
+ 29f:	3c 39                	cmp    $0x39,%al
+ 2a1:	7e c7                	jle    26a <atoi+0x13>
+  return n;
+ 2a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 2a6:	c9                   	leave  
+ 2a7:	c3                   	ret    
+
+000002a8 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2a8:	f3 0f 1e fb          	endbr32 
+ 2ac:	55                   	push   %ebp
+ 2ad:	89 e5                	mov    %esp,%ebp
+ 2af:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 2b2:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2b8:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2be:	eb 17                	jmp    2d7 <memmove+0x2f>
+    *dst++ = *src++;
+ 2c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 2c3:	8d 42 01             	lea    0x1(%edx),%eax
+ 2c6:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 2c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2cc:	8d 48 01             	lea    0x1(%eax),%ecx
+ 2cf:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 2d2:	0f b6 12             	movzbl (%edx),%edx
+ 2d5:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 2d7:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2da:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 2dd:	89 55 10             	mov    %edx,0x10(%ebp)
+ 2e0:	85 c0                	test   %eax,%eax
+ 2e2:	7f dc                	jg     2c0 <memmove+0x18>
+  return vdst;
+ 2e4:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2e7:	c9                   	leave  
+ 2e8:	c3                   	ret    
+
+000002e9 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2e9:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2ee:	cd 40                	int    $0x40
+ 2f0:	c3                   	ret    
+
+000002f1 <exit>:
+SYSCALL(exit)
+ 2f1:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2f6:	cd 40                	int    $0x40
+ 2f8:	c3                   	ret    
+
+000002f9 <wait>:
+SYSCALL(wait)
+ 2f9:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2fe:	cd 40                	int    $0x40
+ 300:	c3                   	ret    
+
+00000301 <pipe>:
+SYSCALL(pipe)
+ 301:	b8 04 00 00 00       	mov    $0x4,%eax
+ 306:	cd 40                	int    $0x40
+ 308:	c3                   	ret    
+
+00000309 <read>:
+SYSCALL(read)
+ 309:	b8 05 00 00 00       	mov    $0x5,%eax
+ 30e:	cd 40                	int    $0x40
+ 310:	c3                   	ret    
+
+00000311 <write>:
+SYSCALL(write)
+ 311:	b8 10 00 00 00       	mov    $0x10,%eax
+ 316:	cd 40                	int    $0x40
+ 318:	c3                   	ret    
+
+00000319 <close>:
+SYSCALL(close)
+ 319:	b8 15 00 00 00       	mov    $0x15,%eax
+ 31e:	cd 40                	int    $0x40
+ 320:	c3                   	ret    
+
+00000321 <kill>:
+SYSCALL(kill)
+ 321:	b8 06 00 00 00       	mov    $0x6,%eax
+ 326:	cd 40                	int    $0x40
+ 328:	c3                   	ret    
+
+00000329 <exec>:
+SYSCALL(exec)
+ 329:	b8 07 00 00 00       	mov    $0x7,%eax
+ 32e:	cd 40                	int    $0x40
+ 330:	c3                   	ret    
+
+00000331 <open>:
+SYSCALL(open)
+ 331:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 336:	cd 40                	int    $0x40
+ 338:	c3                   	ret    
+
+00000339 <mknod>:
+SYSCALL(mknod)
+ 339:	b8 11 00 00 00       	mov    $0x11,%eax
+ 33e:	cd 40                	int    $0x40
+ 340:	c3                   	ret    
+
+00000341 <unlink>:
+SYSCALL(unlink)
+ 341:	b8 12 00 00 00       	mov    $0x12,%eax
+ 346:	cd 40                	int    $0x40
+ 348:	c3                   	ret    
+
+00000349 <fstat>:
+SYSCALL(fstat)
+ 349:	b8 08 00 00 00       	mov    $0x8,%eax
+ 34e:	cd 40                	int    $0x40
+ 350:	c3                   	ret    
+
+00000351 <link>:
+SYSCALL(link)
+ 351:	b8 13 00 00 00       	mov    $0x13,%eax
+ 356:	cd 40                	int    $0x40
+ 358:	c3                   	ret    
+
+00000359 <mkdir>:
+SYSCALL(mkdir)
+ 359:	b8 14 00 00 00       	mov    $0x14,%eax
+ 35e:	cd 40                	int    $0x40
+ 360:	c3                   	ret    
+
+00000361 <chdir>:
+SYSCALL(chdir)
+ 361:	b8 09 00 00 00       	mov    $0x9,%eax
+ 366:	cd 40                	int    $0x40
+ 368:	c3                   	ret    
+
+00000369 <dup>:
+SYSCALL(dup)
+ 369:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 36e:	cd 40                	int    $0x40
+ 370:	c3                   	ret    
+
+00000371 <getpid>:
+SYSCALL(getpid)
+ 371:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 376:	cd 40                	int    $0x40
+ 378:	c3                   	ret    
+
+00000379 <sbrk>:
+SYSCALL(sbrk)
+ 379:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 37e:	cd 40                	int    $0x40
+ 380:	c3                   	ret    
+
+00000381 <sleep>:
+SYSCALL(sleep)
+ 381:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 386:	cd 40                	int    $0x40
+ 388:	c3                   	ret    
+
+00000389 <uptime>:
+SYSCALL(uptime)
+ 389:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 38e:	cd 40                	int    $0x40
+ 390:	c3                   	ret    
+
+00000391 <draw>:
+SYSCALL(draw)
+ 391:	b8 16 00 00 00       	mov    $0x16,%eax
+ 396:	cd 40                	int    $0x40
+ 398:	c3                   	ret    
+
+00000399 <cps>:
+SYSCALL(cps)
+ 399:	b8 17 00 00 00       	mov    $0x17,%eax
+ 39e:	cd 40                	int    $0x40
+ 3a0:	c3                   	ret    
+
+000003a1 <yield>:
+SYSCALL(yield)
+ 3a1:	b8 18 00 00 00       	mov    $0x18,%eax
+ 3a6:	cd 40                	int    $0x40
+ 3a8:	c3                   	ret    
+
+000003a9 <wait2>:
+SYSCALL(wait2)
+ 3a9:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3ae:	cd 40                	int    $0x40
+ 3b0:	c3                   	ret    
+
+000003b1 <set_prio>:
+SYSCALL(set_prio)
+ 3b1:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3b6:	cd 40                	int    $0x40
+ 3b8:	c3                   	ret    
+
+000003b9 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3b9:	f3 0f 1e fb          	endbr32 
+ 3bd:	55                   	push   %ebp
+ 3be:	89 e5                	mov    %esp,%ebp
+ 3c0:	83 ec 18             	sub    $0x18,%esp
+ 3c3:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3c6:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3c9:	83 ec 04             	sub    $0x4,%esp
+ 3cc:	6a 01                	push   $0x1
+ 3ce:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3d1:	50                   	push   %eax
+ 3d2:	ff 75 08             	pushl  0x8(%ebp)
+ 3d5:	e8 37 ff ff ff       	call   311 <write>
+ 3da:	83 c4 10             	add    $0x10,%esp
+}
+ 3dd:	90                   	nop
+ 3de:	c9                   	leave  
+ 3df:	c3                   	ret    
+
+000003e0 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3e0:	f3 0f 1e fb          	endbr32 
+ 3e4:	55                   	push   %ebp
+ 3e5:	89 e5                	mov    %esp,%ebp
+ 3e7:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3ea:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3f1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3f5:	74 17                	je     40e <printint+0x2e>
+ 3f7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3fb:	79 11                	jns    40e <printint+0x2e>
+    neg = 1;
+ 3fd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 404:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 407:	f7 d8                	neg    %eax
+ 409:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 40c:	eb 06                	jmp    414 <printint+0x34>
+  } else {
+    x = xx;
+ 40e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 411:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 414:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 41b:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 41e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 421:	ba 00 00 00 00       	mov    $0x0,%edx
+ 426:	f7 f1                	div    %ecx
+ 428:	89 d1                	mov    %edx,%ecx
+ 42a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 42d:	8d 50 01             	lea    0x1(%eax),%edx
+ 430:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 433:	0f b6 91 c0 0a 00 00 	movzbl 0xac0(%ecx),%edx
+ 43a:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 43e:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 441:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 444:	ba 00 00 00 00       	mov    $0x0,%edx
+ 449:	f7 f1                	div    %ecx
+ 44b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 44e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 452:	75 c7                	jne    41b <printint+0x3b>
+  if(neg)
+ 454:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 458:	74 2d                	je     487 <printint+0xa7>
+    buf[i++] = '-';
+ 45a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 45d:	8d 50 01             	lea    0x1(%eax),%edx
+ 460:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 463:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 468:	eb 1d                	jmp    487 <printint+0xa7>
+    putc(fd, buf[i]);
+ 46a:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 46d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 470:	01 d0                	add    %edx,%eax
+ 472:	0f b6 00             	movzbl (%eax),%eax
+ 475:	0f be c0             	movsbl %al,%eax
+ 478:	83 ec 08             	sub    $0x8,%esp
+ 47b:	50                   	push   %eax
+ 47c:	ff 75 08             	pushl  0x8(%ebp)
+ 47f:	e8 35 ff ff ff       	call   3b9 <putc>
+ 484:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 487:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 48b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 48f:	79 d9                	jns    46a <printint+0x8a>
+}
+ 491:	90                   	nop
+ 492:	90                   	nop
+ 493:	c9                   	leave  
+ 494:	c3                   	ret    
+
+00000495 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 495:	f3 0f 1e fb          	endbr32 
+ 499:	55                   	push   %ebp
+ 49a:	89 e5                	mov    %esp,%ebp
+ 49c:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 49f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 4a6:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 4a9:	83 c0 04             	add    $0x4,%eax
+ 4ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 4af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4b6:	e9 59 01 00 00       	jmp    614 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 4bb:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4be:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4c1:	01 d0                	add    %edx,%eax
+ 4c3:	0f b6 00             	movzbl (%eax),%eax
+ 4c6:	0f be c0             	movsbl %al,%eax
+ 4c9:	25 ff 00 00 00       	and    $0xff,%eax
+ 4ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4d1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4d5:	75 2c                	jne    503 <printf+0x6e>
+      if(c == '%'){
+ 4d7:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4db:	75 0c                	jne    4e9 <printf+0x54>
+        state = '%';
+ 4dd:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4e4:	e9 27 01 00 00       	jmp    610 <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 4e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4ec:	0f be c0             	movsbl %al,%eax
+ 4ef:	83 ec 08             	sub    $0x8,%esp
+ 4f2:	50                   	push   %eax
+ 4f3:	ff 75 08             	pushl  0x8(%ebp)
+ 4f6:	e8 be fe ff ff       	call   3b9 <putc>
+ 4fb:	83 c4 10             	add    $0x10,%esp
+ 4fe:	e9 0d 01 00 00       	jmp    610 <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 503:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 507:	0f 85 03 01 00 00    	jne    610 <printf+0x17b>
+      if(c == 'd'){
+ 50d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 511:	75 1e                	jne    531 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 513:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 516:	8b 00                	mov    (%eax),%eax
+ 518:	6a 01                	push   $0x1
+ 51a:	6a 0a                	push   $0xa
+ 51c:	50                   	push   %eax
+ 51d:	ff 75 08             	pushl  0x8(%ebp)
+ 520:	e8 bb fe ff ff       	call   3e0 <printint>
+ 525:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 528:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 52c:	e9 d8 00 00 00       	jmp    609 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 531:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 535:	74 06                	je     53d <printf+0xa8>
+ 537:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 53b:	75 1e                	jne    55b <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 53d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 540:	8b 00                	mov    (%eax),%eax
+ 542:	6a 00                	push   $0x0
+ 544:	6a 10                	push   $0x10
+ 546:	50                   	push   %eax
+ 547:	ff 75 08             	pushl  0x8(%ebp)
+ 54a:	e8 91 fe ff ff       	call   3e0 <printint>
+ 54f:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 552:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 556:	e9 ae 00 00 00       	jmp    609 <printf+0x174>
+      } else if(c == 's'){
+ 55b:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 55f:	75 43                	jne    5a4 <printf+0x10f>
+        s = (char*)*ap;
+ 561:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 564:	8b 00                	mov    (%eax),%eax
+ 566:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 569:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 56d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 571:	75 25                	jne    598 <printf+0x103>
+          s = "(null)";
+ 573:	c7 45 f4 70 08 00 00 	movl   $0x870,-0xc(%ebp)
+        while(*s != 0){
+ 57a:	eb 1c                	jmp    598 <printf+0x103>
+          putc(fd, *s);
+ 57c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 57f:	0f b6 00             	movzbl (%eax),%eax
+ 582:	0f be c0             	movsbl %al,%eax
+ 585:	83 ec 08             	sub    $0x8,%esp
+ 588:	50                   	push   %eax
+ 589:	ff 75 08             	pushl  0x8(%ebp)
+ 58c:	e8 28 fe ff ff       	call   3b9 <putc>
+ 591:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 594:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 598:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 59b:	0f b6 00             	movzbl (%eax),%eax
+ 59e:	84 c0                	test   %al,%al
+ 5a0:	75 da                	jne    57c <printf+0xe7>
+ 5a2:	eb 65                	jmp    609 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 5a4:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5a8:	75 1d                	jne    5c7 <printf+0x132>
+        putc(fd, *ap);
+ 5aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5ad:	8b 00                	mov    (%eax),%eax
+ 5af:	0f be c0             	movsbl %al,%eax
+ 5b2:	83 ec 08             	sub    $0x8,%esp
+ 5b5:	50                   	push   %eax
+ 5b6:	ff 75 08             	pushl  0x8(%ebp)
+ 5b9:	e8 fb fd ff ff       	call   3b9 <putc>
+ 5be:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5c1:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5c5:	eb 42                	jmp    609 <printf+0x174>
+      } else if(c == '%'){
+ 5c7:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5cb:	75 17                	jne    5e4 <printf+0x14f>
+        putc(fd, c);
+ 5cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5d0:	0f be c0             	movsbl %al,%eax
+ 5d3:	83 ec 08             	sub    $0x8,%esp
+ 5d6:	50                   	push   %eax
+ 5d7:	ff 75 08             	pushl  0x8(%ebp)
+ 5da:	e8 da fd ff ff       	call   3b9 <putc>
+ 5df:	83 c4 10             	add    $0x10,%esp
+ 5e2:	eb 25                	jmp    609 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 5e4:	83 ec 08             	sub    $0x8,%esp
+ 5e7:	6a 25                	push   $0x25
+ 5e9:	ff 75 08             	pushl  0x8(%ebp)
+ 5ec:	e8 c8 fd ff ff       	call   3b9 <putc>
+ 5f1:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 5f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5f7:	0f be c0             	movsbl %al,%eax
+ 5fa:	83 ec 08             	sub    $0x8,%esp
+ 5fd:	50                   	push   %eax
+ 5fe:	ff 75 08             	pushl  0x8(%ebp)
+ 601:	e8 b3 fd ff ff       	call   3b9 <putc>
+ 606:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 609:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 610:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 614:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 617:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 61a:	01 d0                	add    %edx,%eax
+ 61c:	0f b6 00             	movzbl (%eax),%eax
+ 61f:	84 c0                	test   %al,%al
+ 621:	0f 85 94 fe ff ff    	jne    4bb <printf+0x26>
+    }
+  }
+}
+ 627:	90                   	nop
+ 628:	90                   	nop
+ 629:	c9                   	leave  
+ 62a:	c3                   	ret    
+
+0000062b <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 62b:	f3 0f 1e fb          	endbr32 
+ 62f:	55                   	push   %ebp
+ 630:	89 e5                	mov    %esp,%ebp
+ 632:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 635:	8b 45 08             	mov    0x8(%ebp),%eax
+ 638:	83 e8 08             	sub    $0x8,%eax
+ 63b:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 63e:	a1 dc 0a 00 00       	mov    0xadc,%eax
+ 643:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 646:	eb 24                	jmp    66c <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 648:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 64b:	8b 00                	mov    (%eax),%eax
+ 64d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 650:	72 12                	jb     664 <free+0x39>
+ 652:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 655:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 658:	77 24                	ja     67e <free+0x53>
+ 65a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65d:	8b 00                	mov    (%eax),%eax
+ 65f:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 662:	72 1a                	jb     67e <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 664:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 667:	8b 00                	mov    (%eax),%eax
+ 669:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 66c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 66f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 672:	76 d4                	jbe    648 <free+0x1d>
+ 674:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 677:	8b 00                	mov    (%eax),%eax
+ 679:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 67c:	73 ca                	jae    648 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 67e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 681:	8b 40 04             	mov    0x4(%eax),%eax
+ 684:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 68b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 68e:	01 c2                	add    %eax,%edx
+ 690:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 693:	8b 00                	mov    (%eax),%eax
+ 695:	39 c2                	cmp    %eax,%edx
+ 697:	75 24                	jne    6bd <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 699:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69c:	8b 50 04             	mov    0x4(%eax),%edx
+ 69f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a2:	8b 00                	mov    (%eax),%eax
+ 6a4:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a7:	01 c2                	add    %eax,%edx
+ 6a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ac:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6af:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b2:	8b 00                	mov    (%eax),%eax
+ 6b4:	8b 10                	mov    (%eax),%edx
+ 6b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6b9:	89 10                	mov    %edx,(%eax)
+ 6bb:	eb 0a                	jmp    6c7 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c0:	8b 10                	mov    (%eax),%edx
+ 6c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6c5:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ca:	8b 40 04             	mov    0x4(%eax),%eax
+ 6cd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d7:	01 d0                	add    %edx,%eax
+ 6d9:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6dc:	75 20                	jne    6fe <free+0xd3>
+    p->s.size += bp->s.size;
+ 6de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e1:	8b 50 04             	mov    0x4(%eax),%edx
+ 6e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e7:	8b 40 04             	mov    0x4(%eax),%eax
+ 6ea:	01 c2                	add    %eax,%edx
+ 6ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ef:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6f5:	8b 10                	mov    (%eax),%edx
+ 6f7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6fa:	89 10                	mov    %edx,(%eax)
+ 6fc:	eb 08                	jmp    706 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 6fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 701:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 704:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 706:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 709:	a3 dc 0a 00 00       	mov    %eax,0xadc
+}
+ 70e:	90                   	nop
+ 70f:	c9                   	leave  
+ 710:	c3                   	ret    
+
+00000711 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 711:	f3 0f 1e fb          	endbr32 
+ 715:	55                   	push   %ebp
+ 716:	89 e5                	mov    %esp,%ebp
+ 718:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 71b:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 722:	77 07                	ja     72b <morecore+0x1a>
+    nu = 4096;
+ 724:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 72b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 72e:	c1 e0 03             	shl    $0x3,%eax
+ 731:	83 ec 0c             	sub    $0xc,%esp
+ 734:	50                   	push   %eax
+ 735:	e8 3f fc ff ff       	call   379 <sbrk>
+ 73a:	83 c4 10             	add    $0x10,%esp
+ 73d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 740:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 744:	75 07                	jne    74d <morecore+0x3c>
+    return 0;
+ 746:	b8 00 00 00 00       	mov    $0x0,%eax
+ 74b:	eb 26                	jmp    773 <morecore+0x62>
+  hp = (Header*)p;
+ 74d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 750:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 753:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 756:	8b 55 08             	mov    0x8(%ebp),%edx
+ 759:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 75c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 75f:	83 c0 08             	add    $0x8,%eax
+ 762:	83 ec 0c             	sub    $0xc,%esp
+ 765:	50                   	push   %eax
+ 766:	e8 c0 fe ff ff       	call   62b <free>
+ 76b:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 76e:	a1 dc 0a 00 00       	mov    0xadc,%eax
+}
+ 773:	c9                   	leave  
+ 774:	c3                   	ret    
+
+00000775 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 775:	f3 0f 1e fb          	endbr32 
+ 779:	55                   	push   %ebp
+ 77a:	89 e5                	mov    %esp,%ebp
+ 77c:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 77f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 782:	83 c0 07             	add    $0x7,%eax
+ 785:	c1 e8 03             	shr    $0x3,%eax
+ 788:	83 c0 01             	add    $0x1,%eax
+ 78b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 78e:	a1 dc 0a 00 00       	mov    0xadc,%eax
+ 793:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 796:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 79a:	75 23                	jne    7bf <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 79c:	c7 45 f0 d4 0a 00 00 	movl   $0xad4,-0x10(%ebp)
+ 7a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7a6:	a3 dc 0a 00 00       	mov    %eax,0xadc
+ 7ab:	a1 dc 0a 00 00       	mov    0xadc,%eax
+ 7b0:	a3 d4 0a 00 00       	mov    %eax,0xad4
+    base.s.size = 0;
+ 7b5:	c7 05 d8 0a 00 00 00 	movl   $0x0,0xad8
+ 7bc:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7c2:	8b 00                	mov    (%eax),%eax
+ 7c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ca:	8b 40 04             	mov    0x4(%eax),%eax
+ 7cd:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7d0:	77 4d                	ja     81f <malloc+0xaa>
+      if(p->s.size == nunits)
+ 7d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7d5:	8b 40 04             	mov    0x4(%eax),%eax
+ 7d8:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7db:	75 0c                	jne    7e9 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 7dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e0:	8b 10                	mov    (%eax),%edx
+ 7e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7e5:	89 10                	mov    %edx,(%eax)
+ 7e7:	eb 26                	jmp    80f <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 7e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ec:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ef:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 7f2:	89 c2                	mov    %eax,%edx
+ 7f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f7:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7fd:	8b 40 04             	mov    0x4(%eax),%eax
+ 800:	c1 e0 03             	shl    $0x3,%eax
+ 803:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 806:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 809:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 80c:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 80f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 812:	a3 dc 0a 00 00       	mov    %eax,0xadc
+      return (void*)(p + 1);
+ 817:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 81a:	83 c0 08             	add    $0x8,%eax
+ 81d:	eb 3b                	jmp    85a <malloc+0xe5>
+    }
+    if(p == freep)
+ 81f:	a1 dc 0a 00 00       	mov    0xadc,%eax
+ 824:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 827:	75 1e                	jne    847 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 829:	83 ec 0c             	sub    $0xc,%esp
+ 82c:	ff 75 ec             	pushl  -0x14(%ebp)
+ 82f:	e8 dd fe ff ff       	call   711 <morecore>
+ 834:	83 c4 10             	add    $0x10,%esp
+ 837:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 83a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 83e:	75 07                	jne    847 <malloc+0xd2>
+        return 0;
+ 840:	b8 00 00 00 00       	mov    $0x0,%eax
+ 845:	eb 13                	jmp    85a <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 847:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 84a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 850:	8b 00                	mov    (%eax),%eax
+ 852:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 855:	e9 6d ff ff ff       	jmp    7c7 <malloc+0x52>
+  }
+}
+ 85a:	c9                   	leave  
+ 85b:	c3                   	ret    
diff -ruN xv6-public/xv6-public/kill.c xv6-public_new/xv6-public/kill.c
--- xv6-public/xv6-public/kill.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kill.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,17 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char **argv)
+{
+  int i;
+
+  if(argc < 2){
+    printf(2, "usage: kill pid...\n");
+    exit();
+  }
+  for(i=1; i<argc; i++)
+    kill(atoi(argv[i]));
+  exit();
+}
diff -ruN xv6-public/xv6-public/kill.d xv6-public_new/xv6-public/kill.d
--- xv6-public/xv6-public/kill.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kill.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+kill.o: kill.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/kill.o and xv6-public_new/xv6-public/kill.o differ
diff -ruN xv6-public/xv6-public/kill.sym xv6-public_new/xv6-public/kill.sym
--- xv6-public/xv6-public/kill.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/kill.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+0000085c .rodata
+00000878 .eh_frame
+00000ac0 .data
+00000ad4 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 kill.c
+00000000 ulib.c
+00000076 stosb
+00000000 printf.c
+000003b9 putc
+000003e0 printint
+00000ac0 digits.1098
+00000000 umalloc.c
+00000ad4 base
+00000adc freep
+00000711 morecore
+0000009c strcpy
+000003a1 yield
+000003b1 set_prio
+00000495 printf
+000002a8 memmove
+00000339 mknod
+00000193 gets
+00000371 getpid
+00000775 malloc
+00000381 sleep
+000003a9 wait2
+00000301 pipe
+00000311 write
+00000349 fstat
+00000321 kill
+00000361 chdir
+00000329 exec
+000002f9 wait
+00000309 read
+00000341 unlink
+000002e9 fork
+00000379 sbrk
+00000389 uptime
+00000ad1 __bss_start
+0000013e memset
+00000000 main
+000000d0 strcmp
+00000369 dup
+00000206 stat
+00000ad1 _edata
+00000ae0 _end
+00000351 link
+000002f1 exit
+00000257 atoi
+00000391 draw
+00000113 strlen
+00000331 open
+0000015c strchr
+00000399 cps
+00000359 mkdir
+00000319 close
+0000062b free
diff -ruN xv6-public/xv6-public/lapic.c xv6-public_new/xv6-public/lapic.c
--- xv6-public/xv6-public/lapic.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/lapic.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,229 @@
+// The local APIC manages internal (non-I/O) interrupts.
+// See Chapter 8 & Appendix C of Intel processor manual volume 3.
+
+#include "param.h"
+#include "types.h"
+#include "defs.h"
+#include "date.h"
+#include "memlayout.h"
+#include "traps.h"
+#include "mmu.h"
+#include "x86.h"
+
+// Local APIC registers, divided by 4 for use as uint[] indices.
+#define ID      (0x0020/4)   // ID
+#define VER     (0x0030/4)   // Version
+#define TPR     (0x0080/4)   // Task Priority
+#define EOI     (0x00B0/4)   // EOI
+#define SVR     (0x00F0/4)   // Spurious Interrupt Vector
+  #define ENABLE     0x00000100   // Unit Enable
+#define ESR     (0x0280/4)   // Error Status
+#define ICRLO   (0x0300/4)   // Interrupt Command
+  #define INIT       0x00000500   // INIT/RESET
+  #define STARTUP    0x00000600   // Startup IPI
+  #define DELIVS     0x00001000   // Delivery status
+  #define ASSERT     0x00004000   // Assert interrupt (vs deassert)
+  #define DEASSERT   0x00000000
+  #define LEVEL      0x00008000   // Level triggered
+  #define BCAST      0x00080000   // Send to all APICs, including self.
+  #define BUSY       0x00001000
+  #define FIXED      0x00000000
+#define ICRHI   (0x0310/4)   // Interrupt Command [63:32]
+#define TIMER   (0x0320/4)   // Local Vector Table 0 (TIMER)
+  #define X1         0x0000000B   // divide counts by 1
+  #define PERIODIC   0x00020000   // Periodic
+#define PCINT   (0x0340/4)   // Performance Counter LVT
+#define LINT0   (0x0350/4)   // Local Vector Table 1 (LINT0)
+#define LINT1   (0x0360/4)   // Local Vector Table 2 (LINT1)
+#define ERROR   (0x0370/4)   // Local Vector Table 3 (ERROR)
+  #define MASKED     0x00010000   // Interrupt masked
+#define TICR    (0x0380/4)   // Timer Initial Count
+#define TCCR    (0x0390/4)   // Timer Current Count
+#define TDCR    (0x03E0/4)   // Timer Divide Configuration
+
+volatile uint *lapic;  // Initialized in mp.c
+
+//PAGEBREAK!
+static void
+lapicw(int index, int value)
+{
+  lapic[index] = value;
+  lapic[ID];  // wait for write to finish, by reading
+}
+
+void
+lapicinit(void)
+{
+  if(!lapic)
+    return;
+
+  // Enable local APIC; set spurious interrupt vector.
+  lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
+
+  // The timer repeatedly counts down at bus frequency
+  // from lapic[TICR] and then issues an interrupt.
+  // If xv6 cared more about precise timekeeping,
+  // TICR would be calibrated using an external time source.
+  lapicw(TDCR, X1);
+  lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
+  lapicw(TICR, 10000000);
+
+  // Disable logical interrupt lines.
+  lapicw(LINT0, MASKED);
+  lapicw(LINT1, MASKED);
+
+  // Disable performance counter overflow interrupts
+  // on machines that provide that interrupt entry.
+  if(((lapic[VER]>>16) & 0xFF) >= 4)
+    lapicw(PCINT, MASKED);
+
+  // Map error interrupt to IRQ_ERROR.
+  lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
+
+  // Clear error status register (requires back-to-back writes).
+  lapicw(ESR, 0);
+  lapicw(ESR, 0);
+
+  // Ack any outstanding interrupts.
+  lapicw(EOI, 0);
+
+  // Send an Init Level De-Assert to synchronise arbitration ID's.
+  lapicw(ICRHI, 0);
+  lapicw(ICRLO, BCAST | INIT | LEVEL);
+  while(lapic[ICRLO] & DELIVS)
+    ;
+
+  // Enable interrupts on the APIC (but not on the processor).
+  lapicw(TPR, 0);
+}
+
+int
+lapicid(void)
+{
+  if (!lapic)
+    return 0;
+  return lapic[ID] >> 24;
+}
+
+// Acknowledge interrupt.
+void
+lapiceoi(void)
+{
+  if(lapic)
+    lapicw(EOI, 0);
+}
+
+// Spin for a given number of microseconds.
+// On real hardware would want to tune this dynamically.
+void
+microdelay(int us)
+{
+}
+
+#define CMOS_PORT    0x70
+#define CMOS_RETURN  0x71
+
+// Start additional processor running entry code at addr.
+// See Appendix B of MultiProcessor Specification.
+void
+lapicstartap(uchar apicid, uint addr)
+{
+  int i;
+  ushort *wrv;
+
+  // "The BSP must initialize CMOS shutdown code to 0AH
+  // and the warm reset vector (DWORD based at 40:67) to point at
+  // the AP startup code prior to the [universal startup algorithm]."
+  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
+  outb(CMOS_PORT+1, 0x0A);
+  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
+  wrv[0] = 0;
+  wrv[1] = addr >> 4;
+
+  // "Universal startup algorithm."
+  // Send INIT (level-triggered) interrupt to reset other CPU.
+  lapicw(ICRHI, apicid<<24);
+  lapicw(ICRLO, INIT | LEVEL | ASSERT);
+  microdelay(200);
+  lapicw(ICRLO, INIT | LEVEL);
+  microdelay(100);    // should be 10ms, but too slow in Bochs!
+
+  // Send startup IPI (twice!) to enter code.
+  // Regular hardware is supposed to only accept a STARTUP
+  // when it is in the halted state due to an INIT.  So the second
+  // should be ignored, but it is part of the official Intel algorithm.
+  // Bochs complains about the second one.  Too bad for Bochs.
+  for(i = 0; i < 2; i++){
+    lapicw(ICRHI, apicid<<24);
+    lapicw(ICRLO, STARTUP | (addr>>12));
+    microdelay(200);
+  }
+}
+
+#define CMOS_STATA   0x0a
+#define CMOS_STATB   0x0b
+#define CMOS_UIP    (1 << 7)        // RTC update in progress
+
+#define SECS    0x00
+#define MINS    0x02
+#define HOURS   0x04
+#define DAY     0x07
+#define MONTH   0x08
+#define YEAR    0x09
+
+static uint
+cmos_read(uint reg)
+{
+  outb(CMOS_PORT,  reg);
+  microdelay(200);
+
+  return inb(CMOS_RETURN);
+}
+
+static void
+fill_rtcdate(struct rtcdate *r)
+{
+  r->second = cmos_read(SECS);
+  r->minute = cmos_read(MINS);
+  r->hour   = cmos_read(HOURS);
+  r->day    = cmos_read(DAY);
+  r->month  = cmos_read(MONTH);
+  r->year   = cmos_read(YEAR);
+}
+
+// qemu seems to use 24-hour GWT and the values are BCD encoded
+void
+cmostime(struct rtcdate *r)
+{
+  struct rtcdate t1, t2;
+  int sb, bcd;
+
+  sb = cmos_read(CMOS_STATB);
+
+  bcd = (sb & (1 << 2)) == 0;
+
+  // make sure CMOS doesn't modify time while we read it
+  for(;;) {
+    fill_rtcdate(&t1);
+    if(cmos_read(CMOS_STATA) & CMOS_UIP)
+        continue;
+    fill_rtcdate(&t2);
+    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+      break;
+  }
+
+  // convert
+  if(bcd) {
+#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+    CONV(second);
+    CONV(minute);
+    CONV(hour  );
+    CONV(day   );
+    CONV(month );
+    CONV(year  );
+#undef     CONV
+  }
+
+  *r = t1;
+  r->year += 2000;
+}
diff -ruN xv6-public/xv6-public/lapic.d xv6-public_new/xv6-public/lapic.d
--- xv6-public/xv6-public/lapic.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/lapic.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+lapic.o: lapic.c /usr/include/stdc-predef.h param.h types.h defs.h date.h \
+ memlayout.h traps.h mmu.h x86.h
Binary files xv6-public/xv6-public/lapic.o and xv6-public_new/xv6-public/lapic.o differ
diff -ruN xv6-public/xv6-public/ln.asm xv6-public_new/xv6-public/ln.asm
--- xv6-public/xv6-public/ln.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ln.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1173 @@
+
+_ln:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	53                   	push   %ebx
+  12:	51                   	push   %ecx
+  13:	89 cb                	mov    %ecx,%ebx
+  if(argc != 3){
+  15:	83 3b 03             	cmpl   $0x3,(%ebx)
+  18:	74 17                	je     31 <main+0x31>
+    printf(2, "Usage: ln old new\n");
+  1a:	83 ec 08             	sub    $0x8,%esp
+  1d:	68 5e 08 00 00       	push   $0x85e
+  22:	6a 02                	push   $0x2
+  24:	e8 6e 04 00 00       	call   497 <printf>
+  29:	83 c4 10             	add    $0x10,%esp
+    exit();
+  2c:	e8 c2 02 00 00       	call   2f3 <exit>
+  }
+  if(link(argv[1], argv[2]) < 0)
+  31:	8b 43 04             	mov    0x4(%ebx),%eax
+  34:	83 c0 08             	add    $0x8,%eax
+  37:	8b 10                	mov    (%eax),%edx
+  39:	8b 43 04             	mov    0x4(%ebx),%eax
+  3c:	83 c0 04             	add    $0x4,%eax
+  3f:	8b 00                	mov    (%eax),%eax
+  41:	83 ec 08             	sub    $0x8,%esp
+  44:	52                   	push   %edx
+  45:	50                   	push   %eax
+  46:	e8 08 03 00 00       	call   353 <link>
+  4b:	83 c4 10             	add    $0x10,%esp
+  4e:	85 c0                	test   %eax,%eax
+  50:	79 21                	jns    73 <main+0x73>
+    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  52:	8b 43 04             	mov    0x4(%ebx),%eax
+  55:	83 c0 08             	add    $0x8,%eax
+  58:	8b 10                	mov    (%eax),%edx
+  5a:	8b 43 04             	mov    0x4(%ebx),%eax
+  5d:	83 c0 04             	add    $0x4,%eax
+  60:	8b 00                	mov    (%eax),%eax
+  62:	52                   	push   %edx
+  63:	50                   	push   %eax
+  64:	68 71 08 00 00       	push   $0x871
+  69:	6a 02                	push   $0x2
+  6b:	e8 27 04 00 00       	call   497 <printf>
+  70:	83 c4 10             	add    $0x10,%esp
+  exit();
+  73:	e8 7b 02 00 00       	call   2f3 <exit>
+
+00000078 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  78:	55                   	push   %ebp
+  79:	89 e5                	mov    %esp,%ebp
+  7b:	57                   	push   %edi
+  7c:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  7d:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  80:	8b 55 10             	mov    0x10(%ebp),%edx
+  83:	8b 45 0c             	mov    0xc(%ebp),%eax
+  86:	89 cb                	mov    %ecx,%ebx
+  88:	89 df                	mov    %ebx,%edi
+  8a:	89 d1                	mov    %edx,%ecx
+  8c:	fc                   	cld    
+  8d:	f3 aa                	rep stos %al,%es:(%edi)
+  8f:	89 ca                	mov    %ecx,%edx
+  91:	89 fb                	mov    %edi,%ebx
+  93:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  96:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  99:	90                   	nop
+  9a:	5b                   	pop    %ebx
+  9b:	5f                   	pop    %edi
+  9c:	5d                   	pop    %ebp
+  9d:	c3                   	ret    
+
+0000009e <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  9e:	f3 0f 1e fb          	endbr32 
+  a2:	55                   	push   %ebp
+  a3:	89 e5                	mov    %esp,%ebp
+  a5:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  a8:	8b 45 08             	mov    0x8(%ebp),%eax
+  ab:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  ae:	90                   	nop
+  af:	8b 55 0c             	mov    0xc(%ebp),%edx
+  b2:	8d 42 01             	lea    0x1(%edx),%eax
+  b5:	89 45 0c             	mov    %eax,0xc(%ebp)
+  b8:	8b 45 08             	mov    0x8(%ebp),%eax
+  bb:	8d 48 01             	lea    0x1(%eax),%ecx
+  be:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  c1:	0f b6 12             	movzbl (%edx),%edx
+  c4:	88 10                	mov    %dl,(%eax)
+  c6:	0f b6 00             	movzbl (%eax),%eax
+  c9:	84 c0                	test   %al,%al
+  cb:	75 e2                	jne    af <strcpy+0x11>
+    ;
+  return os;
+  cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  d0:	c9                   	leave  
+  d1:	c3                   	ret    
+
+000000d2 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  d2:	f3 0f 1e fb          	endbr32 
+  d6:	55                   	push   %ebp
+  d7:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  d9:	eb 08                	jmp    e3 <strcmp+0x11>
+    p++, q++;
+  db:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  df:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+  e3:	8b 45 08             	mov    0x8(%ebp),%eax
+  e6:	0f b6 00             	movzbl (%eax),%eax
+  e9:	84 c0                	test   %al,%al
+  eb:	74 10                	je     fd <strcmp+0x2b>
+  ed:	8b 45 08             	mov    0x8(%ebp),%eax
+  f0:	0f b6 10             	movzbl (%eax),%edx
+  f3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  f6:	0f b6 00             	movzbl (%eax),%eax
+  f9:	38 c2                	cmp    %al,%dl
+  fb:	74 de                	je     db <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+  fd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 100:	0f b6 00             	movzbl (%eax),%eax
+ 103:	0f b6 d0             	movzbl %al,%edx
+ 106:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 109:	0f b6 00             	movzbl (%eax),%eax
+ 10c:	0f b6 c0             	movzbl %al,%eax
+ 10f:	29 c2                	sub    %eax,%edx
+ 111:	89 d0                	mov    %edx,%eax
+}
+ 113:	5d                   	pop    %ebp
+ 114:	c3                   	ret    
+
+00000115 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 115:	f3 0f 1e fb          	endbr32 
+ 119:	55                   	push   %ebp
+ 11a:	89 e5                	mov    %esp,%ebp
+ 11c:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 11f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 126:	eb 04                	jmp    12c <strlen+0x17>
+ 128:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 12c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 12f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 132:	01 d0                	add    %edx,%eax
+ 134:	0f b6 00             	movzbl (%eax),%eax
+ 137:	84 c0                	test   %al,%al
+ 139:	75 ed                	jne    128 <strlen+0x13>
+    ;
+  return n;
+ 13b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 13e:	c9                   	leave  
+ 13f:	c3                   	ret    
+
+00000140 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 140:	f3 0f 1e fb          	endbr32 
+ 144:	55                   	push   %ebp
+ 145:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 147:	8b 45 10             	mov    0x10(%ebp),%eax
+ 14a:	50                   	push   %eax
+ 14b:	ff 75 0c             	pushl  0xc(%ebp)
+ 14e:	ff 75 08             	pushl  0x8(%ebp)
+ 151:	e8 22 ff ff ff       	call   78 <stosb>
+ 156:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 159:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 15c:	c9                   	leave  
+ 15d:	c3                   	ret    
+
+0000015e <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 15e:	f3 0f 1e fb          	endbr32 
+ 162:	55                   	push   %ebp
+ 163:	89 e5                	mov    %esp,%ebp
+ 165:	83 ec 04             	sub    $0x4,%esp
+ 168:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 16b:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 16e:	eb 14                	jmp    184 <strchr+0x26>
+    if(*s == c)
+ 170:	8b 45 08             	mov    0x8(%ebp),%eax
+ 173:	0f b6 00             	movzbl (%eax),%eax
+ 176:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 179:	75 05                	jne    180 <strchr+0x22>
+      return (char*)s;
+ 17b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 17e:	eb 13                	jmp    193 <strchr+0x35>
+  for(; *s; s++)
+ 180:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 184:	8b 45 08             	mov    0x8(%ebp),%eax
+ 187:	0f b6 00             	movzbl (%eax),%eax
+ 18a:	84 c0                	test   %al,%al
+ 18c:	75 e2                	jne    170 <strchr+0x12>
+  return 0;
+ 18e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 193:	c9                   	leave  
+ 194:	c3                   	ret    
+
+00000195 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 195:	f3 0f 1e fb          	endbr32 
+ 199:	55                   	push   %ebp
+ 19a:	89 e5                	mov    %esp,%ebp
+ 19c:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 19f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1a6:	eb 42                	jmp    1ea <gets+0x55>
+    cc = read(0, &c, 1);
+ 1a8:	83 ec 04             	sub    $0x4,%esp
+ 1ab:	6a 01                	push   $0x1
+ 1ad:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1b0:	50                   	push   %eax
+ 1b1:	6a 00                	push   $0x0
+ 1b3:	e8 53 01 00 00       	call   30b <read>
+ 1b8:	83 c4 10             	add    $0x10,%esp
+ 1bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1be:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1c2:	7e 33                	jle    1f7 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1c7:	8d 50 01             	lea    0x1(%eax),%edx
+ 1ca:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 1cd:	89 c2                	mov    %eax,%edx
+ 1cf:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1d2:	01 c2                	add    %eax,%edx
+ 1d4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1d8:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 1da:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1de:	3c 0a                	cmp    $0xa,%al
+ 1e0:	74 16                	je     1f8 <gets+0x63>
+ 1e2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1e6:	3c 0d                	cmp    $0xd,%al
+ 1e8:	74 0e                	je     1f8 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 1ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1ed:	83 c0 01             	add    $0x1,%eax
+ 1f0:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 1f3:	7f b3                	jg     1a8 <gets+0x13>
+ 1f5:	eb 01                	jmp    1f8 <gets+0x63>
+      break;
+ 1f7:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 1f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1fb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1fe:	01 d0                	add    %edx,%eax
+ 200:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 203:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 206:	c9                   	leave  
+ 207:	c3                   	ret    
+
+00000208 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 208:	f3 0f 1e fb          	endbr32 
+ 20c:	55                   	push   %ebp
+ 20d:	89 e5                	mov    %esp,%ebp
+ 20f:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 212:	83 ec 08             	sub    $0x8,%esp
+ 215:	6a 00                	push   $0x0
+ 217:	ff 75 08             	pushl  0x8(%ebp)
+ 21a:	e8 14 01 00 00       	call   333 <open>
+ 21f:	83 c4 10             	add    $0x10,%esp
+ 222:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 225:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 229:	79 07                	jns    232 <stat+0x2a>
+    return -1;
+ 22b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 230:	eb 25                	jmp    257 <stat+0x4f>
+  r = fstat(fd, st);
+ 232:	83 ec 08             	sub    $0x8,%esp
+ 235:	ff 75 0c             	pushl  0xc(%ebp)
+ 238:	ff 75 f4             	pushl  -0xc(%ebp)
+ 23b:	e8 0b 01 00 00       	call   34b <fstat>
+ 240:	83 c4 10             	add    $0x10,%esp
+ 243:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 246:	83 ec 0c             	sub    $0xc,%esp
+ 249:	ff 75 f4             	pushl  -0xc(%ebp)
+ 24c:	e8 ca 00 00 00       	call   31b <close>
+ 251:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 254:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 257:	c9                   	leave  
+ 258:	c3                   	ret    
+
+00000259 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 259:	f3 0f 1e fb          	endbr32 
+ 25d:	55                   	push   %ebp
+ 25e:	89 e5                	mov    %esp,%ebp
+ 260:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 263:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 26a:	eb 25                	jmp    291 <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 26c:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 26f:	89 d0                	mov    %edx,%eax
+ 271:	c1 e0 02             	shl    $0x2,%eax
+ 274:	01 d0                	add    %edx,%eax
+ 276:	01 c0                	add    %eax,%eax
+ 278:	89 c1                	mov    %eax,%ecx
+ 27a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 27d:	8d 50 01             	lea    0x1(%eax),%edx
+ 280:	89 55 08             	mov    %edx,0x8(%ebp)
+ 283:	0f b6 00             	movzbl (%eax),%eax
+ 286:	0f be c0             	movsbl %al,%eax
+ 289:	01 c8                	add    %ecx,%eax
+ 28b:	83 e8 30             	sub    $0x30,%eax
+ 28e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 291:	8b 45 08             	mov    0x8(%ebp),%eax
+ 294:	0f b6 00             	movzbl (%eax),%eax
+ 297:	3c 2f                	cmp    $0x2f,%al
+ 299:	7e 0a                	jle    2a5 <atoi+0x4c>
+ 29b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 29e:	0f b6 00             	movzbl (%eax),%eax
+ 2a1:	3c 39                	cmp    $0x39,%al
+ 2a3:	7e c7                	jle    26c <atoi+0x13>
+  return n;
+ 2a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 2a8:	c9                   	leave  
+ 2a9:	c3                   	ret    
+
+000002aa <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2aa:	f3 0f 1e fb          	endbr32 
+ 2ae:	55                   	push   %ebp
+ 2af:	89 e5                	mov    %esp,%ebp
+ 2b1:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 2b4:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2ba:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2bd:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2c0:	eb 17                	jmp    2d9 <memmove+0x2f>
+    *dst++ = *src++;
+ 2c2:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 2c5:	8d 42 01             	lea    0x1(%edx),%eax
+ 2c8:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 2cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2ce:	8d 48 01             	lea    0x1(%eax),%ecx
+ 2d1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 2d4:	0f b6 12             	movzbl (%edx),%edx
+ 2d7:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 2d9:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2dc:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 2df:	89 55 10             	mov    %edx,0x10(%ebp)
+ 2e2:	85 c0                	test   %eax,%eax
+ 2e4:	7f dc                	jg     2c2 <memmove+0x18>
+  return vdst;
+ 2e6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2e9:	c9                   	leave  
+ 2ea:	c3                   	ret    
+
+000002eb <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2eb:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <exit>:
+SYSCALL(exit)
+ 2f3:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <wait>:
+SYSCALL(wait)
+ 2fb:	b8 03 00 00 00       	mov    $0x3,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <pipe>:
+SYSCALL(pipe)
+ 303:	b8 04 00 00 00       	mov    $0x4,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <read>:
+SYSCALL(read)
+ 30b:	b8 05 00 00 00       	mov    $0x5,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <write>:
+SYSCALL(write)
+ 313:	b8 10 00 00 00       	mov    $0x10,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <close>:
+SYSCALL(close)
+ 31b:	b8 15 00 00 00       	mov    $0x15,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <kill>:
+SYSCALL(kill)
+ 323:	b8 06 00 00 00       	mov    $0x6,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <exec>:
+SYSCALL(exec)
+ 32b:	b8 07 00 00 00       	mov    $0x7,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <open>:
+SYSCALL(open)
+ 333:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <mknod>:
+SYSCALL(mknod)
+ 33b:	b8 11 00 00 00       	mov    $0x11,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <unlink>:
+SYSCALL(unlink)
+ 343:	b8 12 00 00 00       	mov    $0x12,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <fstat>:
+SYSCALL(fstat)
+ 34b:	b8 08 00 00 00       	mov    $0x8,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <link>:
+SYSCALL(link)
+ 353:	b8 13 00 00 00       	mov    $0x13,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <mkdir>:
+SYSCALL(mkdir)
+ 35b:	b8 14 00 00 00       	mov    $0x14,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <chdir>:
+SYSCALL(chdir)
+ 363:	b8 09 00 00 00       	mov    $0x9,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <dup>:
+SYSCALL(dup)
+ 36b:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <getpid>:
+SYSCALL(getpid)
+ 373:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 378:	cd 40                	int    $0x40
+ 37a:	c3                   	ret    
+
+0000037b <sbrk>:
+SYSCALL(sbrk)
+ 37b:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 380:	cd 40                	int    $0x40
+ 382:	c3                   	ret    
+
+00000383 <sleep>:
+SYSCALL(sleep)
+ 383:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 388:	cd 40                	int    $0x40
+ 38a:	c3                   	ret    
+
+0000038b <uptime>:
+SYSCALL(uptime)
+ 38b:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 390:	cd 40                	int    $0x40
+ 392:	c3                   	ret    
+
+00000393 <draw>:
+SYSCALL(draw)
+ 393:	b8 16 00 00 00       	mov    $0x16,%eax
+ 398:	cd 40                	int    $0x40
+ 39a:	c3                   	ret    
+
+0000039b <cps>:
+SYSCALL(cps)
+ 39b:	b8 17 00 00 00       	mov    $0x17,%eax
+ 3a0:	cd 40                	int    $0x40
+ 3a2:	c3                   	ret    
+
+000003a3 <yield>:
+SYSCALL(yield)
+ 3a3:	b8 18 00 00 00       	mov    $0x18,%eax
+ 3a8:	cd 40                	int    $0x40
+ 3aa:	c3                   	ret    
+
+000003ab <wait2>:
+SYSCALL(wait2)
+ 3ab:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3b0:	cd 40                	int    $0x40
+ 3b2:	c3                   	ret    
+
+000003b3 <set_prio>:
+SYSCALL(set_prio)
+ 3b3:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3b8:	cd 40                	int    $0x40
+ 3ba:	c3                   	ret    
+
+000003bb <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3bb:	f3 0f 1e fb          	endbr32 
+ 3bf:	55                   	push   %ebp
+ 3c0:	89 e5                	mov    %esp,%ebp
+ 3c2:	83 ec 18             	sub    $0x18,%esp
+ 3c5:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3c8:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3cb:	83 ec 04             	sub    $0x4,%esp
+ 3ce:	6a 01                	push   $0x1
+ 3d0:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3d3:	50                   	push   %eax
+ 3d4:	ff 75 08             	pushl  0x8(%ebp)
+ 3d7:	e8 37 ff ff ff       	call   313 <write>
+ 3dc:	83 c4 10             	add    $0x10,%esp
+}
+ 3df:	90                   	nop
+ 3e0:	c9                   	leave  
+ 3e1:	c3                   	ret    
+
+000003e2 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3e2:	f3 0f 1e fb          	endbr32 
+ 3e6:	55                   	push   %ebp
+ 3e7:	89 e5                	mov    %esp,%ebp
+ 3e9:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3f3:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3f7:	74 17                	je     410 <printint+0x2e>
+ 3f9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3fd:	79 11                	jns    410 <printint+0x2e>
+    neg = 1;
+ 3ff:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 406:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 409:	f7 d8                	neg    %eax
+ 40b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 40e:	eb 06                	jmp    416 <printint+0x34>
+  } else {
+    x = xx;
+ 410:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 413:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 416:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 41d:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 420:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 423:	ba 00 00 00 00       	mov    $0x0,%edx
+ 428:	f7 f1                	div    %ecx
+ 42a:	89 d1                	mov    %edx,%ecx
+ 42c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 42f:	8d 50 01             	lea    0x1(%eax),%edx
+ 432:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 435:	0f b6 91 d4 0a 00 00 	movzbl 0xad4(%ecx),%edx
+ 43c:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 440:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 443:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 446:	ba 00 00 00 00       	mov    $0x0,%edx
+ 44b:	f7 f1                	div    %ecx
+ 44d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 450:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 454:	75 c7                	jne    41d <printint+0x3b>
+  if(neg)
+ 456:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 45a:	74 2d                	je     489 <printint+0xa7>
+    buf[i++] = '-';
+ 45c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 45f:	8d 50 01             	lea    0x1(%eax),%edx
+ 462:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 465:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 46a:	eb 1d                	jmp    489 <printint+0xa7>
+    putc(fd, buf[i]);
+ 46c:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 46f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 472:	01 d0                	add    %edx,%eax
+ 474:	0f b6 00             	movzbl (%eax),%eax
+ 477:	0f be c0             	movsbl %al,%eax
+ 47a:	83 ec 08             	sub    $0x8,%esp
+ 47d:	50                   	push   %eax
+ 47e:	ff 75 08             	pushl  0x8(%ebp)
+ 481:	e8 35 ff ff ff       	call   3bb <putc>
+ 486:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 489:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 48d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 491:	79 d9                	jns    46c <printint+0x8a>
+}
+ 493:	90                   	nop
+ 494:	90                   	nop
+ 495:	c9                   	leave  
+ 496:	c3                   	ret    
+
+00000497 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 497:	f3 0f 1e fb          	endbr32 
+ 49b:	55                   	push   %ebp
+ 49c:	89 e5                	mov    %esp,%ebp
+ 49e:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 4a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 4a8:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 4ab:	83 c0 04             	add    $0x4,%eax
+ 4ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 4b1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4b8:	e9 59 01 00 00       	jmp    616 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 4bd:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4c3:	01 d0                	add    %edx,%eax
+ 4c5:	0f b6 00             	movzbl (%eax),%eax
+ 4c8:	0f be c0             	movsbl %al,%eax
+ 4cb:	25 ff 00 00 00       	and    $0xff,%eax
+ 4d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4d3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4d7:	75 2c                	jne    505 <printf+0x6e>
+      if(c == '%'){
+ 4d9:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4dd:	75 0c                	jne    4eb <printf+0x54>
+        state = '%';
+ 4df:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 4e6:	e9 27 01 00 00       	jmp    612 <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 4eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4ee:	0f be c0             	movsbl %al,%eax
+ 4f1:	83 ec 08             	sub    $0x8,%esp
+ 4f4:	50                   	push   %eax
+ 4f5:	ff 75 08             	pushl  0x8(%ebp)
+ 4f8:	e8 be fe ff ff       	call   3bb <putc>
+ 4fd:	83 c4 10             	add    $0x10,%esp
+ 500:	e9 0d 01 00 00       	jmp    612 <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 505:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 509:	0f 85 03 01 00 00    	jne    612 <printf+0x17b>
+      if(c == 'd'){
+ 50f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 513:	75 1e                	jne    533 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 515:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 518:	8b 00                	mov    (%eax),%eax
+ 51a:	6a 01                	push   $0x1
+ 51c:	6a 0a                	push   $0xa
+ 51e:	50                   	push   %eax
+ 51f:	ff 75 08             	pushl  0x8(%ebp)
+ 522:	e8 bb fe ff ff       	call   3e2 <printint>
+ 527:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 52a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 52e:	e9 d8 00 00 00       	jmp    60b <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 533:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 537:	74 06                	je     53f <printf+0xa8>
+ 539:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 53d:	75 1e                	jne    55d <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 53f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 542:	8b 00                	mov    (%eax),%eax
+ 544:	6a 00                	push   $0x0
+ 546:	6a 10                	push   $0x10
+ 548:	50                   	push   %eax
+ 549:	ff 75 08             	pushl  0x8(%ebp)
+ 54c:	e8 91 fe ff ff       	call   3e2 <printint>
+ 551:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 554:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 558:	e9 ae 00 00 00       	jmp    60b <printf+0x174>
+      } else if(c == 's'){
+ 55d:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 561:	75 43                	jne    5a6 <printf+0x10f>
+        s = (char*)*ap;
+ 563:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 566:	8b 00                	mov    (%eax),%eax
+ 568:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 56b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 56f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 573:	75 25                	jne    59a <printf+0x103>
+          s = "(null)";
+ 575:	c7 45 f4 85 08 00 00 	movl   $0x885,-0xc(%ebp)
+        while(*s != 0){
+ 57c:	eb 1c                	jmp    59a <printf+0x103>
+          putc(fd, *s);
+ 57e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 581:	0f b6 00             	movzbl (%eax),%eax
+ 584:	0f be c0             	movsbl %al,%eax
+ 587:	83 ec 08             	sub    $0x8,%esp
+ 58a:	50                   	push   %eax
+ 58b:	ff 75 08             	pushl  0x8(%ebp)
+ 58e:	e8 28 fe ff ff       	call   3bb <putc>
+ 593:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 596:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 59a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 59d:	0f b6 00             	movzbl (%eax),%eax
+ 5a0:	84 c0                	test   %al,%al
+ 5a2:	75 da                	jne    57e <printf+0xe7>
+ 5a4:	eb 65                	jmp    60b <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 5a6:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5aa:	75 1d                	jne    5c9 <printf+0x132>
+        putc(fd, *ap);
+ 5ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5af:	8b 00                	mov    (%eax),%eax
+ 5b1:	0f be c0             	movsbl %al,%eax
+ 5b4:	83 ec 08             	sub    $0x8,%esp
+ 5b7:	50                   	push   %eax
+ 5b8:	ff 75 08             	pushl  0x8(%ebp)
+ 5bb:	e8 fb fd ff ff       	call   3bb <putc>
+ 5c0:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5c3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5c7:	eb 42                	jmp    60b <printf+0x174>
+      } else if(c == '%'){
+ 5c9:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5cd:	75 17                	jne    5e6 <printf+0x14f>
+        putc(fd, c);
+ 5cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5d2:	0f be c0             	movsbl %al,%eax
+ 5d5:	83 ec 08             	sub    $0x8,%esp
+ 5d8:	50                   	push   %eax
+ 5d9:	ff 75 08             	pushl  0x8(%ebp)
+ 5dc:	e8 da fd ff ff       	call   3bb <putc>
+ 5e1:	83 c4 10             	add    $0x10,%esp
+ 5e4:	eb 25                	jmp    60b <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 5e6:	83 ec 08             	sub    $0x8,%esp
+ 5e9:	6a 25                	push   $0x25
+ 5eb:	ff 75 08             	pushl  0x8(%ebp)
+ 5ee:	e8 c8 fd ff ff       	call   3bb <putc>
+ 5f3:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 5f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5f9:	0f be c0             	movsbl %al,%eax
+ 5fc:	83 ec 08             	sub    $0x8,%esp
+ 5ff:	50                   	push   %eax
+ 600:	ff 75 08             	pushl  0x8(%ebp)
+ 603:	e8 b3 fd ff ff       	call   3bb <putc>
+ 608:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 60b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 612:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 616:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 619:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 61c:	01 d0                	add    %edx,%eax
+ 61e:	0f b6 00             	movzbl (%eax),%eax
+ 621:	84 c0                	test   %al,%al
+ 623:	0f 85 94 fe ff ff    	jne    4bd <printf+0x26>
+    }
+  }
+}
+ 629:	90                   	nop
+ 62a:	90                   	nop
+ 62b:	c9                   	leave  
+ 62c:	c3                   	ret    
+
+0000062d <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 62d:	f3 0f 1e fb          	endbr32 
+ 631:	55                   	push   %ebp
+ 632:	89 e5                	mov    %esp,%ebp
+ 634:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 637:	8b 45 08             	mov    0x8(%ebp),%eax
+ 63a:	83 e8 08             	sub    $0x8,%eax
+ 63d:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 640:	a1 f0 0a 00 00       	mov    0xaf0,%eax
+ 645:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 648:	eb 24                	jmp    66e <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 64a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 64d:	8b 00                	mov    (%eax),%eax
+ 64f:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 652:	72 12                	jb     666 <free+0x39>
+ 654:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 657:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 65a:	77 24                	ja     680 <free+0x53>
+ 65c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65f:	8b 00                	mov    (%eax),%eax
+ 661:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 664:	72 1a                	jb     680 <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 666:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 669:	8b 00                	mov    (%eax),%eax
+ 66b:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 66e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 671:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 674:	76 d4                	jbe    64a <free+0x1d>
+ 676:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 679:	8b 00                	mov    (%eax),%eax
+ 67b:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 67e:	73 ca                	jae    64a <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 680:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 683:	8b 40 04             	mov    0x4(%eax),%eax
+ 686:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 68d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 690:	01 c2                	add    %eax,%edx
+ 692:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 695:	8b 00                	mov    (%eax),%eax
+ 697:	39 c2                	cmp    %eax,%edx
+ 699:	75 24                	jne    6bf <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 69b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69e:	8b 50 04             	mov    0x4(%eax),%edx
+ 6a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a4:	8b 00                	mov    (%eax),%eax
+ 6a6:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a9:	01 c2                	add    %eax,%edx
+ 6ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ae:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b4:	8b 00                	mov    (%eax),%eax
+ 6b6:	8b 10                	mov    (%eax),%edx
+ 6b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6bb:	89 10                	mov    %edx,(%eax)
+ 6bd:	eb 0a                	jmp    6c9 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6bf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c2:	8b 10                	mov    (%eax),%edx
+ 6c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6c7:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6cc:	8b 40 04             	mov    0x4(%eax),%eax
+ 6cf:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d9:	01 d0                	add    %edx,%eax
+ 6db:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6de:	75 20                	jne    700 <free+0xd3>
+    p->s.size += bp->s.size;
+ 6e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e3:	8b 50 04             	mov    0x4(%eax),%edx
+ 6e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e9:	8b 40 04             	mov    0x4(%eax),%eax
+ 6ec:	01 c2                	add    %eax,%edx
+ 6ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f1:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6f7:	8b 10                	mov    (%eax),%edx
+ 6f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6fc:	89 10                	mov    %edx,(%eax)
+ 6fe:	eb 08                	jmp    708 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 700:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 703:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 706:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 708:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 70b:	a3 f0 0a 00 00       	mov    %eax,0xaf0
+}
+ 710:	90                   	nop
+ 711:	c9                   	leave  
+ 712:	c3                   	ret    
+
+00000713 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 713:	f3 0f 1e fb          	endbr32 
+ 717:	55                   	push   %ebp
+ 718:	89 e5                	mov    %esp,%ebp
+ 71a:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 71d:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 724:	77 07                	ja     72d <morecore+0x1a>
+    nu = 4096;
+ 726:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 72d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 730:	c1 e0 03             	shl    $0x3,%eax
+ 733:	83 ec 0c             	sub    $0xc,%esp
+ 736:	50                   	push   %eax
+ 737:	e8 3f fc ff ff       	call   37b <sbrk>
+ 73c:	83 c4 10             	add    $0x10,%esp
+ 73f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 742:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 746:	75 07                	jne    74f <morecore+0x3c>
+    return 0;
+ 748:	b8 00 00 00 00       	mov    $0x0,%eax
+ 74d:	eb 26                	jmp    775 <morecore+0x62>
+  hp = (Header*)p;
+ 74f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 752:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 755:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 758:	8b 55 08             	mov    0x8(%ebp),%edx
+ 75b:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 75e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 761:	83 c0 08             	add    $0x8,%eax
+ 764:	83 ec 0c             	sub    $0xc,%esp
+ 767:	50                   	push   %eax
+ 768:	e8 c0 fe ff ff       	call   62d <free>
+ 76d:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 770:	a1 f0 0a 00 00       	mov    0xaf0,%eax
+}
+ 775:	c9                   	leave  
+ 776:	c3                   	ret    
+
+00000777 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 777:	f3 0f 1e fb          	endbr32 
+ 77b:	55                   	push   %ebp
+ 77c:	89 e5                	mov    %esp,%ebp
+ 77e:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 781:	8b 45 08             	mov    0x8(%ebp),%eax
+ 784:	83 c0 07             	add    $0x7,%eax
+ 787:	c1 e8 03             	shr    $0x3,%eax
+ 78a:	83 c0 01             	add    $0x1,%eax
+ 78d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 790:	a1 f0 0a 00 00       	mov    0xaf0,%eax
+ 795:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 798:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 79c:	75 23                	jne    7c1 <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 79e:	c7 45 f0 e8 0a 00 00 	movl   $0xae8,-0x10(%ebp)
+ 7a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7a8:	a3 f0 0a 00 00       	mov    %eax,0xaf0
+ 7ad:	a1 f0 0a 00 00       	mov    0xaf0,%eax
+ 7b2:	a3 e8 0a 00 00       	mov    %eax,0xae8
+    base.s.size = 0;
+ 7b7:	c7 05 ec 0a 00 00 00 	movl   $0x0,0xaec
+ 7be:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7c4:	8b 00                	mov    (%eax),%eax
+ 7c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7cc:	8b 40 04             	mov    0x4(%eax),%eax
+ 7cf:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7d2:	77 4d                	ja     821 <malloc+0xaa>
+      if(p->s.size == nunits)
+ 7d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7d7:	8b 40 04             	mov    0x4(%eax),%eax
+ 7da:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7dd:	75 0c                	jne    7eb <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 7df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e2:	8b 10                	mov    (%eax),%edx
+ 7e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7e7:	89 10                	mov    %edx,(%eax)
+ 7e9:	eb 26                	jmp    811 <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 7eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ee:	8b 40 04             	mov    0x4(%eax),%eax
+ 7f1:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 7f4:	89 c2                	mov    %eax,%edx
+ 7f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f9:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ff:	8b 40 04             	mov    0x4(%eax),%eax
+ 802:	c1 e0 03             	shl    $0x3,%eax
+ 805:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 808:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80b:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 80e:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 811:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 814:	a3 f0 0a 00 00       	mov    %eax,0xaf0
+      return (void*)(p + 1);
+ 819:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 81c:	83 c0 08             	add    $0x8,%eax
+ 81f:	eb 3b                	jmp    85c <malloc+0xe5>
+    }
+    if(p == freep)
+ 821:	a1 f0 0a 00 00       	mov    0xaf0,%eax
+ 826:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 829:	75 1e                	jne    849 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 82b:	83 ec 0c             	sub    $0xc,%esp
+ 82e:	ff 75 ec             	pushl  -0x14(%ebp)
+ 831:	e8 dd fe ff ff       	call   713 <morecore>
+ 836:	83 c4 10             	add    $0x10,%esp
+ 839:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 83c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 840:	75 07                	jne    849 <malloc+0xd2>
+        return 0;
+ 842:	b8 00 00 00 00       	mov    $0x0,%eax
+ 847:	eb 13                	jmp    85c <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 849:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 84c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 84f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 852:	8b 00                	mov    (%eax),%eax
+ 854:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 857:	e9 6d ff ff ff       	jmp    7c9 <malloc+0x52>
+  }
+}
+ 85c:	c9                   	leave  
+ 85d:	c3                   	ret    
diff -ruN xv6-public/xv6-public/ln.c xv6-public_new/xv6-public/ln.c
--- xv6-public/xv6-public/ln.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ln.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,15 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+  if(argc != 3){
+    printf(2, "Usage: ln old new\n");
+    exit();
+  }
+  if(link(argv[1], argv[2]) < 0)
+    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  exit();
+}
diff -ruN xv6-public/xv6-public/ln.d xv6-public_new/xv6-public/ln.d
--- xv6-public/xv6-public/ln.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ln.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+ln.o: ln.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/ln.o and xv6-public_new/xv6-public/ln.o differ
diff -ruN xv6-public/xv6-public/ln.sym xv6-public_new/xv6-public/ln.sym
--- xv6-public/xv6-public/ln.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ln.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+0000085e .rodata
+0000088c .eh_frame
+00000ad4 .data
+00000ae8 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 ln.c
+00000000 ulib.c
+00000078 stosb
+00000000 printf.c
+000003bb putc
+000003e2 printint
+00000ad4 digits.1098
+00000000 umalloc.c
+00000ae8 base
+00000af0 freep
+00000713 morecore
+0000009e strcpy
+000003a3 yield
+000003b3 set_prio
+00000497 printf
+000002aa memmove
+0000033b mknod
+00000195 gets
+00000373 getpid
+00000777 malloc
+00000383 sleep
+000003ab wait2
+00000303 pipe
+00000313 write
+0000034b fstat
+00000323 kill
+00000363 chdir
+0000032b exec
+000002fb wait
+0000030b read
+00000343 unlink
+000002eb fork
+0000037b sbrk
+0000038b uptime
+00000ae5 __bss_start
+00000140 memset
+00000000 main
+000000d2 strcmp
+0000036b dup
+00000208 stat
+00000ae5 _edata
+00000af4 _end
+00000353 link
+000002f3 exit
+00000259 atoi
+00000393 draw
+00000115 strlen
+00000333 open
+0000015e strchr
+0000039b cps
+0000035b mkdir
+0000031b close
+0000062d free
diff -ruN xv6-public/xv6-public/log.c xv6-public_new/xv6-public/log.c
--- xv6-public/xv6-public/log.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/log.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,234 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "buf.h"
+
+// Simple logging that allows concurrent FS system calls.
+//
+// A log transaction contains the updates of multiple FS system
+// calls. The logging system only commits when there are
+// no FS system calls active. Thus there is never
+// any reasoning required about whether a commit might
+// write an uncommitted system call's updates to disk.
+//
+// A system call should call begin_op()/end_op() to mark
+// its start and end. Usually begin_op() just increments
+// the count of in-progress FS system calls and returns.
+// But if it thinks the log is close to running out, it
+// sleeps until the last outstanding end_op() commits.
+//
+// The log is a physical re-do log containing disk blocks.
+// The on-disk log format:
+//   header block, containing block #s for block A, B, C, ...
+//   block A
+//   block B
+//   block C
+//   ...
+// Log appends are synchronous.
+
+// Contents of the header block, used for both the on-disk header block
+// and to keep track in memory of logged block# before commit.
+struct logheader {
+  int n;
+  int block[LOGSIZE];
+};
+
+struct log {
+  struct spinlock lock;
+  int start;
+  int size;
+  int outstanding; // how many FS sys calls are executing.
+  int committing;  // in commit(), please wait.
+  int dev;
+  struct logheader lh;
+};
+struct log log;
+
+static void recover_from_log(void);
+static void commit();
+
+void
+initlog(int dev)
+{
+  if (sizeof(struct logheader) >= BSIZE)
+    panic("initlog: too big logheader");
+
+  struct superblock sb;
+  initlock(&log.lock, "log");
+  readsb(dev, &sb);
+  log.start = sb.logstart;
+  log.size = sb.nlog;
+  log.dev = dev;
+  recover_from_log();
+}
+
+// Copy committed blocks from log to their home location
+static void
+install_trans(void)
+{
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+    bwrite(dbuf);  // write dst to disk
+    brelse(lbuf);
+    brelse(dbuf);
+  }
+}
+
+// Read the log header from disk into the in-memory log header
+static void
+read_head(void)
+{
+  struct buf *buf = bread(log.dev, log.start);
+  struct logheader *lh = (struct logheader *) (buf->data);
+  int i;
+  log.lh.n = lh->n;
+  for (i = 0; i < log.lh.n; i++) {
+    log.lh.block[i] = lh->block[i];
+  }
+  brelse(buf);
+}
+
+// Write in-memory log header to disk.
+// This is the true point at which the
+// current transaction commits.
+static void
+write_head(void)
+{
+  struct buf *buf = bread(log.dev, log.start);
+  struct logheader *hb = (struct logheader *) (buf->data);
+  int i;
+  hb->n = log.lh.n;
+  for (i = 0; i < log.lh.n; i++) {
+    hb->block[i] = log.lh.block[i];
+  }
+  bwrite(buf);
+  brelse(buf);
+}
+
+static void
+recover_from_log(void)
+{
+  read_head();
+  install_trans(); // if committed, copy from log to disk
+  log.lh.n = 0;
+  write_head(); // clear the log
+}
+
+// called at the start of each FS system call.
+void
+begin_op(void)
+{
+  acquire(&log.lock);
+  while(1){
+    if(log.committing){
+      sleep(&log, &log.lock);
+    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
+      // this op might exhaust log space; wait for commit.
+      sleep(&log, &log.lock);
+    } else {
+      log.outstanding += 1;
+      release(&log.lock);
+      break;
+    }
+  }
+}
+
+// called at the end of each FS system call.
+// commits if this was the last outstanding operation.
+void
+end_op(void)
+{
+  int do_commit = 0;
+
+  acquire(&log.lock);
+  log.outstanding -= 1;
+  if(log.committing)
+    panic("log.committing");
+  if(log.outstanding == 0){
+    do_commit = 1;
+    log.committing = 1;
+  } else {
+    // begin_op() may be waiting for log space,
+    // and decrementing log.outstanding has decreased
+    // the amount of reserved space.
+    wakeup(&log);
+  }
+  release(&log.lock);
+
+  if(do_commit){
+    // call commit w/o holding locks, since not allowed
+    // to sleep with locks.
+    commit();
+    acquire(&log.lock);
+    log.committing = 0;
+    wakeup(&log);
+    release(&log.lock);
+  }
+}
+
+// Copy modified blocks from cache to log.
+static void
+write_log(void)
+{
+  int tail;
+
+  for (tail = 0; tail < log.lh.n; tail++) {
+    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+    memmove(to->data, from->data, BSIZE);
+    bwrite(to);  // write the log
+    brelse(from);
+    brelse(to);
+  }
+}
+
+static void
+commit()
+{
+  if (log.lh.n > 0) {
+    write_log();     // Write modified blocks from cache to log
+    write_head();    // Write header to disk -- the real commit
+    install_trans(); // Now install writes to home locations
+    log.lh.n = 0;
+    write_head();    // Erase the transaction from the log
+  }
+}
+
+// Caller has modified b->data and is done with the buffer.
+// Record the block number and pin in the cache with B_DIRTY.
+// commit()/write_log() will do the disk write.
+//
+// log_write() replaces bwrite(); a typical use is:
+//   bp = bread(...)
+//   modify bp->data[]
+//   log_write(bp)
+//   brelse(bp)
+void
+log_write(struct buf *b)
+{
+  int i;
+
+  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
+    panic("too big a transaction");
+  if (log.outstanding < 1)
+    panic("log_write outside of trans");
+
+  acquire(&log.lock);
+  for (i = 0; i < log.lh.n; i++) {
+    if (log.lh.block[i] == b->blockno)   // log absorbtion
+      break;
+  }
+  log.lh.block[i] = b->blockno;
+  if (i == log.lh.n)
+    log.lh.n++;
+  b->flags |= B_DIRTY; // prevent eviction
+  release(&log.lock);
+}
+
diff -ruN xv6-public/xv6-public/log.d xv6-public_new/xv6-public/log.d
--- xv6-public/xv6-public/log.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/log.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+log.o: log.c /usr/include/stdc-predef.h types.h defs.h param.h spinlock.h \
+ sleeplock.h fs.h buf.h
Binary files xv6-public/xv6-public/log.o and xv6-public_new/xv6-public/log.o differ
diff -ruN xv6-public/xv6-public/ls.asm xv6-public_new/xv6-public/ls.asm
--- xv6-public/xv6-public/ls.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ls.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1467 @@
+
+_ls:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <fmtname>:
+#include "user.h"
+#include "fs.h"
+
+char*
+fmtname(char *path)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	55                   	push   %ebp
+   5:	89 e5                	mov    %esp,%ebp
+   7:	53                   	push   %ebx
+   8:	83 ec 14             	sub    $0x14,%esp
+  static char buf[DIRSIZ+1];
+  char *p;
+
+  // Find first character after last slash.
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+   b:	83 ec 0c             	sub    $0xc,%esp
+   e:	ff 75 08             	pushl  0x8(%ebp)
+  11:	e8 d5 03 00 00       	call   3eb <strlen>
+  16:	83 c4 10             	add    $0x10,%esp
+  19:	8b 55 08             	mov    0x8(%ebp),%edx
+  1c:	01 d0                	add    %edx,%eax
+  1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  21:	eb 04                	jmp    27 <fmtname+0x27>
+  23:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  27:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  2a:	3b 45 08             	cmp    0x8(%ebp),%eax
+  2d:	72 0a                	jb     39 <fmtname+0x39>
+  2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  32:	0f b6 00             	movzbl (%eax),%eax
+  35:	3c 2f                	cmp    $0x2f,%al
+  37:	75 ea                	jne    23 <fmtname+0x23>
+    ;
+  p++;
+  39:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+
+  // Return blank-padded name.
+  if(strlen(p) >= DIRSIZ)
+  3d:	83 ec 0c             	sub    $0xc,%esp
+  40:	ff 75 f4             	pushl  -0xc(%ebp)
+  43:	e8 a3 03 00 00       	call   3eb <strlen>
+  48:	83 c4 10             	add    $0x10,%esp
+  4b:	83 f8 0d             	cmp    $0xd,%eax
+  4e:	76 05                	jbe    55 <fmtname+0x55>
+    return p;
+  50:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  53:	eb 60                	jmp    b5 <fmtname+0xb5>
+  memmove(buf, p, strlen(p));
+  55:	83 ec 0c             	sub    $0xc,%esp
+  58:	ff 75 f4             	pushl  -0xc(%ebp)
+  5b:	e8 8b 03 00 00       	call   3eb <strlen>
+  60:	83 c4 10             	add    $0x10,%esp
+  63:	83 ec 04             	sub    $0x4,%esp
+  66:	50                   	push   %eax
+  67:	ff 75 f4             	pushl  -0xc(%ebp)
+  6a:	68 38 0e 00 00       	push   $0xe38
+  6f:	e8 0c 05 00 00       	call   580 <memmove>
+  74:	83 c4 10             	add    $0x10,%esp
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+  77:	83 ec 0c             	sub    $0xc,%esp
+  7a:	ff 75 f4             	pushl  -0xc(%ebp)
+  7d:	e8 69 03 00 00       	call   3eb <strlen>
+  82:	83 c4 10             	add    $0x10,%esp
+  85:	ba 0e 00 00 00       	mov    $0xe,%edx
+  8a:	89 d3                	mov    %edx,%ebx
+  8c:	29 c3                	sub    %eax,%ebx
+  8e:	83 ec 0c             	sub    $0xc,%esp
+  91:	ff 75 f4             	pushl  -0xc(%ebp)
+  94:	e8 52 03 00 00       	call   3eb <strlen>
+  99:	83 c4 10             	add    $0x10,%esp
+  9c:	05 38 0e 00 00       	add    $0xe38,%eax
+  a1:	83 ec 04             	sub    $0x4,%esp
+  a4:	53                   	push   %ebx
+  a5:	6a 20                	push   $0x20
+  a7:	50                   	push   %eax
+  a8:	e8 69 03 00 00       	call   416 <memset>
+  ad:	83 c4 10             	add    $0x10,%esp
+  return buf;
+  b0:	b8 38 0e 00 00       	mov    $0xe38,%eax
+}
+  b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+  b8:	c9                   	leave  
+  b9:	c3                   	ret    
+
+000000ba <ls>:
+
+void
+ls(char *path)
+{
+  ba:	f3 0f 1e fb          	endbr32 
+  be:	55                   	push   %ebp
+  bf:	89 e5                	mov    %esp,%ebp
+  c1:	57                   	push   %edi
+  c2:	56                   	push   %esi
+  c3:	53                   	push   %ebx
+  c4:	81 ec 3c 02 00 00    	sub    $0x23c,%esp
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+
+  if((fd = open(path, 0)) < 0){
+  ca:	83 ec 08             	sub    $0x8,%esp
+  cd:	6a 00                	push   $0x0
+  cf:	ff 75 08             	pushl  0x8(%ebp)
+  d2:	e8 32 05 00 00       	call   609 <open>
+  d7:	83 c4 10             	add    $0x10,%esp
+  da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  dd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  e1:	79 1a                	jns    fd <ls+0x43>
+    printf(2, "ls: cannot open %s\n", path);
+  e3:	83 ec 04             	sub    $0x4,%esp
+  e6:	ff 75 08             	pushl  0x8(%ebp)
+  e9:	68 34 0b 00 00       	push   $0xb34
+  ee:	6a 02                	push   $0x2
+  f0:	e8 78 06 00 00       	call   76d <printf>
+  f5:	83 c4 10             	add    $0x10,%esp
+    return;
+  f8:	e9 e1 01 00 00       	jmp    2de <ls+0x224>
+  }
+
+  if(fstat(fd, &st) < 0){
+  fd:	83 ec 08             	sub    $0x8,%esp
+ 100:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
+ 106:	50                   	push   %eax
+ 107:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 10a:	e8 12 05 00 00       	call   621 <fstat>
+ 10f:	83 c4 10             	add    $0x10,%esp
+ 112:	85 c0                	test   %eax,%eax
+ 114:	79 28                	jns    13e <ls+0x84>
+    printf(2, "ls: cannot stat %s\n", path);
+ 116:	83 ec 04             	sub    $0x4,%esp
+ 119:	ff 75 08             	pushl  0x8(%ebp)
+ 11c:	68 48 0b 00 00       	push   $0xb48
+ 121:	6a 02                	push   $0x2
+ 123:	e8 45 06 00 00       	call   76d <printf>
+ 128:	83 c4 10             	add    $0x10,%esp
+    close(fd);
+ 12b:	83 ec 0c             	sub    $0xc,%esp
+ 12e:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 131:	e8 bb 04 00 00       	call   5f1 <close>
+ 136:	83 c4 10             	add    $0x10,%esp
+    return;
+ 139:	e9 a0 01 00 00       	jmp    2de <ls+0x224>
+  }
+
+  switch(st.type){
+ 13e:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
+ 145:	98                   	cwtl   
+ 146:	83 f8 01             	cmp    $0x1,%eax
+ 149:	74 48                	je     193 <ls+0xd9>
+ 14b:	83 f8 02             	cmp    $0x2,%eax
+ 14e:	0f 85 7c 01 00 00    	jne    2d0 <ls+0x216>
+  case T_FILE:
+    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+ 154:	8b bd cc fd ff ff    	mov    -0x234(%ebp),%edi
+ 15a:	8b b5 c4 fd ff ff    	mov    -0x23c(%ebp),%esi
+ 160:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
+ 167:	0f bf d8             	movswl %ax,%ebx
+ 16a:	83 ec 0c             	sub    $0xc,%esp
+ 16d:	ff 75 08             	pushl  0x8(%ebp)
+ 170:	e8 8b fe ff ff       	call   0 <fmtname>
+ 175:	83 c4 10             	add    $0x10,%esp
+ 178:	83 ec 08             	sub    $0x8,%esp
+ 17b:	57                   	push   %edi
+ 17c:	56                   	push   %esi
+ 17d:	53                   	push   %ebx
+ 17e:	50                   	push   %eax
+ 17f:	68 5c 0b 00 00       	push   $0xb5c
+ 184:	6a 01                	push   $0x1
+ 186:	e8 e2 05 00 00       	call   76d <printf>
+ 18b:	83 c4 20             	add    $0x20,%esp
+    break;
+ 18e:	e9 3d 01 00 00       	jmp    2d0 <ls+0x216>
+
+  case T_DIR:
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+ 193:	83 ec 0c             	sub    $0xc,%esp
+ 196:	ff 75 08             	pushl  0x8(%ebp)
+ 199:	e8 4d 02 00 00       	call   3eb <strlen>
+ 19e:	83 c4 10             	add    $0x10,%esp
+ 1a1:	83 c0 10             	add    $0x10,%eax
+ 1a4:	3d 00 02 00 00       	cmp    $0x200,%eax
+ 1a9:	76 17                	jbe    1c2 <ls+0x108>
+      printf(1, "ls: path too long\n");
+ 1ab:	83 ec 08             	sub    $0x8,%esp
+ 1ae:	68 69 0b 00 00       	push   $0xb69
+ 1b3:	6a 01                	push   $0x1
+ 1b5:	e8 b3 05 00 00       	call   76d <printf>
+ 1ba:	83 c4 10             	add    $0x10,%esp
+      break;
+ 1bd:	e9 0e 01 00 00       	jmp    2d0 <ls+0x216>
+    }
+    strcpy(buf, path);
+ 1c2:	83 ec 08             	sub    $0x8,%esp
+ 1c5:	ff 75 08             	pushl  0x8(%ebp)
+ 1c8:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 1ce:	50                   	push   %eax
+ 1cf:	e8 a0 01 00 00       	call   374 <strcpy>
+ 1d4:	83 c4 10             	add    $0x10,%esp
+    p = buf+strlen(buf);
+ 1d7:	83 ec 0c             	sub    $0xc,%esp
+ 1da:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 1e0:	50                   	push   %eax
+ 1e1:	e8 05 02 00 00       	call   3eb <strlen>
+ 1e6:	83 c4 10             	add    $0x10,%esp
+ 1e9:	8d 95 e0 fd ff ff    	lea    -0x220(%ebp),%edx
+ 1ef:	01 d0                	add    %edx,%eax
+ 1f1:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    *p++ = '/';
+ 1f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
+ 1f7:	8d 50 01             	lea    0x1(%eax),%edx
+ 1fa:	89 55 e0             	mov    %edx,-0x20(%ebp)
+ 1fd:	c6 00 2f             	movb   $0x2f,(%eax)
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+ 200:	e9 aa 00 00 00       	jmp    2af <ls+0x1f5>
+      if(de.inum == 0)
+ 205:	0f b7 85 d0 fd ff ff 	movzwl -0x230(%ebp),%eax
+ 20c:	66 85 c0             	test   %ax,%ax
+ 20f:	75 05                	jne    216 <ls+0x15c>
+        continue;
+ 211:	e9 99 00 00 00       	jmp    2af <ls+0x1f5>
+      memmove(p, de.name, DIRSIZ);
+ 216:	83 ec 04             	sub    $0x4,%esp
+ 219:	6a 0e                	push   $0xe
+ 21b:	8d 85 d0 fd ff ff    	lea    -0x230(%ebp),%eax
+ 221:	83 c0 02             	add    $0x2,%eax
+ 224:	50                   	push   %eax
+ 225:	ff 75 e0             	pushl  -0x20(%ebp)
+ 228:	e8 53 03 00 00       	call   580 <memmove>
+ 22d:	83 c4 10             	add    $0x10,%esp
+      p[DIRSIZ] = 0;
+ 230:	8b 45 e0             	mov    -0x20(%ebp),%eax
+ 233:	83 c0 0e             	add    $0xe,%eax
+ 236:	c6 00 00             	movb   $0x0,(%eax)
+      if(stat(buf, &st) < 0){
+ 239:	83 ec 08             	sub    $0x8,%esp
+ 23c:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
+ 242:	50                   	push   %eax
+ 243:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 249:	50                   	push   %eax
+ 24a:	e8 8f 02 00 00       	call   4de <stat>
+ 24f:	83 c4 10             	add    $0x10,%esp
+ 252:	85 c0                	test   %eax,%eax
+ 254:	79 1b                	jns    271 <ls+0x1b7>
+        printf(1, "ls: cannot stat %s\n", buf);
+ 256:	83 ec 04             	sub    $0x4,%esp
+ 259:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 25f:	50                   	push   %eax
+ 260:	68 48 0b 00 00       	push   $0xb48
+ 265:	6a 01                	push   $0x1
+ 267:	e8 01 05 00 00       	call   76d <printf>
+ 26c:	83 c4 10             	add    $0x10,%esp
+        continue;
+ 26f:	eb 3e                	jmp    2af <ls+0x1f5>
+      }
+      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+ 271:	8b bd cc fd ff ff    	mov    -0x234(%ebp),%edi
+ 277:	8b b5 c4 fd ff ff    	mov    -0x23c(%ebp),%esi
+ 27d:	0f b7 85 bc fd ff ff 	movzwl -0x244(%ebp),%eax
+ 284:	0f bf d8             	movswl %ax,%ebx
+ 287:	83 ec 0c             	sub    $0xc,%esp
+ 28a:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
+ 290:	50                   	push   %eax
+ 291:	e8 6a fd ff ff       	call   0 <fmtname>
+ 296:	83 c4 10             	add    $0x10,%esp
+ 299:	83 ec 08             	sub    $0x8,%esp
+ 29c:	57                   	push   %edi
+ 29d:	56                   	push   %esi
+ 29e:	53                   	push   %ebx
+ 29f:	50                   	push   %eax
+ 2a0:	68 5c 0b 00 00       	push   $0xb5c
+ 2a5:	6a 01                	push   $0x1
+ 2a7:	e8 c1 04 00 00       	call   76d <printf>
+ 2ac:	83 c4 20             	add    $0x20,%esp
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+ 2af:	83 ec 04             	sub    $0x4,%esp
+ 2b2:	6a 10                	push   $0x10
+ 2b4:	8d 85 d0 fd ff ff    	lea    -0x230(%ebp),%eax
+ 2ba:	50                   	push   %eax
+ 2bb:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 2be:	e8 1e 03 00 00       	call   5e1 <read>
+ 2c3:	83 c4 10             	add    $0x10,%esp
+ 2c6:	83 f8 10             	cmp    $0x10,%eax
+ 2c9:	0f 84 36 ff ff ff    	je     205 <ls+0x14b>
+    }
+    break;
+ 2cf:	90                   	nop
+  }
+  close(fd);
+ 2d0:	83 ec 0c             	sub    $0xc,%esp
+ 2d3:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 2d6:	e8 16 03 00 00       	call   5f1 <close>
+ 2db:	83 c4 10             	add    $0x10,%esp
+}
+ 2de:	8d 65 f4             	lea    -0xc(%ebp),%esp
+ 2e1:	5b                   	pop    %ebx
+ 2e2:	5e                   	pop    %esi
+ 2e3:	5f                   	pop    %edi
+ 2e4:	5d                   	pop    %ebp
+ 2e5:	c3                   	ret    
+
+000002e6 <main>:
+
+int
+main(int argc, char *argv[])
+{
+ 2e6:	f3 0f 1e fb          	endbr32 
+ 2ea:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+ 2ee:	83 e4 f0             	and    $0xfffffff0,%esp
+ 2f1:	ff 71 fc             	pushl  -0x4(%ecx)
+ 2f4:	55                   	push   %ebp
+ 2f5:	89 e5                	mov    %esp,%ebp
+ 2f7:	53                   	push   %ebx
+ 2f8:	51                   	push   %ecx
+ 2f9:	83 ec 10             	sub    $0x10,%esp
+ 2fc:	89 cb                	mov    %ecx,%ebx
+  int i;
+
+  if(argc < 2){
+ 2fe:	83 3b 01             	cmpl   $0x1,(%ebx)
+ 301:	7f 15                	jg     318 <main+0x32>
+    ls(".");
+ 303:	83 ec 0c             	sub    $0xc,%esp
+ 306:	68 7c 0b 00 00       	push   $0xb7c
+ 30b:	e8 aa fd ff ff       	call   ba <ls>
+ 310:	83 c4 10             	add    $0x10,%esp
+    exit();
+ 313:	e8 b1 02 00 00       	call   5c9 <exit>
+  }
+  for(i=1; i<argc; i++)
+ 318:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+ 31f:	eb 21                	jmp    342 <main+0x5c>
+    ls(argv[i]);
+ 321:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 324:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 32b:	8b 43 04             	mov    0x4(%ebx),%eax
+ 32e:	01 d0                	add    %edx,%eax
+ 330:	8b 00                	mov    (%eax),%eax
+ 332:	83 ec 0c             	sub    $0xc,%esp
+ 335:	50                   	push   %eax
+ 336:	e8 7f fd ff ff       	call   ba <ls>
+ 33b:	83 c4 10             	add    $0x10,%esp
+  for(i=1; i<argc; i++)
+ 33e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 342:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 345:	3b 03                	cmp    (%ebx),%eax
+ 347:	7c d8                	jl     321 <main+0x3b>
+  exit();
+ 349:	e8 7b 02 00 00       	call   5c9 <exit>
+
+0000034e <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 34e:	55                   	push   %ebp
+ 34f:	89 e5                	mov    %esp,%ebp
+ 351:	57                   	push   %edi
+ 352:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 353:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 356:	8b 55 10             	mov    0x10(%ebp),%edx
+ 359:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 35c:	89 cb                	mov    %ecx,%ebx
+ 35e:	89 df                	mov    %ebx,%edi
+ 360:	89 d1                	mov    %edx,%ecx
+ 362:	fc                   	cld    
+ 363:	f3 aa                	rep stos %al,%es:(%edi)
+ 365:	89 ca                	mov    %ecx,%edx
+ 367:	89 fb                	mov    %edi,%ebx
+ 369:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 36c:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 36f:	90                   	nop
+ 370:	5b                   	pop    %ebx
+ 371:	5f                   	pop    %edi
+ 372:	5d                   	pop    %ebp
+ 373:	c3                   	ret    
+
+00000374 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 374:	f3 0f 1e fb          	endbr32 
+ 378:	55                   	push   %ebp
+ 379:	89 e5                	mov    %esp,%ebp
+ 37b:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 37e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 381:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 384:	90                   	nop
+ 385:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 388:	8d 42 01             	lea    0x1(%edx),%eax
+ 38b:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 38e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 391:	8d 48 01             	lea    0x1(%eax),%ecx
+ 394:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 397:	0f b6 12             	movzbl (%edx),%edx
+ 39a:	88 10                	mov    %dl,(%eax)
+ 39c:	0f b6 00             	movzbl (%eax),%eax
+ 39f:	84 c0                	test   %al,%al
+ 3a1:	75 e2                	jne    385 <strcpy+0x11>
+    ;
+  return os;
+ 3a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 3a6:	c9                   	leave  
+ 3a7:	c3                   	ret    
+
+000003a8 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 3a8:	f3 0f 1e fb          	endbr32 
+ 3ac:	55                   	push   %ebp
+ 3ad:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 3af:	eb 08                	jmp    3b9 <strcmp+0x11>
+    p++, q++;
+ 3b1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 3b5:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 3b9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3bc:	0f b6 00             	movzbl (%eax),%eax
+ 3bf:	84 c0                	test   %al,%al
+ 3c1:	74 10                	je     3d3 <strcmp+0x2b>
+ 3c3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3c6:	0f b6 10             	movzbl (%eax),%edx
+ 3c9:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3cc:	0f b6 00             	movzbl (%eax),%eax
+ 3cf:	38 c2                	cmp    %al,%dl
+ 3d1:	74 de                	je     3b1 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 3d3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3d6:	0f b6 00             	movzbl (%eax),%eax
+ 3d9:	0f b6 d0             	movzbl %al,%edx
+ 3dc:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3df:	0f b6 00             	movzbl (%eax),%eax
+ 3e2:	0f b6 c0             	movzbl %al,%eax
+ 3e5:	29 c2                	sub    %eax,%edx
+ 3e7:	89 d0                	mov    %edx,%eax
+}
+ 3e9:	5d                   	pop    %ebp
+ 3ea:	c3                   	ret    
+
+000003eb <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 3eb:	f3 0f 1e fb          	endbr32 
+ 3ef:	55                   	push   %ebp
+ 3f0:	89 e5                	mov    %esp,%ebp
+ 3f2:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 3f5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 3fc:	eb 04                	jmp    402 <strlen+0x17>
+ 3fe:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 402:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 405:	8b 45 08             	mov    0x8(%ebp),%eax
+ 408:	01 d0                	add    %edx,%eax
+ 40a:	0f b6 00             	movzbl (%eax),%eax
+ 40d:	84 c0                	test   %al,%al
+ 40f:	75 ed                	jne    3fe <strlen+0x13>
+    ;
+  return n;
+ 411:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 414:	c9                   	leave  
+ 415:	c3                   	ret    
+
+00000416 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 416:	f3 0f 1e fb          	endbr32 
+ 41a:	55                   	push   %ebp
+ 41b:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 41d:	8b 45 10             	mov    0x10(%ebp),%eax
+ 420:	50                   	push   %eax
+ 421:	ff 75 0c             	pushl  0xc(%ebp)
+ 424:	ff 75 08             	pushl  0x8(%ebp)
+ 427:	e8 22 ff ff ff       	call   34e <stosb>
+ 42c:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 42f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 432:	c9                   	leave  
+ 433:	c3                   	ret    
+
+00000434 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 434:	f3 0f 1e fb          	endbr32 
+ 438:	55                   	push   %ebp
+ 439:	89 e5                	mov    %esp,%ebp
+ 43b:	83 ec 04             	sub    $0x4,%esp
+ 43e:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 441:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 444:	eb 14                	jmp    45a <strchr+0x26>
+    if(*s == c)
+ 446:	8b 45 08             	mov    0x8(%ebp),%eax
+ 449:	0f b6 00             	movzbl (%eax),%eax
+ 44c:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 44f:	75 05                	jne    456 <strchr+0x22>
+      return (char*)s;
+ 451:	8b 45 08             	mov    0x8(%ebp),%eax
+ 454:	eb 13                	jmp    469 <strchr+0x35>
+  for(; *s; s++)
+ 456:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 45a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 45d:	0f b6 00             	movzbl (%eax),%eax
+ 460:	84 c0                	test   %al,%al
+ 462:	75 e2                	jne    446 <strchr+0x12>
+  return 0;
+ 464:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 469:	c9                   	leave  
+ 46a:	c3                   	ret    
+
+0000046b <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 46b:	f3 0f 1e fb          	endbr32 
+ 46f:	55                   	push   %ebp
+ 470:	89 e5                	mov    %esp,%ebp
+ 472:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 475:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 47c:	eb 42                	jmp    4c0 <gets+0x55>
+    cc = read(0, &c, 1);
+ 47e:	83 ec 04             	sub    $0x4,%esp
+ 481:	6a 01                	push   $0x1
+ 483:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 486:	50                   	push   %eax
+ 487:	6a 00                	push   $0x0
+ 489:	e8 53 01 00 00       	call   5e1 <read>
+ 48e:	83 c4 10             	add    $0x10,%esp
+ 491:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 494:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 498:	7e 33                	jle    4cd <gets+0x62>
+      break;
+    buf[i++] = c;
+ 49a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 49d:	8d 50 01             	lea    0x1(%eax),%edx
+ 4a0:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 4a3:	89 c2                	mov    %eax,%edx
+ 4a5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4a8:	01 c2                	add    %eax,%edx
+ 4aa:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4ae:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 4b0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4b4:	3c 0a                	cmp    $0xa,%al
+ 4b6:	74 16                	je     4ce <gets+0x63>
+ 4b8:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 4bc:	3c 0d                	cmp    $0xd,%al
+ 4be:	74 0e                	je     4ce <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 4c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 4c3:	83 c0 01             	add    $0x1,%eax
+ 4c6:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 4c9:	7f b3                	jg     47e <gets+0x13>
+ 4cb:	eb 01                	jmp    4ce <gets+0x63>
+      break;
+ 4cd:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 4ce:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 4d1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4d4:	01 d0                	add    %edx,%eax
+ 4d6:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 4d9:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 4dc:	c9                   	leave  
+ 4dd:	c3                   	ret    
+
+000004de <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 4de:	f3 0f 1e fb          	endbr32 
+ 4e2:	55                   	push   %ebp
+ 4e3:	89 e5                	mov    %esp,%ebp
+ 4e5:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 4e8:	83 ec 08             	sub    $0x8,%esp
+ 4eb:	6a 00                	push   $0x0
+ 4ed:	ff 75 08             	pushl  0x8(%ebp)
+ 4f0:	e8 14 01 00 00       	call   609 <open>
+ 4f5:	83 c4 10             	add    $0x10,%esp
+ 4f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 4fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 4ff:	79 07                	jns    508 <stat+0x2a>
+    return -1;
+ 501:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 506:	eb 25                	jmp    52d <stat+0x4f>
+  r = fstat(fd, st);
+ 508:	83 ec 08             	sub    $0x8,%esp
+ 50b:	ff 75 0c             	pushl  0xc(%ebp)
+ 50e:	ff 75 f4             	pushl  -0xc(%ebp)
+ 511:	e8 0b 01 00 00       	call   621 <fstat>
+ 516:	83 c4 10             	add    $0x10,%esp
+ 519:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 51c:	83 ec 0c             	sub    $0xc,%esp
+ 51f:	ff 75 f4             	pushl  -0xc(%ebp)
+ 522:	e8 ca 00 00 00       	call   5f1 <close>
+ 527:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 52a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 52d:	c9                   	leave  
+ 52e:	c3                   	ret    
+
+0000052f <atoi>:
+
+int
+atoi(const char *s)
+{
+ 52f:	f3 0f 1e fb          	endbr32 
+ 533:	55                   	push   %ebp
+ 534:	89 e5                	mov    %esp,%ebp
+ 536:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 539:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 540:	eb 25                	jmp    567 <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 542:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 545:	89 d0                	mov    %edx,%eax
+ 547:	c1 e0 02             	shl    $0x2,%eax
+ 54a:	01 d0                	add    %edx,%eax
+ 54c:	01 c0                	add    %eax,%eax
+ 54e:	89 c1                	mov    %eax,%ecx
+ 550:	8b 45 08             	mov    0x8(%ebp),%eax
+ 553:	8d 50 01             	lea    0x1(%eax),%edx
+ 556:	89 55 08             	mov    %edx,0x8(%ebp)
+ 559:	0f b6 00             	movzbl (%eax),%eax
+ 55c:	0f be c0             	movsbl %al,%eax
+ 55f:	01 c8                	add    %ecx,%eax
+ 561:	83 e8 30             	sub    $0x30,%eax
+ 564:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 567:	8b 45 08             	mov    0x8(%ebp),%eax
+ 56a:	0f b6 00             	movzbl (%eax),%eax
+ 56d:	3c 2f                	cmp    $0x2f,%al
+ 56f:	7e 0a                	jle    57b <atoi+0x4c>
+ 571:	8b 45 08             	mov    0x8(%ebp),%eax
+ 574:	0f b6 00             	movzbl (%eax),%eax
+ 577:	3c 39                	cmp    $0x39,%al
+ 579:	7e c7                	jle    542 <atoi+0x13>
+  return n;
+ 57b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 57e:	c9                   	leave  
+ 57f:	c3                   	ret    
+
+00000580 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 580:	f3 0f 1e fb          	endbr32 
+ 584:	55                   	push   %ebp
+ 585:	89 e5                	mov    %esp,%ebp
+ 587:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 58a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 58d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 590:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 593:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 596:	eb 17                	jmp    5af <memmove+0x2f>
+    *dst++ = *src++;
+ 598:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 59b:	8d 42 01             	lea    0x1(%edx),%eax
+ 59e:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 5a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 5a4:	8d 48 01             	lea    0x1(%eax),%ecx
+ 5a7:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 5aa:	0f b6 12             	movzbl (%edx),%edx
+ 5ad:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 5af:	8b 45 10             	mov    0x10(%ebp),%eax
+ 5b2:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 5b5:	89 55 10             	mov    %edx,0x10(%ebp)
+ 5b8:	85 c0                	test   %eax,%eax
+ 5ba:	7f dc                	jg     598 <memmove+0x18>
+  return vdst;
+ 5bc:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 5bf:	c9                   	leave  
+ 5c0:	c3                   	ret    
+
+000005c1 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 5c1:	b8 01 00 00 00       	mov    $0x1,%eax
+ 5c6:	cd 40                	int    $0x40
+ 5c8:	c3                   	ret    
+
+000005c9 <exit>:
+SYSCALL(exit)
+ 5c9:	b8 02 00 00 00       	mov    $0x2,%eax
+ 5ce:	cd 40                	int    $0x40
+ 5d0:	c3                   	ret    
+
+000005d1 <wait>:
+SYSCALL(wait)
+ 5d1:	b8 03 00 00 00       	mov    $0x3,%eax
+ 5d6:	cd 40                	int    $0x40
+ 5d8:	c3                   	ret    
+
+000005d9 <pipe>:
+SYSCALL(pipe)
+ 5d9:	b8 04 00 00 00       	mov    $0x4,%eax
+ 5de:	cd 40                	int    $0x40
+ 5e0:	c3                   	ret    
+
+000005e1 <read>:
+SYSCALL(read)
+ 5e1:	b8 05 00 00 00       	mov    $0x5,%eax
+ 5e6:	cd 40                	int    $0x40
+ 5e8:	c3                   	ret    
+
+000005e9 <write>:
+SYSCALL(write)
+ 5e9:	b8 10 00 00 00       	mov    $0x10,%eax
+ 5ee:	cd 40                	int    $0x40
+ 5f0:	c3                   	ret    
+
+000005f1 <close>:
+SYSCALL(close)
+ 5f1:	b8 15 00 00 00       	mov    $0x15,%eax
+ 5f6:	cd 40                	int    $0x40
+ 5f8:	c3                   	ret    
+
+000005f9 <kill>:
+SYSCALL(kill)
+ 5f9:	b8 06 00 00 00       	mov    $0x6,%eax
+ 5fe:	cd 40                	int    $0x40
+ 600:	c3                   	ret    
+
+00000601 <exec>:
+SYSCALL(exec)
+ 601:	b8 07 00 00 00       	mov    $0x7,%eax
+ 606:	cd 40                	int    $0x40
+ 608:	c3                   	ret    
+
+00000609 <open>:
+SYSCALL(open)
+ 609:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 60e:	cd 40                	int    $0x40
+ 610:	c3                   	ret    
+
+00000611 <mknod>:
+SYSCALL(mknod)
+ 611:	b8 11 00 00 00       	mov    $0x11,%eax
+ 616:	cd 40                	int    $0x40
+ 618:	c3                   	ret    
+
+00000619 <unlink>:
+SYSCALL(unlink)
+ 619:	b8 12 00 00 00       	mov    $0x12,%eax
+ 61e:	cd 40                	int    $0x40
+ 620:	c3                   	ret    
+
+00000621 <fstat>:
+SYSCALL(fstat)
+ 621:	b8 08 00 00 00       	mov    $0x8,%eax
+ 626:	cd 40                	int    $0x40
+ 628:	c3                   	ret    
+
+00000629 <link>:
+SYSCALL(link)
+ 629:	b8 13 00 00 00       	mov    $0x13,%eax
+ 62e:	cd 40                	int    $0x40
+ 630:	c3                   	ret    
+
+00000631 <mkdir>:
+SYSCALL(mkdir)
+ 631:	b8 14 00 00 00       	mov    $0x14,%eax
+ 636:	cd 40                	int    $0x40
+ 638:	c3                   	ret    
+
+00000639 <chdir>:
+SYSCALL(chdir)
+ 639:	b8 09 00 00 00       	mov    $0x9,%eax
+ 63e:	cd 40                	int    $0x40
+ 640:	c3                   	ret    
+
+00000641 <dup>:
+SYSCALL(dup)
+ 641:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 646:	cd 40                	int    $0x40
+ 648:	c3                   	ret    
+
+00000649 <getpid>:
+SYSCALL(getpid)
+ 649:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 64e:	cd 40                	int    $0x40
+ 650:	c3                   	ret    
+
+00000651 <sbrk>:
+SYSCALL(sbrk)
+ 651:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 656:	cd 40                	int    $0x40
+ 658:	c3                   	ret    
+
+00000659 <sleep>:
+SYSCALL(sleep)
+ 659:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 65e:	cd 40                	int    $0x40
+ 660:	c3                   	ret    
+
+00000661 <uptime>:
+SYSCALL(uptime)
+ 661:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 666:	cd 40                	int    $0x40
+ 668:	c3                   	ret    
+
+00000669 <draw>:
+SYSCALL(draw)
+ 669:	b8 16 00 00 00       	mov    $0x16,%eax
+ 66e:	cd 40                	int    $0x40
+ 670:	c3                   	ret    
+
+00000671 <cps>:
+SYSCALL(cps)
+ 671:	b8 17 00 00 00       	mov    $0x17,%eax
+ 676:	cd 40                	int    $0x40
+ 678:	c3                   	ret    
+
+00000679 <yield>:
+SYSCALL(yield)
+ 679:	b8 18 00 00 00       	mov    $0x18,%eax
+ 67e:	cd 40                	int    $0x40
+ 680:	c3                   	ret    
+
+00000681 <wait2>:
+SYSCALL(wait2)
+ 681:	b8 19 00 00 00       	mov    $0x19,%eax
+ 686:	cd 40                	int    $0x40
+ 688:	c3                   	ret    
+
+00000689 <set_prio>:
+SYSCALL(set_prio)
+ 689:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 68e:	cd 40                	int    $0x40
+ 690:	c3                   	ret    
+
+00000691 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 691:	f3 0f 1e fb          	endbr32 
+ 695:	55                   	push   %ebp
+ 696:	89 e5                	mov    %esp,%ebp
+ 698:	83 ec 18             	sub    $0x18,%esp
+ 69b:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 69e:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 6a1:	83 ec 04             	sub    $0x4,%esp
+ 6a4:	6a 01                	push   $0x1
+ 6a6:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 6a9:	50                   	push   %eax
+ 6aa:	ff 75 08             	pushl  0x8(%ebp)
+ 6ad:	e8 37 ff ff ff       	call   5e9 <write>
+ 6b2:	83 c4 10             	add    $0x10,%esp
+}
+ 6b5:	90                   	nop
+ 6b6:	c9                   	leave  
+ 6b7:	c3                   	ret    
+
+000006b8 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 6b8:	f3 0f 1e fb          	endbr32 
+ 6bc:	55                   	push   %ebp
+ 6bd:	89 e5                	mov    %esp,%ebp
+ 6bf:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 6c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 6c9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 6cd:	74 17                	je     6e6 <printint+0x2e>
+ 6cf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 6d3:	79 11                	jns    6e6 <printint+0x2e>
+    neg = 1;
+ 6d5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 6dc:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6df:	f7 d8                	neg    %eax
+ 6e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 6e4:	eb 06                	jmp    6ec <printint+0x34>
+  } else {
+    x = xx;
+ 6e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 6e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 6ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 6f3:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 6f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 6f9:	ba 00 00 00 00       	mov    $0x0,%edx
+ 6fe:	f7 f1                	div    %ecx
+ 700:	89 d1                	mov    %edx,%ecx
+ 702:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 705:	8d 50 01             	lea    0x1(%eax),%edx
+ 708:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 70b:	0f b6 91 24 0e 00 00 	movzbl 0xe24(%ecx),%edx
+ 712:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 716:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 719:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 71c:	ba 00 00 00 00       	mov    $0x0,%edx
+ 721:	f7 f1                	div    %ecx
+ 723:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 726:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 72a:	75 c7                	jne    6f3 <printint+0x3b>
+  if(neg)
+ 72c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 730:	74 2d                	je     75f <printint+0xa7>
+    buf[i++] = '-';
+ 732:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 735:	8d 50 01             	lea    0x1(%eax),%edx
+ 738:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 73b:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 740:	eb 1d                	jmp    75f <printint+0xa7>
+    putc(fd, buf[i]);
+ 742:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 745:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 748:	01 d0                	add    %edx,%eax
+ 74a:	0f b6 00             	movzbl (%eax),%eax
+ 74d:	0f be c0             	movsbl %al,%eax
+ 750:	83 ec 08             	sub    $0x8,%esp
+ 753:	50                   	push   %eax
+ 754:	ff 75 08             	pushl  0x8(%ebp)
+ 757:	e8 35 ff ff ff       	call   691 <putc>
+ 75c:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 75f:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 763:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 767:	79 d9                	jns    742 <printint+0x8a>
+}
+ 769:	90                   	nop
+ 76a:	90                   	nop
+ 76b:	c9                   	leave  
+ 76c:	c3                   	ret    
+
+0000076d <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 76d:	f3 0f 1e fb          	endbr32 
+ 771:	55                   	push   %ebp
+ 772:	89 e5                	mov    %esp,%ebp
+ 774:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 777:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 77e:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 781:	83 c0 04             	add    $0x4,%eax
+ 784:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 787:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 78e:	e9 59 01 00 00       	jmp    8ec <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 793:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 796:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 799:	01 d0                	add    %edx,%eax
+ 79b:	0f b6 00             	movzbl (%eax),%eax
+ 79e:	0f be c0             	movsbl %al,%eax
+ 7a1:	25 ff 00 00 00       	and    $0xff,%eax
+ 7a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 7a9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 7ad:	75 2c                	jne    7db <printf+0x6e>
+      if(c == '%'){
+ 7af:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 7b3:	75 0c                	jne    7c1 <printf+0x54>
+        state = '%';
+ 7b5:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 7bc:	e9 27 01 00 00       	jmp    8e8 <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 7c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 7c4:	0f be c0             	movsbl %al,%eax
+ 7c7:	83 ec 08             	sub    $0x8,%esp
+ 7ca:	50                   	push   %eax
+ 7cb:	ff 75 08             	pushl  0x8(%ebp)
+ 7ce:	e8 be fe ff ff       	call   691 <putc>
+ 7d3:	83 c4 10             	add    $0x10,%esp
+ 7d6:	e9 0d 01 00 00       	jmp    8e8 <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 7db:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 7df:	0f 85 03 01 00 00    	jne    8e8 <printf+0x17b>
+      if(c == 'd'){
+ 7e5:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 7e9:	75 1e                	jne    809 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 7eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 7ee:	8b 00                	mov    (%eax),%eax
+ 7f0:	6a 01                	push   $0x1
+ 7f2:	6a 0a                	push   $0xa
+ 7f4:	50                   	push   %eax
+ 7f5:	ff 75 08             	pushl  0x8(%ebp)
+ 7f8:	e8 bb fe ff ff       	call   6b8 <printint>
+ 7fd:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 800:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 804:	e9 d8 00 00 00       	jmp    8e1 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 809:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 80d:	74 06                	je     815 <printf+0xa8>
+ 80f:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 813:	75 1e                	jne    833 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 815:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 818:	8b 00                	mov    (%eax),%eax
+ 81a:	6a 00                	push   $0x0
+ 81c:	6a 10                	push   $0x10
+ 81e:	50                   	push   %eax
+ 81f:	ff 75 08             	pushl  0x8(%ebp)
+ 822:	e8 91 fe ff ff       	call   6b8 <printint>
+ 827:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 82a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 82e:	e9 ae 00 00 00       	jmp    8e1 <printf+0x174>
+      } else if(c == 's'){
+ 833:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 837:	75 43                	jne    87c <printf+0x10f>
+        s = (char*)*ap;
+ 839:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 83c:	8b 00                	mov    (%eax),%eax
+ 83e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 841:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 845:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 849:	75 25                	jne    870 <printf+0x103>
+          s = "(null)";
+ 84b:	c7 45 f4 7e 0b 00 00 	movl   $0xb7e,-0xc(%ebp)
+        while(*s != 0){
+ 852:	eb 1c                	jmp    870 <printf+0x103>
+          putc(fd, *s);
+ 854:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 857:	0f b6 00             	movzbl (%eax),%eax
+ 85a:	0f be c0             	movsbl %al,%eax
+ 85d:	83 ec 08             	sub    $0x8,%esp
+ 860:	50                   	push   %eax
+ 861:	ff 75 08             	pushl  0x8(%ebp)
+ 864:	e8 28 fe ff ff       	call   691 <putc>
+ 869:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 86c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 870:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 873:	0f b6 00             	movzbl (%eax),%eax
+ 876:	84 c0                	test   %al,%al
+ 878:	75 da                	jne    854 <printf+0xe7>
+ 87a:	eb 65                	jmp    8e1 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 87c:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 880:	75 1d                	jne    89f <printf+0x132>
+        putc(fd, *ap);
+ 882:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 885:	8b 00                	mov    (%eax),%eax
+ 887:	0f be c0             	movsbl %al,%eax
+ 88a:	83 ec 08             	sub    $0x8,%esp
+ 88d:	50                   	push   %eax
+ 88e:	ff 75 08             	pushl  0x8(%ebp)
+ 891:	e8 fb fd ff ff       	call   691 <putc>
+ 896:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 899:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 89d:	eb 42                	jmp    8e1 <printf+0x174>
+      } else if(c == '%'){
+ 89f:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 8a3:	75 17                	jne    8bc <printf+0x14f>
+        putc(fd, c);
+ 8a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 8a8:	0f be c0             	movsbl %al,%eax
+ 8ab:	83 ec 08             	sub    $0x8,%esp
+ 8ae:	50                   	push   %eax
+ 8af:	ff 75 08             	pushl  0x8(%ebp)
+ 8b2:	e8 da fd ff ff       	call   691 <putc>
+ 8b7:	83 c4 10             	add    $0x10,%esp
+ 8ba:	eb 25                	jmp    8e1 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 8bc:	83 ec 08             	sub    $0x8,%esp
+ 8bf:	6a 25                	push   $0x25
+ 8c1:	ff 75 08             	pushl  0x8(%ebp)
+ 8c4:	e8 c8 fd ff ff       	call   691 <putc>
+ 8c9:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 8cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 8cf:	0f be c0             	movsbl %al,%eax
+ 8d2:	83 ec 08             	sub    $0x8,%esp
+ 8d5:	50                   	push   %eax
+ 8d6:	ff 75 08             	pushl  0x8(%ebp)
+ 8d9:	e8 b3 fd ff ff       	call   691 <putc>
+ 8de:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 8e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 8e8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 8ec:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 8ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8f2:	01 d0                	add    %edx,%eax
+ 8f4:	0f b6 00             	movzbl (%eax),%eax
+ 8f7:	84 c0                	test   %al,%al
+ 8f9:	0f 85 94 fe ff ff    	jne    793 <printf+0x26>
+    }
+  }
+}
+ 8ff:	90                   	nop
+ 900:	90                   	nop
+ 901:	c9                   	leave  
+ 902:	c3                   	ret    
+
+00000903 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 903:	f3 0f 1e fb          	endbr32 
+ 907:	55                   	push   %ebp
+ 908:	89 e5                	mov    %esp,%ebp
+ 90a:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 90d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 910:	83 e8 08             	sub    $0x8,%eax
+ 913:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 916:	a1 50 0e 00 00       	mov    0xe50,%eax
+ 91b:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 91e:	eb 24                	jmp    944 <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 920:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 923:	8b 00                	mov    (%eax),%eax
+ 925:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 928:	72 12                	jb     93c <free+0x39>
+ 92a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 92d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 930:	77 24                	ja     956 <free+0x53>
+ 932:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 935:	8b 00                	mov    (%eax),%eax
+ 937:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 93a:	72 1a                	jb     956 <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 93c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 93f:	8b 00                	mov    (%eax),%eax
+ 941:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 944:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 947:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 94a:	76 d4                	jbe    920 <free+0x1d>
+ 94c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 94f:	8b 00                	mov    (%eax),%eax
+ 951:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 954:	73 ca                	jae    920 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 956:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 959:	8b 40 04             	mov    0x4(%eax),%eax
+ 95c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 963:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 966:	01 c2                	add    %eax,%edx
+ 968:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 96b:	8b 00                	mov    (%eax),%eax
+ 96d:	39 c2                	cmp    %eax,%edx
+ 96f:	75 24                	jne    995 <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 971:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 974:	8b 50 04             	mov    0x4(%eax),%edx
+ 977:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 97a:	8b 00                	mov    (%eax),%eax
+ 97c:	8b 40 04             	mov    0x4(%eax),%eax
+ 97f:	01 c2                	add    %eax,%edx
+ 981:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 984:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 987:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 98a:	8b 00                	mov    (%eax),%eax
+ 98c:	8b 10                	mov    (%eax),%edx
+ 98e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 991:	89 10                	mov    %edx,(%eax)
+ 993:	eb 0a                	jmp    99f <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 995:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 998:	8b 10                	mov    (%eax),%edx
+ 99a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 99d:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 99f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9a2:	8b 40 04             	mov    0x4(%eax),%eax
+ 9a5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 9ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9af:	01 d0                	add    %edx,%eax
+ 9b1:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 9b4:	75 20                	jne    9d6 <free+0xd3>
+    p->s.size += bp->s.size;
+ 9b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9b9:	8b 50 04             	mov    0x4(%eax),%edx
+ 9bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9bf:	8b 40 04             	mov    0x4(%eax),%eax
+ 9c2:	01 c2                	add    %eax,%edx
+ 9c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9c7:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 9ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9cd:	8b 10                	mov    (%eax),%edx
+ 9cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9d2:	89 10                	mov    %edx,(%eax)
+ 9d4:	eb 08                	jmp    9de <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 9d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9d9:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 9dc:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 9de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9e1:	a3 50 0e 00 00       	mov    %eax,0xe50
+}
+ 9e6:	90                   	nop
+ 9e7:	c9                   	leave  
+ 9e8:	c3                   	ret    
+
+000009e9 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 9e9:	f3 0f 1e fb          	endbr32 
+ 9ed:	55                   	push   %ebp
+ 9ee:	89 e5                	mov    %esp,%ebp
+ 9f0:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 9f3:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 9fa:	77 07                	ja     a03 <morecore+0x1a>
+    nu = 4096;
+ 9fc:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ a03:	8b 45 08             	mov    0x8(%ebp),%eax
+ a06:	c1 e0 03             	shl    $0x3,%eax
+ a09:	83 ec 0c             	sub    $0xc,%esp
+ a0c:	50                   	push   %eax
+ a0d:	e8 3f fc ff ff       	call   651 <sbrk>
+ a12:	83 c4 10             	add    $0x10,%esp
+ a15:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ a18:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ a1c:	75 07                	jne    a25 <morecore+0x3c>
+    return 0;
+ a1e:	b8 00 00 00 00       	mov    $0x0,%eax
+ a23:	eb 26                	jmp    a4b <morecore+0x62>
+  hp = (Header*)p;
+ a25:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ a28:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ a2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a2e:	8b 55 08             	mov    0x8(%ebp),%edx
+ a31:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ a34:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a37:	83 c0 08             	add    $0x8,%eax
+ a3a:	83 ec 0c             	sub    $0xc,%esp
+ a3d:	50                   	push   %eax
+ a3e:	e8 c0 fe ff ff       	call   903 <free>
+ a43:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ a46:	a1 50 0e 00 00       	mov    0xe50,%eax
+}
+ a4b:	c9                   	leave  
+ a4c:	c3                   	ret    
+
+00000a4d <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ a4d:	f3 0f 1e fb          	endbr32 
+ a51:	55                   	push   %ebp
+ a52:	89 e5                	mov    %esp,%ebp
+ a54:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ a57:	8b 45 08             	mov    0x8(%ebp),%eax
+ a5a:	83 c0 07             	add    $0x7,%eax
+ a5d:	c1 e8 03             	shr    $0x3,%eax
+ a60:	83 c0 01             	add    $0x1,%eax
+ a63:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ a66:	a1 50 0e 00 00       	mov    0xe50,%eax
+ a6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ a6e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ a72:	75 23                	jne    a97 <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ a74:	c7 45 f0 48 0e 00 00 	movl   $0xe48,-0x10(%ebp)
+ a7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a7e:	a3 50 0e 00 00       	mov    %eax,0xe50
+ a83:	a1 50 0e 00 00       	mov    0xe50,%eax
+ a88:	a3 48 0e 00 00       	mov    %eax,0xe48
+    base.s.size = 0;
+ a8d:	c7 05 4c 0e 00 00 00 	movl   $0x0,0xe4c
+ a94:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ a97:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ a9a:	8b 00                	mov    (%eax),%eax
+ a9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ a9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ aa2:	8b 40 04             	mov    0x4(%eax),%eax
+ aa5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ aa8:	77 4d                	ja     af7 <malloc+0xaa>
+      if(p->s.size == nunits)
+ aaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ aad:	8b 40 04             	mov    0x4(%eax),%eax
+ ab0:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ ab3:	75 0c                	jne    ac1 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ ab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ab8:	8b 10                	mov    (%eax),%edx
+ aba:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ abd:	89 10                	mov    %edx,(%eax)
+ abf:	eb 26                	jmp    ae7 <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ ac1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ac4:	8b 40 04             	mov    0x4(%eax),%eax
+ ac7:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ aca:	89 c2                	mov    %eax,%edx
+ acc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ acf:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ ad2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ad5:	8b 40 04             	mov    0x4(%eax),%eax
+ ad8:	c1 e0 03             	shl    $0x3,%eax
+ adb:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ ade:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ ae1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ ae4:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ ae7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ aea:	a3 50 0e 00 00       	mov    %eax,0xe50
+      return (void*)(p + 1);
+ aef:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ af2:	83 c0 08             	add    $0x8,%eax
+ af5:	eb 3b                	jmp    b32 <malloc+0xe5>
+    }
+    if(p == freep)
+ af7:	a1 50 0e 00 00       	mov    0xe50,%eax
+ afc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ aff:	75 1e                	jne    b1f <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ b01:	83 ec 0c             	sub    $0xc,%esp
+ b04:	ff 75 ec             	pushl  -0x14(%ebp)
+ b07:	e8 dd fe ff ff       	call   9e9 <morecore>
+ b0c:	83 c4 10             	add    $0x10,%esp
+ b0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ b12:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ b16:	75 07                	jne    b1f <malloc+0xd2>
+        return 0;
+ b18:	b8 00 00 00 00       	mov    $0x0,%eax
+ b1d:	eb 13                	jmp    b32 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b22:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ b25:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b28:	8b 00                	mov    (%eax),%eax
+ b2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ b2d:	e9 6d ff ff ff       	jmp    a9f <malloc+0x52>
+  }
+}
+ b32:	c9                   	leave  
+ b33:	c3                   	ret    
diff -ruN xv6-public/xv6-public/ls.c xv6-public_new/xv6-public/ls.c
--- xv6-public/xv6-public/ls.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ls.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,85 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+
+char*
+fmtname(char *path)
+{
+  static char buf[DIRSIZ+1];
+  char *p;
+
+  // Find first character after last slash.
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+    ;
+  p++;
+
+  // Return blank-padded name.
+  if(strlen(p) >= DIRSIZ)
+    return p;
+  memmove(buf, p, strlen(p));
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+  return buf;
+}
+
+void
+ls(char *path)
+{
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+
+  if((fd = open(path, 0)) < 0){
+    printf(2, "ls: cannot open %s\n", path);
+    return;
+  }
+
+  if(fstat(fd, &st) < 0){
+    printf(2, "ls: cannot stat %s\n", path);
+    close(fd);
+    return;
+  }
+
+  switch(st.type){
+  case T_FILE:
+    printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+    break;
+
+  case T_DIR:
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+      printf(1, "ls: path too long\n");
+      break;
+    }
+    strcpy(buf, path);
+    p = buf+strlen(buf);
+    *p++ = '/';
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+      if(de.inum == 0)
+        continue;
+      memmove(p, de.name, DIRSIZ);
+      p[DIRSIZ] = 0;
+      if(stat(buf, &st) < 0){
+        printf(1, "ls: cannot stat %s\n", buf);
+        continue;
+      }
+      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+    }
+    break;
+  }
+  close(fd);
+}
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+
+  if(argc < 2){
+    ls(".");
+    exit();
+  }
+  for(i=1; i<argc; i++)
+    ls(argv[i]);
+  exit();
+}
diff -ruN xv6-public/xv6-public/ls.d xv6-public_new/xv6-public/ls.d
--- xv6-public/xv6-public/ls.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ls.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+ls.o: ls.c /usr/include/stdc-predef.h types.h stat.h user.h fs.h
Binary files xv6-public/xv6-public/ls.o and xv6-public_new/xv6-public/ls.o differ
diff -ruN xv6-public/xv6-public/ls.sym xv6-public_new/xv6-public/ls.sym
--- xv6-public/xv6-public/ls.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ls.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,68 @@
+00000000 .text
+00000b34 .rodata
+00000b88 .eh_frame
+00000e24 .data
+00000e38 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 ls.c
+00000e38 buf.1109
+00000000 ulib.c
+0000034e stosb
+00000000 printf.c
+00000691 putc
+000006b8 printint
+00000e24 digits.1098
+00000000 umalloc.c
+00000e48 base
+00000e50 freep
+000009e9 morecore
+00000374 strcpy
+00000679 yield
+00000000 fmtname
+00000689 set_prio
+0000076d printf
+00000580 memmove
+00000611 mknod
+0000046b gets
+00000649 getpid
+00000a4d malloc
+00000659 sleep
+00000681 wait2
+000005d9 pipe
+000005e9 write
+00000621 fstat
+000005f9 kill
+00000639 chdir
+00000601 exec
+000005d1 wait
+000005e1 read
+00000619 unlink
+000005c1 fork
+00000651 sbrk
+00000661 uptime
+00000e35 __bss_start
+00000416 memset
+000002e6 main
+000003a8 strcmp
+00000641 dup
+000004de stat
+00000e35 _edata
+00000e54 _end
+00000629 link
+000000ba ls
+000005c9 exit
+0000052f atoi
+00000669 draw
+000003eb strlen
+00000609 open
+00000434 strchr
+00000671 cps
+00000631 mkdir
+000005f1 close
+00000903 free
diff -ruN xv6-public/xv6-public/main.c xv6-public_new/xv6-public/main.c
--- xv6-public/xv6-public/main.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/main.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,116 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+
+static void startothers(void);
+static void mpmain(void)  __attribute__((noreturn));
+extern pde_t *kpgdir;
+extern char end[]; // first address after kernel loaded from ELF file
+
+// Bootstrap processor starts running C code here.
+// Allocate a real stack and switch to it, first
+// doing some setup required for memory allocator to work.
+int
+main(void)
+{
+  kinit1(end, P2V(4*1024*1024)); // phys page allocator
+  kvmalloc();      // kernel page table
+  mpinit();        // detect other processors
+  lapicinit();     // interrupt controller
+  seginit();       // segment descriptors
+  picinit();       // disable pic
+  ioapicinit();    // another interrupt controller
+  consoleinit();   // console hardware
+  uartinit();      // serial port
+  pinit();         // process table
+  tvinit();        // trap vectors
+  binit();         // buffer cache
+  fileinit();      // file table
+  ideinit();       // disk 
+  startothers();   // start other processors
+  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+  userinit();      // first user process
+  mpmain();        // finish this processor's setup
+}
+
+// Other CPUs jump here from entryother.S.
+static void
+mpenter(void)
+{
+  switchkvm();
+  seginit();
+  lapicinit();
+  mpmain();
+}
+
+// Common CPU setup code.
+static void
+mpmain(void)
+{
+  cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
+  idtinit();       // load idt register
+  xchg(&(mycpu()->started), 1); // tell startothers() we're up
+  scheduler();     // start running processes
+}
+
+pde_t entrypgdir[];  // For entry.S
+
+// Start the non-boot (AP) processors.
+static void
+startothers(void)
+{
+  extern uchar _binary_entryother_start[], _binary_entryother_size[];
+  uchar *code;
+  struct cpu *c;
+  char *stack;
+
+  // Write entry code to unused memory at 0x7000.
+  // The linker has placed the image of entryother.S in
+  // _binary_entryother_start.
+  code = P2V(0x7000);
+  memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+
+  for(c = cpus; c < cpus+ncpu; c++){
+    if(c == mycpu())  // We've started already.
+      continue;
+
+    // Tell entryother.S what stack to use, where to enter, and what
+    // pgdir to use. We cannot use kpgdir yet, because the AP processor
+    // is running in low  memory, so we use entrypgdir for the APs too.
+    stack = kalloc();
+    *(void**)(code-4) = stack + KSTACKSIZE;
+    *(void(**)(void))(code-8) = mpenter;
+    *(int**)(code-12) = (void *) V2P(entrypgdir);
+
+    lapicstartap(c->apicid, V2P(code));
+
+    // wait for cpu to finish mpmain()
+    while(c->started == 0)
+      ;
+  }
+}
+
+// The boot page table used in entry.S and entryother.S.
+// Page directories (and page tables) must start on page boundaries,
+// hence the __aligned__ attribute.
+// PTE_PS in a page directory entry enables 4Mbyte pages.
+
+__attribute__((__aligned__(PGSIZE)))
+pde_t entrypgdir[NPDENTRIES] = {
+  // Map VA's [0, 4MB) to PA's [0, 4MB)
+  [0] = (0) | PTE_P | PTE_W | PTE_PS,
+  // Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
+  [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
+};
+
+//PAGEBREAK!
+// Blank page.
+//PAGEBREAK!
+// Blank page.
+//PAGEBREAK!
+// Blank page.
+
diff -ruN xv6-public/xv6-public/main.d xv6-public_new/xv6-public/main.d
--- xv6-public/xv6-public/main.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/main.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+main.o: main.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h
Binary files xv6-public/xv6-public/main.o and xv6-public_new/xv6-public/main.o differ
diff -ruN xv6-public/xv6-public/memide.c xv6-public_new/xv6-public/memide.c
--- xv6-public/xv6-public/memide.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/memide.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,60 @@
+// Fake IDE disk; stores blocks in memory.
+// Useful for running kernel without scratch disk.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+#include "traps.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "buf.h"
+
+extern uchar _binary_fs_img_start[], _binary_fs_img_size[];
+
+static int disksize;
+static uchar *memdisk;
+
+void
+ideinit(void)
+{
+  memdisk = _binary_fs_img_start;
+  disksize = (uint)_binary_fs_img_size/BSIZE;
+}
+
+// Interrupt handler.
+void
+ideintr(void)
+{
+  // no-op
+}
+
+// Sync buf with disk.
+// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+// Else if B_VALID is not set, read buf from disk, set B_VALID.
+void
+iderw(struct buf *b)
+{
+  uchar *p;
+
+  if(!holdingsleep(&b->lock))
+    panic("iderw: buf not locked");
+  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+    panic("iderw: nothing to do");
+  if(b->dev != 1)
+    panic("iderw: request not for disk 1");
+  if(b->blockno >= disksize)
+    panic("iderw: block out of range");
+
+  p = memdisk + b->blockno*BSIZE;
+
+  if(b->flags & B_DIRTY){
+    b->flags &= ~B_DIRTY;
+    memmove(p, b->data, BSIZE);
+  } else
+    memmove(b->data, p, BSIZE);
+  b->flags |= B_VALID;
+}
diff -ruN xv6-public/xv6-public/memlayout.h xv6-public_new/xv6-public/memlayout.h
--- xv6-public/xv6-public/memlayout.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/memlayout.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,15 @@
+// Memory layout
+
+#define EXTMEM  0x100000            // Start of extended memory
+#define PHYSTOP 0xE000000           // Top physical memory
+#define DEVSPACE 0xFE000000         // Other devices are at high addresses
+
+// Key addresses for address space layout (see kmap in vm.c for layout)
+#define KERNBASE 0x80000000         // First kernel virtual address
+#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+
+#define V2P(a) (((uint) (a)) - KERNBASE)
+#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
+
+#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
+#define P2V_WO(x) ((x) + KERNBASE)    // same as P2V, but without casts
diff -ruN xv6-public/xv6-public/mkdir.asm xv6-public_new/xv6-public/mkdir.asm
--- xv6-public/xv6-public/mkdir.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mkdir.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1187 @@
+
+_mkdir:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	53                   	push   %ebx
+  12:	51                   	push   %ecx
+  13:	83 ec 10             	sub    $0x10,%esp
+  16:	89 cb                	mov    %ecx,%ebx
+  int i;
+
+  if(argc < 2){
+  18:	83 3b 01             	cmpl   $0x1,(%ebx)
+  1b:	7f 17                	jg     34 <main+0x34>
+    printf(2, "Usage: mkdir files...\n");
+  1d:	83 ec 08             	sub    $0x8,%esp
+  20:	68 7a 08 00 00       	push   $0x87a
+  25:	6a 02                	push   $0x2
+  27:	e8 87 04 00 00       	call   4b3 <printf>
+  2c:	83 c4 10             	add    $0x10,%esp
+    exit();
+  2f:	e8 db 02 00 00       	call   30f <exit>
+  }
+
+  for(i = 1; i < argc; i++){
+  34:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+  3b:	eb 4b                	jmp    88 <main+0x88>
+    if(mkdir(argv[i]) < 0){
+  3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  40:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  47:	8b 43 04             	mov    0x4(%ebx),%eax
+  4a:	01 d0                	add    %edx,%eax
+  4c:	8b 00                	mov    (%eax),%eax
+  4e:	83 ec 0c             	sub    $0xc,%esp
+  51:	50                   	push   %eax
+  52:	e8 20 03 00 00       	call   377 <mkdir>
+  57:	83 c4 10             	add    $0x10,%esp
+  5a:	85 c0                	test   %eax,%eax
+  5c:	79 26                	jns    84 <main+0x84>
+      printf(2, "mkdir: %s failed to create\n", argv[i]);
+  5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  61:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  68:	8b 43 04             	mov    0x4(%ebx),%eax
+  6b:	01 d0                	add    %edx,%eax
+  6d:	8b 00                	mov    (%eax),%eax
+  6f:	83 ec 04             	sub    $0x4,%esp
+  72:	50                   	push   %eax
+  73:	68 91 08 00 00       	push   $0x891
+  78:	6a 02                	push   $0x2
+  7a:	e8 34 04 00 00       	call   4b3 <printf>
+  7f:	83 c4 10             	add    $0x10,%esp
+      break;
+  82:	eb 0b                	jmp    8f <main+0x8f>
+  for(i = 1; i < argc; i++){
+  84:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  88:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8b:	3b 03                	cmp    (%ebx),%eax
+  8d:	7c ae                	jl     3d <main+0x3d>
+    }
+  }
+
+  exit();
+  8f:	e8 7b 02 00 00       	call   30f <exit>
+
+00000094 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  94:	55                   	push   %ebp
+  95:	89 e5                	mov    %esp,%ebp
+  97:	57                   	push   %edi
+  98:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  99:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  9c:	8b 55 10             	mov    0x10(%ebp),%edx
+  9f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  a2:	89 cb                	mov    %ecx,%ebx
+  a4:	89 df                	mov    %ebx,%edi
+  a6:	89 d1                	mov    %edx,%ecx
+  a8:	fc                   	cld    
+  a9:	f3 aa                	rep stos %al,%es:(%edi)
+  ab:	89 ca                	mov    %ecx,%edx
+  ad:	89 fb                	mov    %edi,%ebx
+  af:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  b2:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  b5:	90                   	nop
+  b6:	5b                   	pop    %ebx
+  b7:	5f                   	pop    %edi
+  b8:	5d                   	pop    %ebp
+  b9:	c3                   	ret    
+
+000000ba <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  ba:	f3 0f 1e fb          	endbr32 
+  be:	55                   	push   %ebp
+  bf:	89 e5                	mov    %esp,%ebp
+  c1:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  ca:	90                   	nop
+  cb:	8b 55 0c             	mov    0xc(%ebp),%edx
+  ce:	8d 42 01             	lea    0x1(%edx),%eax
+  d1:	89 45 0c             	mov    %eax,0xc(%ebp)
+  d4:	8b 45 08             	mov    0x8(%ebp),%eax
+  d7:	8d 48 01             	lea    0x1(%eax),%ecx
+  da:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  dd:	0f b6 12             	movzbl (%edx),%edx
+  e0:	88 10                	mov    %dl,(%eax)
+  e2:	0f b6 00             	movzbl (%eax),%eax
+  e5:	84 c0                	test   %al,%al
+  e7:	75 e2                	jne    cb <strcpy+0x11>
+    ;
+  return os;
+  e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  ec:	c9                   	leave  
+  ed:	c3                   	ret    
+
+000000ee <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  ee:	f3 0f 1e fb          	endbr32 
+  f2:	55                   	push   %ebp
+  f3:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  f5:	eb 08                	jmp    ff <strcmp+0x11>
+    p++, q++;
+  f7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  fb:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+  ff:	8b 45 08             	mov    0x8(%ebp),%eax
+ 102:	0f b6 00             	movzbl (%eax),%eax
+ 105:	84 c0                	test   %al,%al
+ 107:	74 10                	je     119 <strcmp+0x2b>
+ 109:	8b 45 08             	mov    0x8(%ebp),%eax
+ 10c:	0f b6 10             	movzbl (%eax),%edx
+ 10f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 112:	0f b6 00             	movzbl (%eax),%eax
+ 115:	38 c2                	cmp    %al,%dl
+ 117:	74 de                	je     f7 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 119:	8b 45 08             	mov    0x8(%ebp),%eax
+ 11c:	0f b6 00             	movzbl (%eax),%eax
+ 11f:	0f b6 d0             	movzbl %al,%edx
+ 122:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 125:	0f b6 00             	movzbl (%eax),%eax
+ 128:	0f b6 c0             	movzbl %al,%eax
+ 12b:	29 c2                	sub    %eax,%edx
+ 12d:	89 d0                	mov    %edx,%eax
+}
+ 12f:	5d                   	pop    %ebp
+ 130:	c3                   	ret    
+
+00000131 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 131:	f3 0f 1e fb          	endbr32 
+ 135:	55                   	push   %ebp
+ 136:	89 e5                	mov    %esp,%ebp
+ 138:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 13b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 142:	eb 04                	jmp    148 <strlen+0x17>
+ 144:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 148:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 14b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 14e:	01 d0                	add    %edx,%eax
+ 150:	0f b6 00             	movzbl (%eax),%eax
+ 153:	84 c0                	test   %al,%al
+ 155:	75 ed                	jne    144 <strlen+0x13>
+    ;
+  return n;
+ 157:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 15a:	c9                   	leave  
+ 15b:	c3                   	ret    
+
+0000015c <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 15c:	f3 0f 1e fb          	endbr32 
+ 160:	55                   	push   %ebp
+ 161:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 163:	8b 45 10             	mov    0x10(%ebp),%eax
+ 166:	50                   	push   %eax
+ 167:	ff 75 0c             	pushl  0xc(%ebp)
+ 16a:	ff 75 08             	pushl  0x8(%ebp)
+ 16d:	e8 22 ff ff ff       	call   94 <stosb>
+ 172:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 175:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 178:	c9                   	leave  
+ 179:	c3                   	ret    
+
+0000017a <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 17a:	f3 0f 1e fb          	endbr32 
+ 17e:	55                   	push   %ebp
+ 17f:	89 e5                	mov    %esp,%ebp
+ 181:	83 ec 04             	sub    $0x4,%esp
+ 184:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 187:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 18a:	eb 14                	jmp    1a0 <strchr+0x26>
+    if(*s == c)
+ 18c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 18f:	0f b6 00             	movzbl (%eax),%eax
+ 192:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 195:	75 05                	jne    19c <strchr+0x22>
+      return (char*)s;
+ 197:	8b 45 08             	mov    0x8(%ebp),%eax
+ 19a:	eb 13                	jmp    1af <strchr+0x35>
+  for(; *s; s++)
+ 19c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 1a0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1a3:	0f b6 00             	movzbl (%eax),%eax
+ 1a6:	84 c0                	test   %al,%al
+ 1a8:	75 e2                	jne    18c <strchr+0x12>
+  return 0;
+ 1aa:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 1af:	c9                   	leave  
+ 1b0:	c3                   	ret    
+
+000001b1 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1b1:	f3 0f 1e fb          	endbr32 
+ 1b5:	55                   	push   %ebp
+ 1b6:	89 e5                	mov    %esp,%ebp
+ 1b8:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1c2:	eb 42                	jmp    206 <gets+0x55>
+    cc = read(0, &c, 1);
+ 1c4:	83 ec 04             	sub    $0x4,%esp
+ 1c7:	6a 01                	push   $0x1
+ 1c9:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1cc:	50                   	push   %eax
+ 1cd:	6a 00                	push   $0x0
+ 1cf:	e8 53 01 00 00       	call   327 <read>
+ 1d4:	83 c4 10             	add    $0x10,%esp
+ 1d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1de:	7e 33                	jle    213 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1e3:	8d 50 01             	lea    0x1(%eax),%edx
+ 1e6:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 1e9:	89 c2                	mov    %eax,%edx
+ 1eb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ee:	01 c2                	add    %eax,%edx
+ 1f0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1f4:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 1f6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1fa:	3c 0a                	cmp    $0xa,%al
+ 1fc:	74 16                	je     214 <gets+0x63>
+ 1fe:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 202:	3c 0d                	cmp    $0xd,%al
+ 204:	74 0e                	je     214 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 206:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 209:	83 c0 01             	add    $0x1,%eax
+ 20c:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 20f:	7f b3                	jg     1c4 <gets+0x13>
+ 211:	eb 01                	jmp    214 <gets+0x63>
+      break;
+ 213:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 214:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 217:	8b 45 08             	mov    0x8(%ebp),%eax
+ 21a:	01 d0                	add    %edx,%eax
+ 21c:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 21f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 222:	c9                   	leave  
+ 223:	c3                   	ret    
+
+00000224 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 224:	f3 0f 1e fb          	endbr32 
+ 228:	55                   	push   %ebp
+ 229:	89 e5                	mov    %esp,%ebp
+ 22b:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 22e:	83 ec 08             	sub    $0x8,%esp
+ 231:	6a 00                	push   $0x0
+ 233:	ff 75 08             	pushl  0x8(%ebp)
+ 236:	e8 14 01 00 00       	call   34f <open>
+ 23b:	83 c4 10             	add    $0x10,%esp
+ 23e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 241:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 245:	79 07                	jns    24e <stat+0x2a>
+    return -1;
+ 247:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 24c:	eb 25                	jmp    273 <stat+0x4f>
+  r = fstat(fd, st);
+ 24e:	83 ec 08             	sub    $0x8,%esp
+ 251:	ff 75 0c             	pushl  0xc(%ebp)
+ 254:	ff 75 f4             	pushl  -0xc(%ebp)
+ 257:	e8 0b 01 00 00       	call   367 <fstat>
+ 25c:	83 c4 10             	add    $0x10,%esp
+ 25f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 262:	83 ec 0c             	sub    $0xc,%esp
+ 265:	ff 75 f4             	pushl  -0xc(%ebp)
+ 268:	e8 ca 00 00 00       	call   337 <close>
+ 26d:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 270:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 273:	c9                   	leave  
+ 274:	c3                   	ret    
+
+00000275 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 275:	f3 0f 1e fb          	endbr32 
+ 279:	55                   	push   %ebp
+ 27a:	89 e5                	mov    %esp,%ebp
+ 27c:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 27f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 286:	eb 25                	jmp    2ad <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 288:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 28b:	89 d0                	mov    %edx,%eax
+ 28d:	c1 e0 02             	shl    $0x2,%eax
+ 290:	01 d0                	add    %edx,%eax
+ 292:	01 c0                	add    %eax,%eax
+ 294:	89 c1                	mov    %eax,%ecx
+ 296:	8b 45 08             	mov    0x8(%ebp),%eax
+ 299:	8d 50 01             	lea    0x1(%eax),%edx
+ 29c:	89 55 08             	mov    %edx,0x8(%ebp)
+ 29f:	0f b6 00             	movzbl (%eax),%eax
+ 2a2:	0f be c0             	movsbl %al,%eax
+ 2a5:	01 c8                	add    %ecx,%eax
+ 2a7:	83 e8 30             	sub    $0x30,%eax
+ 2aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 2ad:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b0:	0f b6 00             	movzbl (%eax),%eax
+ 2b3:	3c 2f                	cmp    $0x2f,%al
+ 2b5:	7e 0a                	jle    2c1 <atoi+0x4c>
+ 2b7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2ba:	0f b6 00             	movzbl (%eax),%eax
+ 2bd:	3c 39                	cmp    $0x39,%al
+ 2bf:	7e c7                	jle    288 <atoi+0x13>
+  return n;
+ 2c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 2c4:	c9                   	leave  
+ 2c5:	c3                   	ret    
+
+000002c6 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2c6:	f3 0f 1e fb          	endbr32 
+ 2ca:	55                   	push   %ebp
+ 2cb:	89 e5                	mov    %esp,%ebp
+ 2cd:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 2d0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2dc:	eb 17                	jmp    2f5 <memmove+0x2f>
+    *dst++ = *src++;
+ 2de:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 2e1:	8d 42 01             	lea    0x1(%edx),%eax
+ 2e4:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 2e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2ea:	8d 48 01             	lea    0x1(%eax),%ecx
+ 2ed:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 2f0:	0f b6 12             	movzbl (%edx),%edx
+ 2f3:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 2f5:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2f8:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 2fb:	89 55 10             	mov    %edx,0x10(%ebp)
+ 2fe:	85 c0                	test   %eax,%eax
+ 300:	7f dc                	jg     2de <memmove+0x18>
+  return vdst;
+ 302:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 305:	c9                   	leave  
+ 306:	c3                   	ret    
+
+00000307 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 307:	b8 01 00 00 00       	mov    $0x1,%eax
+ 30c:	cd 40                	int    $0x40
+ 30e:	c3                   	ret    
+
+0000030f <exit>:
+SYSCALL(exit)
+ 30f:	b8 02 00 00 00       	mov    $0x2,%eax
+ 314:	cd 40                	int    $0x40
+ 316:	c3                   	ret    
+
+00000317 <wait>:
+SYSCALL(wait)
+ 317:	b8 03 00 00 00       	mov    $0x3,%eax
+ 31c:	cd 40                	int    $0x40
+ 31e:	c3                   	ret    
+
+0000031f <pipe>:
+SYSCALL(pipe)
+ 31f:	b8 04 00 00 00       	mov    $0x4,%eax
+ 324:	cd 40                	int    $0x40
+ 326:	c3                   	ret    
+
+00000327 <read>:
+SYSCALL(read)
+ 327:	b8 05 00 00 00       	mov    $0x5,%eax
+ 32c:	cd 40                	int    $0x40
+ 32e:	c3                   	ret    
+
+0000032f <write>:
+SYSCALL(write)
+ 32f:	b8 10 00 00 00       	mov    $0x10,%eax
+ 334:	cd 40                	int    $0x40
+ 336:	c3                   	ret    
+
+00000337 <close>:
+SYSCALL(close)
+ 337:	b8 15 00 00 00       	mov    $0x15,%eax
+ 33c:	cd 40                	int    $0x40
+ 33e:	c3                   	ret    
+
+0000033f <kill>:
+SYSCALL(kill)
+ 33f:	b8 06 00 00 00       	mov    $0x6,%eax
+ 344:	cd 40                	int    $0x40
+ 346:	c3                   	ret    
+
+00000347 <exec>:
+SYSCALL(exec)
+ 347:	b8 07 00 00 00       	mov    $0x7,%eax
+ 34c:	cd 40                	int    $0x40
+ 34e:	c3                   	ret    
+
+0000034f <open>:
+SYSCALL(open)
+ 34f:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 354:	cd 40                	int    $0x40
+ 356:	c3                   	ret    
+
+00000357 <mknod>:
+SYSCALL(mknod)
+ 357:	b8 11 00 00 00       	mov    $0x11,%eax
+ 35c:	cd 40                	int    $0x40
+ 35e:	c3                   	ret    
+
+0000035f <unlink>:
+SYSCALL(unlink)
+ 35f:	b8 12 00 00 00       	mov    $0x12,%eax
+ 364:	cd 40                	int    $0x40
+ 366:	c3                   	ret    
+
+00000367 <fstat>:
+SYSCALL(fstat)
+ 367:	b8 08 00 00 00       	mov    $0x8,%eax
+ 36c:	cd 40                	int    $0x40
+ 36e:	c3                   	ret    
+
+0000036f <link>:
+SYSCALL(link)
+ 36f:	b8 13 00 00 00       	mov    $0x13,%eax
+ 374:	cd 40                	int    $0x40
+ 376:	c3                   	ret    
+
+00000377 <mkdir>:
+SYSCALL(mkdir)
+ 377:	b8 14 00 00 00       	mov    $0x14,%eax
+ 37c:	cd 40                	int    $0x40
+ 37e:	c3                   	ret    
+
+0000037f <chdir>:
+SYSCALL(chdir)
+ 37f:	b8 09 00 00 00       	mov    $0x9,%eax
+ 384:	cd 40                	int    $0x40
+ 386:	c3                   	ret    
+
+00000387 <dup>:
+SYSCALL(dup)
+ 387:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 38c:	cd 40                	int    $0x40
+ 38e:	c3                   	ret    
+
+0000038f <getpid>:
+SYSCALL(getpid)
+ 38f:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 394:	cd 40                	int    $0x40
+ 396:	c3                   	ret    
+
+00000397 <sbrk>:
+SYSCALL(sbrk)
+ 397:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 39c:	cd 40                	int    $0x40
+ 39e:	c3                   	ret    
+
+0000039f <sleep>:
+SYSCALL(sleep)
+ 39f:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 3a4:	cd 40                	int    $0x40
+ 3a6:	c3                   	ret    
+
+000003a7 <uptime>:
+SYSCALL(uptime)
+ 3a7:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 3ac:	cd 40                	int    $0x40
+ 3ae:	c3                   	ret    
+
+000003af <draw>:
+SYSCALL(draw)
+ 3af:	b8 16 00 00 00       	mov    $0x16,%eax
+ 3b4:	cd 40                	int    $0x40
+ 3b6:	c3                   	ret    
+
+000003b7 <cps>:
+SYSCALL(cps)
+ 3b7:	b8 17 00 00 00       	mov    $0x17,%eax
+ 3bc:	cd 40                	int    $0x40
+ 3be:	c3                   	ret    
+
+000003bf <yield>:
+SYSCALL(yield)
+ 3bf:	b8 18 00 00 00       	mov    $0x18,%eax
+ 3c4:	cd 40                	int    $0x40
+ 3c6:	c3                   	ret    
+
+000003c7 <wait2>:
+SYSCALL(wait2)
+ 3c7:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3cc:	cd 40                	int    $0x40
+ 3ce:	c3                   	ret    
+
+000003cf <set_prio>:
+SYSCALL(set_prio)
+ 3cf:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3d4:	cd 40                	int    $0x40
+ 3d6:	c3                   	ret    
+
+000003d7 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3d7:	f3 0f 1e fb          	endbr32 
+ 3db:	55                   	push   %ebp
+ 3dc:	89 e5                	mov    %esp,%ebp
+ 3de:	83 ec 18             	sub    $0x18,%esp
+ 3e1:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3e4:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3e7:	83 ec 04             	sub    $0x4,%esp
+ 3ea:	6a 01                	push   $0x1
+ 3ec:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3ef:	50                   	push   %eax
+ 3f0:	ff 75 08             	pushl  0x8(%ebp)
+ 3f3:	e8 37 ff ff ff       	call   32f <write>
+ 3f8:	83 c4 10             	add    $0x10,%esp
+}
+ 3fb:	90                   	nop
+ 3fc:	c9                   	leave  
+ 3fd:	c3                   	ret    
+
+000003fe <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3fe:	f3 0f 1e fb          	endbr32 
+ 402:	55                   	push   %ebp
+ 403:	89 e5                	mov    %esp,%ebp
+ 405:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 408:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 40f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 413:	74 17                	je     42c <printint+0x2e>
+ 415:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 419:	79 11                	jns    42c <printint+0x2e>
+    neg = 1;
+ 41b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 422:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 425:	f7 d8                	neg    %eax
+ 427:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 42a:	eb 06                	jmp    432 <printint+0x34>
+  } else {
+    x = xx;
+ 42c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 42f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 432:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 439:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 43c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 43f:	ba 00 00 00 00       	mov    $0x0,%edx
+ 444:	f7 f1                	div    %ecx
+ 446:	89 d1                	mov    %edx,%ecx
+ 448:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 44b:	8d 50 01             	lea    0x1(%eax),%edx
+ 44e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 451:	0f b6 91 fc 0a 00 00 	movzbl 0xafc(%ecx),%edx
+ 458:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 45c:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 45f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 462:	ba 00 00 00 00       	mov    $0x0,%edx
+ 467:	f7 f1                	div    %ecx
+ 469:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 46c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 470:	75 c7                	jne    439 <printint+0x3b>
+  if(neg)
+ 472:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 476:	74 2d                	je     4a5 <printint+0xa7>
+    buf[i++] = '-';
+ 478:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 47b:	8d 50 01             	lea    0x1(%eax),%edx
+ 47e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 481:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 486:	eb 1d                	jmp    4a5 <printint+0xa7>
+    putc(fd, buf[i]);
+ 488:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 48b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 48e:	01 d0                	add    %edx,%eax
+ 490:	0f b6 00             	movzbl (%eax),%eax
+ 493:	0f be c0             	movsbl %al,%eax
+ 496:	83 ec 08             	sub    $0x8,%esp
+ 499:	50                   	push   %eax
+ 49a:	ff 75 08             	pushl  0x8(%ebp)
+ 49d:	e8 35 ff ff ff       	call   3d7 <putc>
+ 4a2:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 4a5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 4a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 4ad:	79 d9                	jns    488 <printint+0x8a>
+}
+ 4af:	90                   	nop
+ 4b0:	90                   	nop
+ 4b1:	c9                   	leave  
+ 4b2:	c3                   	ret    
+
+000004b3 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 4b3:	f3 0f 1e fb          	endbr32 
+ 4b7:	55                   	push   %ebp
+ 4b8:	89 e5                	mov    %esp,%ebp
+ 4ba:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 4bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 4c4:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 4c7:	83 c0 04             	add    $0x4,%eax
+ 4ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 4cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4d4:	e9 59 01 00 00       	jmp    632 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 4d9:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4df:	01 d0                	add    %edx,%eax
+ 4e1:	0f b6 00             	movzbl (%eax),%eax
+ 4e4:	0f be c0             	movsbl %al,%eax
+ 4e7:	25 ff 00 00 00       	and    $0xff,%eax
+ 4ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4f3:	75 2c                	jne    521 <printf+0x6e>
+      if(c == '%'){
+ 4f5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4f9:	75 0c                	jne    507 <printf+0x54>
+        state = '%';
+ 4fb:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 502:	e9 27 01 00 00       	jmp    62e <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 507:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 50a:	0f be c0             	movsbl %al,%eax
+ 50d:	83 ec 08             	sub    $0x8,%esp
+ 510:	50                   	push   %eax
+ 511:	ff 75 08             	pushl  0x8(%ebp)
+ 514:	e8 be fe ff ff       	call   3d7 <putc>
+ 519:	83 c4 10             	add    $0x10,%esp
+ 51c:	e9 0d 01 00 00       	jmp    62e <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 521:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 525:	0f 85 03 01 00 00    	jne    62e <printf+0x17b>
+      if(c == 'd'){
+ 52b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 52f:	75 1e                	jne    54f <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 531:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 534:	8b 00                	mov    (%eax),%eax
+ 536:	6a 01                	push   $0x1
+ 538:	6a 0a                	push   $0xa
+ 53a:	50                   	push   %eax
+ 53b:	ff 75 08             	pushl  0x8(%ebp)
+ 53e:	e8 bb fe ff ff       	call   3fe <printint>
+ 543:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 546:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 54a:	e9 d8 00 00 00       	jmp    627 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 54f:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 553:	74 06                	je     55b <printf+0xa8>
+ 555:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 559:	75 1e                	jne    579 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 55b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 55e:	8b 00                	mov    (%eax),%eax
+ 560:	6a 00                	push   $0x0
+ 562:	6a 10                	push   $0x10
+ 564:	50                   	push   %eax
+ 565:	ff 75 08             	pushl  0x8(%ebp)
+ 568:	e8 91 fe ff ff       	call   3fe <printint>
+ 56d:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 570:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 574:	e9 ae 00 00 00       	jmp    627 <printf+0x174>
+      } else if(c == 's'){
+ 579:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 57d:	75 43                	jne    5c2 <printf+0x10f>
+        s = (char*)*ap;
+ 57f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 582:	8b 00                	mov    (%eax),%eax
+ 584:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 587:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 58b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 58f:	75 25                	jne    5b6 <printf+0x103>
+          s = "(null)";
+ 591:	c7 45 f4 ad 08 00 00 	movl   $0x8ad,-0xc(%ebp)
+        while(*s != 0){
+ 598:	eb 1c                	jmp    5b6 <printf+0x103>
+          putc(fd, *s);
+ 59a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 59d:	0f b6 00             	movzbl (%eax),%eax
+ 5a0:	0f be c0             	movsbl %al,%eax
+ 5a3:	83 ec 08             	sub    $0x8,%esp
+ 5a6:	50                   	push   %eax
+ 5a7:	ff 75 08             	pushl  0x8(%ebp)
+ 5aa:	e8 28 fe ff ff       	call   3d7 <putc>
+ 5af:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 5b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 5b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5b9:	0f b6 00             	movzbl (%eax),%eax
+ 5bc:	84 c0                	test   %al,%al
+ 5be:	75 da                	jne    59a <printf+0xe7>
+ 5c0:	eb 65                	jmp    627 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 5c2:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5c6:	75 1d                	jne    5e5 <printf+0x132>
+        putc(fd, *ap);
+ 5c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5cb:	8b 00                	mov    (%eax),%eax
+ 5cd:	0f be c0             	movsbl %al,%eax
+ 5d0:	83 ec 08             	sub    $0x8,%esp
+ 5d3:	50                   	push   %eax
+ 5d4:	ff 75 08             	pushl  0x8(%ebp)
+ 5d7:	e8 fb fd ff ff       	call   3d7 <putc>
+ 5dc:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5df:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5e3:	eb 42                	jmp    627 <printf+0x174>
+      } else if(c == '%'){
+ 5e5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5e9:	75 17                	jne    602 <printf+0x14f>
+        putc(fd, c);
+ 5eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5ee:	0f be c0             	movsbl %al,%eax
+ 5f1:	83 ec 08             	sub    $0x8,%esp
+ 5f4:	50                   	push   %eax
+ 5f5:	ff 75 08             	pushl  0x8(%ebp)
+ 5f8:	e8 da fd ff ff       	call   3d7 <putc>
+ 5fd:	83 c4 10             	add    $0x10,%esp
+ 600:	eb 25                	jmp    627 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 602:	83 ec 08             	sub    $0x8,%esp
+ 605:	6a 25                	push   $0x25
+ 607:	ff 75 08             	pushl  0x8(%ebp)
+ 60a:	e8 c8 fd ff ff       	call   3d7 <putc>
+ 60f:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 612:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 615:	0f be c0             	movsbl %al,%eax
+ 618:	83 ec 08             	sub    $0x8,%esp
+ 61b:	50                   	push   %eax
+ 61c:	ff 75 08             	pushl  0x8(%ebp)
+ 61f:	e8 b3 fd ff ff       	call   3d7 <putc>
+ 624:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 627:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 62e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 632:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 635:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 638:	01 d0                	add    %edx,%eax
+ 63a:	0f b6 00             	movzbl (%eax),%eax
+ 63d:	84 c0                	test   %al,%al
+ 63f:	0f 85 94 fe ff ff    	jne    4d9 <printf+0x26>
+    }
+  }
+}
+ 645:	90                   	nop
+ 646:	90                   	nop
+ 647:	c9                   	leave  
+ 648:	c3                   	ret    
+
+00000649 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 649:	f3 0f 1e fb          	endbr32 
+ 64d:	55                   	push   %ebp
+ 64e:	89 e5                	mov    %esp,%ebp
+ 650:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 653:	8b 45 08             	mov    0x8(%ebp),%eax
+ 656:	83 e8 08             	sub    $0x8,%eax
+ 659:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 65c:	a1 18 0b 00 00       	mov    0xb18,%eax
+ 661:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 664:	eb 24                	jmp    68a <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 666:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 669:	8b 00                	mov    (%eax),%eax
+ 66b:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 66e:	72 12                	jb     682 <free+0x39>
+ 670:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 673:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 676:	77 24                	ja     69c <free+0x53>
+ 678:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 67b:	8b 00                	mov    (%eax),%eax
+ 67d:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 680:	72 1a                	jb     69c <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 682:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 685:	8b 00                	mov    (%eax),%eax
+ 687:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 68a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 68d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 690:	76 d4                	jbe    666 <free+0x1d>
+ 692:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 695:	8b 00                	mov    (%eax),%eax
+ 697:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 69a:	73 ca                	jae    666 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 69c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69f:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ac:	01 c2                	add    %eax,%edx
+ 6ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b1:	8b 00                	mov    (%eax),%eax
+ 6b3:	39 c2                	cmp    %eax,%edx
+ 6b5:	75 24                	jne    6db <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 6b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ba:	8b 50 04             	mov    0x4(%eax),%edx
+ 6bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c0:	8b 00                	mov    (%eax),%eax
+ 6c2:	8b 40 04             	mov    0x4(%eax),%eax
+ 6c5:	01 c2                	add    %eax,%edx
+ 6c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ca:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d0:	8b 00                	mov    (%eax),%eax
+ 6d2:	8b 10                	mov    (%eax),%edx
+ 6d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6d7:	89 10                	mov    %edx,(%eax)
+ 6d9:	eb 0a                	jmp    6e5 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6db:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6de:	8b 10                	mov    (%eax),%edx
+ 6e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e3:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e8:	8b 40 04             	mov    0x4(%eax),%eax
+ 6eb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f5:	01 d0                	add    %edx,%eax
+ 6f7:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6fa:	75 20                	jne    71c <free+0xd3>
+    p->s.size += bp->s.size;
+ 6fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ff:	8b 50 04             	mov    0x4(%eax),%edx
+ 702:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 705:	8b 40 04             	mov    0x4(%eax),%eax
+ 708:	01 c2                	add    %eax,%edx
+ 70a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 70d:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 710:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 713:	8b 10                	mov    (%eax),%edx
+ 715:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 718:	89 10                	mov    %edx,(%eax)
+ 71a:	eb 08                	jmp    724 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 71c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 71f:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 722:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 724:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 727:	a3 18 0b 00 00       	mov    %eax,0xb18
+}
+ 72c:	90                   	nop
+ 72d:	c9                   	leave  
+ 72e:	c3                   	ret    
+
+0000072f <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 72f:	f3 0f 1e fb          	endbr32 
+ 733:	55                   	push   %ebp
+ 734:	89 e5                	mov    %esp,%ebp
+ 736:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 739:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 740:	77 07                	ja     749 <morecore+0x1a>
+    nu = 4096;
+ 742:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 749:	8b 45 08             	mov    0x8(%ebp),%eax
+ 74c:	c1 e0 03             	shl    $0x3,%eax
+ 74f:	83 ec 0c             	sub    $0xc,%esp
+ 752:	50                   	push   %eax
+ 753:	e8 3f fc ff ff       	call   397 <sbrk>
+ 758:	83 c4 10             	add    $0x10,%esp
+ 75b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 75e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 762:	75 07                	jne    76b <morecore+0x3c>
+    return 0;
+ 764:	b8 00 00 00 00       	mov    $0x0,%eax
+ 769:	eb 26                	jmp    791 <morecore+0x62>
+  hp = (Header*)p;
+ 76b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 76e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 771:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 774:	8b 55 08             	mov    0x8(%ebp),%edx
+ 777:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 77a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 77d:	83 c0 08             	add    $0x8,%eax
+ 780:	83 ec 0c             	sub    $0xc,%esp
+ 783:	50                   	push   %eax
+ 784:	e8 c0 fe ff ff       	call   649 <free>
+ 789:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 78c:	a1 18 0b 00 00       	mov    0xb18,%eax
+}
+ 791:	c9                   	leave  
+ 792:	c3                   	ret    
+
+00000793 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 793:	f3 0f 1e fb          	endbr32 
+ 797:	55                   	push   %ebp
+ 798:	89 e5                	mov    %esp,%ebp
+ 79a:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 79d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7a0:	83 c0 07             	add    $0x7,%eax
+ 7a3:	c1 e8 03             	shr    $0x3,%eax
+ 7a6:	83 c0 01             	add    $0x1,%eax
+ 7a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 7ac:	a1 18 0b 00 00       	mov    0xb18,%eax
+ 7b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 7b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 7b8:	75 23                	jne    7dd <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 7ba:	c7 45 f0 10 0b 00 00 	movl   $0xb10,-0x10(%ebp)
+ 7c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7c4:	a3 18 0b 00 00       	mov    %eax,0xb18
+ 7c9:	a1 18 0b 00 00       	mov    0xb18,%eax
+ 7ce:	a3 10 0b 00 00       	mov    %eax,0xb10
+    base.s.size = 0;
+ 7d3:	c7 05 14 0b 00 00 00 	movl   $0x0,0xb14
+ 7da:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7e0:	8b 00                	mov    (%eax),%eax
+ 7e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e8:	8b 40 04             	mov    0x4(%eax),%eax
+ 7eb:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7ee:	77 4d                	ja     83d <malloc+0xaa>
+      if(p->s.size == nunits)
+ 7f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f3:	8b 40 04             	mov    0x4(%eax),%eax
+ 7f6:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7f9:	75 0c                	jne    807 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 7fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7fe:	8b 10                	mov    (%eax),%edx
+ 800:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 803:	89 10                	mov    %edx,(%eax)
+ 805:	eb 26                	jmp    82d <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 807:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80a:	8b 40 04             	mov    0x4(%eax),%eax
+ 80d:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 810:	89 c2                	mov    %eax,%edx
+ 812:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 815:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 818:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 81b:	8b 40 04             	mov    0x4(%eax),%eax
+ 81e:	c1 e0 03             	shl    $0x3,%eax
+ 821:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 824:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 827:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 82a:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 82d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 830:	a3 18 0b 00 00       	mov    %eax,0xb18
+      return (void*)(p + 1);
+ 835:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 838:	83 c0 08             	add    $0x8,%eax
+ 83b:	eb 3b                	jmp    878 <malloc+0xe5>
+    }
+    if(p == freep)
+ 83d:	a1 18 0b 00 00       	mov    0xb18,%eax
+ 842:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 845:	75 1e                	jne    865 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 847:	83 ec 0c             	sub    $0xc,%esp
+ 84a:	ff 75 ec             	pushl  -0x14(%ebp)
+ 84d:	e8 dd fe ff ff       	call   72f <morecore>
+ 852:	83 c4 10             	add    $0x10,%esp
+ 855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 858:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 85c:	75 07                	jne    865 <malloc+0xd2>
+        return 0;
+ 85e:	b8 00 00 00 00       	mov    $0x0,%eax
+ 863:	eb 13                	jmp    878 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 865:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 868:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 86b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 86e:	8b 00                	mov    (%eax),%eax
+ 870:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 873:	e9 6d ff ff ff       	jmp    7e5 <malloc+0x52>
+  }
+}
+ 878:	c9                   	leave  
+ 879:	c3                   	ret    
diff -ruN xv6-public/xv6-public/mkdir.c xv6-public_new/xv6-public/mkdir.c
--- xv6-public/xv6-public/mkdir.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mkdir.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,23 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+
+  if(argc < 2){
+    printf(2, "Usage: mkdir files...\n");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if(mkdir(argv[i]) < 0){
+      printf(2, "mkdir: %s failed to create\n", argv[i]);
+      break;
+    }
+  }
+
+  exit();
+}
diff -ruN xv6-public/xv6-public/mkdir.d xv6-public_new/xv6-public/mkdir.d
--- xv6-public/xv6-public/mkdir.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mkdir.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+mkdir.o: mkdir.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/mkdir.o and xv6-public_new/xv6-public/mkdir.o differ
diff -ruN xv6-public/xv6-public/mkdir.sym xv6-public_new/xv6-public/mkdir.sym
--- xv6-public/xv6-public/mkdir.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mkdir.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+0000087a .rodata
+000008b4 .eh_frame
+00000afc .data
+00000b10 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 mkdir.c
+00000000 ulib.c
+00000094 stosb
+00000000 printf.c
+000003d7 putc
+000003fe printint
+00000afc digits.1098
+00000000 umalloc.c
+00000b10 base
+00000b18 freep
+0000072f morecore
+000000ba strcpy
+000003bf yield
+000003cf set_prio
+000004b3 printf
+000002c6 memmove
+00000357 mknod
+000001b1 gets
+0000038f getpid
+00000793 malloc
+0000039f sleep
+000003c7 wait2
+0000031f pipe
+0000032f write
+00000367 fstat
+0000033f kill
+0000037f chdir
+00000347 exec
+00000317 wait
+00000327 read
+0000035f unlink
+00000307 fork
+00000397 sbrk
+000003a7 uptime
+00000b0d __bss_start
+0000015c memset
+00000000 main
+000000ee strcmp
+00000387 dup
+00000224 stat
+00000b0d _edata
+00000b1c _end
+0000036f link
+0000030f exit
+00000275 atoi
+000003af draw
+00000131 strlen
+0000034f open
+0000017a strchr
+000003b7 cps
+00000377 mkdir
+00000337 close
+00000649 free
Binary files xv6-public/xv6-public/mkfs and xv6-public_new/xv6-public/mkfs differ
diff -ruN xv6-public/xv6-public/mkfs.c xv6-public_new/xv6-public/mkfs.c
--- xv6-public/xv6-public/mkfs.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mkfs.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,297 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <assert.h>
+
+#define stat xv6_stat  // avoid clash with host struct stat
+#include "types.h"
+#include "fs.h"
+#include "stat.h"
+#include "param.h"
+
+#ifndef static_assert
+#define static_assert(a, b) do { switch (0) case 0: case (a): ; } while (0)
+#endif
+
+#define NINODES 200
+
+// Disk layout:
+// [ boot block | sb block | log | inode blocks | free bit map | data blocks ]
+
+int nbitmap = FSSIZE/(BSIZE*8) + 1;
+int ninodeblocks = NINODES / IPB + 1;
+int nlog = LOGSIZE;
+int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
+int nblocks;  // Number of data blocks
+
+int fsfd;
+struct superblock sb;
+char zeroes[BSIZE];
+uint freeinode = 1;
+uint freeblock;
+
+
+void balloc(int);
+void wsect(uint, void*);
+void winode(uint, struct dinode*);
+void rinode(uint inum, struct dinode *ip);
+void rsect(uint sec, void *buf);
+uint ialloc(ushort type);
+void iappend(uint inum, void *p, int n);
+
+// convert to intel byte order
+ushort
+xshort(ushort x)
+{
+  ushort y;
+  uchar *a = (uchar*)&y;
+  a[0] = x;
+  a[1] = x >> 8;
+  return y;
+}
+
+uint
+xint(uint x)
+{
+  uint y;
+  uchar *a = (uchar*)&y;
+  a[0] = x;
+  a[1] = x >> 8;
+  a[2] = x >> 16;
+  a[3] = x >> 24;
+  return y;
+}
+
+int
+main(int argc, char *argv[])
+{
+  int i, cc, fd;
+  uint rootino, inum, off;
+  struct dirent de;
+  char buf[BSIZE];
+  struct dinode din;
+
+
+  static_assert(sizeof(int) == 4, "Integers must be 4 bytes!");
+
+  if(argc < 2){
+    fprintf(stderr, "Usage: mkfs fs.img files...\n");
+    exit(1);
+  }
+
+  assert((BSIZE % sizeof(struct dinode)) == 0);
+  assert((BSIZE % sizeof(struct dirent)) == 0);
+
+  fsfd = open(argv[1], O_RDWR|O_CREAT|O_TRUNC, 0666);
+  if(fsfd < 0){
+    perror(argv[1]);
+    exit(1);
+  }
+
+  // 1 fs block = 1 disk sector
+  nmeta = 2 + nlog + ninodeblocks + nbitmap;
+  nblocks = FSSIZE - nmeta;
+
+  sb.size = xint(FSSIZE);
+  sb.nblocks = xint(nblocks);
+  sb.ninodes = xint(NINODES);
+  sb.nlog = xint(nlog);
+  sb.logstart = xint(2);
+  sb.inodestart = xint(2+nlog);
+  sb.bmapstart = xint(2+nlog+ninodeblocks);
+
+  printf("nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n",
+         nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);
+
+  freeblock = nmeta;     // the first free block that we can allocate
+
+  for(i = 0; i < FSSIZE; i++)
+    wsect(i, zeroes);
+
+  memset(buf, 0, sizeof(buf));
+  memmove(buf, &sb, sizeof(sb));
+  wsect(1, buf);
+
+  rootino = ialloc(T_DIR);
+  assert(rootino == ROOTINO);
+
+  bzero(&de, sizeof(de));
+  de.inum = xshort(rootino);
+  strcpy(de.name, ".");
+  iappend(rootino, &de, sizeof(de));
+
+  bzero(&de, sizeof(de));
+  de.inum = xshort(rootino);
+  strcpy(de.name, "..");
+  iappend(rootino, &de, sizeof(de));
+
+  for(i = 2; i < argc; i++){
+    assert(index(argv[i], '/') == 0);
+
+    if((fd = open(argv[i], 0)) < 0){
+      perror(argv[i]);
+      exit(1);
+    }
+
+    // Skip leading _ in name when writing to file system.
+    // The binaries are named _rm, _cat, etc. to keep the
+    // build operating system from trying to execute them
+    // in place of system binaries like rm and cat.
+    if(argv[i][0] == '_')
+      ++argv[i];
+
+    inum = ialloc(T_FILE);
+
+    bzero(&de, sizeof(de));
+    de.inum = xshort(inum);
+    strncpy(de.name, argv[i], DIRSIZ);
+    iappend(rootino, &de, sizeof(de));
+
+    while((cc = read(fd, buf, sizeof(buf))) > 0)
+      iappend(inum, buf, cc);
+
+    close(fd);
+  }
+
+  // fix size of root inode dir
+  rinode(rootino, &din);
+  off = xint(din.size);
+  off = ((off/BSIZE) + 1) * BSIZE;
+  din.size = xint(off);
+  winode(rootino, &din);
+
+  balloc(freeblock);
+
+  exit(0);
+}
+
+void
+wsect(uint sec, void *buf)
+{
+  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+    perror("lseek");
+    exit(1);
+  }
+  if(write(fsfd, buf, BSIZE) != BSIZE){
+    perror("write");
+    exit(1);
+  }
+}
+
+void
+winode(uint inum, struct dinode *ip)
+{
+  char buf[BSIZE];
+  uint bn;
+  struct dinode *dip;
+
+  bn = IBLOCK(inum, sb);
+  rsect(bn, buf);
+  dip = ((struct dinode*)buf) + (inum % IPB);
+  *dip = *ip;
+  wsect(bn, buf);
+}
+
+void
+rinode(uint inum, struct dinode *ip)
+{
+  char buf[BSIZE];
+  uint bn;
+  struct dinode *dip;
+
+  bn = IBLOCK(inum, sb);
+  rsect(bn, buf);
+  dip = ((struct dinode*)buf) + (inum % IPB);
+  *ip = *dip;
+}
+
+void
+rsect(uint sec, void *buf)
+{
+  if(lseek(fsfd, sec * BSIZE, 0) != sec * BSIZE){
+    perror("lseek");
+    exit(1);
+  }
+  if(read(fsfd, buf, BSIZE) != BSIZE){
+    perror("read");
+    exit(1);
+  }
+}
+
+uint
+ialloc(ushort type)
+{
+  uint inum = freeinode++;
+  struct dinode din;
+
+  bzero(&din, sizeof(din));
+  din.type = xshort(type);
+  din.nlink = xshort(1);
+  din.size = xint(0);
+  winode(inum, &din);
+  return inum;
+}
+
+void
+balloc(int used)
+{
+  uchar buf[BSIZE];
+  int i;
+
+  printf("balloc: first %d blocks have been allocated\n", used);
+  assert(used < BSIZE*8);
+  bzero(buf, BSIZE);
+  for(i = 0; i < used; i++){
+    buf[i/8] = buf[i/8] | (0x1 << (i%8));
+  }
+  printf("balloc: write bitmap block at sector %d\n", sb.bmapstart);
+  wsect(sb.bmapstart, buf);
+}
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+
+void
+iappend(uint inum, void *xp, int n)
+{
+  char *p = (char*)xp;
+  uint fbn, off, n1;
+  struct dinode din;
+  char buf[BSIZE];
+  uint indirect[NINDIRECT];
+  uint x;
+
+  rinode(inum, &din);
+  off = xint(din.size);
+  // printf("append inum %d at off %d sz %d\n", inum, off, n);
+  while(n > 0){
+    fbn = off / BSIZE;
+    assert(fbn < MAXFILE);
+    if(fbn < NDIRECT){
+      if(xint(din.addrs[fbn]) == 0){
+        din.addrs[fbn] = xint(freeblock++);
+      }
+      x = xint(din.addrs[fbn]);
+    } else {
+      if(xint(din.addrs[NDIRECT]) == 0){
+        din.addrs[NDIRECT] = xint(freeblock++);
+      }
+      rsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+      if(indirect[fbn - NDIRECT] == 0){
+        indirect[fbn - NDIRECT] = xint(freeblock++);
+        wsect(xint(din.addrs[NDIRECT]), (char*)indirect);
+      }
+      x = xint(indirect[fbn-NDIRECT]);
+    }
+    n1 = min(n, (fbn + 1) * BSIZE - off);
+    rsect(x, buf);
+    bcopy(p, buf + off - (fbn * BSIZE), n1);
+    wsect(x, buf);
+    n -= n1;
+    off += n1;
+    p += n1;
+  }
+  din.size = xint(off);
+  winode(inum, &din);
+}
diff -ruN xv6-public/xv6-public/mmu.h xv6-public_new/xv6-public/mmu.h
--- xv6-public/xv6-public/mmu.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mmu.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,181 @@
+// This file contains definitions for the
+// x86 memory management unit (MMU).
+
+// Eflags register
+#define FL_IF           0x00000200      // Interrupt Enable
+
+// Control Register flags
+#define CR0_PE          0x00000001      // Protection Enable
+#define CR0_WP          0x00010000      // Write Protect
+#define CR0_PG          0x80000000      // Paging
+
+#define CR4_PSE         0x00000010      // Page size extension
+
+// various segment selectors.
+#define SEG_KCODE 1  // kernel code
+#define SEG_KDATA 2  // kernel data+stack
+#define SEG_UCODE 3  // user code
+#define SEG_UDATA 4  // user data+stack
+#define SEG_TSS   5  // this process's task state
+
+// cpu->gdt[NSEGS] holds the above segments.
+#define NSEGS     6
+
+#ifndef __ASSEMBLER__
+// Segment Descriptor
+struct segdesc {
+  uint lim_15_0 : 16;  // Low bits of segment limit
+  uint base_15_0 : 16; // Low bits of segment base address
+  uint base_23_16 : 8; // Middle bits of segment base address
+  uint type : 4;       // Segment type (see STS_ constants)
+  uint s : 1;          // 0 = system, 1 = application
+  uint dpl : 2;        // Descriptor Privilege Level
+  uint p : 1;          // Present
+  uint lim_19_16 : 4;  // High bits of segment limit
+  uint avl : 1;        // Unused (available for software use)
+  uint rsv1 : 1;       // Reserved
+  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
+  uint g : 1;          // Granularity: limit scaled by 4K when set
+  uint base_31_24 : 8; // High bits of segment base address
+};
+
+// Normal segment
+#define SEG(type, base, lim, dpl) (struct segdesc)    \
+{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
+  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
+  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
+#define SEG16(type, base, lim, dpl) (struct segdesc)  \
+{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
+  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
+  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
+#endif
+
+#define DPL_USER    0x3     // User DPL
+
+// Application segment type bits
+#define STA_X       0x8     // Executable segment
+#define STA_W       0x2     // Writeable (non-executable segments)
+#define STA_R       0x2     // Readable (executable segments)
+
+// System segment type bits
+#define STS_T32A    0x9     // Available 32-bit TSS
+#define STS_IG32    0xE     // 32-bit Interrupt Gate
+#define STS_TG32    0xF     // 32-bit Trap Gate
+
+// A virtual address 'la' has a three-part structure as follows:
+//
+// +--------10------+-------10-------+---------12----------+
+// | Page Directory |   Page Table   | Offset within Page  |
+// |      Index     |      Index     |                     |
+// +----------------+----------------+---------------------+
+//  \--- PDX(va) --/ \--- PTX(va) --/
+
+// page directory index
+#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
+
+// page table index
+#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
+
+// construct virtual address from indexes and offset
+#define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
+
+// Page directory and page table constants.
+#define NPDENTRIES      1024    // # directory entries per page directory
+#define NPTENTRIES      1024    // # PTEs per page table
+#define PGSIZE          4096    // bytes mapped by a page
+
+#define PTXSHIFT        12      // offset of PTX in a linear address
+#define PDXSHIFT        22      // offset of PDX in a linear address
+
+#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
+#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+
+// Page table/directory entry flags.
+#define PTE_P           0x001   // Present
+#define PTE_W           0x002   // Writeable
+#define PTE_U           0x004   // User
+#define PTE_PS          0x080   // Page Size
+
+// Address in page table or page directory entry
+#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
+#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
+
+#ifndef __ASSEMBLER__
+typedef uint pte_t;
+
+// Task state segment format
+struct taskstate {
+  uint link;         // Old ts selector
+  uint esp0;         // Stack pointers and segment selectors
+  ushort ss0;        //   after an increase in privilege level
+  ushort padding1;
+  uint *esp1;
+  ushort ss1;
+  ushort padding2;
+  uint *esp2;
+  ushort ss2;
+  ushort padding3;
+  void *cr3;         // Page directory base
+  uint *eip;         // Saved state from last task switch
+  uint eflags;
+  uint eax;          // More saved state (registers)
+  uint ecx;
+  uint edx;
+  uint ebx;
+  uint *esp;
+  uint *ebp;
+  uint esi;
+  uint edi;
+  ushort es;         // Even more saved state (segment selectors)
+  ushort padding4;
+  ushort cs;
+  ushort padding5;
+  ushort ss;
+  ushort padding6;
+  ushort ds;
+  ushort padding7;
+  ushort fs;
+  ushort padding8;
+  ushort gs;
+  ushort padding9;
+  ushort ldt;
+  ushort padding10;
+  ushort t;          // Trap on task switch
+  ushort iomb;       // I/O map base address
+};
+
+// Gate descriptors for interrupts and traps
+struct gatedesc {
+  uint off_15_0 : 16;   // low 16 bits of offset in segment
+  uint cs : 16;         // code segment selector
+  uint args : 5;        // # args, 0 for interrupt/trap gates
+  uint rsv1 : 3;        // reserved(should be zero I guess)
+  uint type : 4;        // type(STS_{IG32,TG32})
+  uint s : 1;           // must be 0 (system)
+  uint dpl : 2;         // descriptor(meaning new) privilege level
+  uint p : 1;           // Present
+  uint off_31_16 : 16;  // high bits of offset in segment
+};
+
+// Set up a normal interrupt/trap gate descriptor.
+// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
+//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
+// - sel: Code segment selector for interrupt/trap handler
+// - off: Offset in code segment for interrupt/trap handler
+// - dpl: Descriptor Privilege Level -
+//        the privilege level required for software to invoke
+//        this interrupt/trap gate explicitly using an int instruction.
+#define SETGATE(gate, istrap, sel, off, d)                \
+{                                                         \
+  (gate).off_15_0 = (uint)(off) & 0xffff;                \
+  (gate).cs = (sel);                                      \
+  (gate).args = 0;                                        \
+  (gate).rsv1 = 0;                                        \
+  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
+  (gate).s = 0;                                           \
+  (gate).dpl = (d);                                       \
+  (gate).p = 1;                                           \
+  (gate).off_31_16 = (uint)(off) >> 16;                  \
+}
+
+#endif
diff -ruN xv6-public/xv6-public/mp.c xv6-public_new/xv6-public/mp.c
--- xv6-public/xv6-public/mp.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mp.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,139 @@
+// Multiprocessor support
+// Search memory for MP description structures.
+// http://developer.intel.com/design/pentium/datashts/24201606.pdf
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mp.h"
+#include "x86.h"
+#include "mmu.h"
+#include "proc.h"
+
+struct cpu cpus[NCPU];
+int ncpu;
+uchar ioapicid;
+
+static uchar
+sum(uchar *addr, int len)
+{
+  int i, sum;
+
+  sum = 0;
+  for(i=0; i<len; i++)
+    sum += addr[i];
+  return sum;
+}
+
+// Look for an MP structure in the len bytes at addr.
+static struct mp*
+mpsearch1(uint a, int len)
+{
+  uchar *e, *p, *addr;
+
+  addr = P2V(a);
+  e = addr+len;
+  for(p = addr; p < e; p += sizeof(struct mp))
+    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+      return (struct mp*)p;
+  return 0;
+}
+
+// Search for the MP Floating Pointer Structure, which according to the
+// spec is in one of the following three locations:
+// 1) in the first KB of the EBDA;
+// 2) in the last KB of system base memory;
+// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
+static struct mp*
+mpsearch(void)
+{
+  uchar *bda;
+  uint p;
+  struct mp *mp;
+
+  bda = (uchar *) P2V(0x400);
+  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
+    if((mp = mpsearch1(p, 1024)))
+      return mp;
+  } else {
+    p = ((bda[0x14]<<8)|bda[0x13])*1024;
+    if((mp = mpsearch1(p-1024, 1024)))
+      return mp;
+  }
+  return mpsearch1(0xF0000, 0x10000);
+}
+
+// Search for an MP configuration table.  For now,
+// don't accept the default configurations (physaddr == 0).
+// Check for correct signature, calculate the checksum and,
+// if correct, check the version.
+// To do: check extended table checksum.
+static struct mpconf*
+mpconfig(struct mp **pmp)
+{
+  struct mpconf *conf;
+  struct mp *mp;
+
+  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+    return 0;
+  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+  if(memcmp(conf, "PCMP", 4) != 0)
+    return 0;
+  if(conf->version != 1 && conf->version != 4)
+    return 0;
+  if(sum((uchar*)conf, conf->length) != 0)
+    return 0;
+  *pmp = mp;
+  return conf;
+}
+
+void
+mpinit(void)
+{
+  uchar *p, *e;
+  int ismp;
+  struct mp *mp;
+  struct mpconf *conf;
+  struct mpproc *proc;
+  struct mpioapic *ioapic;
+
+  if((conf = mpconfig(&mp)) == 0)
+    panic("Expect to run on an SMP");
+  ismp = 1;
+  lapic = (uint*)conf->lapicaddr;
+  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
+    switch(*p){
+    case MPPROC:
+      proc = (struct mpproc*)p;
+      if(ncpu < NCPU) {
+        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+        ncpu++;
+      }
+      p += sizeof(struct mpproc);
+      continue;
+    case MPIOAPIC:
+      ioapic = (struct mpioapic*)p;
+      ioapicid = ioapic->apicno;
+      p += sizeof(struct mpioapic);
+      continue;
+    case MPBUS:
+    case MPIOINTR:
+    case MPLINTR:
+      p += 8;
+      continue;
+    default:
+      ismp = 0;
+      break;
+    }
+  }
+  if(!ismp)
+    panic("Didn't find a suitable machine");
+
+  if(mp->imcrp){
+    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
+    // But it would on real hardware.
+    outb(0x22, 0x70);   // Select IMCR
+    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
+  }
+}
diff -ruN xv6-public/xv6-public/mp.d xv6-public_new/xv6-public/mp.d
--- xv6-public/xv6-public/mp.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mp.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+mp.o: mp.c /usr/include/stdc-predef.h types.h defs.h param.h memlayout.h \
+ mp.h x86.h mmu.h proc.h
diff -ruN xv6-public/xv6-public/mp.h xv6-public_new/xv6-public/mp.h
--- xv6-public/xv6-public/mp.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/mp.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,56 @@
+// See MultiProcessor Specification Version 1.[14]
+
+struct mp {             // floating pointer
+  uchar signature[4];           // "_MP_"
+  void *physaddr;               // phys addr of MP config table
+  uchar length;                 // 1
+  uchar specrev;                // [14]
+  uchar checksum;               // all bytes must add up to 0
+  uchar type;                   // MP system config type
+  uchar imcrp;
+  uchar reserved[3];
+};
+
+struct mpconf {         // configuration table header
+  uchar signature[4];           // "PCMP"
+  ushort length;                // total table length
+  uchar version;                // [14]
+  uchar checksum;               // all bytes must add up to 0
+  uchar product[20];            // product id
+  uint *oemtable;               // OEM table pointer
+  ushort oemlength;             // OEM table length
+  ushort entry;                 // entry count
+  uint *lapicaddr;              // address of local APIC
+  ushort xlength;               // extended table length
+  uchar xchecksum;              // extended table checksum
+  uchar reserved;
+};
+
+struct mpproc {         // processor table entry
+  uchar type;                   // entry type (0)
+  uchar apicid;                 // local APIC id
+  uchar version;                // local APIC verison
+  uchar flags;                  // CPU flags
+    #define MPBOOT 0x02           // This proc is the bootstrap processor.
+  uchar signature[4];           // CPU signature
+  uint feature;                 // feature flags from CPUID instruction
+  uchar reserved[8];
+};
+
+struct mpioapic {       // I/O APIC table entry
+  uchar type;                   // entry type (2)
+  uchar apicno;                 // I/O APIC id
+  uchar version;                // I/O APIC version
+  uchar flags;                  // I/O APIC flags
+  uint *addr;                  // I/O APIC address
+};
+
+// Table entry types
+#define MPPROC    0x00  // One per processor
+#define MPBUS     0x01  // One per bus
+#define MPIOAPIC  0x02  // One per I/O APIC
+#define MPIOINTR  0x03  // One per bus interrupt source
+#define MPLINTR   0x04  // One per system interrupt source
+
+//PAGEBREAK!
+// Blank page.
Binary files xv6-public/xv6-public/mp.o and xv6-public_new/xv6-public/mp.o differ
diff -ruN xv6-public/xv6-public/param.h xv6-public_new/xv6-public/param.h
--- xv6-public/xv6-public/param.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/param.h	2021-09-30 10:44:16.000000000 +0530
@@ -0,0 +1,15 @@
+#define NPROC        64  // maximum number of processes
+#define KSTACKSIZE 4096  // size of per-process kernel stack
+#define NCPU          8  // maximum number of CPUs
+#define NOFILE       16  // open files per process
+#define NFILE       100  // open files per system
+#define NINODE       50  // maximum number of active i-nodes
+#define NDEV         10  // maximum major device number
+#define ROOTDEV       1  // device number of file system root disk
+#define MAXARG       32  // max exec arguments
+#define MAXOPBLOCKS  10  // max # of blocks any FS op writes
+#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
+#define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
+#define FSSIZE       1000  // size of file system in blocks
+#define QUANTA	     10 // time quanta used in the time sharing system
+#define POLICY	     1  // 0=default(round robin), 1=FCFS,
diff -ruN xv6-public/xv6-public/picirq.c xv6-public_new/xv6-public/picirq.c
--- xv6-public/xv6-public/picirq.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/picirq.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,19 @@
+#include "types.h"
+#include "x86.h"
+#include "traps.h"
+
+// I/O Addresses of the two programmable interrupt controllers
+#define IO_PIC1         0x20    // Master (IRQs 0-7)
+#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
+
+// Don't use the 8259A interrupt controllers.  Xv6 assumes SMP hardware.
+void
+picinit(void)
+{
+  // mask all interrupts
+  outb(IO_PIC1+1, 0xFF);
+  outb(IO_PIC2+1, 0xFF);
+}
+
+//PAGEBREAK!
+// Blank page.
diff -ruN xv6-public/xv6-public/picirq.d xv6-public_new/xv6-public/picirq.d
--- xv6-public/xv6-public/picirq.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/picirq.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1 @@
+picirq.o: picirq.c /usr/include/stdc-predef.h types.h x86.h traps.h
Binary files xv6-public/xv6-public/picirq.o and xv6-public_new/xv6-public/picirq.o differ
diff -ruN xv6-public/xv6-public/pipe.c xv6-public_new/xv6-public/pipe.c
--- xv6-public/xv6-public/pipe.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/pipe.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,121 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "mmu.h"
+#include "proc.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "file.h"
+
+#define PIPESIZE 512
+
+struct pipe {
+  struct spinlock lock;
+  char data[PIPESIZE];
+  uint nread;     // number of bytes read
+  uint nwrite;    // number of bytes written
+  int readopen;   // read fd is still open
+  int writeopen;  // write fd is still open
+};
+
+int
+pipealloc(struct file **f0, struct file **f1)
+{
+  struct pipe *p;
+
+  p = 0;
+  *f0 = *f1 = 0;
+  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+    goto bad;
+  if((p = (struct pipe*)kalloc()) == 0)
+    goto bad;
+  p->readopen = 1;
+  p->writeopen = 1;
+  p->nwrite = 0;
+  p->nread = 0;
+  initlock(&p->lock, "pipe");
+  (*f0)->type = FD_PIPE;
+  (*f0)->readable = 1;
+  (*f0)->writable = 0;
+  (*f0)->pipe = p;
+  (*f1)->type = FD_PIPE;
+  (*f1)->readable = 0;
+  (*f1)->writable = 1;
+  (*f1)->pipe = p;
+  return 0;
+
+//PAGEBREAK: 20
+ bad:
+  if(p)
+    kfree((char*)p);
+  if(*f0)
+    fileclose(*f0);
+  if(*f1)
+    fileclose(*f1);
+  return -1;
+}
+
+void
+pipeclose(struct pipe *p, int writable)
+{
+  acquire(&p->lock);
+  if(writable){
+    p->writeopen = 0;
+    wakeup(&p->nread);
+  } else {
+    p->readopen = 0;
+    wakeup(&p->nwrite);
+  }
+  if(p->readopen == 0 && p->writeopen == 0){
+    release(&p->lock);
+    kfree((char*)p);
+  } else
+    release(&p->lock);
+}
+
+//PAGEBREAK: 40
+int
+pipewrite(struct pipe *p, char *addr, int n)
+{
+  int i;
+
+  acquire(&p->lock);
+  for(i = 0; i < n; i++){
+    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
+      if(p->readopen == 0 || myproc()->killed){
+        release(&p->lock);
+        return -1;
+      }
+      wakeup(&p->nread);
+      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
+    }
+    p->data[p->nwrite++ % PIPESIZE] = addr[i];
+  }
+  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
+  release(&p->lock);
+  return n;
+}
+
+int
+piperead(struct pipe *p, char *addr, int n)
+{
+  int i;
+
+  acquire(&p->lock);
+  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
+    if(myproc()->killed){
+      release(&p->lock);
+      return -1;
+    }
+    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
+  }
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+    if(p->nread == p->nwrite)
+      break;
+    addr[i] = p->data[p->nread++ % PIPESIZE];
+  }
+  wakeup(&p->nwrite);  //DOC: piperead-wakeup
+  release(&p->lock);
+  return i;
+}
diff -ruN xv6-public/xv6-public/pipe.d xv6-public_new/xv6-public/pipe.d
--- xv6-public/xv6-public/pipe.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/pipe.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+pipe.o: pipe.c /usr/include/stdc-predef.h types.h defs.h param.h mmu.h \
+ proc.h fs.h spinlock.h sleeplock.h file.h
Binary files xv6-public/xv6-public/pipe.o and xv6-public_new/xv6-public/pipe.o differ
diff -ruN xv6-public/xv6-public/pr.pl xv6-public_new/xv6-public/pr.pl
--- xv6-public/xv6-public/pr.pl	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/pr.pl	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,36 @@
+#!/usr/bin/perl
+
+use POSIX qw(strftime);
+
+if($ARGV[0] eq "-h"){
+	shift @ARGV;
+	$h = $ARGV[0];
+	shift @ARGV;
+}else{
+	$h = $ARGV[0];
+}
+
+$page = 0;
+$now = strftime "%b %e %H:%M %Y", localtime;
+
+@lines = <>;
+for($i=0; $i<@lines; $i+=50){
+	print "\n\n";
+	++$page;
+	print "$now  $h  Page $page\n";
+	print "\n\n";
+	for($j=$i; $j<@lines && $j<$i +50; $j++){
+		$lines[$j] =~ s!//DOC.*!!;
+		print $lines[$j];
+	}
+	for(; $j<$i+50; $j++){
+		print "\n";
+	}
+	$sheet = "";
+	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
+		$sheet = "Sheet $1";
+	}
+	print "\n\n";
+	print "$sheet\n";
+	print "\n\n";
+}
diff -ruN xv6-public/xv6-public/printf.c xv6-public_new/xv6-public/printf.c
--- xv6-public/xv6-public/printf.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/printf.c	2021-09-29 13:08:44.000000000 +0530
@@ -0,0 +1,85 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+  write(fd, &c, 1);
+}
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    neg = 1;
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+  do{
+    buf[i++] = digits[x % base];
+  }while((x /= base) != 0);
+  if(neg)
+    buf[i++] = '-';
+
+  while(--i >= 0)
+    putc(fd, buf[i]);
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+  ap = (uint*)(void*)&fmt + 1;
+  for(i = 0; fmt[i]; i++){
+    c = fmt[i] & 0xff;
+    if(state == 0){
+      if(c == '%'){
+        state = '%';
+      } else {
+        putc(fd, c);
+      }
+    } else if(state == '%'){
+      if(c == 'd'){
+        printint(fd, *ap, 10, 1);
+        ap++;
+      } else if(c == 'x' || c == 'p'){
+        printint(fd, *ap, 16, 0);
+        ap++;
+      } else if(c == 's'){
+        s = (char*)*ap;
+        ap++;
+        if(s == 0)
+          s = "(null)";
+        while(*s != 0){
+          putc(fd, *s);
+          s++;
+        }
+      } else if(c == 'c'){
+        putc(fd, *ap);
+        ap++;
+      } else if(c == '%'){
+        putc(fd, c);
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c);
+      }
+      state = 0;
+    }
+  }
+}
diff -ruN xv6-public/xv6-public/printf.d xv6-public_new/xv6-public/printf.d
--- xv6-public/xv6-public/printf.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/printf.d	2021-09-30 23:15:12.000000000 +0530
@@ -0,0 +1 @@
+printf.o: printf.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/printf.o and xv6-public_new/xv6-public/printf.o differ
diff -ruN xv6-public/xv6-public/printpcs xv6-public_new/xv6-public/printpcs
--- xv6-public/xv6-public/printpcs	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/printpcs	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+# Decode the symbols from a panic EIP list
+
+# Find a working addr2line
+for p in i386-jos-elf-addr2line addr2line; do
+    if which $p 2>&1 >/dev/null && \
+       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
+        break
+    fi
+done
+
+# Enable as much pretty-printing as this addr2line can do
+$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
diff -ruN xv6-public/xv6-public/proc.c xv6-public_new/xv6-public/proc.c
--- xv6-public/xv6-public/proc.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/proc.c	2021-09-30 22:26:10.000000000 +0530
@@ -0,0 +1,947 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "spinlock.h"
+
+struct {
+  struct spinlock lock;
+  struct proc proc[NPROC];
+} ptable;
+
+static struct proc *initproc;
+
+int nextpid = 1;
+int current_time = 0;
+extern void forkret(void);
+extern void trapret(void);
+
+static void wakeup1(void *chan);
+
+
+// this is a handmade function
+int sys_cps(void){
+  struct proc* p;
+
+  // // Enables interrupts on this process
+  sti();
+
+  acquire(&ptable.lock);
+
+  int cnt_unused = 0;
+  cprintf("Process Table:-\n");
+  cprintf("S.no. \t name \t pid \t state \t priority \n");
+  for(int i = 0; i<NPROC ; i++){
+  p = &ptable.proc[i];
+    if(p->state == SLEEPING){
+      cprintf("%d \t %s \t %d \t SLEEPING \t %d \n",i ,p->name, p->pid, p->priority);
+    }else if(p->state == RUNNING){
+      cprintf("%d \t %s \t %d \t RUNNING \t %d \n",i ,p->name, p->pid, p->priority);
+    }else if(p->state == RUNNABLE){
+      cprintf("%d \t %s \t %d \t RUNNABLE \t %d \n",i ,p->name, p->pid, p->priority);
+    }else if(p->state == UNUSED){
+      cprintf("%d \t %s \t %d \t UNUSED \t %d \n",i ,p->name, p->pid, p->priority);
+      cnt_unused++;
+    }
+  }
+  cprintf("Total unused processes: %d\n",cnt_unused);
+  release(&ptable.lock);
+
+  return(1);
+}
+
+void
+pinit(void)
+{
+  initlock(&ptable.lock, "ptable");
+}
+
+// Must be called with interrupts disabled
+int
+cpuid() {
+  return mycpu()-cpus;
+}
+
+// Must be called with interrupts disabled to avoid the caller being
+// rescheduled between reading lapicid and running through the loop.
+struct cpu*
+mycpu(void)
+{
+  int apicid, i;
+  
+  if(readeflags()&FL_IF)
+    panic("mycpu called with interrupts enabled\n");
+  
+  apicid = lapicid();
+  // APIC IDs are not guaranteed to be contiguous. Maybe we should have
+  // a reverse map, or reserve a register to store &cpus[i].
+  for (i = 0; i < ncpu; ++i) {
+    if (cpus[i].apicid == apicid)
+      return &cpus[i];
+  }
+  panic("unknown apicid\n");
+}
+
+// Disable interrupts so that we are not rescheduled
+// while reading proc from the cpu structure
+struct proc*
+myproc(void) {
+  struct cpu *c;
+  struct proc *p;
+  pushcli();
+  c = mycpu();
+  p = c->proc;
+  popcli();
+  return p;
+}
+
+//PAGEBREAK: 32
+// Look in the process table for an UNUSED proc.
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == UNUSED)
+      goto found;
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+  p->ctime = ticks;
+  p->retime = 0;
+  p->rutime = 0;
+  p->stime = 0;
+  p->priority = 2;
+  p->fake[0] = '*';
+  p->fake[1] = '*';
+  p->fake[2] = '*';
+  p->fake[3] = '*';
+  p->fake[4] = '*';
+  p->fake[5] = '*';
+  p->fake[6] = '*';
+  p->fake[7] = '*';
+  release(&ptable.lock);
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+    p->state = UNUSED;
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
+
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+  p->tf = (struct trapframe*)sp;
+
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
+
+  sp -= sizeof *p->context;
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+  p->context->eip = (uint)forkret;
+
+  return p;
+}
+
+//PAGEBREAK: 32
+// Set up first user process.
+void
+userinit(void)
+{
+  struct proc *p;
+  extern char _binary_initcode_start[], _binary_initcode_size[];
+
+  p = allocproc();
+  
+  initproc = p;
+  if((p->pgdir = setupkvm()) == 0)
+    panic("userinit: out of memory?");
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+  p->sz = PGSIZE;
+  memset(p->tf, 0, sizeof(*p->tf));
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+  p->tf->es = p->tf->ds;
+  p->tf->ss = p->tf->ds;
+  p->tf->eflags = FL_IF;
+  p->tf->esp = PGSIZE;
+  p->tf->eip = 0;  // beginning of initcode.S
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+  p->cwd = namei("/");
+
+  // this assignment to p->state lets other cores
+  // run this process. the acquire forces the above
+  // writes to be visible, and the lock is also needed
+  // because the assignment might not be atomic.
+  acquire(&ptable.lock);
+
+  p->state = RUNNABLE;
+
+  release(&ptable.lock);
+}
+
+// Grow current process's memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+  uint sz;
+  struct proc *curproc = myproc();
+
+  sz = curproc->sz;
+  if(n > 0){
+    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  } else if(n < 0){
+    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  }
+  curproc->sz = sz;
+  switchuvm(curproc);
+  return 0;
+}
+
+// Create a new process copying p as the parent.
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+int
+fork(void)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *curproc = myproc();
+
+  // Allocate process.
+  if((np = allocproc()) == 0){
+    return -1;
+  }
+
+  // Copy process state from proc.
+  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+    kfree(np->kstack);
+    np->kstack = 0;
+    np->state = UNUSED;
+    return -1;
+  }
+  np->sz = curproc->sz;
+  np->parent = curproc;
+  *np->tf = *curproc->tf;
+  np->priority = curproc->priority;
+
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+
+  for(i = 0; i < NOFILE; i++)
+    if(curproc->ofile[i])
+      np->ofile[i] = filedup(curproc->ofile[i]);
+  np->cwd = idup(curproc->cwd);
+
+  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
+
+  pid = np->pid;
+
+  acquire(&ptable.lock);
+
+  np->state = RUNNABLE;
+
+  release(&ptable.lock);
+
+  return pid;
+}
+
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait() to find out it exited.
+void
+exit(void)
+{
+  struct proc *curproc = myproc();
+  struct proc *p;
+  int fd;
+
+  if(curproc == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd]){
+      fileclose(curproc->ofile[fd]);
+      curproc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(curproc->cwd);
+  end_op();
+  curproc->cwd = 0;
+
+  acquire(&ptable.lock);
+
+  // Parent might be sleeping in wait().
+  wakeup1(curproc->parent);
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->parent == curproc){
+      p->parent = initproc;
+      if(p->state == ZOMBIE)
+        wakeup1(initproc);
+    }
+  }
+
+  // Jump into the scheduler, never to return.
+  curproc->state = ZOMBIE;
+  sched();
+  panic("zombie exit");
+}
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait(void)
+{
+  struct proc *p;
+  int havekids, pid;
+  struct proc *curproc = myproc();
+  
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != curproc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        p->state = UNUSED;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || curproc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
+int wait2(int *retime, int *rutime, int *stime) {
+  struct proc *p;
+  int havekids, pid;
+  struct proc* proc = myproc();
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc) continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        *retime = p->retime;
+        *rutime = p->rutime;
+        *stime = p->stime;
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        p->ctime = 0;
+        p->retime = 0;
+        p->rutime = 0;
+        p->stime = 0;
+        p->priority = 0;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+p->priority = 2;
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
+
+int sys_wait2(void) {
+  int *retime, *rutime, *stime;
+  if (argptr(0, (void*)&retime, sizeof(retime)) < 0)
+    return -1;
+  if (argptr(1, (void*)&rutime, sizeof(retime)) < 0)
+    return -1;
+  if (argptr(2, (void*)&stime, sizeof(stime)) < 0)
+    return -1;
+  return wait2(retime, rutime, stime);
+}
+
+#ifdef DML
+/*
+Finds the next ready process for DML scheduling
+*/
+struct proc* findreadyprocess(int *index1, int *index2, int *index3, uint *priority) {
+  int i;
+  struct proc* proc2;
+notfound:
+  for (i = 0; i < NPROC; i++) {
+    switch(*priority) {
+      case 1:
+        proc2 = &ptable.proc[(*index1 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority) {
+          *index1 = (*index1 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+      case 2:
+        proc2 = &ptable.proc[(*index2 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority) {
+          *index2 = (*index2 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+      case 3:
+        proc2 = &ptable.proc[(*index3 + i) % NPROC];
+        if (proc2->state == RUNNABLE && proc2->priority == *priority){
+          *index3 = (*index3 + 1 + i) % NPROC;
+          return proc2; // found a runnable process with appropriate priority
+        }
+    }
+  }
+  if (*priority == 1) {//did not find any process on any of the prorities
+    *priority = 3;
+    return 0;
+  }
+  else {
+    *priority -= 1; //will try to find a process at a lower priority
+    goto notfound;
+  }
+  return 0;
+}
+#endif
+
+//PAGEBREAK: 42
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+void
+scheduler(void)
+{
+  struct cpu *cpu = mycpu();
+  cpu->proc = 0;
+
+  struct proc *p;
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+
+
+    // the differnt options for scheduling policies, chosen during compilation
+    #ifdef DEFAULT
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+        continue;
+
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+      cpu->proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      swtch(&(cpu->scheduler), p->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      cpu->proc = 0;
+    }
+
+    #else
+
+    #ifdef FCFS
+      struct proc* bezt_proc = &ptable.proc[0];
+      int bezt_time = -1;
+
+      for(p = ptable.proc; p<&ptable.proc[NPROC]; p++){
+        if(p->state != RUNNABLE) continue;
+        struct proc* curproc = p;
+        if(bezt_time==-1){
+          bezt_proc = curproc;
+          bezt_time = curproc->ctime;
+        }else if(curproc->ctime < bezt_time){
+          bezt_proc = curproc;
+          bezt_time = curproc->ctime;
+        }
+      }
+      if(bezt_time != -1){
+        p = bezt_proc;
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        cpu->proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+        swtch(&(cpu->scheduler), p->context);
+        switchkvm();
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        cpu->proc = 0;
+      }
+    #else
+
+    #ifdef SML
+    struct proc* best_proc = 0;
+    int best_time = -1;
+    int best_priority = -1;
+      for(p = ptable.proc; p<&ptable.proc[NPROC]; p++){
+        if(p->state != RUNNABLE) continue;
+        struct proc* curproc = p;
+        if(best_time==-1){
+          best_proc = curproc;
+          best_priority = curproc -> priority;
+          best_time = curproc->ctime;
+        }else if(best_priority == curproc->priority){
+          if(curproc->ctime < best_time){
+            best_proc = curproc;
+            best_priority = curproc -> priority;
+            best_time = curproc->ctime;
+          }
+        }else if(curproc->priority < best_priority){
+          best_proc = curproc;
+          best_priority = curproc -> priority;
+          best_time = curproc->ctime;
+        }
+      }
+      if(best_time != -1){
+        p = best_proc;
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        cpu->proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+        swtch(&(cpu->scheduler), p->context);
+        switchkvm();
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        cpu->proc = 0;
+      }
+    #else
+
+    #ifdef DML
+    int index1 = 1;
+    int index2 = 1;
+    int index3 = 1;
+    uint priority = 3;
+    p = findreadyprocess(&index1, &index2, &index3, &priority);
+    if (p == 0) {
+      release(&ptable.lock);
+      continue;
+    }
+    cpu->proc = p;
+    switchuvm(p);
+    p->state = RUNNING;
+    p->tickcounter = 0;
+    swtch(&cpu->scheduler, p->context);
+    switchkvm();
+    cpu->proc = 0;
+    #endif
+    #endif
+    #endif
+    #endif
+    release(&ptable.lock);
+  }
+}
+/*void
+scheduler(void)
+{
+  struct proc *p;
+  struct cpu *c = mycpu();
+  c->proc = 0;
+
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    acquire(&ptable.lock);
+
+    // cprintf("just before this was called\n");
+    // #ifdef FCFS
+    // cprintf("hello FCFS haha\n");
+    // #endif
+    #ifdef DEFAULT
+    //
+    #else
+
+    #ifdef FCFS
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+        if(p->state != RUNNABLE) continue;
+        
+        // storez the procezz with the firzt entry time in proc_exec
+        struct proc *proc_exec ;
+        struct proc *itr;
+        proc_exec=p;
+        for(itr=ptable.proc;itr< &ptable.proc[NPROC];itr++){
+            if(itr->pid > 2){
+                if(itr->ctime < proc_exec->ctime && itr->state == RUNNABLE){
+                    proc_exec = itr;
+                }
+            }
+        }
+
+        // p iz taken to that procezz with firzt time
+        p = proc_exec;
+        // p iz context zwithced inn
+        if(p == 0 || p->state != RUNNABLE) continue;
+        c->proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+
+        swtch(&(c->scheduler), p->context);
+        switchkvm();
+
+        // procezz iz done running for now
+        // cprintf("FCFS running with pid %d and cpu %d\n",p->pid,c->apicid);
+        c->proc = 0;
+    }
+    release(&ptable.lock);
+
+
+    // acquire(&ptable.lock);
+    // int sample_time = -1;
+    // struct proc* sample_proc = &ptable.proc[0];
+
+    // for(p = ptable.proc; p<&ptable.proc[NPROC]; p++){
+    //   if(p->state != RUNNABLE) continue;
+    //   if(p && (sample_time==-1 || p->ctime < sample_time)){
+    //     sample_time = p->ctime;
+    //     sample_proc = p;
+    //   }
+    // }
+
+    // // incase no process was found
+    // if(sample_time == -1) continue;
+
+    // c->proc = sample_proc;
+    // switchuvm(sample_proc);
+    // p->state = RUNNING;
+
+    // swtch(&(c->scheduler), p->context);
+    // switchkvm();
+
+    // c->proc = 0;
+
+    // release(&ptable.lock);
+
+    // Loop over process table looking for process to run.
+    // acquire(&ptable.lock);
+    // for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    //   if(p->state != RUNNABLE)
+    //     continue; 
+
+    //   if(p->pid>2) cprintf("pid: %d starts running\n", p->pid);
+
+    //   // Switch to chosen process.  It is the process's job
+    //   // to release ptable.lock and then reacquire it
+    //   // before jumping back to us.
+    //   c->proc = p;
+    //   switchuvm(p);
+    //   p->state = RUNNING;
+
+    //   swtch(&(c->scheduler), p->context);
+    //   switchkvm();
+
+    //   // Process is done running for now.
+    //   // It should have changed its p->state before coming back.
+    //   c->proc = 0;
+    // }
+    // release(&ptable.lock);
+
+  }
+}
+*/
+
+
+int sys_yield(void){
+  yield();
+  return(0);
+}
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+  acquire(&ptable.lock);  //DOC: yieldlock
+  myproc()->state = RUNNABLE;
+  sched();
+  release(&ptable.lock);
+}
+
+// Enter scheduler.  Must hold only ptable.lock
+// and have changed proc->state. Saves and restores
+// intena because intena is a property of this
+// kernel thread, not this CPU. It should
+// be proc->intena and proc->ncli, but that would
+// break in the few places where a lock is held but
+// there's no process.
+void
+sched(void)
+{
+  int intena;
+  struct proc *p = myproc();
+
+  if(!holding(&ptable.lock))
+    panic("sched ptable.lock");
+  if(mycpu()->ncli != 1)
+    panic("sched locks");
+  if(p->state == RUNNING)
+    panic("sched running");
+  if(readeflags()&FL_IF)
+    panic("sched interruptible");
+  intena = mycpu()->intena;
+  swtch(&p->context, mycpu()->scheduler);
+  mycpu()->intena = intena;
+}
+
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+
+  if (first) {
+    // Some initialization functions must be run in the context
+    // of a regular process (e.g., they call sleep), and thus cannot
+    // be run from main().
+    first = 0;
+    iinit(ROOTDEV);
+    initlog(ROOTDEV);
+  }
+
+  // Return to "caller", actually trapret (see allocproc).
+}
+
+// Atomically release lock and sleep on chan.
+// Reacquires lock when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+  struct proc *p = myproc();
+  
+  if(p == 0)
+    panic("sleep");
+
+  if(lk == 0)
+    panic("sleep without lk");
+
+  // Must acquire ptable.lock in order to
+  // change p->state and then call sched.
+  // Once we hold ptable.lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup runs with ptable.lock locked),
+  // so it's okay to release lk.
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+    acquire(&ptable.lock);  //DOC: sleeplock1
+    release(lk);
+  }
+  // Go to sleep.
+  p->chan = chan;
+  p->state = SLEEPING;
+
+  sched();
+
+  // Tidy up.
+  p->chan = 0;
+
+  // Reacquire original lock.
+  if(lk != &ptable.lock){  //DOC: sleeplock2
+    release(&ptable.lock);
+    acquire(lk);
+  }
+}
+
+//PAGEBREAK!
+// Wake up all processes sleeping on chan.
+// The ptable lock must be held.
+static void
+wakeup1(void *chan)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == SLEEPING && p->chan == chan)
+      p->state = RUNNABLE;
+}
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+  acquire(&ptable.lock);
+  wakeup1(chan);
+  release(&ptable.lock);
+}
+
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->pid == pid){
+      p->killed = 1;
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+
+//PAGEBREAK: 36
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    cprintf("%d %s %s", p->pid, state, p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+  }
+}
+
+
+void updatestatistics(void) {
+  struct proc *p;
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    switch(p->state) {
+      case SLEEPING:
+        p->stime++;
+        break;
+      case RUNNABLE:
+        p->retime++;
+        break;
+      case RUNNING:
+        p->rutime++;
+        break;
+      default:
+        ;
+    }
+  }
+  release(&ptable.lock);
+}
+
+
+int set_prio(int priority) {
+  if (priority < 1 || priority > 3)
+    return -1;
+  acquire(&ptable.lock);
+  myproc()->priority = priority;
+  release(&ptable.lock);
+  return 0;
+}
+
+int sys_set_prio(void) {
+  int priority;
+  argint(0, &priority);
+  return set_prio(priority);
+}
+
+void decpriority(void) {
+  // acquire(&ptable.lock);
+  struct proc* proc = myproc();
+  proc->priority = proc->priority == 1 ? 1 : proc->priority - 1;
+  // release(&ptable.lock);
+}
+
+int inctickcounter() {
+  int res;
+  acquire(&ptable.lock);
+  res = ++myproc()->tickcounter;
+  release(&ptable.lock);
+  return res;
+}
+
+
diff -ruN xv6-public/xv6-public/proc.d xv6-public_new/xv6-public/proc.d
--- xv6-public/xv6-public/proc.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/proc.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+proc.o: proc.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h x86.h proc.h spinlock.h
diff -ruN xv6-public/xv6-public/proc.h xv6-public_new/xv6-public/proc.h
--- xv6-public/xv6-public/proc.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/proc.h	2021-09-30 19:58:42.000000000 +0530
@@ -0,0 +1,67 @@
+// Per-CPU state
+struct cpu {
+  uchar apicid;                // Local APIC ID
+  struct context *scheduler;   // swtch() here to enter scheduler
+  struct taskstate ts;         // Used by x86 to find stack for interrupt
+  struct segdesc gdt[NSEGS];   // x86 global descriptor table
+  volatile uint started;       // Has the CPU started?
+  int ncli;                    // Depth of pushcli nesting.
+  int intena;                  // Were interrupts enabled before pushcli?
+  struct proc *proc;           // The process running on this cpu or null
+};
+
+extern struct cpu cpus[NCPU];
+extern int ncpu;
+
+//PAGEBREAK: 17
+// Saved registers for kernel context switches.
+// Don't need to save all the segment registers (%cs, etc),
+// because they are constant across kernel contexts.
+// Don't need to save %eax, %ecx, %edx, because the
+// x86 convention is that the caller has saved them.
+// Contexts are stored at the bottom of the stack they
+// describe; the stack pointer is the address of the context.
+// The layout of the context matches the layout of the stack in swtch.S
+// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
+// but it is on the stack and allocproc() manipulates it.
+struct context {
+  uint edi;
+  uint esi;
+  uint ebx;
+  uint ebp;
+  uint eip;
+};
+
+enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+
+// Per-process state
+struct proc {
+  char name[16];               // Process name (debugging)
+  int pid;                     // Process ID
+  uint sz;                     // Size of process memory (bytes)
+  pde_t* pgdir;                // Page table
+  char *kstack;                // Bottom of kernel stack for this process
+  enum procstate state;        // Process state
+  struct proc *parent;         // Parent process
+  struct trapframe *tf;        // Trap frame for current syscall
+  struct context *context;     // swtch() here to run process
+  void *chan;                  // If non-zero, sleeping on chan
+  int killed;                  // If non-zero, have been killed
+  struct file *ofile[NOFILE];  // Open files
+  struct inode *cwd;           // Current directory
+  uint ctime;                   // Process creation time
+  int stime;                   //process SLEEPING time
+  int retime;                  //process READY(RUNNABLE) time
+  int rutime;                  //process RUNNING time
+  int priority;
+  int tickcounter;
+  char fake[8];
+};
+
+// Process memory is laid out contiguously, low addresses first:
+//   text
+//   original data and bss
+//   fixed-size stack
+//   expandable heap
+
+// void updatestatistics();
\ No newline at end of file
Binary files xv6-public/xv6-public/proc.o and xv6-public_new/xv6-public/proc.o differ
diff -ruN xv6-public/xv6-public/rm.asm xv6-public_new/xv6-public/rm.asm
--- xv6-public/xv6-public/rm.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/rm.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1187 @@
+
+_rm:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	53                   	push   %ebx
+  12:	51                   	push   %ecx
+  13:	83 ec 10             	sub    $0x10,%esp
+  16:	89 cb                	mov    %ecx,%ebx
+  int i;
+
+  if(argc < 2){
+  18:	83 3b 01             	cmpl   $0x1,(%ebx)
+  1b:	7f 17                	jg     34 <main+0x34>
+    printf(2, "Usage: rm files...\n");
+  1d:	83 ec 08             	sub    $0x8,%esp
+  20:	68 7a 08 00 00       	push   $0x87a
+  25:	6a 02                	push   $0x2
+  27:	e8 87 04 00 00       	call   4b3 <printf>
+  2c:	83 c4 10             	add    $0x10,%esp
+    exit();
+  2f:	e8 db 02 00 00       	call   30f <exit>
+  }
+
+  for(i = 1; i < argc; i++){
+  34:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+  3b:	eb 4b                	jmp    88 <main+0x88>
+    if(unlink(argv[i]) < 0){
+  3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  40:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  47:	8b 43 04             	mov    0x4(%ebx),%eax
+  4a:	01 d0                	add    %edx,%eax
+  4c:	8b 00                	mov    (%eax),%eax
+  4e:	83 ec 0c             	sub    $0xc,%esp
+  51:	50                   	push   %eax
+  52:	e8 08 03 00 00       	call   35f <unlink>
+  57:	83 c4 10             	add    $0x10,%esp
+  5a:	85 c0                	test   %eax,%eax
+  5c:	79 26                	jns    84 <main+0x84>
+      printf(2, "rm: %s failed to delete\n", argv[i]);
+  5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  61:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  68:	8b 43 04             	mov    0x4(%ebx),%eax
+  6b:	01 d0                	add    %edx,%eax
+  6d:	8b 00                	mov    (%eax),%eax
+  6f:	83 ec 04             	sub    $0x4,%esp
+  72:	50                   	push   %eax
+  73:	68 8e 08 00 00       	push   $0x88e
+  78:	6a 02                	push   $0x2
+  7a:	e8 34 04 00 00       	call   4b3 <printf>
+  7f:	83 c4 10             	add    $0x10,%esp
+      break;
+  82:	eb 0b                	jmp    8f <main+0x8f>
+  for(i = 1; i < argc; i++){
+  84:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  88:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8b:	3b 03                	cmp    (%ebx),%eax
+  8d:	7c ae                	jl     3d <main+0x3d>
+    }
+  }
+
+  exit();
+  8f:	e8 7b 02 00 00       	call   30f <exit>
+
+00000094 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  94:	55                   	push   %ebp
+  95:	89 e5                	mov    %esp,%ebp
+  97:	57                   	push   %edi
+  98:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  99:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  9c:	8b 55 10             	mov    0x10(%ebp),%edx
+  9f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  a2:	89 cb                	mov    %ecx,%ebx
+  a4:	89 df                	mov    %ebx,%edi
+  a6:	89 d1                	mov    %edx,%ecx
+  a8:	fc                   	cld    
+  a9:	f3 aa                	rep stos %al,%es:(%edi)
+  ab:	89 ca                	mov    %ecx,%edx
+  ad:	89 fb                	mov    %edi,%ebx
+  af:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  b2:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  b5:	90                   	nop
+  b6:	5b                   	pop    %ebx
+  b7:	5f                   	pop    %edi
+  b8:	5d                   	pop    %ebp
+  b9:	c3                   	ret    
+
+000000ba <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  ba:	f3 0f 1e fb          	endbr32 
+  be:	55                   	push   %ebp
+  bf:	89 e5                	mov    %esp,%ebp
+  c1:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  ca:	90                   	nop
+  cb:	8b 55 0c             	mov    0xc(%ebp),%edx
+  ce:	8d 42 01             	lea    0x1(%edx),%eax
+  d1:	89 45 0c             	mov    %eax,0xc(%ebp)
+  d4:	8b 45 08             	mov    0x8(%ebp),%eax
+  d7:	8d 48 01             	lea    0x1(%eax),%ecx
+  da:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  dd:	0f b6 12             	movzbl (%edx),%edx
+  e0:	88 10                	mov    %dl,(%eax)
+  e2:	0f b6 00             	movzbl (%eax),%eax
+  e5:	84 c0                	test   %al,%al
+  e7:	75 e2                	jne    cb <strcpy+0x11>
+    ;
+  return os;
+  e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  ec:	c9                   	leave  
+  ed:	c3                   	ret    
+
+000000ee <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  ee:	f3 0f 1e fb          	endbr32 
+  f2:	55                   	push   %ebp
+  f3:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  f5:	eb 08                	jmp    ff <strcmp+0x11>
+    p++, q++;
+  f7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  fb:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+  ff:	8b 45 08             	mov    0x8(%ebp),%eax
+ 102:	0f b6 00             	movzbl (%eax),%eax
+ 105:	84 c0                	test   %al,%al
+ 107:	74 10                	je     119 <strcmp+0x2b>
+ 109:	8b 45 08             	mov    0x8(%ebp),%eax
+ 10c:	0f b6 10             	movzbl (%eax),%edx
+ 10f:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 112:	0f b6 00             	movzbl (%eax),%eax
+ 115:	38 c2                	cmp    %al,%dl
+ 117:	74 de                	je     f7 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 119:	8b 45 08             	mov    0x8(%ebp),%eax
+ 11c:	0f b6 00             	movzbl (%eax),%eax
+ 11f:	0f b6 d0             	movzbl %al,%edx
+ 122:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 125:	0f b6 00             	movzbl (%eax),%eax
+ 128:	0f b6 c0             	movzbl %al,%eax
+ 12b:	29 c2                	sub    %eax,%edx
+ 12d:	89 d0                	mov    %edx,%eax
+}
+ 12f:	5d                   	pop    %ebp
+ 130:	c3                   	ret    
+
+00000131 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 131:	f3 0f 1e fb          	endbr32 
+ 135:	55                   	push   %ebp
+ 136:	89 e5                	mov    %esp,%ebp
+ 138:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 13b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 142:	eb 04                	jmp    148 <strlen+0x17>
+ 144:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 148:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 14b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 14e:	01 d0                	add    %edx,%eax
+ 150:	0f b6 00             	movzbl (%eax),%eax
+ 153:	84 c0                	test   %al,%al
+ 155:	75 ed                	jne    144 <strlen+0x13>
+    ;
+  return n;
+ 157:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 15a:	c9                   	leave  
+ 15b:	c3                   	ret    
+
+0000015c <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 15c:	f3 0f 1e fb          	endbr32 
+ 160:	55                   	push   %ebp
+ 161:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 163:	8b 45 10             	mov    0x10(%ebp),%eax
+ 166:	50                   	push   %eax
+ 167:	ff 75 0c             	pushl  0xc(%ebp)
+ 16a:	ff 75 08             	pushl  0x8(%ebp)
+ 16d:	e8 22 ff ff ff       	call   94 <stosb>
+ 172:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 175:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 178:	c9                   	leave  
+ 179:	c3                   	ret    
+
+0000017a <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 17a:	f3 0f 1e fb          	endbr32 
+ 17e:	55                   	push   %ebp
+ 17f:	89 e5                	mov    %esp,%ebp
+ 181:	83 ec 04             	sub    $0x4,%esp
+ 184:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 187:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 18a:	eb 14                	jmp    1a0 <strchr+0x26>
+    if(*s == c)
+ 18c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 18f:	0f b6 00             	movzbl (%eax),%eax
+ 192:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 195:	75 05                	jne    19c <strchr+0x22>
+      return (char*)s;
+ 197:	8b 45 08             	mov    0x8(%ebp),%eax
+ 19a:	eb 13                	jmp    1af <strchr+0x35>
+  for(; *s; s++)
+ 19c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 1a0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1a3:	0f b6 00             	movzbl (%eax),%eax
+ 1a6:	84 c0                	test   %al,%al
+ 1a8:	75 e2                	jne    18c <strchr+0x12>
+  return 0;
+ 1aa:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 1af:	c9                   	leave  
+ 1b0:	c3                   	ret    
+
+000001b1 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1b1:	f3 0f 1e fb          	endbr32 
+ 1b5:	55                   	push   %ebp
+ 1b6:	89 e5                	mov    %esp,%ebp
+ 1b8:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1c2:	eb 42                	jmp    206 <gets+0x55>
+    cc = read(0, &c, 1);
+ 1c4:	83 ec 04             	sub    $0x4,%esp
+ 1c7:	6a 01                	push   $0x1
+ 1c9:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 1cc:	50                   	push   %eax
+ 1cd:	6a 00                	push   $0x0
+ 1cf:	e8 53 01 00 00       	call   327 <read>
+ 1d4:	83 c4 10             	add    $0x10,%esp
+ 1d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 1da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 1de:	7e 33                	jle    213 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 1e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1e3:	8d 50 01             	lea    0x1(%eax),%edx
+ 1e6:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 1e9:	89 c2                	mov    %eax,%edx
+ 1eb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ee:	01 c2                	add    %eax,%edx
+ 1f0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1f4:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 1f6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 1fa:	3c 0a                	cmp    $0xa,%al
+ 1fc:	74 16                	je     214 <gets+0x63>
+ 1fe:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 202:	3c 0d                	cmp    $0xd,%al
+ 204:	74 0e                	je     214 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 206:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 209:	83 c0 01             	add    $0x1,%eax
+ 20c:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 20f:	7f b3                	jg     1c4 <gets+0x13>
+ 211:	eb 01                	jmp    214 <gets+0x63>
+      break;
+ 213:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 214:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 217:	8b 45 08             	mov    0x8(%ebp),%eax
+ 21a:	01 d0                	add    %edx,%eax
+ 21c:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 21f:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 222:	c9                   	leave  
+ 223:	c3                   	ret    
+
+00000224 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 224:	f3 0f 1e fb          	endbr32 
+ 228:	55                   	push   %ebp
+ 229:	89 e5                	mov    %esp,%ebp
+ 22b:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 22e:	83 ec 08             	sub    $0x8,%esp
+ 231:	6a 00                	push   $0x0
+ 233:	ff 75 08             	pushl  0x8(%ebp)
+ 236:	e8 14 01 00 00       	call   34f <open>
+ 23b:	83 c4 10             	add    $0x10,%esp
+ 23e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 241:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 245:	79 07                	jns    24e <stat+0x2a>
+    return -1;
+ 247:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 24c:	eb 25                	jmp    273 <stat+0x4f>
+  r = fstat(fd, st);
+ 24e:	83 ec 08             	sub    $0x8,%esp
+ 251:	ff 75 0c             	pushl  0xc(%ebp)
+ 254:	ff 75 f4             	pushl  -0xc(%ebp)
+ 257:	e8 0b 01 00 00       	call   367 <fstat>
+ 25c:	83 c4 10             	add    $0x10,%esp
+ 25f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 262:	83 ec 0c             	sub    $0xc,%esp
+ 265:	ff 75 f4             	pushl  -0xc(%ebp)
+ 268:	e8 ca 00 00 00       	call   337 <close>
+ 26d:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 270:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 273:	c9                   	leave  
+ 274:	c3                   	ret    
+
+00000275 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 275:	f3 0f 1e fb          	endbr32 
+ 279:	55                   	push   %ebp
+ 27a:	89 e5                	mov    %esp,%ebp
+ 27c:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 27f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 286:	eb 25                	jmp    2ad <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 288:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 28b:	89 d0                	mov    %edx,%eax
+ 28d:	c1 e0 02             	shl    $0x2,%eax
+ 290:	01 d0                	add    %edx,%eax
+ 292:	01 c0                	add    %eax,%eax
+ 294:	89 c1                	mov    %eax,%ecx
+ 296:	8b 45 08             	mov    0x8(%ebp),%eax
+ 299:	8d 50 01             	lea    0x1(%eax),%edx
+ 29c:	89 55 08             	mov    %edx,0x8(%ebp)
+ 29f:	0f b6 00             	movzbl (%eax),%eax
+ 2a2:	0f be c0             	movsbl %al,%eax
+ 2a5:	01 c8                	add    %ecx,%eax
+ 2a7:	83 e8 30             	sub    $0x30,%eax
+ 2aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 2ad:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b0:	0f b6 00             	movzbl (%eax),%eax
+ 2b3:	3c 2f                	cmp    $0x2f,%al
+ 2b5:	7e 0a                	jle    2c1 <atoi+0x4c>
+ 2b7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2ba:	0f b6 00             	movzbl (%eax),%eax
+ 2bd:	3c 39                	cmp    $0x39,%al
+ 2bf:	7e c7                	jle    288 <atoi+0x13>
+  return n;
+ 2c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 2c4:	c9                   	leave  
+ 2c5:	c3                   	ret    
+
+000002c6 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2c6:	f3 0f 1e fb          	endbr32 
+ 2ca:	55                   	push   %ebp
+ 2cb:	89 e5                	mov    %esp,%ebp
+ 2cd:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 2d0:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 2d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 2dc:	eb 17                	jmp    2f5 <memmove+0x2f>
+    *dst++ = *src++;
+ 2de:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 2e1:	8d 42 01             	lea    0x1(%edx),%eax
+ 2e4:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 2e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 2ea:	8d 48 01             	lea    0x1(%eax),%ecx
+ 2ed:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 2f0:	0f b6 12             	movzbl (%edx),%edx
+ 2f3:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 2f5:	8b 45 10             	mov    0x10(%ebp),%eax
+ 2f8:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 2fb:	89 55 10             	mov    %edx,0x10(%ebp)
+ 2fe:	85 c0                	test   %eax,%eax
+ 300:	7f dc                	jg     2de <memmove+0x18>
+  return vdst;
+ 302:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 305:	c9                   	leave  
+ 306:	c3                   	ret    
+
+00000307 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 307:	b8 01 00 00 00       	mov    $0x1,%eax
+ 30c:	cd 40                	int    $0x40
+ 30e:	c3                   	ret    
+
+0000030f <exit>:
+SYSCALL(exit)
+ 30f:	b8 02 00 00 00       	mov    $0x2,%eax
+ 314:	cd 40                	int    $0x40
+ 316:	c3                   	ret    
+
+00000317 <wait>:
+SYSCALL(wait)
+ 317:	b8 03 00 00 00       	mov    $0x3,%eax
+ 31c:	cd 40                	int    $0x40
+ 31e:	c3                   	ret    
+
+0000031f <pipe>:
+SYSCALL(pipe)
+ 31f:	b8 04 00 00 00       	mov    $0x4,%eax
+ 324:	cd 40                	int    $0x40
+ 326:	c3                   	ret    
+
+00000327 <read>:
+SYSCALL(read)
+ 327:	b8 05 00 00 00       	mov    $0x5,%eax
+ 32c:	cd 40                	int    $0x40
+ 32e:	c3                   	ret    
+
+0000032f <write>:
+SYSCALL(write)
+ 32f:	b8 10 00 00 00       	mov    $0x10,%eax
+ 334:	cd 40                	int    $0x40
+ 336:	c3                   	ret    
+
+00000337 <close>:
+SYSCALL(close)
+ 337:	b8 15 00 00 00       	mov    $0x15,%eax
+ 33c:	cd 40                	int    $0x40
+ 33e:	c3                   	ret    
+
+0000033f <kill>:
+SYSCALL(kill)
+ 33f:	b8 06 00 00 00       	mov    $0x6,%eax
+ 344:	cd 40                	int    $0x40
+ 346:	c3                   	ret    
+
+00000347 <exec>:
+SYSCALL(exec)
+ 347:	b8 07 00 00 00       	mov    $0x7,%eax
+ 34c:	cd 40                	int    $0x40
+ 34e:	c3                   	ret    
+
+0000034f <open>:
+SYSCALL(open)
+ 34f:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 354:	cd 40                	int    $0x40
+ 356:	c3                   	ret    
+
+00000357 <mknod>:
+SYSCALL(mknod)
+ 357:	b8 11 00 00 00       	mov    $0x11,%eax
+ 35c:	cd 40                	int    $0x40
+ 35e:	c3                   	ret    
+
+0000035f <unlink>:
+SYSCALL(unlink)
+ 35f:	b8 12 00 00 00       	mov    $0x12,%eax
+ 364:	cd 40                	int    $0x40
+ 366:	c3                   	ret    
+
+00000367 <fstat>:
+SYSCALL(fstat)
+ 367:	b8 08 00 00 00       	mov    $0x8,%eax
+ 36c:	cd 40                	int    $0x40
+ 36e:	c3                   	ret    
+
+0000036f <link>:
+SYSCALL(link)
+ 36f:	b8 13 00 00 00       	mov    $0x13,%eax
+ 374:	cd 40                	int    $0x40
+ 376:	c3                   	ret    
+
+00000377 <mkdir>:
+SYSCALL(mkdir)
+ 377:	b8 14 00 00 00       	mov    $0x14,%eax
+ 37c:	cd 40                	int    $0x40
+ 37e:	c3                   	ret    
+
+0000037f <chdir>:
+SYSCALL(chdir)
+ 37f:	b8 09 00 00 00       	mov    $0x9,%eax
+ 384:	cd 40                	int    $0x40
+ 386:	c3                   	ret    
+
+00000387 <dup>:
+SYSCALL(dup)
+ 387:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 38c:	cd 40                	int    $0x40
+ 38e:	c3                   	ret    
+
+0000038f <getpid>:
+SYSCALL(getpid)
+ 38f:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 394:	cd 40                	int    $0x40
+ 396:	c3                   	ret    
+
+00000397 <sbrk>:
+SYSCALL(sbrk)
+ 397:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 39c:	cd 40                	int    $0x40
+ 39e:	c3                   	ret    
+
+0000039f <sleep>:
+SYSCALL(sleep)
+ 39f:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 3a4:	cd 40                	int    $0x40
+ 3a6:	c3                   	ret    
+
+000003a7 <uptime>:
+SYSCALL(uptime)
+ 3a7:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 3ac:	cd 40                	int    $0x40
+ 3ae:	c3                   	ret    
+
+000003af <draw>:
+SYSCALL(draw)
+ 3af:	b8 16 00 00 00       	mov    $0x16,%eax
+ 3b4:	cd 40                	int    $0x40
+ 3b6:	c3                   	ret    
+
+000003b7 <cps>:
+SYSCALL(cps)
+ 3b7:	b8 17 00 00 00       	mov    $0x17,%eax
+ 3bc:	cd 40                	int    $0x40
+ 3be:	c3                   	ret    
+
+000003bf <yield>:
+SYSCALL(yield)
+ 3bf:	b8 18 00 00 00       	mov    $0x18,%eax
+ 3c4:	cd 40                	int    $0x40
+ 3c6:	c3                   	ret    
+
+000003c7 <wait2>:
+SYSCALL(wait2)
+ 3c7:	b8 19 00 00 00       	mov    $0x19,%eax
+ 3cc:	cd 40                	int    $0x40
+ 3ce:	c3                   	ret    
+
+000003cf <set_prio>:
+SYSCALL(set_prio)
+ 3cf:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 3d4:	cd 40                	int    $0x40
+ 3d6:	c3                   	ret    
+
+000003d7 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 3d7:	f3 0f 1e fb          	endbr32 
+ 3db:	55                   	push   %ebp
+ 3dc:	89 e5                	mov    %esp,%ebp
+ 3de:	83 ec 18             	sub    $0x18,%esp
+ 3e1:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3e4:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 3e7:	83 ec 04             	sub    $0x4,%esp
+ 3ea:	6a 01                	push   $0x1
+ 3ec:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 3ef:	50                   	push   %eax
+ 3f0:	ff 75 08             	pushl  0x8(%ebp)
+ 3f3:	e8 37 ff ff ff       	call   32f <write>
+ 3f8:	83 c4 10             	add    $0x10,%esp
+}
+ 3fb:	90                   	nop
+ 3fc:	c9                   	leave  
+ 3fd:	c3                   	ret    
+
+000003fe <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 3fe:	f3 0f 1e fb          	endbr32 
+ 402:	55                   	push   %ebp
+ 403:	89 e5                	mov    %esp,%ebp
+ 405:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 408:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 40f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 413:	74 17                	je     42c <printint+0x2e>
+ 415:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 419:	79 11                	jns    42c <printint+0x2e>
+    neg = 1;
+ 41b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 422:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 425:	f7 d8                	neg    %eax
+ 427:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 42a:	eb 06                	jmp    432 <printint+0x34>
+  } else {
+    x = xx;
+ 42c:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 42f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 432:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 439:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 43c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 43f:	ba 00 00 00 00       	mov    $0x0,%edx
+ 444:	f7 f1                	div    %ecx
+ 446:	89 d1                	mov    %edx,%ecx
+ 448:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 44b:	8d 50 01             	lea    0x1(%eax),%edx
+ 44e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 451:	0f b6 91 f8 0a 00 00 	movzbl 0xaf8(%ecx),%edx
+ 458:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 45c:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 45f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 462:	ba 00 00 00 00       	mov    $0x0,%edx
+ 467:	f7 f1                	div    %ecx
+ 469:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 46c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 470:	75 c7                	jne    439 <printint+0x3b>
+  if(neg)
+ 472:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 476:	74 2d                	je     4a5 <printint+0xa7>
+    buf[i++] = '-';
+ 478:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 47b:	8d 50 01             	lea    0x1(%eax),%edx
+ 47e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 481:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 486:	eb 1d                	jmp    4a5 <printint+0xa7>
+    putc(fd, buf[i]);
+ 488:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 48b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 48e:	01 d0                	add    %edx,%eax
+ 490:	0f b6 00             	movzbl (%eax),%eax
+ 493:	0f be c0             	movsbl %al,%eax
+ 496:	83 ec 08             	sub    $0x8,%esp
+ 499:	50                   	push   %eax
+ 49a:	ff 75 08             	pushl  0x8(%ebp)
+ 49d:	e8 35 ff ff ff       	call   3d7 <putc>
+ 4a2:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 4a5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 4a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 4ad:	79 d9                	jns    488 <printint+0x8a>
+}
+ 4af:	90                   	nop
+ 4b0:	90                   	nop
+ 4b1:	c9                   	leave  
+ 4b2:	c3                   	ret    
+
+000004b3 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 4b3:	f3 0f 1e fb          	endbr32 
+ 4b7:	55                   	push   %ebp
+ 4b8:	89 e5                	mov    %esp,%ebp
+ 4ba:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 4bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 4c4:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 4c7:	83 c0 04             	add    $0x4,%eax
+ 4ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 4cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 4d4:	e9 59 01 00 00       	jmp    632 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 4d9:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 4dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 4df:	01 d0                	add    %edx,%eax
+ 4e1:	0f b6 00             	movzbl (%eax),%eax
+ 4e4:	0f be c0             	movsbl %al,%eax
+ 4e7:	25 ff 00 00 00       	and    $0xff,%eax
+ 4ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 4ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 4f3:	75 2c                	jne    521 <printf+0x6e>
+      if(c == '%'){
+ 4f5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 4f9:	75 0c                	jne    507 <printf+0x54>
+        state = '%';
+ 4fb:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 502:	e9 27 01 00 00       	jmp    62e <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 507:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 50a:	0f be c0             	movsbl %al,%eax
+ 50d:	83 ec 08             	sub    $0x8,%esp
+ 510:	50                   	push   %eax
+ 511:	ff 75 08             	pushl  0x8(%ebp)
+ 514:	e8 be fe ff ff       	call   3d7 <putc>
+ 519:	83 c4 10             	add    $0x10,%esp
+ 51c:	e9 0d 01 00 00       	jmp    62e <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 521:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 525:	0f 85 03 01 00 00    	jne    62e <printf+0x17b>
+      if(c == 'd'){
+ 52b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 52f:	75 1e                	jne    54f <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 531:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 534:	8b 00                	mov    (%eax),%eax
+ 536:	6a 01                	push   $0x1
+ 538:	6a 0a                	push   $0xa
+ 53a:	50                   	push   %eax
+ 53b:	ff 75 08             	pushl  0x8(%ebp)
+ 53e:	e8 bb fe ff ff       	call   3fe <printint>
+ 543:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 546:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 54a:	e9 d8 00 00 00       	jmp    627 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 54f:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 553:	74 06                	je     55b <printf+0xa8>
+ 555:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 559:	75 1e                	jne    579 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 55b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 55e:	8b 00                	mov    (%eax),%eax
+ 560:	6a 00                	push   $0x0
+ 562:	6a 10                	push   $0x10
+ 564:	50                   	push   %eax
+ 565:	ff 75 08             	pushl  0x8(%ebp)
+ 568:	e8 91 fe ff ff       	call   3fe <printint>
+ 56d:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 570:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 574:	e9 ae 00 00 00       	jmp    627 <printf+0x174>
+      } else if(c == 's'){
+ 579:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 57d:	75 43                	jne    5c2 <printf+0x10f>
+        s = (char*)*ap;
+ 57f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 582:	8b 00                	mov    (%eax),%eax
+ 584:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 587:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 58b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 58f:	75 25                	jne    5b6 <printf+0x103>
+          s = "(null)";
+ 591:	c7 45 f4 a7 08 00 00 	movl   $0x8a7,-0xc(%ebp)
+        while(*s != 0){
+ 598:	eb 1c                	jmp    5b6 <printf+0x103>
+          putc(fd, *s);
+ 59a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 59d:	0f b6 00             	movzbl (%eax),%eax
+ 5a0:	0f be c0             	movsbl %al,%eax
+ 5a3:	83 ec 08             	sub    $0x8,%esp
+ 5a6:	50                   	push   %eax
+ 5a7:	ff 75 08             	pushl  0x8(%ebp)
+ 5aa:	e8 28 fe ff ff       	call   3d7 <putc>
+ 5af:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 5b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 5b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5b9:	0f b6 00             	movzbl (%eax),%eax
+ 5bc:	84 c0                	test   %al,%al
+ 5be:	75 da                	jne    59a <printf+0xe7>
+ 5c0:	eb 65                	jmp    627 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 5c2:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 5c6:	75 1d                	jne    5e5 <printf+0x132>
+        putc(fd, *ap);
+ 5c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5cb:	8b 00                	mov    (%eax),%eax
+ 5cd:	0f be c0             	movsbl %al,%eax
+ 5d0:	83 ec 08             	sub    $0x8,%esp
+ 5d3:	50                   	push   %eax
+ 5d4:	ff 75 08             	pushl  0x8(%ebp)
+ 5d7:	e8 fb fd ff ff       	call   3d7 <putc>
+ 5dc:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 5df:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 5e3:	eb 42                	jmp    627 <printf+0x174>
+      } else if(c == '%'){
+ 5e5:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5e9:	75 17                	jne    602 <printf+0x14f>
+        putc(fd, c);
+ 5eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5ee:	0f be c0             	movsbl %al,%eax
+ 5f1:	83 ec 08             	sub    $0x8,%esp
+ 5f4:	50                   	push   %eax
+ 5f5:	ff 75 08             	pushl  0x8(%ebp)
+ 5f8:	e8 da fd ff ff       	call   3d7 <putc>
+ 5fd:	83 c4 10             	add    $0x10,%esp
+ 600:	eb 25                	jmp    627 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 602:	83 ec 08             	sub    $0x8,%esp
+ 605:	6a 25                	push   $0x25
+ 607:	ff 75 08             	pushl  0x8(%ebp)
+ 60a:	e8 c8 fd ff ff       	call   3d7 <putc>
+ 60f:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 612:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 615:	0f be c0             	movsbl %al,%eax
+ 618:	83 ec 08             	sub    $0x8,%esp
+ 61b:	50                   	push   %eax
+ 61c:	ff 75 08             	pushl  0x8(%ebp)
+ 61f:	e8 b3 fd ff ff       	call   3d7 <putc>
+ 624:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 627:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 62e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 632:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 635:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 638:	01 d0                	add    %edx,%eax
+ 63a:	0f b6 00             	movzbl (%eax),%eax
+ 63d:	84 c0                	test   %al,%al
+ 63f:	0f 85 94 fe ff ff    	jne    4d9 <printf+0x26>
+    }
+  }
+}
+ 645:	90                   	nop
+ 646:	90                   	nop
+ 647:	c9                   	leave  
+ 648:	c3                   	ret    
+
+00000649 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 649:	f3 0f 1e fb          	endbr32 
+ 64d:	55                   	push   %ebp
+ 64e:	89 e5                	mov    %esp,%ebp
+ 650:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 653:	8b 45 08             	mov    0x8(%ebp),%eax
+ 656:	83 e8 08             	sub    $0x8,%eax
+ 659:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 65c:	a1 14 0b 00 00       	mov    0xb14,%eax
+ 661:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 664:	eb 24                	jmp    68a <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 666:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 669:	8b 00                	mov    (%eax),%eax
+ 66b:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 66e:	72 12                	jb     682 <free+0x39>
+ 670:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 673:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 676:	77 24                	ja     69c <free+0x53>
+ 678:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 67b:	8b 00                	mov    (%eax),%eax
+ 67d:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 680:	72 1a                	jb     69c <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 682:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 685:	8b 00                	mov    (%eax),%eax
+ 687:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 68a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 68d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 690:	76 d4                	jbe    666 <free+0x1d>
+ 692:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 695:	8b 00                	mov    (%eax),%eax
+ 697:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 69a:	73 ca                	jae    666 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 69c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 69f:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ac:	01 c2                	add    %eax,%edx
+ 6ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b1:	8b 00                	mov    (%eax),%eax
+ 6b3:	39 c2                	cmp    %eax,%edx
+ 6b5:	75 24                	jne    6db <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 6b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ba:	8b 50 04             	mov    0x4(%eax),%edx
+ 6bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c0:	8b 00                	mov    (%eax),%eax
+ 6c2:	8b 40 04             	mov    0x4(%eax),%eax
+ 6c5:	01 c2                	add    %eax,%edx
+ 6c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6ca:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 6cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6d0:	8b 00                	mov    (%eax),%eax
+ 6d2:	8b 10                	mov    (%eax),%edx
+ 6d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6d7:	89 10                	mov    %edx,(%eax)
+ 6d9:	eb 0a                	jmp    6e5 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 6db:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6de:	8b 10                	mov    (%eax),%edx
+ 6e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6e3:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 6e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6e8:	8b 40 04             	mov    0x4(%eax),%eax
+ 6eb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 6f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6f5:	01 d0                	add    %edx,%eax
+ 6f7:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 6fa:	75 20                	jne    71c <free+0xd3>
+    p->s.size += bp->s.size;
+ 6fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6ff:	8b 50 04             	mov    0x4(%eax),%edx
+ 702:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 705:	8b 40 04             	mov    0x4(%eax),%eax
+ 708:	01 c2                	add    %eax,%edx
+ 70a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 70d:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 710:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 713:	8b 10                	mov    (%eax),%edx
+ 715:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 718:	89 10                	mov    %edx,(%eax)
+ 71a:	eb 08                	jmp    724 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 71c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 71f:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 722:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 724:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 727:	a3 14 0b 00 00       	mov    %eax,0xb14
+}
+ 72c:	90                   	nop
+ 72d:	c9                   	leave  
+ 72e:	c3                   	ret    
+
+0000072f <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 72f:	f3 0f 1e fb          	endbr32 
+ 733:	55                   	push   %ebp
+ 734:	89 e5                	mov    %esp,%ebp
+ 736:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 739:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 740:	77 07                	ja     749 <morecore+0x1a>
+    nu = 4096;
+ 742:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 749:	8b 45 08             	mov    0x8(%ebp),%eax
+ 74c:	c1 e0 03             	shl    $0x3,%eax
+ 74f:	83 ec 0c             	sub    $0xc,%esp
+ 752:	50                   	push   %eax
+ 753:	e8 3f fc ff ff       	call   397 <sbrk>
+ 758:	83 c4 10             	add    $0x10,%esp
+ 75b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 75e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 762:	75 07                	jne    76b <morecore+0x3c>
+    return 0;
+ 764:	b8 00 00 00 00       	mov    $0x0,%eax
+ 769:	eb 26                	jmp    791 <morecore+0x62>
+  hp = (Header*)p;
+ 76b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 76e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 771:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 774:	8b 55 08             	mov    0x8(%ebp),%edx
+ 777:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 77a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 77d:	83 c0 08             	add    $0x8,%eax
+ 780:	83 ec 0c             	sub    $0xc,%esp
+ 783:	50                   	push   %eax
+ 784:	e8 c0 fe ff ff       	call   649 <free>
+ 789:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 78c:	a1 14 0b 00 00       	mov    0xb14,%eax
+}
+ 791:	c9                   	leave  
+ 792:	c3                   	ret    
+
+00000793 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 793:	f3 0f 1e fb          	endbr32 
+ 797:	55                   	push   %ebp
+ 798:	89 e5                	mov    %esp,%ebp
+ 79a:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 79d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 7a0:	83 c0 07             	add    $0x7,%eax
+ 7a3:	c1 e8 03             	shr    $0x3,%eax
+ 7a6:	83 c0 01             	add    $0x1,%eax
+ 7a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 7ac:	a1 14 0b 00 00       	mov    0xb14,%eax
+ 7b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 7b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 7b8:	75 23                	jne    7dd <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 7ba:	c7 45 f0 0c 0b 00 00 	movl   $0xb0c,-0x10(%ebp)
+ 7c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7c4:	a3 14 0b 00 00       	mov    %eax,0xb14
+ 7c9:	a1 14 0b 00 00       	mov    0xb14,%eax
+ 7ce:	a3 0c 0b 00 00       	mov    %eax,0xb0c
+    base.s.size = 0;
+ 7d3:	c7 05 10 0b 00 00 00 	movl   $0x0,0xb10
+ 7da:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7e0:	8b 00                	mov    (%eax),%eax
+ 7e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 7e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7e8:	8b 40 04             	mov    0x4(%eax),%eax
+ 7eb:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7ee:	77 4d                	ja     83d <malloc+0xaa>
+      if(p->s.size == nunits)
+ 7f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7f3:	8b 40 04             	mov    0x4(%eax),%eax
+ 7f6:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 7f9:	75 0c                	jne    807 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 7fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7fe:	8b 10                	mov    (%eax),%edx
+ 800:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 803:	89 10                	mov    %edx,(%eax)
+ 805:	eb 26                	jmp    82d <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 807:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80a:	8b 40 04             	mov    0x4(%eax),%eax
+ 80d:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 810:	89 c2                	mov    %eax,%edx
+ 812:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 815:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 818:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 81b:	8b 40 04             	mov    0x4(%eax),%eax
+ 81e:	c1 e0 03             	shl    $0x3,%eax
+ 821:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 824:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 827:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 82a:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 82d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 830:	a3 14 0b 00 00       	mov    %eax,0xb14
+      return (void*)(p + 1);
+ 835:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 838:	83 c0 08             	add    $0x8,%eax
+ 83b:	eb 3b                	jmp    878 <malloc+0xe5>
+    }
+    if(p == freep)
+ 83d:	a1 14 0b 00 00       	mov    0xb14,%eax
+ 842:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 845:	75 1e                	jne    865 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 847:	83 ec 0c             	sub    $0xc,%esp
+ 84a:	ff 75 ec             	pushl  -0x14(%ebp)
+ 84d:	e8 dd fe ff ff       	call   72f <morecore>
+ 852:	83 c4 10             	add    $0x10,%esp
+ 855:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 858:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 85c:	75 07                	jne    865 <malloc+0xd2>
+        return 0;
+ 85e:	b8 00 00 00 00       	mov    $0x0,%eax
+ 863:	eb 13                	jmp    878 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 865:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 868:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 86b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 86e:	8b 00                	mov    (%eax),%eax
+ 870:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 873:	e9 6d ff ff ff       	jmp    7e5 <malloc+0x52>
+  }
+}
+ 878:	c9                   	leave  
+ 879:	c3                   	ret    
diff -ruN xv6-public/xv6-public/rm.c xv6-public_new/xv6-public/rm.c
--- xv6-public/xv6-public/rm.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/rm.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,23 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+
+  if(argc < 2){
+    printf(2, "Usage: rm files...\n");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if(unlink(argv[i]) < 0){
+      printf(2, "rm: %s failed to delete\n", argv[i]);
+      break;
+    }
+  }
+
+  exit();
+}
diff -ruN xv6-public/xv6-public/rm.d xv6-public_new/xv6-public/rm.d
--- xv6-public/xv6-public/rm.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/rm.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+rm.o: rm.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/rm.o and xv6-public_new/xv6-public/rm.o differ
diff -ruN xv6-public/xv6-public/rm.sym xv6-public_new/xv6-public/rm.sym
--- xv6-public/xv6-public/rm.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/rm.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+0000087a .rodata
+000008b0 .eh_frame
+00000af8 .data
+00000b0c .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 rm.c
+00000000 ulib.c
+00000094 stosb
+00000000 printf.c
+000003d7 putc
+000003fe printint
+00000af8 digits.1098
+00000000 umalloc.c
+00000b0c base
+00000b14 freep
+0000072f morecore
+000000ba strcpy
+000003bf yield
+000003cf set_prio
+000004b3 printf
+000002c6 memmove
+00000357 mknod
+000001b1 gets
+0000038f getpid
+00000793 malloc
+0000039f sleep
+000003c7 wait2
+0000031f pipe
+0000032f write
+00000367 fstat
+0000033f kill
+0000037f chdir
+00000347 exec
+00000317 wait
+00000327 read
+0000035f unlink
+00000307 fork
+00000397 sbrk
+000003a7 uptime
+00000b09 __bss_start
+0000015c memset
+00000000 main
+000000ee strcmp
+00000387 dup
+00000224 stat
+00000b09 _edata
+00000b18 _end
+0000036f link
+0000030f exit
+00000275 atoi
+000003af draw
+00000131 strlen
+0000034f open
+0000017a strchr
+000003b7 cps
+00000377 mkdir
+00000337 close
+00000649 free
diff -ruN xv6-public/xv6-public/runoff xv6-public_new/xv6-public/runoff
--- xv6-public/xv6-public/runoff	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/runoff	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,246 @@
+#!/bin/sh
+
+echo This script takes a minute to run.  Be patient. 1>&2
+
+LC_CTYPE=C export LC_CTYPE
+
+# pad stdin to multiple of 120 lines
+pad()
+{
+	awk '{print} END{for(; NR%120!=0; NR++) print ""}'
+}
+
+# create formatted (numbered) files
+mkdir -p fmt
+rm -f fmt/*
+cp README fmt
+echo > fmt/blank
+files=`grep -v '^#' runoff.list | awk '{print $1}'`
+n=99
+for i in $files
+do
+	./runoff1 -n $n $i >fmt/$i
+	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
+	if [ "x$nn" != x ]; then
+		n=$nn
+	fi
+done
+
+# create table of contents
+cat toc.hdr >fmt/toc
+pr -e8 -t runoff.list | awk '
+/^[a-z0-9]/ {
+	s=$0
+	f="fmt/"$1
+	getline<f
+	close(f)
+	n=$1
+	printf("%02d %s\n", n/100, s);
+	printf("TOC: %04d %s\n", n, s) >"fmt/tocdata"
+	next
+}
+{
+	print
+}' | pr -3 -t >>fmt/toc
+cat toc.ftr >>fmt/toc
+
+# check for bad alignments
+perl -e '
+	$leftwarn = 0;
+	while(<>){
+		chomp;
+		s!#.*!!;
+		s!\s+! !g;
+		s! +$!!;
+		next if /^$/;
+		
+		if(/TOC: (\d+) (.*)/){
+			$toc{$2} = $1;
+			next;
+		}
+		
+		if(/sheet1: (left|right)$/){
+			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
+			$left = $1 eq "left" ? "13579" : "02468";
+			$right = $1 eq "left" ? "02468" : "13579";
+			next;
+		}
+		
+		if(/even: (.*)/){
+			$file = $1;
+			if(!defined($toc{$file})){
+				print STDERR "Have no toc for $file\n";
+				next;
+			}
+			if($toc{$file} =~ /^\d\d[^0]/){
+				print STDERR "$file does not start on a fresh page.\n";
+			}
+			next;
+		}
+		
+		if(/odd: (.*)/){
+			$file = $1;
+			if(!defined($toc{$file})){
+				print STDERR "Have no toc for $file\n";
+				next;
+			}
+			if($toc{$file} !~ /^\d\d5/){
+				print STDERR "$file does not start on a second half page.\n";
+			}
+			next;
+		}
+		
+		if(/(left|right): (.*)/){
+			$what = $1;
+			$file = $2;
+			if(!defined($toc{$file})){
+				print STDERR "Have no toc for $file\n";
+				next;
+			}
+			if($what eq "left" && !($toc{$file} =~ /^\d[$left][05]/)){
+				print STDERR "$file does not start on a left page [$toc{$file}]\n";
+			}
+			# why does this not work if I inline $x in the if?
+			$x = ($toc{$file} =~ /^\d[$right][05]/);
+			if($what eq "right" && !$x){
+				print STDERR "$file does not start on a right page [$toc{$file}] [$x]\n";
+			}
+			next;
+		}
+		
+		print STDERR "Unknown spec: $_\n";
+	}
+' fmt/tocdata runoff.spec
+
+# make definition list
+cd fmt
+perl -e '
+	while(<>) {
+		chomp;
+
+		s!//.*!!;
+		s!/\*([^*]|[*][^/])*\*/!!g;
+		s!\s! !g;
+		s! +$!!;
+
+		# look for declarations like char* x;
+		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
+			next;
+		}
+		if (/^[0-9]+ extern/) {
+			next;
+		}
+		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
+			next;
+		}
+		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
+			print "$1 $2\n"
+		}
+		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
+			print "$1 $2 $3\n";
+		}
+		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
+			print "$1 $2\n";
+		}
+		
+		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
+			$isglobl{$2} = 1;
+		}
+		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
+			print "$1 $2\n";
+		}
+		
+		if (/\(/) {
+			next;
+		}
+
+		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
+			print "$1 $7\n";
+		}
+		
+		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
+			print "$1 $3\n";
+		}
+		# TODO: enum members
+	}
+' $files >defs
+
+(for i in $files
+do
+	case "$i" in
+	*.S)
+		cat $i | sed 's;#.*;;; s;//.*;;;'
+		;;
+	*)
+		cat $i | sed 's;//.*;;; s;"([^"\\]|\\.)*";;;'
+	esac
+done
+) >alltext
+
+perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
+	egrep -v ' (STUB|usage|main|if|for)$' >>defs
+#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
+#	>>defs
+(
+>s.defs
+
+# make reference list
+for i in `awk '{print $2}' defs | sort -f | uniq`
+do
+	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
+	echo $i $defs >>s.defs
+	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
+	if [ "x$defs" != "x$uses" ]; then
+		echo $i $defs
+		echo $uses |fmt -29 | sed 's/^/    /'
+#	else
+#		echo $i defined but not used >&2
+	fi
+done
+) >refs
+
+# build defs list
+awk '
+{
+	printf("%04d %s\n", $2, $1);
+	for(i=3; i<=NF; i++)
+		printf("%04d    \" \n", $i);
+}
+' s.defs > t.defs
+
+# format the whole thing
+(
+	../pr.pl README
+	../pr.pl -h "table of contents" toc
+	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
+	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
+	# pr.pl -h "definitions" -2 t.defs | pad
+	# pr.pl -h "cross-references" -2 refs | pad
+	../pr.pl blank  # make sheet 1 start on left page
+	../pr.pl blank
+	for i in $files
+	do
+		../pr.pl -h "xv6/$i" $i
+	done
+) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
+grep Pages: all.ps
+
+# if we have the nice font, use it
+nicefont=LucidaSans-Typewriter83
+if [ ! -f ../$nicefont ]
+then
+	if git cat-file blob font:$nicefont > ../$nicefont~; then
+		mv ../$nicefont~ ../$nicefont
+	fi
+fi
+if [ -f ../$nicefont ]
+then
+	echo nicefont
+	(sed 1q all.ps; cat ../$nicefont; sed "1d; s/Courier/$nicefont/" all.ps) >allf.ps
+else
+	echo ugly font!
+	cp all.ps allf.ps
+fi
+ps2pdf allf.ps ../xv6.pdf
+# cd ..
+# pdftops xv6.pdf xv6.ps
diff -ruN xv6-public/xv6-public/runoff.list xv6-public_new/xv6-public/runoff.list
--- xv6-public/xv6-public/runoff.list	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/runoff.list	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,80 @@
+# basic headers
+types.h
+param.h
+memlayout.h
+defs.h
+x86.h
+asm.h
+mmu.h
+elf.h
+date.h
+
+# entering xv6
+entry.S
+entryother.S
+main.c
+
+# locks
+spinlock.h
+spinlock.c
+
+# processes
+vm.c
+proc.h
+proc.c
+swtch.S
+kalloc.c
+
+# system calls
+traps.h
+vectors.pl
+trapasm.S
+trap.c
+syscall.h
+syscall.c
+sysproc.c
+
+# file system
+buf.h
+sleeplock.h
+fcntl.h
+stat.h
+fs.h
+file.h
+ide.c
+bio.c
+sleeplock.c
+log.c
+fs.c
+file.c
+sysfile.c
+exec.c
+
+# pipes
+pipe.c
+
+# string operations
+string.c
+
+# low-level hardware
+mp.h
+mp.c
+lapic.c
+ioapic.c
+kbd.h
+kbd.c
+console.c
+uart.c
+
+# user-level
+initcode.S
+usys.S
+init.c
+sh.c
+
+# bootloader
+bootasm.S
+bootmain.c
+
+# link
+kernel.ld
diff -ruN xv6-public/xv6-public/runoff.spec xv6-public_new/xv6-public/runoff.spec
--- xv6-public/xv6-public/runoff.spec	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/runoff.spec	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,102 @@
+# Is sheet 01 (after the TOC) a left sheet or a right sheet?
+sheet1: left
+
+# "left" and "right" specify which page of a two-page spread a file
+# must start on.  "left" means that a file must start on the first of
+# the two pages.  "right" means it must start on the second of the two
+# pages.  The file may start in either column.
+#
+# "even" and "odd" specify which column a file must start on.  "even"
+# means it must start in the left of the two columns (00).  "odd" means it
+# must start in the right of the two columns (50).
+#
+# You'd think these would be the other way around.
+
+# types.h either
+# param.h either
+# defs.h either
+# x86.h either
+# asm.h either
+# mmu.h either
+# elf.h either
+# mp.h either
+
+even: entry.S  # mild preference
+even: entryother.S  # mild preference
+even: main.c
+# mp.c don't care at all
+# even: initcode.S
+# odd: init.c
+
+left: spinlock.h
+even: spinlock.h
+
+# This gets struct proc and allocproc on the same spread
+left: proc.h
+even: proc.h
+
+# goal is to have two action-packed 2-page spreads,
+# one with
+#     userinit growproc fork exit wait
+# and another with
+#     scheduler sched yield forkret sleep wakeup1 wakeup
+right: proc.c   # VERY important
+even: proc.c   # VERY important
+
+# A few more action packed spreads
+# page table creation and process loading
+#     walkpgdir mappages setupkvm switch[ku]vm inituvm (loaduvm)
+# process memory management
+#     allocuvm deallocuvm freevm
+left: vm.c
+
+even: kalloc.c  # mild preference
+
+# syscall.h either
+# trapasm.S either
+# traps.h either
+# even: trap.c
+# vectors.pl either
+# syscall.c either
+# sysproc.c either
+
+# buf.h either
+# dev.h either
+# fcntl.h either
+# stat.h either
+# file.h either
+# fs.h either
+# fsvar.h either
+# left: ide.c # mild preference
+even: ide.c
+# odd: bio.c
+
+# log.c fits nicely in a spread
+even: log.c
+left: log.c
+
+# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
+#	ialloc iupdate iget idup ilock iunlock iput iunlockput
+#	bmap itrunc stati readi writei
+#	namecmp dirlookup dirlink skipelem namex namei
+#	fileinit filealloc filedup fileclose filestat fileread filewrite
+# starting on 2nd column of a right page is not terrible either
+odd: fs.c   # VERY important
+left: fs.c  # mild preference
+# file.c either
+# exec.c either
+# sysfile.c either
+
+# Mild preference, but makes spreads of mp.c, lapic.c, and ioapic.c+picirq.c
+even: mp.c
+left: mp.c
+
+# even: pipe.c  # mild preference
+# string.c either
+# left: kbd.h  # mild preference
+even: kbd.h
+even: console.c
+odd: sh.c
+
+even: bootasm.S   # mild preference
+even: bootmain.c  # mild preference
diff -ruN xv6-public/xv6-public/runoff1 xv6-public_new/xv6-public/runoff1
--- xv6-public/xv6-public/runoff1	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/runoff1	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,108 @@
+#!/usr/bin/perl
+
+$n = 0;
+$v = 0;
+if($ARGV[0] eq "-v") {
+	$v = 1;
+	shift @ARGV;
+}
+if($ARGV[0] eq "-n") {
+	$n = $ARGV[1];
+	shift @ARGV;
+	shift @ARGV;
+}
+$n = int(($n+49)/50)*50 - 1;
+
+$file = $ARGV[0];
+@lines = <>;
+$linenum = 0;
+foreach (@lines) {
+	$linenum++;
+	chomp;
+	s/\s+$//;
+	if(length() >= 75){
+		print STDERR "$file:$linenum: line too long\n";
+	}
+}
+@outlines = ();
+$nextout = 0;
+
+for($i=0; $i<@lines; ){
+	# Skip leading blank lines.
+	$i++ while $i<@lines && $lines[$i] =~ /^$/;
+	last if $i>=@lines;
+
+	# If the rest of the file fits, use the whole thing.
+	if(@lines <= $i+50 && !grep { /PAGEBREAK/ } @lines){
+		$breakbefore = @lines;
+	}else{
+		# Find a good next page break;
+		# Hope for end of function.
+		# but settle for a blank line (but not first blank line
+		# in function, which comes after variable declarations).
+		$breakbefore = $i;
+		$lastblank = $i;
+		$sawbrace = 0;
+		$breaksize = 15;  # 15 lines to get to function
+		for($j=$i; $j<$i+50 && $j < @lines; $j++){
+			if($lines[$j] =~ /PAGEBREAK!/){
+				$lines[$j] = "";
+				$breakbefore = $j;
+				$breaksize = 100;
+				last;
+			}
+			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
+				$breaksize = $1;
+				$breakbefore = $j;
+				$lines[$j] = "";
+			}
+			if($lines[$j] =~ /^};?$/){
+				$breakbefore = $j+1;
+				$breaksize = 15;
+			}
+			if($lines[$j] =~ /^{$/){
+				$sawbrace = 1;
+			}
+			if($lines[$j] =~ /^$/){
+				if($sawbrace){
+					$sawbrace = 0;
+				}else{
+					$lastblank = $j;
+				}
+			}
+		}
+		if($j<@lines && $lines[$j] =~ /^$/){
+			$lastblank = $j;
+		}
+
+		# If we are not putting enough on a page, try a blank line.
+		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
+			if($v){
+				print STDERR "breakbefore $breakbefore i $i breaksize $breaksize\n";
+			}
+			$breakbefore = $lastblank;
+			$breaksize = 5;  # only 5 lines to get to blank line
+		}
+
+		# If we are not putting enough on a page, force a full page.
+		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
+			$breakbefore = $i + 50;
+			$breakbefore = @lines if @lines < $breakbefore;
+		}
+
+		if($breakbefore < $i+2){
+			$breakbefore = $i+2;
+		}
+	}
+
+	# Emit the page.
+	$i50 = $i + 50;
+	for(; $i<$breakbefore; $i++){
+		printf "%04d %s\n", ++$n, $lines[$i];
+	}
+
+	# Finish page
+	for($j=$i; $j<$i50; $j++){
+		printf "%04d \n", ++$n;
+	}
+}
diff -ruN xv6-public/xv6-public/sanity.asm xv6-public_new/xv6-public/sanity.asm
--- xv6-public/xv6-public/sanity.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sanity.asm	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,1558 @@
+
+_sanity:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "user.h"
+
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	53                   	push   %ebx
+  12:	51                   	push   %ecx
+  13:	83 ec 50             	sub    $0x50,%esp
+  16:	89 ca                	mov    %ecx,%edx
+	if (argc != 2){
+  18:	83 3a 02             	cmpl   $0x2,(%edx)
+  1b:	74 17                	je     34 <main+0x34>
+				printf(1, "Usage: sanity <n>\n");
+  1d:	83 ec 08             	sub    $0x8,%esp
+  20:	68 00 0c 00 00       	push   $0xc00
+  25:	6a 01                	push   $0x1
+  27:	e8 0a 08 00 00       	call   836 <printf>
+  2c:	83 c4 10             	add    $0x10,%esp
+				exit();
+  2f:	e8 5e 06 00 00       	call   692 <exit>
+ 		}
+	int i;
+	int n;
+	int j = 0;
+  34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+	int k;
+	int retime;
+	int rutime;
+	int stime;
+	int sums[3][3];
+	for (i = 0; i < 3; i++)
+  3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  42:	eb 2d                	jmp    71 <main+0x71>
+		for (j = 0; j < 3; j++)
+  44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  4b:	eb 1a                	jmp    67 <main+0x67>
+			sums[i][j] = 0;
+  4d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+  50:	89 c8                	mov    %ecx,%eax
+  52:	01 c0                	add    %eax,%eax
+  54:	01 c8                	add    %ecx,%eax
+  56:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+  59:	01 c8                	add    %ecx,%eax
+  5b:	c7 44 85 b0 00 00 00 	movl   $0x0,-0x50(%ebp,%eax,4)
+  62:	00 
+		for (j = 0; j < 3; j++)
+  63:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  67:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+  6b:	7e e0                	jle    4d <main+0x4d>
+	for (i = 0; i < 3; i++)
+  6d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  71:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
+  75:	7e cd                	jle    44 <main+0x44>
+	n = atoi(argv[1]);
+  77:	8b 42 04             	mov    0x4(%edx),%eax
+  7a:	83 c0 04             	add    $0x4,%eax
+  7d:	8b 00                	mov    (%eax),%eax
+  7f:	83 ec 0c             	sub    $0xc,%esp
+  82:	50                   	push   %eax
+  83:	e8 70 05 00 00       	call   5f8 <atoi>
+  88:	83 c4 10             	add    $0x10,%esp
+  8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+	i = n; //unimportant
+  8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  91:	89 45 f4             	mov    %eax,-0xc(%ebp)
+	int pid;
+	for (i = 0; i < 3 * n; i++) {
+  94:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  9b:	e9 02 01 00 00       	jmp    1a2 <main+0x1a2>
+		j = i % 3;
+  a0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+  a3:	ba 56 55 55 55       	mov    $0x55555556,%edx
+  a8:	89 c8                	mov    %ecx,%eax
+  aa:	f7 ea                	imul   %edx
+  ac:	89 c8                	mov    %ecx,%eax
+  ae:	c1 f8 1f             	sar    $0x1f,%eax
+  b1:	29 c2                	sub    %eax,%edx
+  b3:	89 d0                	mov    %edx,%eax
+  b5:	01 c0                	add    %eax,%eax
+  b7:	01 d0                	add    %edx,%eax
+  b9:	29 c1                	sub    %eax,%ecx
+  bb:	89 c8                	mov    %ecx,%eax
+  bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+		pid = fork();
+  c0:	e8 c5 05 00 00       	call   68a <fork>
+  c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		if (pid == 0) {//child
+  c8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  cc:	0f 85 cc 00 00 00    	jne    19e <main+0x19e>
+			j = (getpid() - 4) % 3; // ensures independence from the first son's pid when gathering the results in the second part of the program
+  d2:	e8 3b 06 00 00       	call   712 <getpid>
+  d7:	8d 48 fc             	lea    -0x4(%eax),%ecx
+  da:	ba 56 55 55 55       	mov    $0x55555556,%edx
+  df:	89 c8                	mov    %ecx,%eax
+  e1:	f7 ea                	imul   %edx
+  e3:	89 c8                	mov    %ecx,%eax
+  e5:	c1 f8 1f             	sar    $0x1f,%eax
+  e8:	29 c2                	sub    %eax,%edx
+  ea:	89 d0                	mov    %edx,%eax
+  ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  f2:	89 d0                	mov    %edx,%eax
+  f4:	01 c0                	add    %eax,%eax
+  f6:	01 d0                	add    %edx,%eax
+  f8:	29 c1                	sub    %eax,%ecx
+  fa:	89 c8                	mov    %ecx,%eax
+  fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
+			switch(j) {
+  ff:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+ 103:	74 73                	je     178 <main+0x178>
+ 105:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+ 109:	0f 8f 8a 00 00 00    	jg     199 <main+0x199>
+ 10f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 113:	74 08                	je     11d <main+0x11d>
+ 115:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
+ 119:	74 2d                	je     148 <main+0x148>
+ 11b:	eb 7c                	jmp    199 <main+0x199>
+				case 0: //CPU‐bound process (CPU):
+					for (k = 0; k < 100; k++){
+ 11d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+ 124:	eb 1a                	jmp    140 <main+0x140>
+						for (j = 0; j < 1000000; j++){}
+ 126:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 12d:	eb 04                	jmp    133 <main+0x133>
+ 12f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 133:	81 7d f0 3f 42 0f 00 	cmpl   $0xf423f,-0x10(%ebp)
+ 13a:	7e f3                	jle    12f <main+0x12f>
+					for (k = 0; k < 100; k++){
+ 13c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+ 140:	83 7d ec 63          	cmpl   $0x63,-0x14(%ebp)
+ 144:	7e e0                	jle    126 <main+0x126>
+					}
+					break;
+ 146:	eb 51                	jmp    199 <main+0x199>
+				case 1: //short tasks based CPU‐bound process (S‐CPU):
+					for (k = 0; k < 100; k++){
+ 148:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+ 14f:	eb 1f                	jmp    170 <main+0x170>
+						for (j = 0; j < 1000000; j++){}
+ 151:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 158:	eb 04                	jmp    15e <main+0x15e>
+ 15a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 15e:	81 7d f0 3f 42 0f 00 	cmpl   $0xf423f,-0x10(%ebp)
+ 165:	7e f3                	jle    15a <main+0x15a>
+						yield();
+ 167:	e8 d6 05 00 00       	call   742 <yield>
+					for (k = 0; k < 100; k++){
+ 16c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+ 170:	83 7d ec 63          	cmpl   $0x63,-0x14(%ebp)
+ 174:	7e db                	jle    151 <main+0x151>
+					}
+					break;
+ 176:	eb 21                	jmp    199 <main+0x199>
+				case 2:// simulate I/O bound process (IO)
+					for(k = 0; k < 100; k++){
+ 178:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+ 17f:	eb 11                	jmp    192 <main+0x192>
+						sleep(1);
+ 181:	83 ec 0c             	sub    $0xc,%esp
+ 184:	6a 01                	push   $0x1
+ 186:	e8 97 05 00 00       	call   722 <sleep>
+ 18b:	83 c4 10             	add    $0x10,%esp
+					for(k = 0; k < 100; k++){
+ 18e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+ 192:	83 7d ec 63          	cmpl   $0x63,-0x14(%ebp)
+ 196:	7e e9                	jle    181 <main+0x181>
+					}
+					break;
+ 198:	90                   	nop
+			}
+			exit(); // children exit here
+ 199:	e8 f4 04 00 00       	call   692 <exit>
+	for (i = 0; i < 3 * n; i++) {
+ 19e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 1a2:	8b 55 e8             	mov    -0x18(%ebp),%edx
+ 1a5:	89 d0                	mov    %edx,%eax
+ 1a7:	01 c0                	add    %eax,%eax
+ 1a9:	01 d0                	add    %edx,%eax
+ 1ab:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 1ae:	0f 8c ec fe ff ff    	jl     a0 <main+0xa0>
+		}
+		continue; // father continues to spawn the next child
+	}
+	for (i = 0; i < 3 * n; i++) {
+ 1b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 1bb:	e9 69 01 00 00       	jmp    329 <main+0x329>
+		pid = wait2(&retime, &rutime, &stime);
+ 1c0:	83 ec 04             	sub    $0x4,%esp
+ 1c3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+ 1c6:	50                   	push   %eax
+ 1c7:	8d 45 d8             	lea    -0x28(%ebp),%eax
+ 1ca:	50                   	push   %eax
+ 1cb:	8d 45 dc             	lea    -0x24(%ebp),%eax
+ 1ce:	50                   	push   %eax
+ 1cf:	e8 76 05 00 00       	call   74a <wait2>
+ 1d4:	83 c4 10             	add    $0x10,%esp
+ 1d7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+		int res = (pid - 4) % 3; // correlates to j in the dispatching loop
+ 1da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 1dd:	8d 48 fc             	lea    -0x4(%eax),%ecx
+ 1e0:	ba 56 55 55 55       	mov    $0x55555556,%edx
+ 1e5:	89 c8                	mov    %ecx,%eax
+ 1e7:	f7 ea                	imul   %edx
+ 1e9:	89 c8                	mov    %ecx,%eax
+ 1eb:	c1 f8 1f             	sar    $0x1f,%eax
+ 1ee:	29 c2                	sub    %eax,%edx
+ 1f0:	89 d0                	mov    %edx,%eax
+ 1f2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+ 1f5:	8b 55 e0             	mov    -0x20(%ebp),%edx
+ 1f8:	89 d0                	mov    %edx,%eax
+ 1fa:	01 c0                	add    %eax,%eax
+ 1fc:	01 d0                	add    %edx,%eax
+ 1fe:	29 c1                	sub    %eax,%ecx
+ 200:	89 c8                	mov    %ecx,%eax
+ 202:	89 45 e0             	mov    %eax,-0x20(%ebp)
+		switch(res) {
+ 205:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
+ 209:	0f 84 c4 00 00 00    	je     2d3 <main+0x2d3>
+ 20f:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
+ 213:	0f 8f 0c 01 00 00    	jg     325 <main+0x325>
+ 219:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+ 21d:	74 0b                	je     22a <main+0x22a>
+ 21f:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
+ 223:	74 5b                	je     280 <main+0x280>
+ 225:	e9 fb 00 00 00       	jmp    325 <main+0x325>
+			case 0: // CPU bound processes
+				printf(1, "CPU-bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+ 22a:	8b 55 dc             	mov    -0x24(%ebp),%edx
+ 22d:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 230:	01 c2                	add    %eax,%edx
+ 232:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 235:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 238:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
+ 23b:	8b 55 d8             	mov    -0x28(%ebp),%edx
+ 23e:	8b 45 dc             	mov    -0x24(%ebp),%eax
+ 241:	83 ec 04             	sub    $0x4,%esp
+ 244:	53                   	push   %ebx
+ 245:	51                   	push   %ecx
+ 246:	52                   	push   %edx
+ 247:	50                   	push   %eax
+ 248:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 24b:	68 14 0c 00 00       	push   $0xc14
+ 250:	6a 01                	push   $0x1
+ 252:	e8 df 05 00 00       	call   836 <printf>
+ 257:	83 c4 20             	add    $0x20,%esp
+				sums[0][0] += retime;
+ 25a:	8b 55 b0             	mov    -0x50(%ebp),%edx
+ 25d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+ 260:	01 d0                	add    %edx,%eax
+ 262:	89 45 b0             	mov    %eax,-0x50(%ebp)
+				sums[0][1] += rutime;
+ 265:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+ 268:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 26b:	01 d0                	add    %edx,%eax
+ 26d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+				sums[0][2] += stime;
+ 270:	8b 55 b8             	mov    -0x48(%ebp),%edx
+ 273:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 276:	01 d0                	add    %edx,%eax
+ 278:	89 45 b8             	mov    %eax,-0x48(%ebp)
+				break;
+ 27b:	e9 a5 00 00 00       	jmp    325 <main+0x325>
+			case 1: // CPU bound processes, short tasks
+				printf(1, "CPU-S bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+ 280:	8b 55 dc             	mov    -0x24(%ebp),%edx
+ 283:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 286:	01 c2                	add    %eax,%edx
+ 288:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 28b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 28e:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
+ 291:	8b 55 d8             	mov    -0x28(%ebp),%edx
+ 294:	8b 45 dc             	mov    -0x24(%ebp),%eax
+ 297:	83 ec 04             	sub    $0x4,%esp
+ 29a:	53                   	push   %ebx
+ 29b:	51                   	push   %ecx
+ 29c:	52                   	push   %edx
+ 29d:	50                   	push   %eax
+ 29e:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 2a1:	68 60 0c 00 00       	push   $0xc60
+ 2a6:	6a 01                	push   $0x1
+ 2a8:	e8 89 05 00 00       	call   836 <printf>
+ 2ad:	83 c4 20             	add    $0x20,%esp
+				sums[1][0] += retime;
+ 2b0:	8b 55 bc             	mov    -0x44(%ebp),%edx
+ 2b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
+ 2b6:	01 d0                	add    %edx,%eax
+ 2b8:	89 45 bc             	mov    %eax,-0x44(%ebp)
+				sums[1][1] += rutime;
+ 2bb:	8b 55 c0             	mov    -0x40(%ebp),%edx
+ 2be:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 2c1:	01 d0                	add    %edx,%eax
+ 2c3:	89 45 c0             	mov    %eax,-0x40(%ebp)
+				sums[1][2] += stime;
+ 2c6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+ 2c9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 2cc:	01 d0                	add    %edx,%eax
+ 2ce:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+				break;
+ 2d1:	eb 52                	jmp    325 <main+0x325>
+			case 2: // simulating I/O bound processes
+				printf(1, "I/O bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+ 2d3:	8b 55 dc             	mov    -0x24(%ebp),%edx
+ 2d6:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 2d9:	01 c2                	add    %eax,%edx
+ 2db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 2de:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 2e1:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
+ 2e4:	8b 55 d8             	mov    -0x28(%ebp),%edx
+ 2e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
+ 2ea:	83 ec 04             	sub    $0x4,%esp
+ 2ed:	53                   	push   %ebx
+ 2ee:	51                   	push   %ecx
+ 2ef:	52                   	push   %edx
+ 2f0:	50                   	push   %eax
+ 2f1:	ff 75 e4             	pushl  -0x1c(%ebp)
+ 2f4:	68 ac 0c 00 00       	push   $0xcac
+ 2f9:	6a 01                	push   $0x1
+ 2fb:	e8 36 05 00 00       	call   836 <printf>
+ 300:	83 c4 20             	add    $0x20,%esp
+				sums[2][0] += retime;
+ 303:	8b 55 c8             	mov    -0x38(%ebp),%edx
+ 306:	8b 45 dc             	mov    -0x24(%ebp),%eax
+ 309:	01 d0                	add    %edx,%eax
+ 30b:	89 45 c8             	mov    %eax,-0x38(%ebp)
+				sums[2][1] += rutime;
+ 30e:	8b 55 cc             	mov    -0x34(%ebp),%edx
+ 311:	8b 45 d8             	mov    -0x28(%ebp),%eax
+ 314:	01 d0                	add    %edx,%eax
+ 316:	89 45 cc             	mov    %eax,-0x34(%ebp)
+				sums[2][2] += stime;
+ 319:	8b 55 d0             	mov    -0x30(%ebp),%edx
+ 31c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+ 31f:	01 d0                	add    %edx,%eax
+ 321:	89 45 d0             	mov    %eax,-0x30(%ebp)
+				break;
+ 324:	90                   	nop
+	for (i = 0; i < 3 * n; i++) {
+ 325:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 329:	8b 55 e8             	mov    -0x18(%ebp),%edx
+ 32c:	89 d0                	mov    %edx,%eax
+ 32e:	01 c0                	add    %eax,%eax
+ 330:	01 d0                	add    %edx,%eax
+ 332:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 335:	0f 8c 85 fe ff ff    	jl     1c0 <main+0x1c0>
+		}
+	}
+	for (i = 0; i < 3; i++)
+ 33b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 342:	eb 41                	jmp    385 <main+0x385>
+		for (j = 0; j < 3; j++)
+ 344:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 34b:	eb 2e                	jmp    37b <main+0x37b>
+			sums[i][j] /= n;
+ 34d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 350:	89 d0                	mov    %edx,%eax
+ 352:	01 c0                	add    %eax,%eax
+ 354:	01 d0                	add    %edx,%eax
+ 356:	8b 55 f0             	mov    -0x10(%ebp),%edx
+ 359:	01 d0                	add    %edx,%eax
+ 35b:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
+ 35f:	99                   	cltd   
+ 360:	f7 7d e8             	idivl  -0x18(%ebp)
+ 363:	89 c1                	mov    %eax,%ecx
+ 365:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 368:	89 d0                	mov    %edx,%eax
+ 36a:	01 c0                	add    %eax,%eax
+ 36c:	01 d0                	add    %edx,%eax
+ 36e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+ 371:	01 d0                	add    %edx,%eax
+ 373:	89 4c 85 b0          	mov    %ecx,-0x50(%ebp,%eax,4)
+		for (j = 0; j < 3; j++)
+ 377:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 37b:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+ 37f:	7e cc                	jle    34d <main+0x34d>
+	for (i = 0; i < 3; i++)
+ 381:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 385:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
+ 389:	7e b9                	jle    344 <main+0x344>
+	printf(1, "\n\nCPU bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[0][0], sums[0][1], sums[0][2], sums[0][0] + sums[0][1] + sums[0][2]);
+ 38b:	8b 55 b0             	mov    -0x50(%ebp),%edx
+ 38e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+ 391:	01 c2                	add    %eax,%edx
+ 393:	8b 45 b8             	mov    -0x48(%ebp),%eax
+ 396:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 399:	8b 4d b8             	mov    -0x48(%ebp),%ecx
+ 39c:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+ 39f:	8b 45 b0             	mov    -0x50(%ebp),%eax
+ 3a2:	83 ec 08             	sub    $0x8,%esp
+ 3a5:	53                   	push   %ebx
+ 3a6:	51                   	push   %ecx
+ 3a7:	52                   	push   %edx
+ 3a8:	50                   	push   %eax
+ 3a9:	68 f8 0c 00 00       	push   $0xcf8
+ 3ae:	6a 01                	push   $0x1
+ 3b0:	e8 81 04 00 00       	call   836 <printf>
+ 3b5:	83 c4 20             	add    $0x20,%esp
+	printf(1, "CPU-S bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[1][0], sums[1][1], sums[1][2], sums[1][0] + sums[1][1] + sums[1][2]);
+ 3b8:	8b 55 bc             	mov    -0x44(%ebp),%edx
+ 3bb:	8b 45 c0             	mov    -0x40(%ebp),%eax
+ 3be:	01 c2                	add    %eax,%edx
+ 3c0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+ 3c3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 3c6:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+ 3c9:	8b 55 c0             	mov    -0x40(%ebp),%edx
+ 3cc:	8b 45 bc             	mov    -0x44(%ebp),%eax
+ 3cf:	83 ec 08             	sub    $0x8,%esp
+ 3d2:	53                   	push   %ebx
+ 3d3:	51                   	push   %ecx
+ 3d4:	52                   	push   %edx
+ 3d5:	50                   	push   %eax
+ 3d6:	68 70 0d 00 00       	push   $0xd70
+ 3db:	6a 01                	push   $0x1
+ 3dd:	e8 54 04 00 00       	call   836 <printf>
+ 3e2:	83 c4 20             	add    $0x20,%esp
+	printf(1, "I/O bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[2][0], sums[2][1], sums[2][2], sums[2][0] + sums[2][1] + sums[2][2]);
+ 3e5:	8b 55 c8             	mov    -0x38(%ebp),%edx
+ 3e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
+ 3eb:	01 c2                	add    %eax,%edx
+ 3ed:	8b 45 d0             	mov    -0x30(%ebp),%eax
+ 3f0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
+ 3f3:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+ 3f6:	8b 55 cc             	mov    -0x34(%ebp),%edx
+ 3f9:	8b 45 c8             	mov    -0x38(%ebp),%eax
+ 3fc:	83 ec 08             	sub    $0x8,%esp
+ 3ff:	53                   	push   %ebx
+ 400:	51                   	push   %ecx
+ 401:	52                   	push   %edx
+ 402:	50                   	push   %eax
+ 403:	68 e8 0d 00 00       	push   $0xde8
+ 408:	6a 01                	push   $0x1
+ 40a:	e8 27 04 00 00       	call   836 <printf>
+ 40f:	83 c4 20             	add    $0x20,%esp
+	exit();
+ 412:	e8 7b 02 00 00       	call   692 <exit>
+
+00000417 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 417:	55                   	push   %ebp
+ 418:	89 e5                	mov    %esp,%ebp
+ 41a:	57                   	push   %edi
+ 41b:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 41c:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 41f:	8b 55 10             	mov    0x10(%ebp),%edx
+ 422:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 425:	89 cb                	mov    %ecx,%ebx
+ 427:	89 df                	mov    %ebx,%edi
+ 429:	89 d1                	mov    %edx,%ecx
+ 42b:	fc                   	cld    
+ 42c:	f3 aa                	rep stos %al,%es:(%edi)
+ 42e:	89 ca                	mov    %ecx,%edx
+ 430:	89 fb                	mov    %edi,%ebx
+ 432:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 435:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 438:	90                   	nop
+ 439:	5b                   	pop    %ebx
+ 43a:	5f                   	pop    %edi
+ 43b:	5d                   	pop    %ebp
+ 43c:	c3                   	ret    
+
+0000043d <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 43d:	f3 0f 1e fb          	endbr32 
+ 441:	55                   	push   %ebp
+ 442:	89 e5                	mov    %esp,%ebp
+ 444:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 447:	8b 45 08             	mov    0x8(%ebp),%eax
+ 44a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 44d:	90                   	nop
+ 44e:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 451:	8d 42 01             	lea    0x1(%edx),%eax
+ 454:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 457:	8b 45 08             	mov    0x8(%ebp),%eax
+ 45a:	8d 48 01             	lea    0x1(%eax),%ecx
+ 45d:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 460:	0f b6 12             	movzbl (%edx),%edx
+ 463:	88 10                	mov    %dl,(%eax)
+ 465:	0f b6 00             	movzbl (%eax),%eax
+ 468:	84 c0                	test   %al,%al
+ 46a:	75 e2                	jne    44e <strcpy+0x11>
+    ;
+  return os;
+ 46c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 46f:	c9                   	leave  
+ 470:	c3                   	ret    
+
+00000471 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 471:	f3 0f 1e fb          	endbr32 
+ 475:	55                   	push   %ebp
+ 476:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 478:	eb 08                	jmp    482 <strcmp+0x11>
+    p++, q++;
+ 47a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 47e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 482:	8b 45 08             	mov    0x8(%ebp),%eax
+ 485:	0f b6 00             	movzbl (%eax),%eax
+ 488:	84 c0                	test   %al,%al
+ 48a:	74 10                	je     49c <strcmp+0x2b>
+ 48c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 48f:	0f b6 10             	movzbl (%eax),%edx
+ 492:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 495:	0f b6 00             	movzbl (%eax),%eax
+ 498:	38 c2                	cmp    %al,%dl
+ 49a:	74 de                	je     47a <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 49c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 49f:	0f b6 00             	movzbl (%eax),%eax
+ 4a2:	0f b6 d0             	movzbl %al,%edx
+ 4a5:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4a8:	0f b6 00             	movzbl (%eax),%eax
+ 4ab:	0f b6 c0             	movzbl %al,%eax
+ 4ae:	29 c2                	sub    %eax,%edx
+ 4b0:	89 d0                	mov    %edx,%eax
+}
+ 4b2:	5d                   	pop    %ebp
+ 4b3:	c3                   	ret    
+
+000004b4 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 4b4:	f3 0f 1e fb          	endbr32 
+ 4b8:	55                   	push   %ebp
+ 4b9:	89 e5                	mov    %esp,%ebp
+ 4bb:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 4be:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 4c5:	eb 04                	jmp    4cb <strlen+0x17>
+ 4c7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 4cb:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 4ce:	8b 45 08             	mov    0x8(%ebp),%eax
+ 4d1:	01 d0                	add    %edx,%eax
+ 4d3:	0f b6 00             	movzbl (%eax),%eax
+ 4d6:	84 c0                	test   %al,%al
+ 4d8:	75 ed                	jne    4c7 <strlen+0x13>
+    ;
+  return n;
+ 4da:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 4dd:	c9                   	leave  
+ 4de:	c3                   	ret    
+
+000004df <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 4df:	f3 0f 1e fb          	endbr32 
+ 4e3:	55                   	push   %ebp
+ 4e4:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 4e6:	8b 45 10             	mov    0x10(%ebp),%eax
+ 4e9:	50                   	push   %eax
+ 4ea:	ff 75 0c             	pushl  0xc(%ebp)
+ 4ed:	ff 75 08             	pushl  0x8(%ebp)
+ 4f0:	e8 22 ff ff ff       	call   417 <stosb>
+ 4f5:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 4f8:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 4fb:	c9                   	leave  
+ 4fc:	c3                   	ret    
+
+000004fd <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 4fd:	f3 0f 1e fb          	endbr32 
+ 501:	55                   	push   %ebp
+ 502:	89 e5                	mov    %esp,%ebp
+ 504:	83 ec 04             	sub    $0x4,%esp
+ 507:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 50a:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 50d:	eb 14                	jmp    523 <strchr+0x26>
+    if(*s == c)
+ 50f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 512:	0f b6 00             	movzbl (%eax),%eax
+ 515:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 518:	75 05                	jne    51f <strchr+0x22>
+      return (char*)s;
+ 51a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 51d:	eb 13                	jmp    532 <strchr+0x35>
+  for(; *s; s++)
+ 51f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 523:	8b 45 08             	mov    0x8(%ebp),%eax
+ 526:	0f b6 00             	movzbl (%eax),%eax
+ 529:	84 c0                	test   %al,%al
+ 52b:	75 e2                	jne    50f <strchr+0x12>
+  return 0;
+ 52d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 532:	c9                   	leave  
+ 533:	c3                   	ret    
+
+00000534 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 534:	f3 0f 1e fb          	endbr32 
+ 538:	55                   	push   %ebp
+ 539:	89 e5                	mov    %esp,%ebp
+ 53b:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 53e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 545:	eb 42                	jmp    589 <gets+0x55>
+    cc = read(0, &c, 1);
+ 547:	83 ec 04             	sub    $0x4,%esp
+ 54a:	6a 01                	push   $0x1
+ 54c:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 54f:	50                   	push   %eax
+ 550:	6a 00                	push   $0x0
+ 552:	e8 53 01 00 00       	call   6aa <read>
+ 557:	83 c4 10             	add    $0x10,%esp
+ 55a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 55d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 561:	7e 33                	jle    596 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 563:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 566:	8d 50 01             	lea    0x1(%eax),%edx
+ 569:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 56c:	89 c2                	mov    %eax,%edx
+ 56e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 571:	01 c2                	add    %eax,%edx
+ 573:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 577:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 579:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 57d:	3c 0a                	cmp    $0xa,%al
+ 57f:	74 16                	je     597 <gets+0x63>
+ 581:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 585:	3c 0d                	cmp    $0xd,%al
+ 587:	74 0e                	je     597 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 589:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 58c:	83 c0 01             	add    $0x1,%eax
+ 58f:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 592:	7f b3                	jg     547 <gets+0x13>
+ 594:	eb 01                	jmp    597 <gets+0x63>
+      break;
+ 596:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 597:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 59a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 59d:	01 d0                	add    %edx,%eax
+ 59f:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 5a2:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 5a5:	c9                   	leave  
+ 5a6:	c3                   	ret    
+
+000005a7 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 5a7:	f3 0f 1e fb          	endbr32 
+ 5ab:	55                   	push   %ebp
+ 5ac:	89 e5                	mov    %esp,%ebp
+ 5ae:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 5b1:	83 ec 08             	sub    $0x8,%esp
+ 5b4:	6a 00                	push   $0x0
+ 5b6:	ff 75 08             	pushl  0x8(%ebp)
+ 5b9:	e8 14 01 00 00       	call   6d2 <open>
+ 5be:	83 c4 10             	add    $0x10,%esp
+ 5c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 5c4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 5c8:	79 07                	jns    5d1 <stat+0x2a>
+    return -1;
+ 5ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 5cf:	eb 25                	jmp    5f6 <stat+0x4f>
+  r = fstat(fd, st);
+ 5d1:	83 ec 08             	sub    $0x8,%esp
+ 5d4:	ff 75 0c             	pushl  0xc(%ebp)
+ 5d7:	ff 75 f4             	pushl  -0xc(%ebp)
+ 5da:	e8 0b 01 00 00       	call   6ea <fstat>
+ 5df:	83 c4 10             	add    $0x10,%esp
+ 5e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 5e5:	83 ec 0c             	sub    $0xc,%esp
+ 5e8:	ff 75 f4             	pushl  -0xc(%ebp)
+ 5eb:	e8 ca 00 00 00       	call   6ba <close>
+ 5f0:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 5f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 5f6:	c9                   	leave  
+ 5f7:	c3                   	ret    
+
+000005f8 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 5f8:	f3 0f 1e fb          	endbr32 
+ 5fc:	55                   	push   %ebp
+ 5fd:	89 e5                	mov    %esp,%ebp
+ 5ff:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 602:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 609:	eb 25                	jmp    630 <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 60b:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 60e:	89 d0                	mov    %edx,%eax
+ 610:	c1 e0 02             	shl    $0x2,%eax
+ 613:	01 d0                	add    %edx,%eax
+ 615:	01 c0                	add    %eax,%eax
+ 617:	89 c1                	mov    %eax,%ecx
+ 619:	8b 45 08             	mov    0x8(%ebp),%eax
+ 61c:	8d 50 01             	lea    0x1(%eax),%edx
+ 61f:	89 55 08             	mov    %edx,0x8(%ebp)
+ 622:	0f b6 00             	movzbl (%eax),%eax
+ 625:	0f be c0             	movsbl %al,%eax
+ 628:	01 c8                	add    %ecx,%eax
+ 62a:	83 e8 30             	sub    $0x30,%eax
+ 62d:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 630:	8b 45 08             	mov    0x8(%ebp),%eax
+ 633:	0f b6 00             	movzbl (%eax),%eax
+ 636:	3c 2f                	cmp    $0x2f,%al
+ 638:	7e 0a                	jle    644 <atoi+0x4c>
+ 63a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 63d:	0f b6 00             	movzbl (%eax),%eax
+ 640:	3c 39                	cmp    $0x39,%al
+ 642:	7e c7                	jle    60b <atoi+0x13>
+  return n;
+ 644:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 647:	c9                   	leave  
+ 648:	c3                   	ret    
+
+00000649 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 649:	f3 0f 1e fb          	endbr32 
+ 64d:	55                   	push   %ebp
+ 64e:	89 e5                	mov    %esp,%ebp
+ 650:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 653:	8b 45 08             	mov    0x8(%ebp),%eax
+ 656:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 659:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 65c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 65f:	eb 17                	jmp    678 <memmove+0x2f>
+    *dst++ = *src++;
+ 661:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 664:	8d 42 01             	lea    0x1(%edx),%eax
+ 667:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 66a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 66d:	8d 48 01             	lea    0x1(%eax),%ecx
+ 670:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 673:	0f b6 12             	movzbl (%edx),%edx
+ 676:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 678:	8b 45 10             	mov    0x10(%ebp),%eax
+ 67b:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 67e:	89 55 10             	mov    %edx,0x10(%ebp)
+ 681:	85 c0                	test   %eax,%eax
+ 683:	7f dc                	jg     661 <memmove+0x18>
+  return vdst;
+ 685:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 688:	c9                   	leave  
+ 689:	c3                   	ret    
+
+0000068a <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 68a:	b8 01 00 00 00       	mov    $0x1,%eax
+ 68f:	cd 40                	int    $0x40
+ 691:	c3                   	ret    
+
+00000692 <exit>:
+SYSCALL(exit)
+ 692:	b8 02 00 00 00       	mov    $0x2,%eax
+ 697:	cd 40                	int    $0x40
+ 699:	c3                   	ret    
+
+0000069a <wait>:
+SYSCALL(wait)
+ 69a:	b8 03 00 00 00       	mov    $0x3,%eax
+ 69f:	cd 40                	int    $0x40
+ 6a1:	c3                   	ret    
+
+000006a2 <pipe>:
+SYSCALL(pipe)
+ 6a2:	b8 04 00 00 00       	mov    $0x4,%eax
+ 6a7:	cd 40                	int    $0x40
+ 6a9:	c3                   	ret    
+
+000006aa <read>:
+SYSCALL(read)
+ 6aa:	b8 05 00 00 00       	mov    $0x5,%eax
+ 6af:	cd 40                	int    $0x40
+ 6b1:	c3                   	ret    
+
+000006b2 <write>:
+SYSCALL(write)
+ 6b2:	b8 10 00 00 00       	mov    $0x10,%eax
+ 6b7:	cd 40                	int    $0x40
+ 6b9:	c3                   	ret    
+
+000006ba <close>:
+SYSCALL(close)
+ 6ba:	b8 15 00 00 00       	mov    $0x15,%eax
+ 6bf:	cd 40                	int    $0x40
+ 6c1:	c3                   	ret    
+
+000006c2 <kill>:
+SYSCALL(kill)
+ 6c2:	b8 06 00 00 00       	mov    $0x6,%eax
+ 6c7:	cd 40                	int    $0x40
+ 6c9:	c3                   	ret    
+
+000006ca <exec>:
+SYSCALL(exec)
+ 6ca:	b8 07 00 00 00       	mov    $0x7,%eax
+ 6cf:	cd 40                	int    $0x40
+ 6d1:	c3                   	ret    
+
+000006d2 <open>:
+SYSCALL(open)
+ 6d2:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 6d7:	cd 40                	int    $0x40
+ 6d9:	c3                   	ret    
+
+000006da <mknod>:
+SYSCALL(mknod)
+ 6da:	b8 11 00 00 00       	mov    $0x11,%eax
+ 6df:	cd 40                	int    $0x40
+ 6e1:	c3                   	ret    
+
+000006e2 <unlink>:
+SYSCALL(unlink)
+ 6e2:	b8 12 00 00 00       	mov    $0x12,%eax
+ 6e7:	cd 40                	int    $0x40
+ 6e9:	c3                   	ret    
+
+000006ea <fstat>:
+SYSCALL(fstat)
+ 6ea:	b8 08 00 00 00       	mov    $0x8,%eax
+ 6ef:	cd 40                	int    $0x40
+ 6f1:	c3                   	ret    
+
+000006f2 <link>:
+SYSCALL(link)
+ 6f2:	b8 13 00 00 00       	mov    $0x13,%eax
+ 6f7:	cd 40                	int    $0x40
+ 6f9:	c3                   	ret    
+
+000006fa <mkdir>:
+SYSCALL(mkdir)
+ 6fa:	b8 14 00 00 00       	mov    $0x14,%eax
+ 6ff:	cd 40                	int    $0x40
+ 701:	c3                   	ret    
+
+00000702 <chdir>:
+SYSCALL(chdir)
+ 702:	b8 09 00 00 00       	mov    $0x9,%eax
+ 707:	cd 40                	int    $0x40
+ 709:	c3                   	ret    
+
+0000070a <dup>:
+SYSCALL(dup)
+ 70a:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 70f:	cd 40                	int    $0x40
+ 711:	c3                   	ret    
+
+00000712 <getpid>:
+SYSCALL(getpid)
+ 712:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 717:	cd 40                	int    $0x40
+ 719:	c3                   	ret    
+
+0000071a <sbrk>:
+SYSCALL(sbrk)
+ 71a:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 71f:	cd 40                	int    $0x40
+ 721:	c3                   	ret    
+
+00000722 <sleep>:
+SYSCALL(sleep)
+ 722:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 727:	cd 40                	int    $0x40
+ 729:	c3                   	ret    
+
+0000072a <uptime>:
+SYSCALL(uptime)
+ 72a:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 72f:	cd 40                	int    $0x40
+ 731:	c3                   	ret    
+
+00000732 <draw>:
+SYSCALL(draw)
+ 732:	b8 16 00 00 00       	mov    $0x16,%eax
+ 737:	cd 40                	int    $0x40
+ 739:	c3                   	ret    
+
+0000073a <cps>:
+SYSCALL(cps)
+ 73a:	b8 17 00 00 00       	mov    $0x17,%eax
+ 73f:	cd 40                	int    $0x40
+ 741:	c3                   	ret    
+
+00000742 <yield>:
+SYSCALL(yield)
+ 742:	b8 18 00 00 00       	mov    $0x18,%eax
+ 747:	cd 40                	int    $0x40
+ 749:	c3                   	ret    
+
+0000074a <wait2>:
+SYSCALL(wait2)
+ 74a:	b8 19 00 00 00       	mov    $0x19,%eax
+ 74f:	cd 40                	int    $0x40
+ 751:	c3                   	ret    
+
+00000752 <set_prio>:
+SYSCALL(set_prio)
+ 752:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 757:	cd 40                	int    $0x40
+ 759:	c3                   	ret    
+
+0000075a <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 75a:	f3 0f 1e fb          	endbr32 
+ 75e:	55                   	push   %ebp
+ 75f:	89 e5                	mov    %esp,%ebp
+ 761:	83 ec 18             	sub    $0x18,%esp
+ 764:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 767:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 76a:	83 ec 04             	sub    $0x4,%esp
+ 76d:	6a 01                	push   $0x1
+ 76f:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 772:	50                   	push   %eax
+ 773:	ff 75 08             	pushl  0x8(%ebp)
+ 776:	e8 37 ff ff ff       	call   6b2 <write>
+ 77b:	83 c4 10             	add    $0x10,%esp
+}
+ 77e:	90                   	nop
+ 77f:	c9                   	leave  
+ 780:	c3                   	ret    
+
+00000781 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 781:	f3 0f 1e fb          	endbr32 
+ 785:	55                   	push   %ebp
+ 786:	89 e5                	mov    %esp,%ebp
+ 788:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 78b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 792:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 796:	74 17                	je     7af <printint+0x2e>
+ 798:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 79c:	79 11                	jns    7af <printint+0x2e>
+    neg = 1;
+ 79e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 7a5:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 7a8:	f7 d8                	neg    %eax
+ 7aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 7ad:	eb 06                	jmp    7b5 <printint+0x34>
+  } else {
+    x = xx;
+ 7af:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 7b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 7b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 7bc:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 7bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 7c2:	ba 00 00 00 00       	mov    $0x0,%edx
+ 7c7:	f7 f1                	div    %ecx
+ 7c9:	89 d1                	mov    %edx,%ecx
+ 7cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7ce:	8d 50 01             	lea    0x1(%eax),%edx
+ 7d1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 7d4:	0f b6 91 ac 10 00 00 	movzbl 0x10ac(%ecx),%edx
+ 7db:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 7df:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 7e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 7e5:	ba 00 00 00 00       	mov    $0x0,%edx
+ 7ea:	f7 f1                	div    %ecx
+ 7ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 7ef:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 7f3:	75 c7                	jne    7bc <printint+0x3b>
+  if(neg)
+ 7f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 7f9:	74 2d                	je     828 <printint+0xa7>
+    buf[i++] = '-';
+ 7fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7fe:	8d 50 01             	lea    0x1(%eax),%edx
+ 801:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 804:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 809:	eb 1d                	jmp    828 <printint+0xa7>
+    putc(fd, buf[i]);
+ 80b:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 80e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 811:	01 d0                	add    %edx,%eax
+ 813:	0f b6 00             	movzbl (%eax),%eax
+ 816:	0f be c0             	movsbl %al,%eax
+ 819:	83 ec 08             	sub    $0x8,%esp
+ 81c:	50                   	push   %eax
+ 81d:	ff 75 08             	pushl  0x8(%ebp)
+ 820:	e8 35 ff ff ff       	call   75a <putc>
+ 825:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 828:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 82c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 830:	79 d9                	jns    80b <printint+0x8a>
+}
+ 832:	90                   	nop
+ 833:	90                   	nop
+ 834:	c9                   	leave  
+ 835:	c3                   	ret    
+
+00000836 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 836:	f3 0f 1e fb          	endbr32 
+ 83a:	55                   	push   %ebp
+ 83b:	89 e5                	mov    %esp,%ebp
+ 83d:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 840:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 847:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 84a:	83 c0 04             	add    $0x4,%eax
+ 84d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 850:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 857:	e9 59 01 00 00       	jmp    9b5 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 85c:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 85f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 862:	01 d0                	add    %edx,%eax
+ 864:	0f b6 00             	movzbl (%eax),%eax
+ 867:	0f be c0             	movsbl %al,%eax
+ 86a:	25 ff 00 00 00       	and    $0xff,%eax
+ 86f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 872:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 876:	75 2c                	jne    8a4 <printf+0x6e>
+      if(c == '%'){
+ 878:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 87c:	75 0c                	jne    88a <printf+0x54>
+        state = '%';
+ 87e:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 885:	e9 27 01 00 00       	jmp    9b1 <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 88a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 88d:	0f be c0             	movsbl %al,%eax
+ 890:	83 ec 08             	sub    $0x8,%esp
+ 893:	50                   	push   %eax
+ 894:	ff 75 08             	pushl  0x8(%ebp)
+ 897:	e8 be fe ff ff       	call   75a <putc>
+ 89c:	83 c4 10             	add    $0x10,%esp
+ 89f:	e9 0d 01 00 00       	jmp    9b1 <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 8a4:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 8a8:	0f 85 03 01 00 00    	jne    9b1 <printf+0x17b>
+      if(c == 'd'){
+ 8ae:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 8b2:	75 1e                	jne    8d2 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 8b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 8b7:	8b 00                	mov    (%eax),%eax
+ 8b9:	6a 01                	push   $0x1
+ 8bb:	6a 0a                	push   $0xa
+ 8bd:	50                   	push   %eax
+ 8be:	ff 75 08             	pushl  0x8(%ebp)
+ 8c1:	e8 bb fe ff ff       	call   781 <printint>
+ 8c6:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 8c9:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 8cd:	e9 d8 00 00 00       	jmp    9aa <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 8d2:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 8d6:	74 06                	je     8de <printf+0xa8>
+ 8d8:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 8dc:	75 1e                	jne    8fc <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 8de:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 8e1:	8b 00                	mov    (%eax),%eax
+ 8e3:	6a 00                	push   $0x0
+ 8e5:	6a 10                	push   $0x10
+ 8e7:	50                   	push   %eax
+ 8e8:	ff 75 08             	pushl  0x8(%ebp)
+ 8eb:	e8 91 fe ff ff       	call   781 <printint>
+ 8f0:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 8f3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 8f7:	e9 ae 00 00 00       	jmp    9aa <printf+0x174>
+      } else if(c == 's'){
+ 8fc:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 900:	75 43                	jne    945 <printf+0x10f>
+        s = (char*)*ap;
+ 902:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 905:	8b 00                	mov    (%eax),%eax
+ 907:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 90a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 90e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 912:	75 25                	jne    939 <printf+0x103>
+          s = "(null)";
+ 914:	c7 45 f4 5c 0e 00 00 	movl   $0xe5c,-0xc(%ebp)
+        while(*s != 0){
+ 91b:	eb 1c                	jmp    939 <printf+0x103>
+          putc(fd, *s);
+ 91d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 920:	0f b6 00             	movzbl (%eax),%eax
+ 923:	0f be c0             	movsbl %al,%eax
+ 926:	83 ec 08             	sub    $0x8,%esp
+ 929:	50                   	push   %eax
+ 92a:	ff 75 08             	pushl  0x8(%ebp)
+ 92d:	e8 28 fe ff ff       	call   75a <putc>
+ 932:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 935:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 939:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 93c:	0f b6 00             	movzbl (%eax),%eax
+ 93f:	84 c0                	test   %al,%al
+ 941:	75 da                	jne    91d <printf+0xe7>
+ 943:	eb 65                	jmp    9aa <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 945:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 949:	75 1d                	jne    968 <printf+0x132>
+        putc(fd, *ap);
+ 94b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 94e:	8b 00                	mov    (%eax),%eax
+ 950:	0f be c0             	movsbl %al,%eax
+ 953:	83 ec 08             	sub    $0x8,%esp
+ 956:	50                   	push   %eax
+ 957:	ff 75 08             	pushl  0x8(%ebp)
+ 95a:	e8 fb fd ff ff       	call   75a <putc>
+ 95f:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 962:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 966:	eb 42                	jmp    9aa <printf+0x174>
+      } else if(c == '%'){
+ 968:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 96c:	75 17                	jne    985 <printf+0x14f>
+        putc(fd, c);
+ 96e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 971:	0f be c0             	movsbl %al,%eax
+ 974:	83 ec 08             	sub    $0x8,%esp
+ 977:	50                   	push   %eax
+ 978:	ff 75 08             	pushl  0x8(%ebp)
+ 97b:	e8 da fd ff ff       	call   75a <putc>
+ 980:	83 c4 10             	add    $0x10,%esp
+ 983:	eb 25                	jmp    9aa <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 985:	83 ec 08             	sub    $0x8,%esp
+ 988:	6a 25                	push   $0x25
+ 98a:	ff 75 08             	pushl  0x8(%ebp)
+ 98d:	e8 c8 fd ff ff       	call   75a <putc>
+ 992:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 995:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 998:	0f be c0             	movsbl %al,%eax
+ 99b:	83 ec 08             	sub    $0x8,%esp
+ 99e:	50                   	push   %eax
+ 99f:	ff 75 08             	pushl  0x8(%ebp)
+ 9a2:	e8 b3 fd ff ff       	call   75a <putc>
+ 9a7:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 9aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 9b1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 9b5:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 9b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 9bb:	01 d0                	add    %edx,%eax
+ 9bd:	0f b6 00             	movzbl (%eax),%eax
+ 9c0:	84 c0                	test   %al,%al
+ 9c2:	0f 85 94 fe ff ff    	jne    85c <printf+0x26>
+    }
+  }
+}
+ 9c8:	90                   	nop
+ 9c9:	90                   	nop
+ 9ca:	c9                   	leave  
+ 9cb:	c3                   	ret    
+
+000009cc <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 9cc:	f3 0f 1e fb          	endbr32 
+ 9d0:	55                   	push   %ebp
+ 9d1:	89 e5                	mov    %esp,%ebp
+ 9d3:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 9d6:	8b 45 08             	mov    0x8(%ebp),%eax
+ 9d9:	83 e8 08             	sub    $0x8,%eax
+ 9dc:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 9df:	a1 c8 10 00 00       	mov    0x10c8,%eax
+ 9e4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 9e7:	eb 24                	jmp    a0d <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 9e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9ec:	8b 00                	mov    (%eax),%eax
+ 9ee:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 9f1:	72 12                	jb     a05 <free+0x39>
+ 9f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 9f6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 9f9:	77 24                	ja     a1f <free+0x53>
+ 9fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 9fe:	8b 00                	mov    (%eax),%eax
+ a00:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ a03:	72 1a                	jb     a1f <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ a05:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a08:	8b 00                	mov    (%eax),%eax
+ a0a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ a0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a10:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ a13:	76 d4                	jbe    9e9 <free+0x1d>
+ a15:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a18:	8b 00                	mov    (%eax),%eax
+ a1a:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ a1d:	73 ca                	jae    9e9 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ a1f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a22:	8b 40 04             	mov    0x4(%eax),%eax
+ a25:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ a2c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a2f:	01 c2                	add    %eax,%edx
+ a31:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a34:	8b 00                	mov    (%eax),%eax
+ a36:	39 c2                	cmp    %eax,%edx
+ a38:	75 24                	jne    a5e <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ a3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a3d:	8b 50 04             	mov    0x4(%eax),%edx
+ a40:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a43:	8b 00                	mov    (%eax),%eax
+ a45:	8b 40 04             	mov    0x4(%eax),%eax
+ a48:	01 c2                	add    %eax,%edx
+ a4a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a4d:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ a50:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a53:	8b 00                	mov    (%eax),%eax
+ a55:	8b 10                	mov    (%eax),%edx
+ a57:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a5a:	89 10                	mov    %edx,(%eax)
+ a5c:	eb 0a                	jmp    a68 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ a5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a61:	8b 10                	mov    (%eax),%edx
+ a63:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a66:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ a68:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a6b:	8b 40 04             	mov    0x4(%eax),%eax
+ a6e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ a75:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a78:	01 d0                	add    %edx,%eax
+ a7a:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ a7d:	75 20                	jne    a9f <free+0xd3>
+    p->s.size += bp->s.size;
+ a7f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a82:	8b 50 04             	mov    0x4(%eax),%edx
+ a85:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a88:	8b 40 04             	mov    0x4(%eax),%eax
+ a8b:	01 c2                	add    %eax,%edx
+ a8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a90:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ a93:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ a96:	8b 10                	mov    (%eax),%edx
+ a98:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ a9b:	89 10                	mov    %edx,(%eax)
+ a9d:	eb 08                	jmp    aa7 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ a9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ aa2:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ aa5:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ aa7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ aaa:	a3 c8 10 00 00       	mov    %eax,0x10c8
+}
+ aaf:	90                   	nop
+ ab0:	c9                   	leave  
+ ab1:	c3                   	ret    
+
+00000ab2 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ ab2:	f3 0f 1e fb          	endbr32 
+ ab6:	55                   	push   %ebp
+ ab7:	89 e5                	mov    %esp,%ebp
+ ab9:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ abc:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ ac3:	77 07                	ja     acc <morecore+0x1a>
+    nu = 4096;
+ ac5:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ acc:	8b 45 08             	mov    0x8(%ebp),%eax
+ acf:	c1 e0 03             	shl    $0x3,%eax
+ ad2:	83 ec 0c             	sub    $0xc,%esp
+ ad5:	50                   	push   %eax
+ ad6:	e8 3f fc ff ff       	call   71a <sbrk>
+ adb:	83 c4 10             	add    $0x10,%esp
+ ade:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ ae1:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ ae5:	75 07                	jne    aee <morecore+0x3c>
+    return 0;
+ ae7:	b8 00 00 00 00       	mov    $0x0,%eax
+ aec:	eb 26                	jmp    b14 <morecore+0x62>
+  hp = (Header*)p;
+ aee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ af1:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ af4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ af7:	8b 55 08             	mov    0x8(%ebp),%edx
+ afa:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ afd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b00:	83 c0 08             	add    $0x8,%eax
+ b03:	83 ec 0c             	sub    $0xc,%esp
+ b06:	50                   	push   %eax
+ b07:	e8 c0 fe ff ff       	call   9cc <free>
+ b0c:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ b0f:	a1 c8 10 00 00       	mov    0x10c8,%eax
+}
+ b14:	c9                   	leave  
+ b15:	c3                   	ret    
+
+00000b16 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ b16:	f3 0f 1e fb          	endbr32 
+ b1a:	55                   	push   %ebp
+ b1b:	89 e5                	mov    %esp,%ebp
+ b1d:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ b20:	8b 45 08             	mov    0x8(%ebp),%eax
+ b23:	83 c0 07             	add    $0x7,%eax
+ b26:	c1 e8 03             	shr    $0x3,%eax
+ b29:	83 c0 01             	add    $0x1,%eax
+ b2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ b2f:	a1 c8 10 00 00       	mov    0x10c8,%eax
+ b34:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ b37:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ b3b:	75 23                	jne    b60 <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ b3d:	c7 45 f0 c0 10 00 00 	movl   $0x10c0,-0x10(%ebp)
+ b44:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b47:	a3 c8 10 00 00       	mov    %eax,0x10c8
+ b4c:	a1 c8 10 00 00       	mov    0x10c8,%eax
+ b51:	a3 c0 10 00 00       	mov    %eax,0x10c0
+    base.s.size = 0;
+ b56:	c7 05 c4 10 00 00 00 	movl   $0x0,0x10c4
+ b5d:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ b60:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b63:	8b 00                	mov    (%eax),%eax
+ b65:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ b68:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b6b:	8b 40 04             	mov    0x4(%eax),%eax
+ b6e:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ b71:	77 4d                	ja     bc0 <malloc+0xaa>
+      if(p->s.size == nunits)
+ b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b76:	8b 40 04             	mov    0x4(%eax),%eax
+ b79:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ b7c:	75 0c                	jne    b8a <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ b7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b81:	8b 10                	mov    (%eax),%edx
+ b83:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ b86:	89 10                	mov    %edx,(%eax)
+ b88:	eb 26                	jmp    bb0 <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ b8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b8d:	8b 40 04             	mov    0x4(%eax),%eax
+ b90:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ b93:	89 c2                	mov    %eax,%edx
+ b95:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b98:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ b9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ b9e:	8b 40 04             	mov    0x4(%eax),%eax
+ ba1:	c1 e0 03             	shl    $0x3,%eax
+ ba4:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ baa:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ bad:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ bb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ bb3:	a3 c8 10 00 00       	mov    %eax,0x10c8
+      return (void*)(p + 1);
+ bb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ bbb:	83 c0 08             	add    $0x8,%eax
+ bbe:	eb 3b                	jmp    bfb <malloc+0xe5>
+    }
+    if(p == freep)
+ bc0:	a1 c8 10 00 00       	mov    0x10c8,%eax
+ bc5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ bc8:	75 1e                	jne    be8 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ bca:	83 ec 0c             	sub    $0xc,%esp
+ bcd:	ff 75 ec             	pushl  -0x14(%ebp)
+ bd0:	e8 dd fe ff ff       	call   ab2 <morecore>
+ bd5:	83 c4 10             	add    $0x10,%esp
+ bd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ bdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ bdf:	75 07                	jne    be8 <malloc+0xd2>
+        return 0;
+ be1:	b8 00 00 00 00       	mov    $0x0,%eax
+ be6:	eb 13                	jmp    bfb <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ be8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ beb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ bee:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ bf1:	8b 00                	mov    (%eax),%eax
+ bf3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ bf6:	e9 6d ff ff ff       	jmp    b68 <malloc+0x52>
+  }
+}
+ bfb:	c9                   	leave  
+ bfc:	c3                   	ret    
diff -ruN xv6-public/xv6-public/sanity.c xv6-public_new/xv6-public/sanity.c
--- xv6-public/xv6-public/sanity.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sanity.c	2021-09-30 16:43:12.000000000 +0530
@@ -0,0 +1,103 @@
+// # include "types.h"
+// # include "stat.h"
+// # include "user.h"
+// # include "fcntl.h"
+// int main(int argc, char** argv){
+// 	if(argc < 2){
+// 		printf(1, "Insufficient arguments\n");
+// 		exit();
+// 	}
+// 	if(argc > 2){
+// 		printf(1, "Too many arguments\n");
+// 		exit();
+// 	}
+// 	int n = atoi(argv[1]); // n as given in the question
+// 	printf(1, "%d\n", n);
+// 	exit();
+// }
+
+
+#include "types.h"
+#include "user.h"
+
+
+int
+main(int argc, char *argv[])
+{
+	if (argc != 2){
+				printf(1, "Usage: sanity <n>\n");
+				exit();
+ 		}
+	int i;
+	int n;
+	int j = 0;
+	int k;
+	int retime;
+	int rutime;
+	int stime;
+	int sums[3][3];
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			sums[i][j] = 0;
+	n = atoi(argv[1]);
+	i = n; //unimportant
+	int pid;
+	for (i = 0; i < 3 * n; i++) {
+		j = i % 3;
+		pid = fork();
+		if (pid == 0) {//child
+			j = (getpid() - 4) % 3; // ensures independence from the first son's pid when gathering the results in the second part of the program
+			switch(j) {
+				case 0: //CPU‐bound process (CPU):
+					for (k = 0; k < 100; k++){
+						for (j = 0; j < 1000000; j++){}
+					}
+					break;
+				case 1: //short tasks based CPU‐bound process (S‐CPU):
+					for (k = 0; k < 100; k++){
+						for (j = 0; j < 1000000; j++){}
+						yield();
+					}
+					break;
+				case 2:// simulate I/O bound process (IO)
+					for(k = 0; k < 100; k++){
+						sleep(1);
+					}
+					break;
+			}
+			exit(); // children exit here
+		}
+		continue; // father continues to spawn the next child
+	}
+	for (i = 0; i < 3 * n; i++) {
+		pid = wait2(&retime, &rutime, &stime);
+		int res = (pid - 4) % 3; // correlates to j in the dispatching loop
+		switch(res) {
+			case 0: // CPU bound processes
+				printf(1, "CPU-bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[0][0] += retime;
+				sums[0][1] += rutime;
+				sums[0][2] += stime;
+				break;
+			case 1: // CPU bound processes, short tasks
+				printf(1, "CPU-S bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[1][0] += retime;
+				sums[1][1] += rutime;
+				sums[1][2] += stime;
+				break;
+			case 2: // simulating I/O bound processes
+				printf(1, "I/O bound, pid: %d, ready: %d, running: %d, sleeping: %d, turnaround: %d\n", pid, retime, rutime, stime, retime + rutime + stime);
+				sums[2][0] += retime;
+				sums[2][1] += rutime;
+				sums[2][2] += stime;
+				break;
+		}
+	}
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++)
+			sums[i][j] /= n;
+	printf(1, "\n\nCPU bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[0][0], sums[0][1], sums[0][2], sums[0][0] + sums[0][1] + sums[0][2]);
+	printf(1, "CPU-S bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[1][0], sums[1][1], sums[1][2], sums[1][0] + sums[1][1] + sums[1][2]);
+	printf(1, "I/O bound:\nAverage ready time: %d\nAverage running time: %d\nAverage sleeping time: %d\nAverage turnaround time: %d\n\n\n", sums[2][0], sums[2][1], sums[2][2], sums[2][0] + sums[2][1] + sums[2][2]);
+	exit();
+}
diff -ruN xv6-public/xv6-public/sanity.d xv6-public_new/xv6-public/sanity.d
--- xv6-public/xv6-public/sanity.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sanity.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1 @@
+sanity.o: sanity.c /usr/include/stdc-predef.h types.h user.h
Binary files xv6-public/xv6-public/sanity.o and xv6-public_new/xv6-public/sanity.o differ
diff -ruN xv6-public/xv6-public/sanity.sym xv6-public_new/xv6-public/sanity.sym
--- xv6-public/xv6-public/sanity.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sanity.sym	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+00000c00 .rodata
+00000e64 .eh_frame
+000010ac .data
+000010c0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 sanity.c
+00000000 ulib.c
+00000417 stosb
+00000000 printf.c
+0000075a putc
+00000781 printint
+000010ac digits.1098
+00000000 umalloc.c
+000010c0 base
+000010c8 freep
+00000ab2 morecore
+0000043d strcpy
+00000742 yield
+00000752 set_prio
+00000836 printf
+00000649 memmove
+000006da mknod
+00000534 gets
+00000712 getpid
+00000b16 malloc
+00000722 sleep
+0000074a wait2
+000006a2 pipe
+000006b2 write
+000006ea fstat
+000006c2 kill
+00000702 chdir
+000006ca exec
+0000069a wait
+000006aa read
+000006e2 unlink
+0000068a fork
+0000071a sbrk
+0000072a uptime
+000010bd __bss_start
+000004df memset
+00000000 main
+00000471 strcmp
+0000070a dup
+000005a7 stat
+000010bd _edata
+000010cc _end
+000006f2 link
+00000692 exit
+000005f8 atoi
+00000732 draw
+000004b4 strlen
+000006d2 open
+000004fd strchr
+0000073a cps
+000006fa mkdir
+000006ba close
+000009cc free
diff -ruN xv6-public/xv6-public/sh.asm xv6-public_new/xv6-public/sh.asm
--- xv6-public/xv6-public/sh.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sh.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,2670 @@
+
+_sh:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <runcmd>:
+struct cmd *parsecmd(char*);
+
+// Execute cmd.  Never returns.
+void
+runcmd(struct cmd *cmd)
+{
+       0:	f3 0f 1e fb          	endbr32 
+       4:	55                   	push   %ebp
+       5:	89 e5                	mov    %esp,%ebp
+       7:	83 ec 28             	sub    $0x28,%esp
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+       a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+       e:	75 05                	jne    15 <runcmd+0x15>
+    exit();
+      10:	e8 35 0f 00 00       	call   f4a <exit>
+
+  switch(cmd->type){
+      15:	8b 45 08             	mov    0x8(%ebp),%eax
+      18:	8b 00                	mov    (%eax),%eax
+      1a:	83 f8 05             	cmp    $0x5,%eax
+      1d:	77 0a                	ja     29 <runcmd+0x29>
+      1f:	8b 04 85 e4 14 00 00 	mov    0x14e4(,%eax,4),%eax
+      26:	3e ff e0             	notrack jmp *%eax
+  default:
+    panic("runcmd");
+      29:	83 ec 0c             	sub    $0xc,%esp
+      2c:	68 b8 14 00 00       	push   $0x14b8
+      31:	e8 73 03 00 00       	call   3a9 <panic>
+      36:	83 c4 10             	add    $0x10,%esp
+
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+      39:	8b 45 08             	mov    0x8(%ebp),%eax
+      3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(ecmd->argv[0] == 0)
+      3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+      42:	8b 40 04             	mov    0x4(%eax),%eax
+      45:	85 c0                	test   %eax,%eax
+      47:	75 05                	jne    4e <runcmd+0x4e>
+      exit();
+      49:	e8 fc 0e 00 00       	call   f4a <exit>
+    exec(ecmd->argv[0], ecmd->argv);
+      4e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+      51:	8d 50 04             	lea    0x4(%eax),%edx
+      54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+      57:	8b 40 04             	mov    0x4(%eax),%eax
+      5a:	83 ec 08             	sub    $0x8,%esp
+      5d:	52                   	push   %edx
+      5e:	50                   	push   %eax
+      5f:	e8 1e 0f 00 00       	call   f82 <exec>
+      64:	83 c4 10             	add    $0x10,%esp
+    printf(2, "exec %s failed\n", ecmd->argv[0]);
+      67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+      6a:	8b 40 04             	mov    0x4(%eax),%eax
+      6d:	83 ec 04             	sub    $0x4,%esp
+      70:	50                   	push   %eax
+      71:	68 bf 14 00 00       	push   $0x14bf
+      76:	6a 02                	push   $0x2
+      78:	e8 71 10 00 00       	call   10ee <printf>
+      7d:	83 c4 10             	add    $0x10,%esp
+    break;
+      80:	e9 c6 01 00 00       	jmp    24b <runcmd+0x24b>
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+      85:	8b 45 08             	mov    0x8(%ebp),%eax
+      88:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    close(rcmd->fd);
+      8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+      8e:	8b 40 14             	mov    0x14(%eax),%eax
+      91:	83 ec 0c             	sub    $0xc,%esp
+      94:	50                   	push   %eax
+      95:	e8 d8 0e 00 00       	call   f72 <close>
+      9a:	83 c4 10             	add    $0x10,%esp
+    if(open(rcmd->file, rcmd->mode) < 0){
+      9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+      a0:	8b 50 10             	mov    0x10(%eax),%edx
+      a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+      a6:	8b 40 08             	mov    0x8(%eax),%eax
+      a9:	83 ec 08             	sub    $0x8,%esp
+      ac:	52                   	push   %edx
+      ad:	50                   	push   %eax
+      ae:	e8 d7 0e 00 00       	call   f8a <open>
+      b3:	83 c4 10             	add    $0x10,%esp
+      b6:	85 c0                	test   %eax,%eax
+      b8:	79 1e                	jns    d8 <runcmd+0xd8>
+      printf(2, "open %s failed\n", rcmd->file);
+      ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
+      bd:	8b 40 08             	mov    0x8(%eax),%eax
+      c0:	83 ec 04             	sub    $0x4,%esp
+      c3:	50                   	push   %eax
+      c4:	68 cf 14 00 00       	push   $0x14cf
+      c9:	6a 02                	push   $0x2
+      cb:	e8 1e 10 00 00       	call   10ee <printf>
+      d0:	83 c4 10             	add    $0x10,%esp
+      exit();
+      d3:	e8 72 0e 00 00       	call   f4a <exit>
+    }
+    runcmd(rcmd->cmd);
+      d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+      db:	8b 40 04             	mov    0x4(%eax),%eax
+      de:	83 ec 0c             	sub    $0xc,%esp
+      e1:	50                   	push   %eax
+      e2:	e8 19 ff ff ff       	call   0 <runcmd>
+      e7:	83 c4 10             	add    $0x10,%esp
+    break;
+      ea:	e9 5c 01 00 00       	jmp    24b <runcmd+0x24b>
+
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+      ef:	8b 45 08             	mov    0x8(%ebp),%eax
+      f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(fork1() == 0)
+      f5:	e8 d3 02 00 00       	call   3cd <fork1>
+      fa:	85 c0                	test   %eax,%eax
+      fc:	75 12                	jne    110 <runcmd+0x110>
+      runcmd(lcmd->left);
+      fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     101:	8b 40 04             	mov    0x4(%eax),%eax
+     104:	83 ec 0c             	sub    $0xc,%esp
+     107:	50                   	push   %eax
+     108:	e8 f3 fe ff ff       	call   0 <runcmd>
+     10d:	83 c4 10             	add    $0x10,%esp
+    wait();
+     110:	e8 3d 0e 00 00       	call   f52 <wait>
+    runcmd(lcmd->right);
+     115:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     118:	8b 40 08             	mov    0x8(%eax),%eax
+     11b:	83 ec 0c             	sub    $0xc,%esp
+     11e:	50                   	push   %eax
+     11f:	e8 dc fe ff ff       	call   0 <runcmd>
+     124:	83 c4 10             	add    $0x10,%esp
+    break;
+     127:	e9 1f 01 00 00       	jmp    24b <runcmd+0x24b>
+
+  case PIPE:
+    pcmd = (struct pipecmd*)cmd;
+     12c:	8b 45 08             	mov    0x8(%ebp),%eax
+     12f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(pipe(p) < 0)
+     132:	83 ec 0c             	sub    $0xc,%esp
+     135:	8d 45 dc             	lea    -0x24(%ebp),%eax
+     138:	50                   	push   %eax
+     139:	e8 1c 0e 00 00       	call   f5a <pipe>
+     13e:	83 c4 10             	add    $0x10,%esp
+     141:	85 c0                	test   %eax,%eax
+     143:	79 10                	jns    155 <runcmd+0x155>
+      panic("pipe");
+     145:	83 ec 0c             	sub    $0xc,%esp
+     148:	68 df 14 00 00       	push   $0x14df
+     14d:	e8 57 02 00 00       	call   3a9 <panic>
+     152:	83 c4 10             	add    $0x10,%esp
+    if(fork1() == 0){
+     155:	e8 73 02 00 00       	call   3cd <fork1>
+     15a:	85 c0                	test   %eax,%eax
+     15c:	75 4c                	jne    1aa <runcmd+0x1aa>
+      close(1);
+     15e:	83 ec 0c             	sub    $0xc,%esp
+     161:	6a 01                	push   $0x1
+     163:	e8 0a 0e 00 00       	call   f72 <close>
+     168:	83 c4 10             	add    $0x10,%esp
+      dup(p[1]);
+     16b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     16e:	83 ec 0c             	sub    $0xc,%esp
+     171:	50                   	push   %eax
+     172:	e8 4b 0e 00 00       	call   fc2 <dup>
+     177:	83 c4 10             	add    $0x10,%esp
+      close(p[0]);
+     17a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     17d:	83 ec 0c             	sub    $0xc,%esp
+     180:	50                   	push   %eax
+     181:	e8 ec 0d 00 00       	call   f72 <close>
+     186:	83 c4 10             	add    $0x10,%esp
+      close(p[1]);
+     189:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     18c:	83 ec 0c             	sub    $0xc,%esp
+     18f:	50                   	push   %eax
+     190:	e8 dd 0d 00 00       	call   f72 <close>
+     195:	83 c4 10             	add    $0x10,%esp
+      runcmd(pcmd->left);
+     198:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     19b:	8b 40 04             	mov    0x4(%eax),%eax
+     19e:	83 ec 0c             	sub    $0xc,%esp
+     1a1:	50                   	push   %eax
+     1a2:	e8 59 fe ff ff       	call   0 <runcmd>
+     1a7:	83 c4 10             	add    $0x10,%esp
+    }
+    if(fork1() == 0){
+     1aa:	e8 1e 02 00 00       	call   3cd <fork1>
+     1af:	85 c0                	test   %eax,%eax
+     1b1:	75 4c                	jne    1ff <runcmd+0x1ff>
+      close(0);
+     1b3:	83 ec 0c             	sub    $0xc,%esp
+     1b6:	6a 00                	push   $0x0
+     1b8:	e8 b5 0d 00 00       	call   f72 <close>
+     1bd:	83 c4 10             	add    $0x10,%esp
+      dup(p[0]);
+     1c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     1c3:	83 ec 0c             	sub    $0xc,%esp
+     1c6:	50                   	push   %eax
+     1c7:	e8 f6 0d 00 00       	call   fc2 <dup>
+     1cc:	83 c4 10             	add    $0x10,%esp
+      close(p[0]);
+     1cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     1d2:	83 ec 0c             	sub    $0xc,%esp
+     1d5:	50                   	push   %eax
+     1d6:	e8 97 0d 00 00       	call   f72 <close>
+     1db:	83 c4 10             	add    $0x10,%esp
+      close(p[1]);
+     1de:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     1e1:	83 ec 0c             	sub    $0xc,%esp
+     1e4:	50                   	push   %eax
+     1e5:	e8 88 0d 00 00       	call   f72 <close>
+     1ea:	83 c4 10             	add    $0x10,%esp
+      runcmd(pcmd->right);
+     1ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     1f0:	8b 40 08             	mov    0x8(%eax),%eax
+     1f3:	83 ec 0c             	sub    $0xc,%esp
+     1f6:	50                   	push   %eax
+     1f7:	e8 04 fe ff ff       	call   0 <runcmd>
+     1fc:	83 c4 10             	add    $0x10,%esp
+    }
+    close(p[0]);
+     1ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     202:	83 ec 0c             	sub    $0xc,%esp
+     205:	50                   	push   %eax
+     206:	e8 67 0d 00 00       	call   f72 <close>
+     20b:	83 c4 10             	add    $0x10,%esp
+    close(p[1]);
+     20e:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     211:	83 ec 0c             	sub    $0xc,%esp
+     214:	50                   	push   %eax
+     215:	e8 58 0d 00 00       	call   f72 <close>
+     21a:	83 c4 10             	add    $0x10,%esp
+    wait();
+     21d:	e8 30 0d 00 00       	call   f52 <wait>
+    wait();
+     222:	e8 2b 0d 00 00       	call   f52 <wait>
+    break;
+     227:	eb 22                	jmp    24b <runcmd+0x24b>
+
+  case BACK:
+    bcmd = (struct backcmd*)cmd;
+     229:	8b 45 08             	mov    0x8(%ebp),%eax
+     22c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(fork1() == 0)
+     22f:	e8 99 01 00 00       	call   3cd <fork1>
+     234:	85 c0                	test   %eax,%eax
+     236:	75 12                	jne    24a <runcmd+0x24a>
+      runcmd(bcmd->cmd);
+     238:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     23b:	8b 40 04             	mov    0x4(%eax),%eax
+     23e:	83 ec 0c             	sub    $0xc,%esp
+     241:	50                   	push   %eax
+     242:	e8 b9 fd ff ff       	call   0 <runcmd>
+     247:	83 c4 10             	add    $0x10,%esp
+    break;
+     24a:	90                   	nop
+  }
+  exit();
+     24b:	e8 fa 0c 00 00       	call   f4a <exit>
+
+00000250 <getcmd>:
+}
+
+int
+getcmd(char *buf, int nbuf)
+{
+     250:	f3 0f 1e fb          	endbr32 
+     254:	55                   	push   %ebp
+     255:	89 e5                	mov    %esp,%ebp
+     257:	83 ec 08             	sub    $0x8,%esp
+  printf(2, "$ ");
+     25a:	83 ec 08             	sub    $0x8,%esp
+     25d:	68 fc 14 00 00       	push   $0x14fc
+     262:	6a 02                	push   $0x2
+     264:	e8 85 0e 00 00       	call   10ee <printf>
+     269:	83 c4 10             	add    $0x10,%esp
+  memset(buf, 0, nbuf);
+     26c:	8b 45 0c             	mov    0xc(%ebp),%eax
+     26f:	83 ec 04             	sub    $0x4,%esp
+     272:	50                   	push   %eax
+     273:	6a 00                	push   $0x0
+     275:	ff 75 08             	pushl  0x8(%ebp)
+     278:	e8 1a 0b 00 00       	call   d97 <memset>
+     27d:	83 c4 10             	add    $0x10,%esp
+  gets(buf, nbuf);
+     280:	83 ec 08             	sub    $0x8,%esp
+     283:	ff 75 0c             	pushl  0xc(%ebp)
+     286:	ff 75 08             	pushl  0x8(%ebp)
+     289:	e8 5e 0b 00 00       	call   dec <gets>
+     28e:	83 c4 10             	add    $0x10,%esp
+  if(buf[0] == 0) // EOF
+     291:	8b 45 08             	mov    0x8(%ebp),%eax
+     294:	0f b6 00             	movzbl (%eax),%eax
+     297:	84 c0                	test   %al,%al
+     299:	75 07                	jne    2a2 <getcmd+0x52>
+    return -1;
+     29b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+     2a0:	eb 05                	jmp    2a7 <getcmd+0x57>
+  return 0;
+     2a2:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+     2a7:	c9                   	leave  
+     2a8:	c3                   	ret    
+
+000002a9 <main>:
+
+int
+main(void)
+{
+     2a9:	f3 0f 1e fb          	endbr32 
+     2ad:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+     2b1:	83 e4 f0             	and    $0xfffffff0,%esp
+     2b4:	ff 71 fc             	pushl  -0x4(%ecx)
+     2b7:	55                   	push   %ebp
+     2b8:	89 e5                	mov    %esp,%ebp
+     2ba:	51                   	push   %ecx
+     2bb:	83 ec 14             	sub    $0x14,%esp
+  static char buf[100];
+  int fd;
+
+  // Ensure that three file descriptors are open.
+  while((fd = open("console", O_RDWR)) >= 0){
+     2be:	eb 16                	jmp    2d6 <main+0x2d>
+    if(fd >= 3){
+     2c0:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
+     2c4:	7e 10                	jle    2d6 <main+0x2d>
+      close(fd);
+     2c6:	83 ec 0c             	sub    $0xc,%esp
+     2c9:	ff 75 f4             	pushl  -0xc(%ebp)
+     2cc:	e8 a1 0c 00 00       	call   f72 <close>
+     2d1:	83 c4 10             	add    $0x10,%esp
+      break;
+     2d4:	eb 1b                	jmp    2f1 <main+0x48>
+  while((fd = open("console", O_RDWR)) >= 0){
+     2d6:	83 ec 08             	sub    $0x8,%esp
+     2d9:	6a 02                	push   $0x2
+     2db:	68 ff 14 00 00       	push   $0x14ff
+     2e0:	e8 a5 0c 00 00       	call   f8a <open>
+     2e5:	83 c4 10             	add    $0x10,%esp
+     2e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+     2eb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     2ef:	79 cf                	jns    2c0 <main+0x17>
+    }
+  }
+
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0){
+     2f1:	e9 94 00 00 00       	jmp    38a <main+0xe1>
+    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+     2f6:	0f b6 05 60 1a 00 00 	movzbl 0x1a60,%eax
+     2fd:	3c 63                	cmp    $0x63,%al
+     2ff:	75 5f                	jne    360 <main+0xb7>
+     301:	0f b6 05 61 1a 00 00 	movzbl 0x1a61,%eax
+     308:	3c 64                	cmp    $0x64,%al
+     30a:	75 54                	jne    360 <main+0xb7>
+     30c:	0f b6 05 62 1a 00 00 	movzbl 0x1a62,%eax
+     313:	3c 20                	cmp    $0x20,%al
+     315:	75 49                	jne    360 <main+0xb7>
+      // Chdir must be called by the parent, not the child.
+      buf[strlen(buf)-1] = 0;  // chop \n
+     317:	83 ec 0c             	sub    $0xc,%esp
+     31a:	68 60 1a 00 00       	push   $0x1a60
+     31f:	e8 48 0a 00 00       	call   d6c <strlen>
+     324:	83 c4 10             	add    $0x10,%esp
+     327:	83 e8 01             	sub    $0x1,%eax
+     32a:	c6 80 60 1a 00 00 00 	movb   $0x0,0x1a60(%eax)
+      if(chdir(buf+3) < 0)
+     331:	b8 63 1a 00 00       	mov    $0x1a63,%eax
+     336:	83 ec 0c             	sub    $0xc,%esp
+     339:	50                   	push   %eax
+     33a:	e8 7b 0c 00 00       	call   fba <chdir>
+     33f:	83 c4 10             	add    $0x10,%esp
+     342:	85 c0                	test   %eax,%eax
+     344:	79 44                	jns    38a <main+0xe1>
+        printf(2, "cannot cd %s\n", buf+3);
+     346:	b8 63 1a 00 00       	mov    $0x1a63,%eax
+     34b:	83 ec 04             	sub    $0x4,%esp
+     34e:	50                   	push   %eax
+     34f:	68 07 15 00 00       	push   $0x1507
+     354:	6a 02                	push   $0x2
+     356:	e8 93 0d 00 00       	call   10ee <printf>
+     35b:	83 c4 10             	add    $0x10,%esp
+      continue;
+     35e:	eb 2a                	jmp    38a <main+0xe1>
+    }
+    if(fork1() == 0)
+     360:	e8 68 00 00 00       	call   3cd <fork1>
+     365:	85 c0                	test   %eax,%eax
+     367:	75 1c                	jne    385 <main+0xdc>
+      runcmd(parsecmd(buf));
+     369:	83 ec 0c             	sub    $0xc,%esp
+     36c:	68 60 1a 00 00       	push   $0x1a60
+     371:	e8 ce 03 00 00       	call   744 <parsecmd>
+     376:	83 c4 10             	add    $0x10,%esp
+     379:	83 ec 0c             	sub    $0xc,%esp
+     37c:	50                   	push   %eax
+     37d:	e8 7e fc ff ff       	call   0 <runcmd>
+     382:	83 c4 10             	add    $0x10,%esp
+    wait();
+     385:	e8 c8 0b 00 00       	call   f52 <wait>
+  while(getcmd(buf, sizeof(buf)) >= 0){
+     38a:	83 ec 08             	sub    $0x8,%esp
+     38d:	6a 64                	push   $0x64
+     38f:	68 60 1a 00 00       	push   $0x1a60
+     394:	e8 b7 fe ff ff       	call   250 <getcmd>
+     399:	83 c4 10             	add    $0x10,%esp
+     39c:	85 c0                	test   %eax,%eax
+     39e:	0f 89 52 ff ff ff    	jns    2f6 <main+0x4d>
+  }
+  exit();
+     3a4:	e8 a1 0b 00 00       	call   f4a <exit>
+
+000003a9 <panic>:
+}
+
+void
+panic(char *s)
+{
+     3a9:	f3 0f 1e fb          	endbr32 
+     3ad:	55                   	push   %ebp
+     3ae:	89 e5                	mov    %esp,%ebp
+     3b0:	83 ec 08             	sub    $0x8,%esp
+  printf(2, "%s\n", s);
+     3b3:	83 ec 04             	sub    $0x4,%esp
+     3b6:	ff 75 08             	pushl  0x8(%ebp)
+     3b9:	68 15 15 00 00       	push   $0x1515
+     3be:	6a 02                	push   $0x2
+     3c0:	e8 29 0d 00 00       	call   10ee <printf>
+     3c5:	83 c4 10             	add    $0x10,%esp
+  exit();
+     3c8:	e8 7d 0b 00 00       	call   f4a <exit>
+
+000003cd <fork1>:
+}
+
+int
+fork1(void)
+{
+     3cd:	f3 0f 1e fb          	endbr32 
+     3d1:	55                   	push   %ebp
+     3d2:	89 e5                	mov    %esp,%ebp
+     3d4:	83 ec 18             	sub    $0x18,%esp
+  int pid;
+
+  pid = fork();
+     3d7:	e8 66 0b 00 00       	call   f42 <fork>
+     3dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pid == -1)
+     3df:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+     3e3:	75 10                	jne    3f5 <fork1+0x28>
+    panic("fork");
+     3e5:	83 ec 0c             	sub    $0xc,%esp
+     3e8:	68 19 15 00 00       	push   $0x1519
+     3ed:	e8 b7 ff ff ff       	call   3a9 <panic>
+     3f2:	83 c4 10             	add    $0x10,%esp
+  return pid;
+     3f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     3f8:	c9                   	leave  
+     3f9:	c3                   	ret    
+
+000003fa <execcmd>:
+//PAGEBREAK!
+// Constructors
+
+struct cmd*
+execcmd(void)
+{
+     3fa:	f3 0f 1e fb          	endbr32 
+     3fe:	55                   	push   %ebp
+     3ff:	89 e5                	mov    %esp,%ebp
+     401:	83 ec 18             	sub    $0x18,%esp
+  struct execcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     404:	83 ec 0c             	sub    $0xc,%esp
+     407:	6a 54                	push   $0x54
+     409:	e8 c0 0f 00 00       	call   13ce <malloc>
+     40e:	83 c4 10             	add    $0x10,%esp
+     411:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     414:	83 ec 04             	sub    $0x4,%esp
+     417:	6a 54                	push   $0x54
+     419:	6a 00                	push   $0x0
+     41b:	ff 75 f4             	pushl  -0xc(%ebp)
+     41e:	e8 74 09 00 00       	call   d97 <memset>
+     423:	83 c4 10             	add    $0x10,%esp
+  cmd->type = EXEC;
+     426:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     429:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
+  return (struct cmd*)cmd;
+     42f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     432:	c9                   	leave  
+     433:	c3                   	ret    
+
+00000434 <redircmd>:
+
+struct cmd*
+redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+{
+     434:	f3 0f 1e fb          	endbr32 
+     438:	55                   	push   %ebp
+     439:	89 e5                	mov    %esp,%ebp
+     43b:	83 ec 18             	sub    $0x18,%esp
+  struct redircmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     43e:	83 ec 0c             	sub    $0xc,%esp
+     441:	6a 18                	push   $0x18
+     443:	e8 86 0f 00 00       	call   13ce <malloc>
+     448:	83 c4 10             	add    $0x10,%esp
+     44b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     44e:	83 ec 04             	sub    $0x4,%esp
+     451:	6a 18                	push   $0x18
+     453:	6a 00                	push   $0x0
+     455:	ff 75 f4             	pushl  -0xc(%ebp)
+     458:	e8 3a 09 00 00       	call   d97 <memset>
+     45d:	83 c4 10             	add    $0x10,%esp
+  cmd->type = REDIR;
+     460:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     463:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
+  cmd->cmd = subcmd;
+     469:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     46c:	8b 55 08             	mov    0x8(%ebp),%edx
+     46f:	89 50 04             	mov    %edx,0x4(%eax)
+  cmd->file = file;
+     472:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     475:	8b 55 0c             	mov    0xc(%ebp),%edx
+     478:	89 50 08             	mov    %edx,0x8(%eax)
+  cmd->efile = efile;
+     47b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     47e:	8b 55 10             	mov    0x10(%ebp),%edx
+     481:	89 50 0c             	mov    %edx,0xc(%eax)
+  cmd->mode = mode;
+     484:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     487:	8b 55 14             	mov    0x14(%ebp),%edx
+     48a:	89 50 10             	mov    %edx,0x10(%eax)
+  cmd->fd = fd;
+     48d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     490:	8b 55 18             	mov    0x18(%ebp),%edx
+     493:	89 50 14             	mov    %edx,0x14(%eax)
+  return (struct cmd*)cmd;
+     496:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     499:	c9                   	leave  
+     49a:	c3                   	ret    
+
+0000049b <pipecmd>:
+
+struct cmd*
+pipecmd(struct cmd *left, struct cmd *right)
+{
+     49b:	f3 0f 1e fb          	endbr32 
+     49f:	55                   	push   %ebp
+     4a0:	89 e5                	mov    %esp,%ebp
+     4a2:	83 ec 18             	sub    $0x18,%esp
+  struct pipecmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     4a5:	83 ec 0c             	sub    $0xc,%esp
+     4a8:	6a 0c                	push   $0xc
+     4aa:	e8 1f 0f 00 00       	call   13ce <malloc>
+     4af:	83 c4 10             	add    $0x10,%esp
+     4b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     4b5:	83 ec 04             	sub    $0x4,%esp
+     4b8:	6a 0c                	push   $0xc
+     4ba:	6a 00                	push   $0x0
+     4bc:	ff 75 f4             	pushl  -0xc(%ebp)
+     4bf:	e8 d3 08 00 00       	call   d97 <memset>
+     4c4:	83 c4 10             	add    $0x10,%esp
+  cmd->type = PIPE;
+     4c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     4ca:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
+  cmd->left = left;
+     4d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     4d3:	8b 55 08             	mov    0x8(%ebp),%edx
+     4d6:	89 50 04             	mov    %edx,0x4(%eax)
+  cmd->right = right;
+     4d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     4dc:	8b 55 0c             	mov    0xc(%ebp),%edx
+     4df:	89 50 08             	mov    %edx,0x8(%eax)
+  return (struct cmd*)cmd;
+     4e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     4e5:	c9                   	leave  
+     4e6:	c3                   	ret    
+
+000004e7 <listcmd>:
+
+struct cmd*
+listcmd(struct cmd *left, struct cmd *right)
+{
+     4e7:	f3 0f 1e fb          	endbr32 
+     4eb:	55                   	push   %ebp
+     4ec:	89 e5                	mov    %esp,%ebp
+     4ee:	83 ec 18             	sub    $0x18,%esp
+  struct listcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     4f1:	83 ec 0c             	sub    $0xc,%esp
+     4f4:	6a 0c                	push   $0xc
+     4f6:	e8 d3 0e 00 00       	call   13ce <malloc>
+     4fb:	83 c4 10             	add    $0x10,%esp
+     4fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     501:	83 ec 04             	sub    $0x4,%esp
+     504:	6a 0c                	push   $0xc
+     506:	6a 00                	push   $0x0
+     508:	ff 75 f4             	pushl  -0xc(%ebp)
+     50b:	e8 87 08 00 00       	call   d97 <memset>
+     510:	83 c4 10             	add    $0x10,%esp
+  cmd->type = LIST;
+     513:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     516:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
+  cmd->left = left;
+     51c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     51f:	8b 55 08             	mov    0x8(%ebp),%edx
+     522:	89 50 04             	mov    %edx,0x4(%eax)
+  cmd->right = right;
+     525:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     528:	8b 55 0c             	mov    0xc(%ebp),%edx
+     52b:	89 50 08             	mov    %edx,0x8(%eax)
+  return (struct cmd*)cmd;
+     52e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     531:	c9                   	leave  
+     532:	c3                   	ret    
+
+00000533 <backcmd>:
+
+struct cmd*
+backcmd(struct cmd *subcmd)
+{
+     533:	f3 0f 1e fb          	endbr32 
+     537:	55                   	push   %ebp
+     538:	89 e5                	mov    %esp,%ebp
+     53a:	83 ec 18             	sub    $0x18,%esp
+  struct backcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     53d:	83 ec 0c             	sub    $0xc,%esp
+     540:	6a 08                	push   $0x8
+     542:	e8 87 0e 00 00       	call   13ce <malloc>
+     547:	83 c4 10             	add    $0x10,%esp
+     54a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  memset(cmd, 0, sizeof(*cmd));
+     54d:	83 ec 04             	sub    $0x4,%esp
+     550:	6a 08                	push   $0x8
+     552:	6a 00                	push   $0x0
+     554:	ff 75 f4             	pushl  -0xc(%ebp)
+     557:	e8 3b 08 00 00       	call   d97 <memset>
+     55c:	83 c4 10             	add    $0x10,%esp
+  cmd->type = BACK;
+     55f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     562:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
+  cmd->cmd = subcmd;
+     568:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     56b:	8b 55 08             	mov    0x8(%ebp),%edx
+     56e:	89 50 04             	mov    %edx,0x4(%eax)
+  return (struct cmd*)cmd;
+     571:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     574:	c9                   	leave  
+     575:	c3                   	ret    
+
+00000576 <gettoken>:
+char whitespace[] = " \t\r\n\v";
+char symbols[] = "<|>&;()";
+
+int
+gettoken(char **ps, char *es, char **q, char **eq)
+{
+     576:	f3 0f 1e fb          	endbr32 
+     57a:	55                   	push   %ebp
+     57b:	89 e5                	mov    %esp,%ebp
+     57d:	83 ec 18             	sub    $0x18,%esp
+  char *s;
+  int ret;
+
+  s = *ps;
+     580:	8b 45 08             	mov    0x8(%ebp),%eax
+     583:	8b 00                	mov    (%eax),%eax
+     585:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(s < es && strchr(whitespace, *s))
+     588:	eb 04                	jmp    58e <gettoken+0x18>
+    s++;
+     58a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  while(s < es && strchr(whitespace, *s))
+     58e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     591:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     594:	73 1e                	jae    5b4 <gettoken+0x3e>
+     596:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     599:	0f b6 00             	movzbl (%eax),%eax
+     59c:	0f be c0             	movsbl %al,%eax
+     59f:	83 ec 08             	sub    $0x8,%esp
+     5a2:	50                   	push   %eax
+     5a3:	68 30 1a 00 00       	push   $0x1a30
+     5a8:	e8 08 08 00 00       	call   db5 <strchr>
+     5ad:	83 c4 10             	add    $0x10,%esp
+     5b0:	85 c0                	test   %eax,%eax
+     5b2:	75 d6                	jne    58a <gettoken+0x14>
+  if(q)
+     5b4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+     5b8:	74 08                	je     5c2 <gettoken+0x4c>
+    *q = s;
+     5ba:	8b 45 10             	mov    0x10(%ebp),%eax
+     5bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     5c0:	89 10                	mov    %edx,(%eax)
+  ret = *s;
+     5c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     5c5:	0f b6 00             	movzbl (%eax),%eax
+     5c8:	0f be c0             	movsbl %al,%eax
+     5cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  switch(*s){
+     5ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     5d1:	0f b6 00             	movzbl (%eax),%eax
+     5d4:	0f be c0             	movsbl %al,%eax
+     5d7:	83 f8 7c             	cmp    $0x7c,%eax
+     5da:	74 2c                	je     608 <gettoken+0x92>
+     5dc:	83 f8 7c             	cmp    $0x7c,%eax
+     5df:	7f 48                	jg     629 <gettoken+0xb3>
+     5e1:	83 f8 3e             	cmp    $0x3e,%eax
+     5e4:	74 28                	je     60e <gettoken+0x98>
+     5e6:	83 f8 3e             	cmp    $0x3e,%eax
+     5e9:	7f 3e                	jg     629 <gettoken+0xb3>
+     5eb:	83 f8 3c             	cmp    $0x3c,%eax
+     5ee:	7f 39                	jg     629 <gettoken+0xb3>
+     5f0:	83 f8 3b             	cmp    $0x3b,%eax
+     5f3:	7d 13                	jge    608 <gettoken+0x92>
+     5f5:	83 f8 29             	cmp    $0x29,%eax
+     5f8:	7f 2f                	jg     629 <gettoken+0xb3>
+     5fa:	83 f8 28             	cmp    $0x28,%eax
+     5fd:	7d 09                	jge    608 <gettoken+0x92>
+     5ff:	85 c0                	test   %eax,%eax
+     601:	74 79                	je     67c <gettoken+0x106>
+     603:	83 f8 26             	cmp    $0x26,%eax
+     606:	75 21                	jne    629 <gettoken+0xb3>
+  case '(':
+  case ')':
+  case ';':
+  case '&':
+  case '<':
+    s++;
+     608:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    break;
+     60c:	eb 75                	jmp    683 <gettoken+0x10d>
+  case '>':
+    s++;
+     60e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(*s == '>'){
+     612:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     615:	0f b6 00             	movzbl (%eax),%eax
+     618:	3c 3e                	cmp    $0x3e,%al
+     61a:	75 63                	jne    67f <gettoken+0x109>
+      ret = '+';
+     61c:	c7 45 f0 2b 00 00 00 	movl   $0x2b,-0x10(%ebp)
+      s++;
+     623:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    }
+    break;
+     627:	eb 56                	jmp    67f <gettoken+0x109>
+  default:
+    ret = 'a';
+     629:	c7 45 f0 61 00 00 00 	movl   $0x61,-0x10(%ebp)
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     630:	eb 04                	jmp    636 <gettoken+0xc0>
+      s++;
+     632:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     636:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     639:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     63c:	73 44                	jae    682 <gettoken+0x10c>
+     63e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     641:	0f b6 00             	movzbl (%eax),%eax
+     644:	0f be c0             	movsbl %al,%eax
+     647:	83 ec 08             	sub    $0x8,%esp
+     64a:	50                   	push   %eax
+     64b:	68 30 1a 00 00       	push   $0x1a30
+     650:	e8 60 07 00 00       	call   db5 <strchr>
+     655:	83 c4 10             	add    $0x10,%esp
+     658:	85 c0                	test   %eax,%eax
+     65a:	75 26                	jne    682 <gettoken+0x10c>
+     65c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     65f:	0f b6 00             	movzbl (%eax),%eax
+     662:	0f be c0             	movsbl %al,%eax
+     665:	83 ec 08             	sub    $0x8,%esp
+     668:	50                   	push   %eax
+     669:	68 38 1a 00 00       	push   $0x1a38
+     66e:	e8 42 07 00 00       	call   db5 <strchr>
+     673:	83 c4 10             	add    $0x10,%esp
+     676:	85 c0                	test   %eax,%eax
+     678:	74 b8                	je     632 <gettoken+0xbc>
+    break;
+     67a:	eb 06                	jmp    682 <gettoken+0x10c>
+    break;
+     67c:	90                   	nop
+     67d:	eb 04                	jmp    683 <gettoken+0x10d>
+    break;
+     67f:	90                   	nop
+     680:	eb 01                	jmp    683 <gettoken+0x10d>
+    break;
+     682:	90                   	nop
+  }
+  if(eq)
+     683:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+     687:	74 0e                	je     697 <gettoken+0x121>
+    *eq = s;
+     689:	8b 45 14             	mov    0x14(%ebp),%eax
+     68c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     68f:	89 10                	mov    %edx,(%eax)
+
+  while(s < es && strchr(whitespace, *s))
+     691:	eb 04                	jmp    697 <gettoken+0x121>
+    s++;
+     693:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  while(s < es && strchr(whitespace, *s))
+     697:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     69a:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     69d:	73 1e                	jae    6bd <gettoken+0x147>
+     69f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     6a2:	0f b6 00             	movzbl (%eax),%eax
+     6a5:	0f be c0             	movsbl %al,%eax
+     6a8:	83 ec 08             	sub    $0x8,%esp
+     6ab:	50                   	push   %eax
+     6ac:	68 30 1a 00 00       	push   $0x1a30
+     6b1:	e8 ff 06 00 00       	call   db5 <strchr>
+     6b6:	83 c4 10             	add    $0x10,%esp
+     6b9:	85 c0                	test   %eax,%eax
+     6bb:	75 d6                	jne    693 <gettoken+0x11d>
+  *ps = s;
+     6bd:	8b 45 08             	mov    0x8(%ebp),%eax
+     6c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     6c3:	89 10                	mov    %edx,(%eax)
+  return ret;
+     6c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+     6c8:	c9                   	leave  
+     6c9:	c3                   	ret    
+
+000006ca <peek>:
+
+int
+peek(char **ps, char *es, char *toks)
+{
+     6ca:	f3 0f 1e fb          	endbr32 
+     6ce:	55                   	push   %ebp
+     6cf:	89 e5                	mov    %esp,%ebp
+     6d1:	83 ec 18             	sub    $0x18,%esp
+  char *s;
+
+  s = *ps;
+     6d4:	8b 45 08             	mov    0x8(%ebp),%eax
+     6d7:	8b 00                	mov    (%eax),%eax
+     6d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(s < es && strchr(whitespace, *s))
+     6dc:	eb 04                	jmp    6e2 <peek+0x18>
+    s++;
+     6de:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  while(s < es && strchr(whitespace, *s))
+     6e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     6e5:	3b 45 0c             	cmp    0xc(%ebp),%eax
+     6e8:	73 1e                	jae    708 <peek+0x3e>
+     6ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     6ed:	0f b6 00             	movzbl (%eax),%eax
+     6f0:	0f be c0             	movsbl %al,%eax
+     6f3:	83 ec 08             	sub    $0x8,%esp
+     6f6:	50                   	push   %eax
+     6f7:	68 30 1a 00 00       	push   $0x1a30
+     6fc:	e8 b4 06 00 00       	call   db5 <strchr>
+     701:	83 c4 10             	add    $0x10,%esp
+     704:	85 c0                	test   %eax,%eax
+     706:	75 d6                	jne    6de <peek+0x14>
+  *ps = s;
+     708:	8b 45 08             	mov    0x8(%ebp),%eax
+     70b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     70e:	89 10                	mov    %edx,(%eax)
+  return *s && strchr(toks, *s);
+     710:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     713:	0f b6 00             	movzbl (%eax),%eax
+     716:	84 c0                	test   %al,%al
+     718:	74 23                	je     73d <peek+0x73>
+     71a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     71d:	0f b6 00             	movzbl (%eax),%eax
+     720:	0f be c0             	movsbl %al,%eax
+     723:	83 ec 08             	sub    $0x8,%esp
+     726:	50                   	push   %eax
+     727:	ff 75 10             	pushl  0x10(%ebp)
+     72a:	e8 86 06 00 00       	call   db5 <strchr>
+     72f:	83 c4 10             	add    $0x10,%esp
+     732:	85 c0                	test   %eax,%eax
+     734:	74 07                	je     73d <peek+0x73>
+     736:	b8 01 00 00 00       	mov    $0x1,%eax
+     73b:	eb 05                	jmp    742 <peek+0x78>
+     73d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+     742:	c9                   	leave  
+     743:	c3                   	ret    
+
+00000744 <parsecmd>:
+struct cmd *parseexec(char**, char*);
+struct cmd *nulterminate(struct cmd*);
+
+struct cmd*
+parsecmd(char *s)
+{
+     744:	f3 0f 1e fb          	endbr32 
+     748:	55                   	push   %ebp
+     749:	89 e5                	mov    %esp,%ebp
+     74b:	53                   	push   %ebx
+     74c:	83 ec 14             	sub    $0x14,%esp
+  char *es;
+  struct cmd *cmd;
+
+  es = s + strlen(s);
+     74f:	8b 5d 08             	mov    0x8(%ebp),%ebx
+     752:	8b 45 08             	mov    0x8(%ebp),%eax
+     755:	83 ec 0c             	sub    $0xc,%esp
+     758:	50                   	push   %eax
+     759:	e8 0e 06 00 00       	call   d6c <strlen>
+     75e:	83 c4 10             	add    $0x10,%esp
+     761:	01 d8                	add    %ebx,%eax
+     763:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  cmd = parseline(&s, es);
+     766:	83 ec 08             	sub    $0x8,%esp
+     769:	ff 75 f4             	pushl  -0xc(%ebp)
+     76c:	8d 45 08             	lea    0x8(%ebp),%eax
+     76f:	50                   	push   %eax
+     770:	e8 61 00 00 00       	call   7d6 <parseline>
+     775:	83 c4 10             	add    $0x10,%esp
+     778:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  peek(&s, es, "");
+     77b:	83 ec 04             	sub    $0x4,%esp
+     77e:	68 1e 15 00 00       	push   $0x151e
+     783:	ff 75 f4             	pushl  -0xc(%ebp)
+     786:	8d 45 08             	lea    0x8(%ebp),%eax
+     789:	50                   	push   %eax
+     78a:	e8 3b ff ff ff       	call   6ca <peek>
+     78f:	83 c4 10             	add    $0x10,%esp
+  if(s != es){
+     792:	8b 45 08             	mov    0x8(%ebp),%eax
+     795:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+     798:	74 26                	je     7c0 <parsecmd+0x7c>
+    printf(2, "leftovers: %s\n", s);
+     79a:	8b 45 08             	mov    0x8(%ebp),%eax
+     79d:	83 ec 04             	sub    $0x4,%esp
+     7a0:	50                   	push   %eax
+     7a1:	68 1f 15 00 00       	push   $0x151f
+     7a6:	6a 02                	push   $0x2
+     7a8:	e8 41 09 00 00       	call   10ee <printf>
+     7ad:	83 c4 10             	add    $0x10,%esp
+    panic("syntax");
+     7b0:	83 ec 0c             	sub    $0xc,%esp
+     7b3:	68 2e 15 00 00       	push   $0x152e
+     7b8:	e8 ec fb ff ff       	call   3a9 <panic>
+     7bd:	83 c4 10             	add    $0x10,%esp
+  }
+  nulterminate(cmd);
+     7c0:	83 ec 0c             	sub    $0xc,%esp
+     7c3:	ff 75 f0             	pushl  -0x10(%ebp)
+     7c6:	e8 03 04 00 00       	call   bce <nulterminate>
+     7cb:	83 c4 10             	add    $0x10,%esp
+  return cmd;
+     7ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+     7d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+     7d4:	c9                   	leave  
+     7d5:	c3                   	ret    
+
+000007d6 <parseline>:
+
+struct cmd*
+parseline(char **ps, char *es)
+{
+     7d6:	f3 0f 1e fb          	endbr32 
+     7da:	55                   	push   %ebp
+     7db:	89 e5                	mov    %esp,%ebp
+     7dd:	83 ec 18             	sub    $0x18,%esp
+  struct cmd *cmd;
+
+  cmd = parsepipe(ps, es);
+     7e0:	83 ec 08             	sub    $0x8,%esp
+     7e3:	ff 75 0c             	pushl  0xc(%ebp)
+     7e6:	ff 75 08             	pushl  0x8(%ebp)
+     7e9:	e8 99 00 00 00       	call   887 <parsepipe>
+     7ee:	83 c4 10             	add    $0x10,%esp
+     7f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(peek(ps, es, "&")){
+     7f4:	eb 23                	jmp    819 <parseline+0x43>
+    gettoken(ps, es, 0, 0);
+     7f6:	6a 00                	push   $0x0
+     7f8:	6a 00                	push   $0x0
+     7fa:	ff 75 0c             	pushl  0xc(%ebp)
+     7fd:	ff 75 08             	pushl  0x8(%ebp)
+     800:	e8 71 fd ff ff       	call   576 <gettoken>
+     805:	83 c4 10             	add    $0x10,%esp
+    cmd = backcmd(cmd);
+     808:	83 ec 0c             	sub    $0xc,%esp
+     80b:	ff 75 f4             	pushl  -0xc(%ebp)
+     80e:	e8 20 fd ff ff       	call   533 <backcmd>
+     813:	83 c4 10             	add    $0x10,%esp
+     816:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  while(peek(ps, es, "&")){
+     819:	83 ec 04             	sub    $0x4,%esp
+     81c:	68 35 15 00 00       	push   $0x1535
+     821:	ff 75 0c             	pushl  0xc(%ebp)
+     824:	ff 75 08             	pushl  0x8(%ebp)
+     827:	e8 9e fe ff ff       	call   6ca <peek>
+     82c:	83 c4 10             	add    $0x10,%esp
+     82f:	85 c0                	test   %eax,%eax
+     831:	75 c3                	jne    7f6 <parseline+0x20>
+  }
+  if(peek(ps, es, ";")){
+     833:	83 ec 04             	sub    $0x4,%esp
+     836:	68 37 15 00 00       	push   $0x1537
+     83b:	ff 75 0c             	pushl  0xc(%ebp)
+     83e:	ff 75 08             	pushl  0x8(%ebp)
+     841:	e8 84 fe ff ff       	call   6ca <peek>
+     846:	83 c4 10             	add    $0x10,%esp
+     849:	85 c0                	test   %eax,%eax
+     84b:	74 35                	je     882 <parseline+0xac>
+    gettoken(ps, es, 0, 0);
+     84d:	6a 00                	push   $0x0
+     84f:	6a 00                	push   $0x0
+     851:	ff 75 0c             	pushl  0xc(%ebp)
+     854:	ff 75 08             	pushl  0x8(%ebp)
+     857:	e8 1a fd ff ff       	call   576 <gettoken>
+     85c:	83 c4 10             	add    $0x10,%esp
+    cmd = listcmd(cmd, parseline(ps, es));
+     85f:	83 ec 08             	sub    $0x8,%esp
+     862:	ff 75 0c             	pushl  0xc(%ebp)
+     865:	ff 75 08             	pushl  0x8(%ebp)
+     868:	e8 69 ff ff ff       	call   7d6 <parseline>
+     86d:	83 c4 10             	add    $0x10,%esp
+     870:	83 ec 08             	sub    $0x8,%esp
+     873:	50                   	push   %eax
+     874:	ff 75 f4             	pushl  -0xc(%ebp)
+     877:	e8 6b fc ff ff       	call   4e7 <listcmd>
+     87c:	83 c4 10             	add    $0x10,%esp
+     87f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  }
+  return cmd;
+     882:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     885:	c9                   	leave  
+     886:	c3                   	ret    
+
+00000887 <parsepipe>:
+
+struct cmd*
+parsepipe(char **ps, char *es)
+{
+     887:	f3 0f 1e fb          	endbr32 
+     88b:	55                   	push   %ebp
+     88c:	89 e5                	mov    %esp,%ebp
+     88e:	83 ec 18             	sub    $0x18,%esp
+  struct cmd *cmd;
+
+  cmd = parseexec(ps, es);
+     891:	83 ec 08             	sub    $0x8,%esp
+     894:	ff 75 0c             	pushl  0xc(%ebp)
+     897:	ff 75 08             	pushl  0x8(%ebp)
+     89a:	e8 f8 01 00 00       	call   a97 <parseexec>
+     89f:	83 c4 10             	add    $0x10,%esp
+     8a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(peek(ps, es, "|")){
+     8a5:	83 ec 04             	sub    $0x4,%esp
+     8a8:	68 39 15 00 00       	push   $0x1539
+     8ad:	ff 75 0c             	pushl  0xc(%ebp)
+     8b0:	ff 75 08             	pushl  0x8(%ebp)
+     8b3:	e8 12 fe ff ff       	call   6ca <peek>
+     8b8:	83 c4 10             	add    $0x10,%esp
+     8bb:	85 c0                	test   %eax,%eax
+     8bd:	74 35                	je     8f4 <parsepipe+0x6d>
+    gettoken(ps, es, 0, 0);
+     8bf:	6a 00                	push   $0x0
+     8c1:	6a 00                	push   $0x0
+     8c3:	ff 75 0c             	pushl  0xc(%ebp)
+     8c6:	ff 75 08             	pushl  0x8(%ebp)
+     8c9:	e8 a8 fc ff ff       	call   576 <gettoken>
+     8ce:	83 c4 10             	add    $0x10,%esp
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+     8d1:	83 ec 08             	sub    $0x8,%esp
+     8d4:	ff 75 0c             	pushl  0xc(%ebp)
+     8d7:	ff 75 08             	pushl  0x8(%ebp)
+     8da:	e8 a8 ff ff ff       	call   887 <parsepipe>
+     8df:	83 c4 10             	add    $0x10,%esp
+     8e2:	83 ec 08             	sub    $0x8,%esp
+     8e5:	50                   	push   %eax
+     8e6:	ff 75 f4             	pushl  -0xc(%ebp)
+     8e9:	e8 ad fb ff ff       	call   49b <pipecmd>
+     8ee:	83 c4 10             	add    $0x10,%esp
+     8f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  }
+  return cmd;
+     8f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     8f7:	c9                   	leave  
+     8f8:	c3                   	ret    
+
+000008f9 <parseredirs>:
+
+struct cmd*
+parseredirs(struct cmd *cmd, char **ps, char *es)
+{
+     8f9:	f3 0f 1e fb          	endbr32 
+     8fd:	55                   	push   %ebp
+     8fe:	89 e5                	mov    %esp,%ebp
+     900:	83 ec 18             	sub    $0x18,%esp
+  int tok;
+  char *q, *eq;
+
+  while(peek(ps, es, "<>")){
+     903:	e9 ba 00 00 00       	jmp    9c2 <parseredirs+0xc9>
+    tok = gettoken(ps, es, 0, 0);
+     908:	6a 00                	push   $0x0
+     90a:	6a 00                	push   $0x0
+     90c:	ff 75 10             	pushl  0x10(%ebp)
+     90f:	ff 75 0c             	pushl  0xc(%ebp)
+     912:	e8 5f fc ff ff       	call   576 <gettoken>
+     917:	83 c4 10             	add    $0x10,%esp
+     91a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(gettoken(ps, es, &q, &eq) != 'a')
+     91d:	8d 45 ec             	lea    -0x14(%ebp),%eax
+     920:	50                   	push   %eax
+     921:	8d 45 f0             	lea    -0x10(%ebp),%eax
+     924:	50                   	push   %eax
+     925:	ff 75 10             	pushl  0x10(%ebp)
+     928:	ff 75 0c             	pushl  0xc(%ebp)
+     92b:	e8 46 fc ff ff       	call   576 <gettoken>
+     930:	83 c4 10             	add    $0x10,%esp
+     933:	83 f8 61             	cmp    $0x61,%eax
+     936:	74 10                	je     948 <parseredirs+0x4f>
+      panic("missing file for redirection");
+     938:	83 ec 0c             	sub    $0xc,%esp
+     93b:	68 3b 15 00 00       	push   $0x153b
+     940:	e8 64 fa ff ff       	call   3a9 <panic>
+     945:	83 c4 10             	add    $0x10,%esp
+    switch(tok){
+     948:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
+     94c:	74 31                	je     97f <parseredirs+0x86>
+     94e:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
+     952:	7f 6e                	jg     9c2 <parseredirs+0xc9>
+     954:	83 7d f4 2b          	cmpl   $0x2b,-0xc(%ebp)
+     958:	74 47                	je     9a1 <parseredirs+0xa8>
+     95a:	83 7d f4 3c          	cmpl   $0x3c,-0xc(%ebp)
+     95e:	75 62                	jne    9c2 <parseredirs+0xc9>
+    case '<':
+      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+     960:	8b 55 ec             	mov    -0x14(%ebp),%edx
+     963:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     966:	83 ec 0c             	sub    $0xc,%esp
+     969:	6a 00                	push   $0x0
+     96b:	6a 00                	push   $0x0
+     96d:	52                   	push   %edx
+     96e:	50                   	push   %eax
+     96f:	ff 75 08             	pushl  0x8(%ebp)
+     972:	e8 bd fa ff ff       	call   434 <redircmd>
+     977:	83 c4 20             	add    $0x20,%esp
+     97a:	89 45 08             	mov    %eax,0x8(%ebp)
+      break;
+     97d:	eb 43                	jmp    9c2 <parseredirs+0xc9>
+    case '>':
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+     97f:	8b 55 ec             	mov    -0x14(%ebp),%edx
+     982:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     985:	83 ec 0c             	sub    $0xc,%esp
+     988:	6a 01                	push   $0x1
+     98a:	68 01 02 00 00       	push   $0x201
+     98f:	52                   	push   %edx
+     990:	50                   	push   %eax
+     991:	ff 75 08             	pushl  0x8(%ebp)
+     994:	e8 9b fa ff ff       	call   434 <redircmd>
+     999:	83 c4 20             	add    $0x20,%esp
+     99c:	89 45 08             	mov    %eax,0x8(%ebp)
+      break;
+     99f:	eb 21                	jmp    9c2 <parseredirs+0xc9>
+    case '+':  // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+     9a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
+     9a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     9a7:	83 ec 0c             	sub    $0xc,%esp
+     9aa:	6a 01                	push   $0x1
+     9ac:	68 01 02 00 00       	push   $0x201
+     9b1:	52                   	push   %edx
+     9b2:	50                   	push   %eax
+     9b3:	ff 75 08             	pushl  0x8(%ebp)
+     9b6:	e8 79 fa ff ff       	call   434 <redircmd>
+     9bb:	83 c4 20             	add    $0x20,%esp
+     9be:	89 45 08             	mov    %eax,0x8(%ebp)
+      break;
+     9c1:	90                   	nop
+  while(peek(ps, es, "<>")){
+     9c2:	83 ec 04             	sub    $0x4,%esp
+     9c5:	68 58 15 00 00       	push   $0x1558
+     9ca:	ff 75 10             	pushl  0x10(%ebp)
+     9cd:	ff 75 0c             	pushl  0xc(%ebp)
+     9d0:	e8 f5 fc ff ff       	call   6ca <peek>
+     9d5:	83 c4 10             	add    $0x10,%esp
+     9d8:	85 c0                	test   %eax,%eax
+     9da:	0f 85 28 ff ff ff    	jne    908 <parseredirs+0xf>
+    }
+  }
+  return cmd;
+     9e0:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     9e3:	c9                   	leave  
+     9e4:	c3                   	ret    
+
+000009e5 <parseblock>:
+
+struct cmd*
+parseblock(char **ps, char *es)
+{
+     9e5:	f3 0f 1e fb          	endbr32 
+     9e9:	55                   	push   %ebp
+     9ea:	89 e5                	mov    %esp,%ebp
+     9ec:	83 ec 18             	sub    $0x18,%esp
+  struct cmd *cmd;
+
+  if(!peek(ps, es, "("))
+     9ef:	83 ec 04             	sub    $0x4,%esp
+     9f2:	68 5b 15 00 00       	push   $0x155b
+     9f7:	ff 75 0c             	pushl  0xc(%ebp)
+     9fa:	ff 75 08             	pushl  0x8(%ebp)
+     9fd:	e8 c8 fc ff ff       	call   6ca <peek>
+     a02:	83 c4 10             	add    $0x10,%esp
+     a05:	85 c0                	test   %eax,%eax
+     a07:	75 10                	jne    a19 <parseblock+0x34>
+    panic("parseblock");
+     a09:	83 ec 0c             	sub    $0xc,%esp
+     a0c:	68 5d 15 00 00       	push   $0x155d
+     a11:	e8 93 f9 ff ff       	call   3a9 <panic>
+     a16:	83 c4 10             	add    $0x10,%esp
+  gettoken(ps, es, 0, 0);
+     a19:	6a 00                	push   $0x0
+     a1b:	6a 00                	push   $0x0
+     a1d:	ff 75 0c             	pushl  0xc(%ebp)
+     a20:	ff 75 08             	pushl  0x8(%ebp)
+     a23:	e8 4e fb ff ff       	call   576 <gettoken>
+     a28:	83 c4 10             	add    $0x10,%esp
+  cmd = parseline(ps, es);
+     a2b:	83 ec 08             	sub    $0x8,%esp
+     a2e:	ff 75 0c             	pushl  0xc(%ebp)
+     a31:	ff 75 08             	pushl  0x8(%ebp)
+     a34:	e8 9d fd ff ff       	call   7d6 <parseline>
+     a39:	83 c4 10             	add    $0x10,%esp
+     a3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(!peek(ps, es, ")"))
+     a3f:	83 ec 04             	sub    $0x4,%esp
+     a42:	68 68 15 00 00       	push   $0x1568
+     a47:	ff 75 0c             	pushl  0xc(%ebp)
+     a4a:	ff 75 08             	pushl  0x8(%ebp)
+     a4d:	e8 78 fc ff ff       	call   6ca <peek>
+     a52:	83 c4 10             	add    $0x10,%esp
+     a55:	85 c0                	test   %eax,%eax
+     a57:	75 10                	jne    a69 <parseblock+0x84>
+    panic("syntax - missing )");
+     a59:	83 ec 0c             	sub    $0xc,%esp
+     a5c:	68 6a 15 00 00       	push   $0x156a
+     a61:	e8 43 f9 ff ff       	call   3a9 <panic>
+     a66:	83 c4 10             	add    $0x10,%esp
+  gettoken(ps, es, 0, 0);
+     a69:	6a 00                	push   $0x0
+     a6b:	6a 00                	push   $0x0
+     a6d:	ff 75 0c             	pushl  0xc(%ebp)
+     a70:	ff 75 08             	pushl  0x8(%ebp)
+     a73:	e8 fe fa ff ff       	call   576 <gettoken>
+     a78:	83 c4 10             	add    $0x10,%esp
+  cmd = parseredirs(cmd, ps, es);
+     a7b:	83 ec 04             	sub    $0x4,%esp
+     a7e:	ff 75 0c             	pushl  0xc(%ebp)
+     a81:	ff 75 08             	pushl  0x8(%ebp)
+     a84:	ff 75 f4             	pushl  -0xc(%ebp)
+     a87:	e8 6d fe ff ff       	call   8f9 <parseredirs>
+     a8c:	83 c4 10             	add    $0x10,%esp
+     a8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  return cmd;
+     a92:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+     a95:	c9                   	leave  
+     a96:	c3                   	ret    
+
+00000a97 <parseexec>:
+
+struct cmd*
+parseexec(char **ps, char *es)
+{
+     a97:	f3 0f 1e fb          	endbr32 
+     a9b:	55                   	push   %ebp
+     a9c:	89 e5                	mov    %esp,%ebp
+     a9e:	83 ec 28             	sub    $0x28,%esp
+  char *q, *eq;
+  int tok, argc;
+  struct execcmd *cmd;
+  struct cmd *ret;
+
+  if(peek(ps, es, "("))
+     aa1:	83 ec 04             	sub    $0x4,%esp
+     aa4:	68 5b 15 00 00       	push   $0x155b
+     aa9:	ff 75 0c             	pushl  0xc(%ebp)
+     aac:	ff 75 08             	pushl  0x8(%ebp)
+     aaf:	e8 16 fc ff ff       	call   6ca <peek>
+     ab4:	83 c4 10             	add    $0x10,%esp
+     ab7:	85 c0                	test   %eax,%eax
+     ab9:	74 16                	je     ad1 <parseexec+0x3a>
+    return parseblock(ps, es);
+     abb:	83 ec 08             	sub    $0x8,%esp
+     abe:	ff 75 0c             	pushl  0xc(%ebp)
+     ac1:	ff 75 08             	pushl  0x8(%ebp)
+     ac4:	e8 1c ff ff ff       	call   9e5 <parseblock>
+     ac9:	83 c4 10             	add    $0x10,%esp
+     acc:	e9 fb 00 00 00       	jmp    bcc <parseexec+0x135>
+
+  ret = execcmd();
+     ad1:	e8 24 f9 ff ff       	call   3fa <execcmd>
+     ad6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  cmd = (struct execcmd*)ret;
+     ad9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     adc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+  argc = 0;
+     adf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  ret = parseredirs(ret, ps, es);
+     ae6:	83 ec 04             	sub    $0x4,%esp
+     ae9:	ff 75 0c             	pushl  0xc(%ebp)
+     aec:	ff 75 08             	pushl  0x8(%ebp)
+     aef:	ff 75 f0             	pushl  -0x10(%ebp)
+     af2:	e8 02 fe ff ff       	call   8f9 <parseredirs>
+     af7:	83 c4 10             	add    $0x10,%esp
+     afa:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  while(!peek(ps, es, "|)&;")){
+     afd:	e9 87 00 00 00       	jmp    b89 <parseexec+0xf2>
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+     b02:	8d 45 e0             	lea    -0x20(%ebp),%eax
+     b05:	50                   	push   %eax
+     b06:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+     b09:	50                   	push   %eax
+     b0a:	ff 75 0c             	pushl  0xc(%ebp)
+     b0d:	ff 75 08             	pushl  0x8(%ebp)
+     b10:	e8 61 fa ff ff       	call   576 <gettoken>
+     b15:	83 c4 10             	add    $0x10,%esp
+     b18:	89 45 e8             	mov    %eax,-0x18(%ebp)
+     b1b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+     b1f:	0f 84 84 00 00 00    	je     ba9 <parseexec+0x112>
+      break;
+    if(tok != 'a')
+     b25:	83 7d e8 61          	cmpl   $0x61,-0x18(%ebp)
+     b29:	74 10                	je     b3b <parseexec+0xa4>
+      panic("syntax");
+     b2b:	83 ec 0c             	sub    $0xc,%esp
+     b2e:	68 2e 15 00 00       	push   $0x152e
+     b33:	e8 71 f8 ff ff       	call   3a9 <panic>
+     b38:	83 c4 10             	add    $0x10,%esp
+    cmd->argv[argc] = q;
+     b3b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
+     b3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     b41:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     b44:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)
+    cmd->eargv[argc] = eq;
+     b48:	8b 55 e0             	mov    -0x20(%ebp),%edx
+     b4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     b4e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+     b51:	83 c1 08             	add    $0x8,%ecx
+     b54:	89 54 88 0c          	mov    %edx,0xc(%eax,%ecx,4)
+    argc++;
+     b58:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    if(argc >= MAXARGS)
+     b5c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+     b60:	7e 10                	jle    b72 <parseexec+0xdb>
+      panic("too many args");
+     b62:	83 ec 0c             	sub    $0xc,%esp
+     b65:	68 7d 15 00 00       	push   $0x157d
+     b6a:	e8 3a f8 ff ff       	call   3a9 <panic>
+     b6f:	83 c4 10             	add    $0x10,%esp
+    ret = parseredirs(ret, ps, es);
+     b72:	83 ec 04             	sub    $0x4,%esp
+     b75:	ff 75 0c             	pushl  0xc(%ebp)
+     b78:	ff 75 08             	pushl  0x8(%ebp)
+     b7b:	ff 75 f0             	pushl  -0x10(%ebp)
+     b7e:	e8 76 fd ff ff       	call   8f9 <parseredirs>
+     b83:	83 c4 10             	add    $0x10,%esp
+     b86:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  while(!peek(ps, es, "|)&;")){
+     b89:	83 ec 04             	sub    $0x4,%esp
+     b8c:	68 8b 15 00 00       	push   $0x158b
+     b91:	ff 75 0c             	pushl  0xc(%ebp)
+     b94:	ff 75 08             	pushl  0x8(%ebp)
+     b97:	e8 2e fb ff ff       	call   6ca <peek>
+     b9c:	83 c4 10             	add    $0x10,%esp
+     b9f:	85 c0                	test   %eax,%eax
+     ba1:	0f 84 5b ff ff ff    	je     b02 <parseexec+0x6b>
+     ba7:	eb 01                	jmp    baa <parseexec+0x113>
+      break;
+     ba9:	90                   	nop
+  }
+  cmd->argv[argc] = 0;
+     baa:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     bad:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     bb0:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)
+     bb7:	00 
+  cmd->eargv[argc] = 0;
+     bb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     bbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     bbe:	83 c2 08             	add    $0x8,%edx
+     bc1:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
+     bc8:	00 
+  return ret;
+     bc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+     bcc:	c9                   	leave  
+     bcd:	c3                   	ret    
+
+00000bce <nulterminate>:
+
+// NUL-terminate all the counted strings.
+struct cmd*
+nulterminate(struct cmd *cmd)
+{
+     bce:	f3 0f 1e fb          	endbr32 
+     bd2:	55                   	push   %ebp
+     bd3:	89 e5                	mov    %esp,%ebp
+     bd5:	83 ec 28             	sub    $0x28,%esp
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+     bd8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+     bdc:	75 0a                	jne    be8 <nulterminate+0x1a>
+    return 0;
+     bde:	b8 00 00 00 00       	mov    $0x0,%eax
+     be3:	e9 e5 00 00 00       	jmp    ccd <nulterminate+0xff>
+
+  switch(cmd->type){
+     be8:	8b 45 08             	mov    0x8(%ebp),%eax
+     beb:	8b 00                	mov    (%eax),%eax
+     bed:	83 f8 05             	cmp    $0x5,%eax
+     bf0:	0f 87 d4 00 00 00    	ja     cca <nulterminate+0xfc>
+     bf6:	8b 04 85 90 15 00 00 	mov    0x1590(,%eax,4),%eax
+     bfd:	3e ff e0             	notrack jmp *%eax
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+     c00:	8b 45 08             	mov    0x8(%ebp),%eax
+     c03:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    for(i=0; ecmd->argv[i]; i++)
+     c06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     c0d:	eb 14                	jmp    c23 <nulterminate+0x55>
+      *ecmd->eargv[i] = 0;
+     c0f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     c12:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     c15:	83 c2 08             	add    $0x8,%edx
+     c18:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
+     c1c:	c6 00 00             	movb   $0x0,(%eax)
+    for(i=0; ecmd->argv[i]; i++)
+     c1f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     c23:	8b 45 e0             	mov    -0x20(%ebp),%eax
+     c26:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     c29:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
+     c2d:	85 c0                	test   %eax,%eax
+     c2f:	75 de                	jne    c0f <nulterminate+0x41>
+    break;
+     c31:	e9 94 00 00 00       	jmp    cca <nulterminate+0xfc>
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+     c36:	8b 45 08             	mov    0x8(%ebp),%eax
+     c39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    nulterminate(rcmd->cmd);
+     c3c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     c3f:	8b 40 04             	mov    0x4(%eax),%eax
+     c42:	83 ec 0c             	sub    $0xc,%esp
+     c45:	50                   	push   %eax
+     c46:	e8 83 ff ff ff       	call   bce <nulterminate>
+     c4b:	83 c4 10             	add    $0x10,%esp
+    *rcmd->efile = 0;
+     c4e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     c51:	8b 40 0c             	mov    0xc(%eax),%eax
+     c54:	c6 00 00             	movb   $0x0,(%eax)
+    break;
+     c57:	eb 71                	jmp    cca <nulterminate+0xfc>
+
+  case PIPE:
+    pcmd = (struct pipecmd*)cmd;
+     c59:	8b 45 08             	mov    0x8(%ebp),%eax
+     c5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    nulterminate(pcmd->left);
+     c5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     c62:	8b 40 04             	mov    0x4(%eax),%eax
+     c65:	83 ec 0c             	sub    $0xc,%esp
+     c68:	50                   	push   %eax
+     c69:	e8 60 ff ff ff       	call   bce <nulterminate>
+     c6e:	83 c4 10             	add    $0x10,%esp
+    nulterminate(pcmd->right);
+     c71:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     c74:	8b 40 08             	mov    0x8(%eax),%eax
+     c77:	83 ec 0c             	sub    $0xc,%esp
+     c7a:	50                   	push   %eax
+     c7b:	e8 4e ff ff ff       	call   bce <nulterminate>
+     c80:	83 c4 10             	add    $0x10,%esp
+    break;
+     c83:	eb 45                	jmp    cca <nulterminate+0xfc>
+
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+     c85:	8b 45 08             	mov    0x8(%ebp),%eax
+     c88:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    nulterminate(lcmd->left);
+     c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     c8e:	8b 40 04             	mov    0x4(%eax),%eax
+     c91:	83 ec 0c             	sub    $0xc,%esp
+     c94:	50                   	push   %eax
+     c95:	e8 34 ff ff ff       	call   bce <nulterminate>
+     c9a:	83 c4 10             	add    $0x10,%esp
+    nulterminate(lcmd->right);
+     c9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     ca0:	8b 40 08             	mov    0x8(%eax),%eax
+     ca3:	83 ec 0c             	sub    $0xc,%esp
+     ca6:	50                   	push   %eax
+     ca7:	e8 22 ff ff ff       	call   bce <nulterminate>
+     cac:	83 c4 10             	add    $0x10,%esp
+    break;
+     caf:	eb 19                	jmp    cca <nulterminate+0xfc>
+
+  case BACK:
+    bcmd = (struct backcmd*)cmd;
+     cb1:	8b 45 08             	mov    0x8(%ebp),%eax
+     cb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    nulterminate(bcmd->cmd);
+     cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     cba:	8b 40 04             	mov    0x4(%eax),%eax
+     cbd:	83 ec 0c             	sub    $0xc,%esp
+     cc0:	50                   	push   %eax
+     cc1:	e8 08 ff ff ff       	call   bce <nulterminate>
+     cc6:	83 c4 10             	add    $0x10,%esp
+    break;
+     cc9:	90                   	nop
+  }
+  return cmd;
+     cca:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     ccd:	c9                   	leave  
+     cce:	c3                   	ret    
+
+00000ccf <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+     ccf:	55                   	push   %ebp
+     cd0:	89 e5                	mov    %esp,%ebp
+     cd2:	57                   	push   %edi
+     cd3:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+     cd4:	8b 4d 08             	mov    0x8(%ebp),%ecx
+     cd7:	8b 55 10             	mov    0x10(%ebp),%edx
+     cda:	8b 45 0c             	mov    0xc(%ebp),%eax
+     cdd:	89 cb                	mov    %ecx,%ebx
+     cdf:	89 df                	mov    %ebx,%edi
+     ce1:	89 d1                	mov    %edx,%ecx
+     ce3:	fc                   	cld    
+     ce4:	f3 aa                	rep stos %al,%es:(%edi)
+     ce6:	89 ca                	mov    %ecx,%edx
+     ce8:	89 fb                	mov    %edi,%ebx
+     cea:	89 5d 08             	mov    %ebx,0x8(%ebp)
+     ced:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+     cf0:	90                   	nop
+     cf1:	5b                   	pop    %ebx
+     cf2:	5f                   	pop    %edi
+     cf3:	5d                   	pop    %ebp
+     cf4:	c3                   	ret    
+
+00000cf5 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+     cf5:	f3 0f 1e fb          	endbr32 
+     cf9:	55                   	push   %ebp
+     cfa:	89 e5                	mov    %esp,%ebp
+     cfc:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+     cff:	8b 45 08             	mov    0x8(%ebp),%eax
+     d02:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+     d05:	90                   	nop
+     d06:	8b 55 0c             	mov    0xc(%ebp),%edx
+     d09:	8d 42 01             	lea    0x1(%edx),%eax
+     d0c:	89 45 0c             	mov    %eax,0xc(%ebp)
+     d0f:	8b 45 08             	mov    0x8(%ebp),%eax
+     d12:	8d 48 01             	lea    0x1(%eax),%ecx
+     d15:	89 4d 08             	mov    %ecx,0x8(%ebp)
+     d18:	0f b6 12             	movzbl (%edx),%edx
+     d1b:	88 10                	mov    %dl,(%eax)
+     d1d:	0f b6 00             	movzbl (%eax),%eax
+     d20:	84 c0                	test   %al,%al
+     d22:	75 e2                	jne    d06 <strcpy+0x11>
+    ;
+  return os;
+     d24:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+     d27:	c9                   	leave  
+     d28:	c3                   	ret    
+
+00000d29 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+     d29:	f3 0f 1e fb          	endbr32 
+     d2d:	55                   	push   %ebp
+     d2e:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+     d30:	eb 08                	jmp    d3a <strcmp+0x11>
+    p++, q++;
+     d32:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+     d36:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+     d3a:	8b 45 08             	mov    0x8(%ebp),%eax
+     d3d:	0f b6 00             	movzbl (%eax),%eax
+     d40:	84 c0                	test   %al,%al
+     d42:	74 10                	je     d54 <strcmp+0x2b>
+     d44:	8b 45 08             	mov    0x8(%ebp),%eax
+     d47:	0f b6 10             	movzbl (%eax),%edx
+     d4a:	8b 45 0c             	mov    0xc(%ebp),%eax
+     d4d:	0f b6 00             	movzbl (%eax),%eax
+     d50:	38 c2                	cmp    %al,%dl
+     d52:	74 de                	je     d32 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+     d54:	8b 45 08             	mov    0x8(%ebp),%eax
+     d57:	0f b6 00             	movzbl (%eax),%eax
+     d5a:	0f b6 d0             	movzbl %al,%edx
+     d5d:	8b 45 0c             	mov    0xc(%ebp),%eax
+     d60:	0f b6 00             	movzbl (%eax),%eax
+     d63:	0f b6 c0             	movzbl %al,%eax
+     d66:	29 c2                	sub    %eax,%edx
+     d68:	89 d0                	mov    %edx,%eax
+}
+     d6a:	5d                   	pop    %ebp
+     d6b:	c3                   	ret    
+
+00000d6c <strlen>:
+
+uint
+strlen(const char *s)
+{
+     d6c:	f3 0f 1e fb          	endbr32 
+     d70:	55                   	push   %ebp
+     d71:	89 e5                	mov    %esp,%ebp
+     d73:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+     d76:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+     d7d:	eb 04                	jmp    d83 <strlen+0x17>
+     d7f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+     d83:	8b 55 fc             	mov    -0x4(%ebp),%edx
+     d86:	8b 45 08             	mov    0x8(%ebp),%eax
+     d89:	01 d0                	add    %edx,%eax
+     d8b:	0f b6 00             	movzbl (%eax),%eax
+     d8e:	84 c0                	test   %al,%al
+     d90:	75 ed                	jne    d7f <strlen+0x13>
+    ;
+  return n;
+     d92:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+     d95:	c9                   	leave  
+     d96:	c3                   	ret    
+
+00000d97 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+     d97:	f3 0f 1e fb          	endbr32 
+     d9b:	55                   	push   %ebp
+     d9c:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+     d9e:	8b 45 10             	mov    0x10(%ebp),%eax
+     da1:	50                   	push   %eax
+     da2:	ff 75 0c             	pushl  0xc(%ebp)
+     da5:	ff 75 08             	pushl  0x8(%ebp)
+     da8:	e8 22 ff ff ff       	call   ccf <stosb>
+     dad:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+     db0:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     db3:	c9                   	leave  
+     db4:	c3                   	ret    
+
+00000db5 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+     db5:	f3 0f 1e fb          	endbr32 
+     db9:	55                   	push   %ebp
+     dba:	89 e5                	mov    %esp,%ebp
+     dbc:	83 ec 04             	sub    $0x4,%esp
+     dbf:	8b 45 0c             	mov    0xc(%ebp),%eax
+     dc2:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+     dc5:	eb 14                	jmp    ddb <strchr+0x26>
+    if(*s == c)
+     dc7:	8b 45 08             	mov    0x8(%ebp),%eax
+     dca:	0f b6 00             	movzbl (%eax),%eax
+     dcd:	38 45 fc             	cmp    %al,-0x4(%ebp)
+     dd0:	75 05                	jne    dd7 <strchr+0x22>
+      return (char*)s;
+     dd2:	8b 45 08             	mov    0x8(%ebp),%eax
+     dd5:	eb 13                	jmp    dea <strchr+0x35>
+  for(; *s; s++)
+     dd7:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+     ddb:	8b 45 08             	mov    0x8(%ebp),%eax
+     dde:	0f b6 00             	movzbl (%eax),%eax
+     de1:	84 c0                	test   %al,%al
+     de3:	75 e2                	jne    dc7 <strchr+0x12>
+  return 0;
+     de5:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+     dea:	c9                   	leave  
+     deb:	c3                   	ret    
+
+00000dec <gets>:
+
+char*
+gets(char *buf, int max)
+{
+     dec:	f3 0f 1e fb          	endbr32 
+     df0:	55                   	push   %ebp
+     df1:	89 e5                	mov    %esp,%ebp
+     df3:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+     df6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     dfd:	eb 42                	jmp    e41 <gets+0x55>
+    cc = read(0, &c, 1);
+     dff:	83 ec 04             	sub    $0x4,%esp
+     e02:	6a 01                	push   $0x1
+     e04:	8d 45 ef             	lea    -0x11(%ebp),%eax
+     e07:	50                   	push   %eax
+     e08:	6a 00                	push   $0x0
+     e0a:	e8 53 01 00 00       	call   f62 <read>
+     e0f:	83 c4 10             	add    $0x10,%esp
+     e12:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+     e15:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     e19:	7e 33                	jle    e4e <gets+0x62>
+      break;
+    buf[i++] = c;
+     e1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     e1e:	8d 50 01             	lea    0x1(%eax),%edx
+     e21:	89 55 f4             	mov    %edx,-0xc(%ebp)
+     e24:	89 c2                	mov    %eax,%edx
+     e26:	8b 45 08             	mov    0x8(%ebp),%eax
+     e29:	01 c2                	add    %eax,%edx
+     e2b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+     e2f:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+     e31:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+     e35:	3c 0a                	cmp    $0xa,%al
+     e37:	74 16                	je     e4f <gets+0x63>
+     e39:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+     e3d:	3c 0d                	cmp    $0xd,%al
+     e3f:	74 0e                	je     e4f <gets+0x63>
+  for(i=0; i+1 < max; ){
+     e41:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     e44:	83 c0 01             	add    $0x1,%eax
+     e47:	39 45 0c             	cmp    %eax,0xc(%ebp)
+     e4a:	7f b3                	jg     dff <gets+0x13>
+     e4c:	eb 01                	jmp    e4f <gets+0x63>
+      break;
+     e4e:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+     e4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     e52:	8b 45 08             	mov    0x8(%ebp),%eax
+     e55:	01 d0                	add    %edx,%eax
+     e57:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+     e5a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     e5d:	c9                   	leave  
+     e5e:	c3                   	ret    
+
+00000e5f <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+     e5f:	f3 0f 1e fb          	endbr32 
+     e63:	55                   	push   %ebp
+     e64:	89 e5                	mov    %esp,%ebp
+     e66:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+     e69:	83 ec 08             	sub    $0x8,%esp
+     e6c:	6a 00                	push   $0x0
+     e6e:	ff 75 08             	pushl  0x8(%ebp)
+     e71:	e8 14 01 00 00       	call   f8a <open>
+     e76:	83 c4 10             	add    $0x10,%esp
+     e79:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+     e7c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     e80:	79 07                	jns    e89 <stat+0x2a>
+    return -1;
+     e82:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+     e87:	eb 25                	jmp    eae <stat+0x4f>
+  r = fstat(fd, st);
+     e89:	83 ec 08             	sub    $0x8,%esp
+     e8c:	ff 75 0c             	pushl  0xc(%ebp)
+     e8f:	ff 75 f4             	pushl  -0xc(%ebp)
+     e92:	e8 0b 01 00 00       	call   fa2 <fstat>
+     e97:	83 c4 10             	add    $0x10,%esp
+     e9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+     e9d:	83 ec 0c             	sub    $0xc,%esp
+     ea0:	ff 75 f4             	pushl  -0xc(%ebp)
+     ea3:	e8 ca 00 00 00       	call   f72 <close>
+     ea8:	83 c4 10             	add    $0x10,%esp
+  return r;
+     eab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+     eae:	c9                   	leave  
+     eaf:	c3                   	ret    
+
+00000eb0 <atoi>:
+
+int
+atoi(const char *s)
+{
+     eb0:	f3 0f 1e fb          	endbr32 
+     eb4:	55                   	push   %ebp
+     eb5:	89 e5                	mov    %esp,%ebp
+     eb7:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+     eba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+     ec1:	eb 25                	jmp    ee8 <atoi+0x38>
+    n = n*10 + *s++ - '0';
+     ec3:	8b 55 fc             	mov    -0x4(%ebp),%edx
+     ec6:	89 d0                	mov    %edx,%eax
+     ec8:	c1 e0 02             	shl    $0x2,%eax
+     ecb:	01 d0                	add    %edx,%eax
+     ecd:	01 c0                	add    %eax,%eax
+     ecf:	89 c1                	mov    %eax,%ecx
+     ed1:	8b 45 08             	mov    0x8(%ebp),%eax
+     ed4:	8d 50 01             	lea    0x1(%eax),%edx
+     ed7:	89 55 08             	mov    %edx,0x8(%ebp)
+     eda:	0f b6 00             	movzbl (%eax),%eax
+     edd:	0f be c0             	movsbl %al,%eax
+     ee0:	01 c8                	add    %ecx,%eax
+     ee2:	83 e8 30             	sub    $0x30,%eax
+     ee5:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+     ee8:	8b 45 08             	mov    0x8(%ebp),%eax
+     eeb:	0f b6 00             	movzbl (%eax),%eax
+     eee:	3c 2f                	cmp    $0x2f,%al
+     ef0:	7e 0a                	jle    efc <atoi+0x4c>
+     ef2:	8b 45 08             	mov    0x8(%ebp),%eax
+     ef5:	0f b6 00             	movzbl (%eax),%eax
+     ef8:	3c 39                	cmp    $0x39,%al
+     efa:	7e c7                	jle    ec3 <atoi+0x13>
+  return n;
+     efc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+     eff:	c9                   	leave  
+     f00:	c3                   	ret    
+
+00000f01 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+     f01:	f3 0f 1e fb          	endbr32 
+     f05:	55                   	push   %ebp
+     f06:	89 e5                	mov    %esp,%ebp
+     f08:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+     f0b:	8b 45 08             	mov    0x8(%ebp),%eax
+     f0e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+     f11:	8b 45 0c             	mov    0xc(%ebp),%eax
+     f14:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+     f17:	eb 17                	jmp    f30 <memmove+0x2f>
+    *dst++ = *src++;
+     f19:	8b 55 f8             	mov    -0x8(%ebp),%edx
+     f1c:	8d 42 01             	lea    0x1(%edx),%eax
+     f1f:	89 45 f8             	mov    %eax,-0x8(%ebp)
+     f22:	8b 45 fc             	mov    -0x4(%ebp),%eax
+     f25:	8d 48 01             	lea    0x1(%eax),%ecx
+     f28:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+     f2b:	0f b6 12             	movzbl (%edx),%edx
+     f2e:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+     f30:	8b 45 10             	mov    0x10(%ebp),%eax
+     f33:	8d 50 ff             	lea    -0x1(%eax),%edx
+     f36:	89 55 10             	mov    %edx,0x10(%ebp)
+     f39:	85 c0                	test   %eax,%eax
+     f3b:	7f dc                	jg     f19 <memmove+0x18>
+  return vdst;
+     f3d:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+     f40:	c9                   	leave  
+     f41:	c3                   	ret    
+
+00000f42 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+     f42:	b8 01 00 00 00       	mov    $0x1,%eax
+     f47:	cd 40                	int    $0x40
+     f49:	c3                   	ret    
+
+00000f4a <exit>:
+SYSCALL(exit)
+     f4a:	b8 02 00 00 00       	mov    $0x2,%eax
+     f4f:	cd 40                	int    $0x40
+     f51:	c3                   	ret    
+
+00000f52 <wait>:
+SYSCALL(wait)
+     f52:	b8 03 00 00 00       	mov    $0x3,%eax
+     f57:	cd 40                	int    $0x40
+     f59:	c3                   	ret    
+
+00000f5a <pipe>:
+SYSCALL(pipe)
+     f5a:	b8 04 00 00 00       	mov    $0x4,%eax
+     f5f:	cd 40                	int    $0x40
+     f61:	c3                   	ret    
+
+00000f62 <read>:
+SYSCALL(read)
+     f62:	b8 05 00 00 00       	mov    $0x5,%eax
+     f67:	cd 40                	int    $0x40
+     f69:	c3                   	ret    
+
+00000f6a <write>:
+SYSCALL(write)
+     f6a:	b8 10 00 00 00       	mov    $0x10,%eax
+     f6f:	cd 40                	int    $0x40
+     f71:	c3                   	ret    
+
+00000f72 <close>:
+SYSCALL(close)
+     f72:	b8 15 00 00 00       	mov    $0x15,%eax
+     f77:	cd 40                	int    $0x40
+     f79:	c3                   	ret    
+
+00000f7a <kill>:
+SYSCALL(kill)
+     f7a:	b8 06 00 00 00       	mov    $0x6,%eax
+     f7f:	cd 40                	int    $0x40
+     f81:	c3                   	ret    
+
+00000f82 <exec>:
+SYSCALL(exec)
+     f82:	b8 07 00 00 00       	mov    $0x7,%eax
+     f87:	cd 40                	int    $0x40
+     f89:	c3                   	ret    
+
+00000f8a <open>:
+SYSCALL(open)
+     f8a:	b8 0f 00 00 00       	mov    $0xf,%eax
+     f8f:	cd 40                	int    $0x40
+     f91:	c3                   	ret    
+
+00000f92 <mknod>:
+SYSCALL(mknod)
+     f92:	b8 11 00 00 00       	mov    $0x11,%eax
+     f97:	cd 40                	int    $0x40
+     f99:	c3                   	ret    
+
+00000f9a <unlink>:
+SYSCALL(unlink)
+     f9a:	b8 12 00 00 00       	mov    $0x12,%eax
+     f9f:	cd 40                	int    $0x40
+     fa1:	c3                   	ret    
+
+00000fa2 <fstat>:
+SYSCALL(fstat)
+     fa2:	b8 08 00 00 00       	mov    $0x8,%eax
+     fa7:	cd 40                	int    $0x40
+     fa9:	c3                   	ret    
+
+00000faa <link>:
+SYSCALL(link)
+     faa:	b8 13 00 00 00       	mov    $0x13,%eax
+     faf:	cd 40                	int    $0x40
+     fb1:	c3                   	ret    
+
+00000fb2 <mkdir>:
+SYSCALL(mkdir)
+     fb2:	b8 14 00 00 00       	mov    $0x14,%eax
+     fb7:	cd 40                	int    $0x40
+     fb9:	c3                   	ret    
+
+00000fba <chdir>:
+SYSCALL(chdir)
+     fba:	b8 09 00 00 00       	mov    $0x9,%eax
+     fbf:	cd 40                	int    $0x40
+     fc1:	c3                   	ret    
+
+00000fc2 <dup>:
+SYSCALL(dup)
+     fc2:	b8 0a 00 00 00       	mov    $0xa,%eax
+     fc7:	cd 40                	int    $0x40
+     fc9:	c3                   	ret    
+
+00000fca <getpid>:
+SYSCALL(getpid)
+     fca:	b8 0b 00 00 00       	mov    $0xb,%eax
+     fcf:	cd 40                	int    $0x40
+     fd1:	c3                   	ret    
+
+00000fd2 <sbrk>:
+SYSCALL(sbrk)
+     fd2:	b8 0c 00 00 00       	mov    $0xc,%eax
+     fd7:	cd 40                	int    $0x40
+     fd9:	c3                   	ret    
+
+00000fda <sleep>:
+SYSCALL(sleep)
+     fda:	b8 0d 00 00 00       	mov    $0xd,%eax
+     fdf:	cd 40                	int    $0x40
+     fe1:	c3                   	ret    
+
+00000fe2 <uptime>:
+SYSCALL(uptime)
+     fe2:	b8 0e 00 00 00       	mov    $0xe,%eax
+     fe7:	cd 40                	int    $0x40
+     fe9:	c3                   	ret    
+
+00000fea <draw>:
+SYSCALL(draw)
+     fea:	b8 16 00 00 00       	mov    $0x16,%eax
+     fef:	cd 40                	int    $0x40
+     ff1:	c3                   	ret    
+
+00000ff2 <cps>:
+SYSCALL(cps)
+     ff2:	b8 17 00 00 00       	mov    $0x17,%eax
+     ff7:	cd 40                	int    $0x40
+     ff9:	c3                   	ret    
+
+00000ffa <yield>:
+SYSCALL(yield)
+     ffa:	b8 18 00 00 00       	mov    $0x18,%eax
+     fff:	cd 40                	int    $0x40
+    1001:	c3                   	ret    
+
+00001002 <wait2>:
+SYSCALL(wait2)
+    1002:	b8 19 00 00 00       	mov    $0x19,%eax
+    1007:	cd 40                	int    $0x40
+    1009:	c3                   	ret    
+
+0000100a <set_prio>:
+SYSCALL(set_prio)
+    100a:	b8 1a 00 00 00       	mov    $0x1a,%eax
+    100f:	cd 40                	int    $0x40
+    1011:	c3                   	ret    
+
+00001012 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+    1012:	f3 0f 1e fb          	endbr32 
+    1016:	55                   	push   %ebp
+    1017:	89 e5                	mov    %esp,%ebp
+    1019:	83 ec 18             	sub    $0x18,%esp
+    101c:	8b 45 0c             	mov    0xc(%ebp),%eax
+    101f:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+    1022:	83 ec 04             	sub    $0x4,%esp
+    1025:	6a 01                	push   $0x1
+    1027:	8d 45 f4             	lea    -0xc(%ebp),%eax
+    102a:	50                   	push   %eax
+    102b:	ff 75 08             	pushl  0x8(%ebp)
+    102e:	e8 37 ff ff ff       	call   f6a <write>
+    1033:	83 c4 10             	add    $0x10,%esp
+}
+    1036:	90                   	nop
+    1037:	c9                   	leave  
+    1038:	c3                   	ret    
+
+00001039 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    1039:	f3 0f 1e fb          	endbr32 
+    103d:	55                   	push   %ebp
+    103e:	89 e5                	mov    %esp,%ebp
+    1040:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+    1043:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+    104a:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+    104e:	74 17                	je     1067 <printint+0x2e>
+    1050:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+    1054:	79 11                	jns    1067 <printint+0x2e>
+    neg = 1;
+    1056:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+    105d:	8b 45 0c             	mov    0xc(%ebp),%eax
+    1060:	f7 d8                	neg    %eax
+    1062:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    1065:	eb 06                	jmp    106d <printint+0x34>
+  } else {
+    x = xx;
+    1067:	8b 45 0c             	mov    0xc(%ebp),%eax
+    106a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+    106d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+    1074:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    1077:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    107a:	ba 00 00 00 00       	mov    $0x0,%edx
+    107f:	f7 f1                	div    %ecx
+    1081:	89 d1                	mov    %edx,%ecx
+    1083:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1086:	8d 50 01             	lea    0x1(%eax),%edx
+    1089:	89 55 f4             	mov    %edx,-0xc(%ebp)
+    108c:	0f b6 91 40 1a 00 00 	movzbl 0x1a40(%ecx),%edx
+    1093:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+    1097:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    109a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    109d:	ba 00 00 00 00       	mov    $0x0,%edx
+    10a2:	f7 f1                	div    %ecx
+    10a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    10a7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    10ab:	75 c7                	jne    1074 <printint+0x3b>
+  if(neg)
+    10ad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    10b1:	74 2d                	je     10e0 <printint+0xa7>
+    buf[i++] = '-';
+    10b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    10b6:	8d 50 01             	lea    0x1(%eax),%edx
+    10b9:	89 55 f4             	mov    %edx,-0xc(%ebp)
+    10bc:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+    10c1:	eb 1d                	jmp    10e0 <printint+0xa7>
+    putc(fd, buf[i]);
+    10c3:	8d 55 dc             	lea    -0x24(%ebp),%edx
+    10c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    10c9:	01 d0                	add    %edx,%eax
+    10cb:	0f b6 00             	movzbl (%eax),%eax
+    10ce:	0f be c0             	movsbl %al,%eax
+    10d1:	83 ec 08             	sub    $0x8,%esp
+    10d4:	50                   	push   %eax
+    10d5:	ff 75 08             	pushl  0x8(%ebp)
+    10d8:	e8 35 ff ff ff       	call   1012 <putc>
+    10dd:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+    10e0:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+    10e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    10e8:	79 d9                	jns    10c3 <printint+0x8a>
+}
+    10ea:	90                   	nop
+    10eb:	90                   	nop
+    10ec:	c9                   	leave  
+    10ed:	c3                   	ret    
+
+000010ee <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+    10ee:	f3 0f 1e fb          	endbr32 
+    10f2:	55                   	push   %ebp
+    10f3:	89 e5                	mov    %esp,%ebp
+    10f5:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    10f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+    10ff:	8d 45 0c             	lea    0xc(%ebp),%eax
+    1102:	83 c0 04             	add    $0x4,%eax
+    1105:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1108:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    110f:	e9 59 01 00 00       	jmp    126d <printf+0x17f>
+    c = fmt[i] & 0xff;
+    1114:	8b 55 0c             	mov    0xc(%ebp),%edx
+    1117:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    111a:	01 d0                	add    %edx,%eax
+    111c:	0f b6 00             	movzbl (%eax),%eax
+    111f:	0f be c0             	movsbl %al,%eax
+    1122:	25 ff 00 00 00       	and    $0xff,%eax
+    1127:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+    112a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    112e:	75 2c                	jne    115c <printf+0x6e>
+      if(c == '%'){
+    1130:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+    1134:	75 0c                	jne    1142 <printf+0x54>
+        state = '%';
+    1136:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+    113d:	e9 27 01 00 00       	jmp    1269 <printf+0x17b>
+      } else {
+        putc(fd, c);
+    1142:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1145:	0f be c0             	movsbl %al,%eax
+    1148:	83 ec 08             	sub    $0x8,%esp
+    114b:	50                   	push   %eax
+    114c:	ff 75 08             	pushl  0x8(%ebp)
+    114f:	e8 be fe ff ff       	call   1012 <putc>
+    1154:	83 c4 10             	add    $0x10,%esp
+    1157:	e9 0d 01 00 00       	jmp    1269 <printf+0x17b>
+      }
+    } else if(state == '%'){
+    115c:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+    1160:	0f 85 03 01 00 00    	jne    1269 <printf+0x17b>
+      if(c == 'd'){
+    1166:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+    116a:	75 1e                	jne    118a <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+    116c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    116f:	8b 00                	mov    (%eax),%eax
+    1171:	6a 01                	push   $0x1
+    1173:	6a 0a                	push   $0xa
+    1175:	50                   	push   %eax
+    1176:	ff 75 08             	pushl  0x8(%ebp)
+    1179:	e8 bb fe ff ff       	call   1039 <printint>
+    117e:	83 c4 10             	add    $0x10,%esp
+        ap++;
+    1181:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    1185:	e9 d8 00 00 00       	jmp    1262 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+    118a:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+    118e:	74 06                	je     1196 <printf+0xa8>
+    1190:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+    1194:	75 1e                	jne    11b4 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+    1196:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    1199:	8b 00                	mov    (%eax),%eax
+    119b:	6a 00                	push   $0x0
+    119d:	6a 10                	push   $0x10
+    119f:	50                   	push   %eax
+    11a0:	ff 75 08             	pushl  0x8(%ebp)
+    11a3:	e8 91 fe ff ff       	call   1039 <printint>
+    11a8:	83 c4 10             	add    $0x10,%esp
+        ap++;
+    11ab:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    11af:	e9 ae 00 00 00       	jmp    1262 <printf+0x174>
+      } else if(c == 's'){
+    11b4:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+    11b8:	75 43                	jne    11fd <printf+0x10f>
+        s = (char*)*ap;
+    11ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    11bd:	8b 00                	mov    (%eax),%eax
+    11bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+    11c2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+    11c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    11ca:	75 25                	jne    11f1 <printf+0x103>
+          s = "(null)";
+    11cc:	c7 45 f4 a8 15 00 00 	movl   $0x15a8,-0xc(%ebp)
+        while(*s != 0){
+    11d3:	eb 1c                	jmp    11f1 <printf+0x103>
+          putc(fd, *s);
+    11d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    11d8:	0f b6 00             	movzbl (%eax),%eax
+    11db:	0f be c0             	movsbl %al,%eax
+    11de:	83 ec 08             	sub    $0x8,%esp
+    11e1:	50                   	push   %eax
+    11e2:	ff 75 08             	pushl  0x8(%ebp)
+    11e5:	e8 28 fe ff ff       	call   1012 <putc>
+    11ea:	83 c4 10             	add    $0x10,%esp
+          s++;
+    11ed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+    11f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    11f4:	0f b6 00             	movzbl (%eax),%eax
+    11f7:	84 c0                	test   %al,%al
+    11f9:	75 da                	jne    11d5 <printf+0xe7>
+    11fb:	eb 65                	jmp    1262 <printf+0x174>
+        }
+      } else if(c == 'c'){
+    11fd:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+    1201:	75 1d                	jne    1220 <printf+0x132>
+        putc(fd, *ap);
+    1203:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    1206:	8b 00                	mov    (%eax),%eax
+    1208:	0f be c0             	movsbl %al,%eax
+    120b:	83 ec 08             	sub    $0x8,%esp
+    120e:	50                   	push   %eax
+    120f:	ff 75 08             	pushl  0x8(%ebp)
+    1212:	e8 fb fd ff ff       	call   1012 <putc>
+    1217:	83 c4 10             	add    $0x10,%esp
+        ap++;
+    121a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    121e:	eb 42                	jmp    1262 <printf+0x174>
+      } else if(c == '%'){
+    1220:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+    1224:	75 17                	jne    123d <printf+0x14f>
+        putc(fd, c);
+    1226:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1229:	0f be c0             	movsbl %al,%eax
+    122c:	83 ec 08             	sub    $0x8,%esp
+    122f:	50                   	push   %eax
+    1230:	ff 75 08             	pushl  0x8(%ebp)
+    1233:	e8 da fd ff ff       	call   1012 <putc>
+    1238:	83 c4 10             	add    $0x10,%esp
+    123b:	eb 25                	jmp    1262 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+    123d:	83 ec 08             	sub    $0x8,%esp
+    1240:	6a 25                	push   $0x25
+    1242:	ff 75 08             	pushl  0x8(%ebp)
+    1245:	e8 c8 fd ff ff       	call   1012 <putc>
+    124a:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+    124d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    1250:	0f be c0             	movsbl %al,%eax
+    1253:	83 ec 08             	sub    $0x8,%esp
+    1256:	50                   	push   %eax
+    1257:	ff 75 08             	pushl  0x8(%ebp)
+    125a:	e8 b3 fd ff ff       	call   1012 <putc>
+    125f:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+    1262:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+    1269:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    126d:	8b 55 0c             	mov    0xc(%ebp),%edx
+    1270:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1273:	01 d0                	add    %edx,%eax
+    1275:	0f b6 00             	movzbl (%eax),%eax
+    1278:	84 c0                	test   %al,%al
+    127a:	0f 85 94 fe ff ff    	jne    1114 <printf+0x26>
+    }
+  }
+}
+    1280:	90                   	nop
+    1281:	90                   	nop
+    1282:	c9                   	leave  
+    1283:	c3                   	ret    
+
+00001284 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1284:	f3 0f 1e fb          	endbr32 
+    1288:	55                   	push   %ebp
+    1289:	89 e5                	mov    %esp,%ebp
+    128b:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+    128e:	8b 45 08             	mov    0x8(%ebp),%eax
+    1291:	83 e8 08             	sub    $0x8,%eax
+    1294:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1297:	a1 cc 1a 00 00       	mov    0x1acc,%eax
+    129c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    129f:	eb 24                	jmp    12c5 <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    12a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12a4:	8b 00                	mov    (%eax),%eax
+    12a6:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+    12a9:	72 12                	jb     12bd <free+0x39>
+    12ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    12ae:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    12b1:	77 24                	ja     12d7 <free+0x53>
+    12b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12b6:	8b 00                	mov    (%eax),%eax
+    12b8:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+    12bb:	72 1a                	jb     12d7 <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    12bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12c0:	8b 00                	mov    (%eax),%eax
+    12c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    12c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    12c8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    12cb:	76 d4                	jbe    12a1 <free+0x1d>
+    12cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12d0:	8b 00                	mov    (%eax),%eax
+    12d2:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+    12d5:	73 ca                	jae    12a1 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    12d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    12da:	8b 40 04             	mov    0x4(%eax),%eax
+    12dd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+    12e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    12e7:	01 c2                	add    %eax,%edx
+    12e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12ec:	8b 00                	mov    (%eax),%eax
+    12ee:	39 c2                	cmp    %eax,%edx
+    12f0:	75 24                	jne    1316 <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+    12f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    12f5:	8b 50 04             	mov    0x4(%eax),%edx
+    12f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    12fb:	8b 00                	mov    (%eax),%eax
+    12fd:	8b 40 04             	mov    0x4(%eax),%eax
+    1300:	01 c2                	add    %eax,%edx
+    1302:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    1305:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    1308:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    130b:	8b 00                	mov    (%eax),%eax
+    130d:	8b 10                	mov    (%eax),%edx
+    130f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    1312:	89 10                	mov    %edx,(%eax)
+    1314:	eb 0a                	jmp    1320 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+    1316:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1319:	8b 10                	mov    (%eax),%edx
+    131b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    131e:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+    1320:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1323:	8b 40 04             	mov    0x4(%eax),%eax
+    1326:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+    132d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1330:	01 d0                	add    %edx,%eax
+    1332:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+    1335:	75 20                	jne    1357 <free+0xd3>
+    p->s.size += bp->s.size;
+    1337:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    133a:	8b 50 04             	mov    0x4(%eax),%edx
+    133d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    1340:	8b 40 04             	mov    0x4(%eax),%eax
+    1343:	01 c2                	add    %eax,%edx
+    1345:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1348:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    134b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    134e:	8b 10                	mov    (%eax),%edx
+    1350:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1353:	89 10                	mov    %edx,(%eax)
+    1355:	eb 08                	jmp    135f <free+0xdb>
+  } else
+    p->s.ptr = bp;
+    1357:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    135a:	8b 55 f8             	mov    -0x8(%ebp),%edx
+    135d:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    135f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    1362:	a3 cc 1a 00 00       	mov    %eax,0x1acc
+}
+    1367:	90                   	nop
+    1368:	c9                   	leave  
+    1369:	c3                   	ret    
+
+0000136a <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+    136a:	f3 0f 1e fb          	endbr32 
+    136e:	55                   	push   %ebp
+    136f:	89 e5                	mov    %esp,%ebp
+    1371:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+    1374:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+    137b:	77 07                	ja     1384 <morecore+0x1a>
+    nu = 4096;
+    137d:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+    1384:	8b 45 08             	mov    0x8(%ebp),%eax
+    1387:	c1 e0 03             	shl    $0x3,%eax
+    138a:	83 ec 0c             	sub    $0xc,%esp
+    138d:	50                   	push   %eax
+    138e:	e8 3f fc ff ff       	call   fd2 <sbrk>
+    1393:	83 c4 10             	add    $0x10,%esp
+    1396:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+    1399:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+    139d:	75 07                	jne    13a6 <morecore+0x3c>
+    return 0;
+    139f:	b8 00 00 00 00       	mov    $0x0,%eax
+    13a4:	eb 26                	jmp    13cc <morecore+0x62>
+  hp = (Header*)p;
+    13a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    13a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+    13ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    13af:	8b 55 08             	mov    0x8(%ebp),%edx
+    13b2:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+    13b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    13b8:	83 c0 08             	add    $0x8,%eax
+    13bb:	83 ec 0c             	sub    $0xc,%esp
+    13be:	50                   	push   %eax
+    13bf:	e8 c0 fe ff ff       	call   1284 <free>
+    13c4:	83 c4 10             	add    $0x10,%esp
+  return freep;
+    13c7:	a1 cc 1a 00 00       	mov    0x1acc,%eax
+}
+    13cc:	c9                   	leave  
+    13cd:	c3                   	ret    
+
+000013ce <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+    13ce:	f3 0f 1e fb          	endbr32 
+    13d2:	55                   	push   %ebp
+    13d3:	89 e5                	mov    %esp,%ebp
+    13d5:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    13d8:	8b 45 08             	mov    0x8(%ebp),%eax
+    13db:	83 c0 07             	add    $0x7,%eax
+    13de:	c1 e8 03             	shr    $0x3,%eax
+    13e1:	83 c0 01             	add    $0x1,%eax
+    13e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+    13e7:	a1 cc 1a 00 00       	mov    0x1acc,%eax
+    13ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    13ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    13f3:	75 23                	jne    1418 <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+    13f5:	c7 45 f0 c4 1a 00 00 	movl   $0x1ac4,-0x10(%ebp)
+    13fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    13ff:	a3 cc 1a 00 00       	mov    %eax,0x1acc
+    1404:	a1 cc 1a 00 00       	mov    0x1acc,%eax
+    1409:	a3 c4 1a 00 00       	mov    %eax,0x1ac4
+    base.s.size = 0;
+    140e:	c7 05 c8 1a 00 00 00 	movl   $0x0,0x1ac8
+    1415:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1418:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    141b:	8b 00                	mov    (%eax),%eax
+    141d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+    1420:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1423:	8b 40 04             	mov    0x4(%eax),%eax
+    1426:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+    1429:	77 4d                	ja     1478 <malloc+0xaa>
+      if(p->s.size == nunits)
+    142b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    142e:	8b 40 04             	mov    0x4(%eax),%eax
+    1431:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+    1434:	75 0c                	jne    1442 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+    1436:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1439:	8b 10                	mov    (%eax),%edx
+    143b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    143e:	89 10                	mov    %edx,(%eax)
+    1440:	eb 26                	jmp    1468 <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+    1442:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1445:	8b 40 04             	mov    0x4(%eax),%eax
+    1448:	2b 45 ec             	sub    -0x14(%ebp),%eax
+    144b:	89 c2                	mov    %eax,%edx
+    144d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1450:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+    1453:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1456:	8b 40 04             	mov    0x4(%eax),%eax
+    1459:	c1 e0 03             	shl    $0x3,%eax
+    145c:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+    145f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1462:	8b 55 ec             	mov    -0x14(%ebp),%edx
+    1465:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+    1468:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    146b:	a3 cc 1a 00 00       	mov    %eax,0x1acc
+      return (void*)(p + 1);
+    1470:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1473:	83 c0 08             	add    $0x8,%eax
+    1476:	eb 3b                	jmp    14b3 <malloc+0xe5>
+    }
+    if(p == freep)
+    1478:	a1 cc 1a 00 00       	mov    0x1acc,%eax
+    147d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+    1480:	75 1e                	jne    14a0 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+    1482:	83 ec 0c             	sub    $0xc,%esp
+    1485:	ff 75 ec             	pushl  -0x14(%ebp)
+    1488:	e8 dd fe ff ff       	call   136a <morecore>
+    148d:	83 c4 10             	add    $0x10,%esp
+    1490:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    1493:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1497:	75 07                	jne    14a0 <malloc+0xd2>
+        return 0;
+    1499:	b8 00 00 00 00       	mov    $0x0,%eax
+    149e:	eb 13                	jmp    14b3 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    14a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    14a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    14a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    14a9:	8b 00                	mov    (%eax),%eax
+    14ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+    14ae:	e9 6d ff ff ff       	jmp    1420 <malloc+0x52>
+  }
+}
+    14b3:	c9                   	leave  
+    14b4:	c3                   	ret    
diff -ruN xv6-public/xv6-public/sh.c xv6-public_new/xv6-public/sh.c
--- xv6-public/xv6-public/sh.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sh.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,493 @@
+// Shell.
+
+#include "types.h"
+#include "user.h"
+#include "fcntl.h"
+
+// Parsed command representation
+#define EXEC  1
+#define REDIR 2
+#define PIPE  3
+#define LIST  4
+#define BACK  5
+
+#define MAXARGS 10
+
+struct cmd {
+  int type;
+};
+
+struct execcmd {
+  int type;
+  char *argv[MAXARGS];
+  char *eargv[MAXARGS];
+};
+
+struct redircmd {
+  int type;
+  struct cmd *cmd;
+  char *file;
+  char *efile;
+  int mode;
+  int fd;
+};
+
+struct pipecmd {
+  int type;
+  struct cmd *left;
+  struct cmd *right;
+};
+
+struct listcmd {
+  int type;
+  struct cmd *left;
+  struct cmd *right;
+};
+
+struct backcmd {
+  int type;
+  struct cmd *cmd;
+};
+
+int fork1(void);  // Fork but panics on failure.
+void panic(char*);
+struct cmd *parsecmd(char*);
+
+// Execute cmd.  Never returns.
+void
+runcmd(struct cmd *cmd)
+{
+  int p[2];
+  struct backcmd *bcmd;
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+    exit();
+
+  switch(cmd->type){
+  default:
+    panic("runcmd");
+
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+    if(ecmd->argv[0] == 0)
+      exit();
+    exec(ecmd->argv[0], ecmd->argv);
+    printf(2, "exec %s failed\n", ecmd->argv[0]);
+    break;
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+    close(rcmd->fd);
+    if(open(rcmd->file, rcmd->mode) < 0){
+      printf(2, "open %s failed\n", rcmd->file);
+      exit();
+    }
+    runcmd(rcmd->cmd);
+    break;
+
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+    if(fork1() == 0)
+      runcmd(lcmd->left);
+    wait();
+    runcmd(lcmd->right);
+    break;
+
+  case PIPE:
+    pcmd = (struct pipecmd*)cmd;
+    if(pipe(p) < 0)
+      panic("pipe");
+    if(fork1() == 0){
+      close(1);
+      dup(p[1]);
+      close(p[0]);
+      close(p[1]);
+      runcmd(pcmd->left);
+    }
+    if(fork1() == 0){
+      close(0);
+      dup(p[0]);
+      close(p[0]);
+      close(p[1]);
+      runcmd(pcmd->right);
+    }
+    close(p[0]);
+    close(p[1]);
+    wait();
+    wait();
+    break;
+
+  case BACK:
+    bcmd = (struct backcmd*)cmd;
+    if(fork1() == 0)
+      runcmd(bcmd->cmd);
+    break;
+  }
+  exit();
+}
+
+int
+getcmd(char *buf, int nbuf)
+{
+  printf(2, "$ ");
+  memset(buf, 0, nbuf);
+  gets(buf, nbuf);
+  if(buf[0] == 0) // EOF
+    return -1;
+  return 0;
+}
+
+int
+main(void)
+{
+  static char buf[100];
+  int fd;
+
+  // Ensure that three file descriptors are open.
+  while((fd = open("console", O_RDWR)) >= 0){
+    if(fd >= 3){
+      close(fd);
+      break;
+    }
+  }
+
+  // Read and run input commands.
+  while(getcmd(buf, sizeof(buf)) >= 0){
+    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+      // Chdir must be called by the parent, not the child.
+      buf[strlen(buf)-1] = 0;  // chop \n
+      if(chdir(buf+3) < 0)
+        printf(2, "cannot cd %s\n", buf+3);
+      continue;
+    }
+    if(fork1() == 0)
+      runcmd(parsecmd(buf));
+    wait();
+  }
+  exit();
+}
+
+void
+panic(char *s)
+{
+  printf(2, "%s\n", s);
+  exit();
+}
+
+int
+fork1(void)
+{
+  int pid;
+
+  pid = fork();
+  if(pid == -1)
+    panic("fork");
+  return pid;
+}
+
+//PAGEBREAK!
+// Constructors
+
+struct cmd*
+execcmd(void)
+{
+  struct execcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = EXEC;
+  return (struct cmd*)cmd;
+}
+
+struct cmd*
+redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+{
+  struct redircmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = REDIR;
+  cmd->cmd = subcmd;
+  cmd->file = file;
+  cmd->efile = efile;
+  cmd->mode = mode;
+  cmd->fd = fd;
+  return (struct cmd*)cmd;
+}
+
+struct cmd*
+pipecmd(struct cmd *left, struct cmd *right)
+{
+  struct pipecmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = PIPE;
+  cmd->left = left;
+  cmd->right = right;
+  return (struct cmd*)cmd;
+}
+
+struct cmd*
+listcmd(struct cmd *left, struct cmd *right)
+{
+  struct listcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = LIST;
+  cmd->left = left;
+  cmd->right = right;
+  return (struct cmd*)cmd;
+}
+
+struct cmd*
+backcmd(struct cmd *subcmd)
+{
+  struct backcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+  memset(cmd, 0, sizeof(*cmd));
+  cmd->type = BACK;
+  cmd->cmd = subcmd;
+  return (struct cmd*)cmd;
+}
+//PAGEBREAK!
+// Parsing
+
+char whitespace[] = " \t\r\n\v";
+char symbols[] = "<|>&;()";
+
+int
+gettoken(char **ps, char *es, char **q, char **eq)
+{
+  char *s;
+  int ret;
+
+  s = *ps;
+  while(s < es && strchr(whitespace, *s))
+    s++;
+  if(q)
+    *q = s;
+  ret = *s;
+  switch(*s){
+  case 0:
+    break;
+  case '|':
+  case '(':
+  case ')':
+  case ';':
+  case '&':
+  case '<':
+    s++;
+    break;
+  case '>':
+    s++;
+    if(*s == '>'){
+      ret = '+';
+      s++;
+    }
+    break;
+  default:
+    ret = 'a';
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+      s++;
+    break;
+  }
+  if(eq)
+    *eq = s;
+
+  while(s < es && strchr(whitespace, *s))
+    s++;
+  *ps = s;
+  return ret;
+}
+
+int
+peek(char **ps, char *es, char *toks)
+{
+  char *s;
+
+  s = *ps;
+  while(s < es && strchr(whitespace, *s))
+    s++;
+  *ps = s;
+  return *s && strchr(toks, *s);
+}
+
+struct cmd *parseline(char**, char*);
+struct cmd *parsepipe(char**, char*);
+struct cmd *parseexec(char**, char*);
+struct cmd *nulterminate(struct cmd*);
+
+struct cmd*
+parsecmd(char *s)
+{
+  char *es;
+  struct cmd *cmd;
+
+  es = s + strlen(s);
+  cmd = parseline(&s, es);
+  peek(&s, es, "");
+  if(s != es){
+    printf(2, "leftovers: %s\n", s);
+    panic("syntax");
+  }
+  nulterminate(cmd);
+  return cmd;
+}
+
+struct cmd*
+parseline(char **ps, char *es)
+{
+  struct cmd *cmd;
+
+  cmd = parsepipe(ps, es);
+  while(peek(ps, es, "&")){
+    gettoken(ps, es, 0, 0);
+    cmd = backcmd(cmd);
+  }
+  if(peek(ps, es, ";")){
+    gettoken(ps, es, 0, 0);
+    cmd = listcmd(cmd, parseline(ps, es));
+  }
+  return cmd;
+}
+
+struct cmd*
+parsepipe(char **ps, char *es)
+{
+  struct cmd *cmd;
+
+  cmd = parseexec(ps, es);
+  if(peek(ps, es, "|")){
+    gettoken(ps, es, 0, 0);
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+  }
+  return cmd;
+}
+
+struct cmd*
+parseredirs(struct cmd *cmd, char **ps, char *es)
+{
+  int tok;
+  char *q, *eq;
+
+  while(peek(ps, es, "<>")){
+    tok = gettoken(ps, es, 0, 0);
+    if(gettoken(ps, es, &q, &eq) != 'a')
+      panic("missing file for redirection");
+    switch(tok){
+    case '<':
+      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+      break;
+    case '>':
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      break;
+    case '+':  // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+      break;
+    }
+  }
+  return cmd;
+}
+
+struct cmd*
+parseblock(char **ps, char *es)
+{
+  struct cmd *cmd;
+
+  if(!peek(ps, es, "("))
+    panic("parseblock");
+  gettoken(ps, es, 0, 0);
+  cmd = parseline(ps, es);
+  if(!peek(ps, es, ")"))
+    panic("syntax - missing )");
+  gettoken(ps, es, 0, 0);
+  cmd = parseredirs(cmd, ps, es);
+  return cmd;
+}
+
+struct cmd*
+parseexec(char **ps, char *es)
+{
+  char *q, *eq;
+  int tok, argc;
+  struct execcmd *cmd;
+  struct cmd *ret;
+
+  if(peek(ps, es, "("))
+    return parseblock(ps, es);
+
+  ret = execcmd();
+  cmd = (struct execcmd*)ret;
+
+  argc = 0;
+  ret = parseredirs(ret, ps, es);
+  while(!peek(ps, es, "|)&;")){
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+      break;
+    if(tok != 'a')
+      panic("syntax");
+    cmd->argv[argc] = q;
+    cmd->eargv[argc] = eq;
+    argc++;
+    if(argc >= MAXARGS)
+      panic("too many args");
+    ret = parseredirs(ret, ps, es);
+  }
+  cmd->argv[argc] = 0;
+  cmd->eargv[argc] = 0;
+  return ret;
+}
+
+// NUL-terminate all the counted strings.
+struct cmd*
+nulterminate(struct cmd *cmd)
+{
+  int i;
+  struct backcmd *bcmd;
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+    return 0;
+
+  switch(cmd->type){
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+    for(i=0; ecmd->argv[i]; i++)
+      *ecmd->eargv[i] = 0;
+    break;
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+    nulterminate(rcmd->cmd);
+    *rcmd->efile = 0;
+    break;
+
+  case PIPE:
+    pcmd = (struct pipecmd*)cmd;
+    nulterminate(pcmd->left);
+    nulterminate(pcmd->right);
+    break;
+
+  case LIST:
+    lcmd = (struct listcmd*)cmd;
+    nulterminate(lcmd->left);
+    nulterminate(lcmd->right);
+    break;
+
+  case BACK:
+    bcmd = (struct backcmd*)cmd;
+    nulterminate(bcmd->cmd);
+    break;
+  }
+  return cmd;
+}
diff -ruN xv6-public/xv6-public/sh.d xv6-public_new/xv6-public/sh.d
--- xv6-public/xv6-public/sh.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sh.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1 @@
+sh.o: sh.c /usr/include/stdc-predef.h types.h user.h fcntl.h
Binary files xv6-public/xv6-public/sh.o and xv6-public_new/xv6-public/sh.o differ
diff -ruN xv6-public/xv6-public/sh.sym xv6-public_new/xv6-public/sh.sym
--- xv6-public/xv6-public/sh.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sh.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,86 @@
+00000000 .text
+000014b8 .rodata
+000015b0 .eh_frame
+00001a30 .data
+00001a60 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 sh.c
+00001a60 buf.1136
+00000000 ulib.c
+00000ccf stosb
+00000000 printf.c
+00001012 putc
+00001039 printint
+00001a40 digits.1098
+00000000 umalloc.c
+00001ac4 base
+00001acc freep
+0000136a morecore
+00000cf5 strcpy
+00000ffa yield
+0000100a set_prio
+000010ee printf
+00000f01 memmove
+00000f92 mknod
+000003fa execcmd
+00000dec gets
+00000fca getpid
+00000887 parsepipe
+00000744 parsecmd
+00000533 backcmd
+000006ca peek
+000008f9 parseredirs
+00000576 gettoken
+000013ce malloc
+00000fda sleep
+00001a30 whitespace
+00001002 wait2
+000003cd fork1
+00000bce nulterminate
+00000f5a pipe
+00000250 getcmd
+00000f6a write
+00000fa2 fstat
+00000f7a kill
+00000fba chdir
+000007d6 parseline
+00000000 runcmd
+000009e5 parseblock
+00000f82 exec
+00000f52 wait
+00001a38 symbols
+00000f62 read
+00000a97 parseexec
+00000f9a unlink
+000003a9 panic
+00000f42 fork
+00000fd2 sbrk
+00000fe2 uptime
+00001a51 __bss_start
+00000d97 memset
+000002a9 main
+00000d29 strcmp
+00000fc2 dup
+0000049b pipecmd
+00000434 redircmd
+00000e5f stat
+00001a51 _edata
+00001ad0 _end
+00000faa link
+00000f4a exit
+00000eb0 atoi
+00000fea draw
+00000d6c strlen
+00000f8a open
+00000db5 strchr
+00000ff2 cps
+00000fb2 mkdir
+00000f72 close
+000004e7 listcmd
+00001284 free
diff -ruN xv6-public/xv6-public/show1 xv6-public_new/xv6-public/show1
--- xv6-public/xv6-public/show1	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/show1	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
diff -ruN xv6-public/xv6-public/sign.pl xv6-public_new/xv6-public/sign.pl
--- xv6-public/xv6-public/sign.pl	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sign.pl	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,19 @@
+#!/usr/bin/perl
+
+open(SIG, $ARGV[0]) || die "open $ARGV[0]: $!";
+
+$n = sysread(SIG, $buf, 1000);
+
+if($n > 510){
+  print STDERR "boot block too large: $n bytes (max 510)\n";
+  exit 1;
+}
+
+print STDERR "boot block is $n bytes (max 510)\n";
+
+$buf .= "\0" x (510-$n);
+$buf .= "\x55\xAA";
+
+open(SIG, ">$ARGV[0]") || die "open >$ARGV[0]: $!";
+print SIG $buf;
+close SIG;
diff -ruN xv6-public/xv6-public/sleep1.p xv6-public_new/xv6-public/sleep1.p
--- xv6-public/xv6-public/sleep1.p	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sleep1.p	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,134 @@
+/*
+This file defines a Promela model for xv6's
+acquire, release, sleep, and wakeup, along with
+a model of a simple producer/consumer queue.
+
+To run:
+	spinp sleep1.p
+
+(You may need to install Spin, available at http://spinroot.com/.)
+
+After a successful run spin prints something like:
+
+	unreached in proctype consumer
+		(0 of 37 states)
+	unreached in proctype producer
+		(0 of 23 states)
+
+After an unsuccessful run, the spinp script prints
+an execution trace that causes a deadlock.
+
+The safe body of producer reads:
+
+		acquire(lk);
+		x = value; value = x + 1; x = 0;
+		wakeup(0);
+		release(lk);
+		i = i + 1;
+
+If this is changed to:
+
+		x = value; value = x + 1; x = 0;
+		acquire(lk);
+		wakeup(0);
+		release(lk);
+		i = i + 1;
+
+then a deadlock can happen, because the non-atomic
+increment of value conflicts with the non-atomic 
+decrement in consumer, causing value to have a bad value.
+Try this.
+
+If it is changed to:
+
+		acquire(lk);
+		x = value; value = x + 1; x = 0;
+		release(lk);
+		wakeup(0);
+		i = i + 1;
+
+then nothing bad happens: it is okay to wakeup after release
+instead of before, although it seems morally wrong.
+*/
+
+#define ITER 4
+#define N 2
+
+bit lk;
+byte value;
+bit sleeping[N];
+
+inline acquire(x)
+{
+	atomic { x == 0; x = 1 }
+}
+
+inline release(x)
+{
+	assert x==1;
+	x = 0
+}
+
+inline sleep(cond, lk)
+{
+	assert !sleeping[_pid];
+	if
+	:: cond ->
+		skip
+	:: else ->
+		atomic { release(lk); sleeping[_pid] = 1 };
+		sleeping[_pid] == 0;
+		acquire(lk)
+	fi
+}
+
+inline wakeup()
+{
+	w = 0;
+	do
+	:: w < N ->
+		sleeping[w] = 0;
+		w = w + 1
+	:: else ->
+		break
+	od
+}
+
+active[N] proctype consumer()
+{
+	byte i, x;
+	
+	i = 0;
+	do
+	:: i < ITER ->
+		acquire(lk);
+		sleep(value > 0, lk);
+		x = value; value = x - 1; x = 0;
+		release(lk);
+		i = i + 1;
+	:: else ->
+		break
+	od;
+	i = 0;
+	skip
+}
+
+active[N] proctype producer()
+{
+	byte i, x, w;
+	
+	i = 0;
+	do
+	:: i < ITER ->
+		acquire(lk);
+		x = value; value = x + 1; x = 0;
+		release(lk);
+		wakeup();
+		i = i + 1;
+	:: else ->
+		break
+	od;
+	i = 0;
+	skip	
+}
+
diff -ruN xv6-public/xv6-public/sleeplock.c xv6-public_new/xv6-public/sleeplock.c
--- xv6-public/xv6-public/sleeplock.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sleeplock.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,56 @@
+// Sleeping locks
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "x86.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+
+void
+initsleeplock(struct sleeplock *lk, char *name)
+{
+  initlock(&lk->lk, "sleep lock");
+  lk->name = name;
+  lk->locked = 0;
+  lk->pid = 0;
+}
+
+void
+acquiresleep(struct sleeplock *lk)
+{
+  acquire(&lk->lk);
+  while (lk->locked) {
+    sleep(lk, &lk->lk);
+  }
+  lk->locked = 1;
+  lk->pid = myproc()->pid;
+  release(&lk->lk);
+}
+
+void
+releasesleep(struct sleeplock *lk)
+{
+  acquire(&lk->lk);
+  lk->locked = 0;
+  lk->pid = 0;
+  wakeup(lk);
+  release(&lk->lk);
+}
+
+int
+holdingsleep(struct sleeplock *lk)
+{
+  int r;
+  
+  acquire(&lk->lk);
+  r = lk->locked && (lk->pid == myproc()->pid);
+  release(&lk->lk);
+  return r;
+}
+
+
+
diff -ruN xv6-public/xv6-public/sleeplock.d xv6-public_new/xv6-public/sleeplock.d
--- xv6-public/xv6-public/sleeplock.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sleeplock.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+sleeplock.o: sleeplock.c /usr/include/stdc-predef.h types.h defs.h \
+ param.h x86.h memlayout.h mmu.h proc.h spinlock.h sleeplock.h
diff -ruN xv6-public/xv6-public/sleeplock.h xv6-public_new/xv6-public/sleeplock.h
--- xv6-public/xv6-public/sleeplock.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sleeplock.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,10 @@
+// Long-term locks for processes
+struct sleeplock {
+  uint locked;       // Is the lock held?
+  struct spinlock lk; // spinlock protecting this sleep lock
+  
+  // For debugging:
+  char *name;        // Name of lock.
+  int pid;           // Process holding lock
+};
+
Binary files xv6-public/xv6-public/sleeplock.o and xv6-public_new/xv6-public/sleeplock.o differ
diff -ruN xv6-public/xv6-public/spinlock.c xv6-public_new/xv6-public/spinlock.c
--- xv6-public/xv6-public/spinlock.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/spinlock.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,126 @@
+// Mutual exclusion spin locks.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "x86.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "spinlock.h"
+
+void
+initlock(struct spinlock *lk, char *name)
+{
+  lk->name = name;
+  lk->locked = 0;
+  lk->cpu = 0;
+}
+
+// Acquire the lock.
+// Loops (spins) until the lock is acquired.
+// Holding a lock for a long time may cause
+// other CPUs to waste time spinning to acquire it.
+void
+acquire(struct spinlock *lk)
+{
+  pushcli(); // disable interrupts to avoid deadlock.
+  if(holding(lk))
+    panic("acquire");
+
+  // The xchg is atomic.
+  while(xchg(&lk->locked, 1) != 0)
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen after the lock is acquired.
+  __sync_synchronize();
+
+  // Record info about lock acquisition for debugging.
+  lk->cpu = mycpu();
+  getcallerpcs(&lk, lk->pcs);
+}
+
+// Release the lock.
+void
+release(struct spinlock *lk)
+{
+  if(!holding(lk))
+    panic("release");
+
+  lk->pcs[0] = 0;
+  lk->cpu = 0;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that all the stores in the critical
+  // section are visible to other cores before the lock is released.
+  // Both the C compiler and the hardware may re-order loads and
+  // stores; __sync_synchronize() tells them both not to.
+  __sync_synchronize();
+
+  // Release the lock, equivalent to lk->locked = 0.
+  // This code can't use a C assignment, since it might
+  // not be atomic. A real OS would use C atomics here.
+  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+
+  popcli();
+}
+
+// Record the current call stack in pcs[] by following the %ebp chain.
+void
+getcallerpcs(void *v, uint pcs[])
+{
+  uint *ebp;
+  int i;
+
+  ebp = (uint*)v - 2;
+  for(i = 0; i < 10; i++){
+    if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+      break;
+    pcs[i] = ebp[1];     // saved %eip
+    ebp = (uint*)ebp[0]; // saved %ebp
+  }
+  for(; i < 10; i++)
+    pcs[i] = 0;
+}
+
+// Check whether this cpu is holding the lock.
+int
+holding(struct spinlock *lock)
+{
+  int r;
+  pushcli();
+  r = lock->locked && lock->cpu == mycpu();
+  popcli();
+  return r;
+}
+
+
+// Pushcli/popcli are like cli/sti except that they are matched:
+// it takes two popcli to undo two pushcli.  Also, if interrupts
+// are off, then pushcli, popcli leaves them off.
+
+void
+pushcli(void)
+{
+  int eflags;
+
+  eflags = readeflags();
+  cli();
+  if(mycpu()->ncli == 0)
+    mycpu()->intena = eflags & FL_IF;
+  mycpu()->ncli += 1;
+}
+
+void
+popcli(void)
+{
+  if(readeflags()&FL_IF)
+    panic("popcli - interruptible");
+  if(--mycpu()->ncli < 0)
+    panic("popcli");
+  if(mycpu()->ncli == 0 && mycpu()->intena)
+    sti();
+}
+
diff -ruN xv6-public/xv6-public/spinlock.d xv6-public_new/xv6-public/spinlock.d
--- xv6-public/xv6-public/spinlock.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/spinlock.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+spinlock.o: spinlock.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ x86.h memlayout.h mmu.h proc.h spinlock.h
diff -ruN xv6-public/xv6-public/spinlock.h xv6-public_new/xv6-public/spinlock.h
--- xv6-public/xv6-public/spinlock.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/spinlock.h	2021-09-29 00:50:24.000000000 +0530
@@ -0,0 +1,11 @@
+// Mutual exclusion lock.
+struct spinlock {
+  uint locked;       // Is the lock held?
+
+  // For debugging:
+  char *name;        // Name of lock.
+  struct cpu *cpu;   // The cpu holding the lock.
+  uint pcs[10];      // The call stack (an array of program counters)
+                     // that locked the lock.
+};
+
Binary files xv6-public/xv6-public/spinlock.o and xv6-public_new/xv6-public/spinlock.o differ
diff -ruN xv6-public/xv6-public/spinp xv6-public_new/xv6-public/spinp
--- xv6-public/xv6-public/spinp	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/spinp	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+if [ $# != 1 ] || [ ! -f "$1" ]; then
+	echo 'usage: spinp file.p' 1>&2
+	exit 1
+fi
+
+rm -f $1.trail
+spin -a $1 || exit 1
+cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
+pan -i
+rm pan.* pan
+if [ -f $1.trail ]; then
+	spin -t -p $1
+fi
+
diff -ruN xv6-public/xv6-public/stat.h xv6-public_new/xv6-public/stat.h
--- xv6-public/xv6-public/stat.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/stat.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,11 @@
+#define T_DIR  1   // Directory
+#define T_FILE 2   // File
+#define T_DEV  3   // Device
+
+struct stat {
+  short type;  // Type of file
+  int dev;     // File system's disk device
+  uint ino;    // Inode number
+  short nlink; // Number of links to file
+  uint size;   // Size of file in bytes
+};
diff -ruN xv6-public/xv6-public/stressfs.asm xv6-public_new/xv6-public/stressfs.asm
--- xv6-public/xv6-public/stressfs.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/stressfs.asm	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,1253 @@
+
+_stressfs:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "fs.h"
+#include "fcntl.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	51                   	push   %ecx
+  12:	81 ec 24 02 00 00    	sub    $0x224,%esp
+  int fd, i;
+  char path[] = "stressfs0";
+  18:	c7 45 e6 73 74 72 65 	movl   $0x65727473,-0x1a(%ebp)
+  1f:	c7 45 ea 73 73 66 73 	movl   $0x73667373,-0x16(%ebp)
+  26:	66 c7 45 ee 30 00    	movw   $0x30,-0x12(%ebp)
+  char data[512];
+
+  printf(1, "stressfs starting\n");
+  2c:	83 ec 08             	sub    $0x8,%esp
+  2f:	68 3c 09 00 00       	push   $0x93c
+  34:	6a 01                	push   $0x1
+  36:	e8 3a 05 00 00       	call   575 <printf>
+  3b:	83 c4 10             	add    $0x10,%esp
+  memset(data, 'a', sizeof(data));
+  3e:	83 ec 04             	sub    $0x4,%esp
+  41:	68 00 02 00 00       	push   $0x200
+  46:	6a 61                	push   $0x61
+  48:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
+  4e:	50                   	push   %eax
+  4f:	e8 ca 01 00 00       	call   21e <memset>
+  54:	83 c4 10             	add    $0x10,%esp
+
+  for(i = 0; i < 4; i++)
+  57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  5e:	eb 0d                	jmp    6d <main+0x6d>
+    if(fork() > 0)
+  60:	e8 64 03 00 00       	call   3c9 <fork>
+  65:	85 c0                	test   %eax,%eax
+  67:	7f 0c                	jg     75 <main+0x75>
+  for(i = 0; i < 4; i++)
+  69:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  6d:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
+  71:	7e ed                	jle    60 <main+0x60>
+  73:	eb 01                	jmp    76 <main+0x76>
+      break;
+  75:	90                   	nop
+
+  printf(1, "write %d\n", i);
+  76:	83 ec 04             	sub    $0x4,%esp
+  79:	ff 75 f4             	pushl  -0xc(%ebp)
+  7c:	68 4f 09 00 00       	push   $0x94f
+  81:	6a 01                	push   $0x1
+  83:	e8 ed 04 00 00       	call   575 <printf>
+  88:	83 c4 10             	add    $0x10,%esp
+
+  path[8] += i;
+  8b:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
+  8f:	89 c2                	mov    %eax,%edx
+  91:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  94:	01 d0                	add    %edx,%eax
+  96:	88 45 ee             	mov    %al,-0x12(%ebp)
+  fd = open(path, O_CREATE | O_RDWR);
+  99:	83 ec 08             	sub    $0x8,%esp
+  9c:	68 02 02 00 00       	push   $0x202
+  a1:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+  a4:	50                   	push   %eax
+  a5:	e8 67 03 00 00       	call   411 <open>
+  aa:	83 c4 10             	add    $0x10,%esp
+  ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(i = 0; i < 20; i++)
+  b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  b7:	eb 1e                	jmp    d7 <main+0xd7>
+//    printf(fd, "%d\n", i);
+    write(fd, data, sizeof(data));
+  b9:	83 ec 04             	sub    $0x4,%esp
+  bc:	68 00 02 00 00       	push   $0x200
+  c1:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
+  c7:	50                   	push   %eax
+  c8:	ff 75 f0             	pushl  -0x10(%ebp)
+  cb:	e8 21 03 00 00       	call   3f1 <write>
+  d0:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 20; i++)
+  d3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  d7:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+  db:	7e dc                	jle    b9 <main+0xb9>
+  close(fd);
+  dd:	83 ec 0c             	sub    $0xc,%esp
+  e0:	ff 75 f0             	pushl  -0x10(%ebp)
+  e3:	e8 11 03 00 00       	call   3f9 <close>
+  e8:	83 c4 10             	add    $0x10,%esp
+
+  printf(1, "read\n");
+  eb:	83 ec 08             	sub    $0x8,%esp
+  ee:	68 59 09 00 00       	push   $0x959
+  f3:	6a 01                	push   $0x1
+  f5:	e8 7b 04 00 00       	call   575 <printf>
+  fa:	83 c4 10             	add    $0x10,%esp
+
+  fd = open(path, O_RDONLY);
+  fd:	83 ec 08             	sub    $0x8,%esp
+ 100:	6a 00                	push   $0x0
+ 102:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+ 105:	50                   	push   %eax
+ 106:	e8 06 03 00 00       	call   411 <open>
+ 10b:	83 c4 10             	add    $0x10,%esp
+ 10e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for (i = 0; i < 20; i++)
+ 111:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 118:	eb 1e                	jmp    138 <main+0x138>
+    read(fd, data, sizeof(data));
+ 11a:	83 ec 04             	sub    $0x4,%esp
+ 11d:	68 00 02 00 00       	push   $0x200
+ 122:	8d 85 e6 fd ff ff    	lea    -0x21a(%ebp),%eax
+ 128:	50                   	push   %eax
+ 129:	ff 75 f0             	pushl  -0x10(%ebp)
+ 12c:	e8 b8 02 00 00       	call   3e9 <read>
+ 131:	83 c4 10             	add    $0x10,%esp
+  for (i = 0; i < 20; i++)
+ 134:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 138:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+ 13c:	7e dc                	jle    11a <main+0x11a>
+  close(fd);
+ 13e:	83 ec 0c             	sub    $0xc,%esp
+ 141:	ff 75 f0             	pushl  -0x10(%ebp)
+ 144:	e8 b0 02 00 00       	call   3f9 <close>
+ 149:	83 c4 10             	add    $0x10,%esp
+
+  wait();
+ 14c:	e8 88 02 00 00       	call   3d9 <wait>
+
+  exit();
+ 151:	e8 7b 02 00 00       	call   3d1 <exit>
+
+00000156 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 156:	55                   	push   %ebp
+ 157:	89 e5                	mov    %esp,%ebp
+ 159:	57                   	push   %edi
+ 15a:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 15b:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 15e:	8b 55 10             	mov    0x10(%ebp),%edx
+ 161:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 164:	89 cb                	mov    %ecx,%ebx
+ 166:	89 df                	mov    %ebx,%edi
+ 168:	89 d1                	mov    %edx,%ecx
+ 16a:	fc                   	cld    
+ 16b:	f3 aa                	rep stos %al,%es:(%edi)
+ 16d:	89 ca                	mov    %ecx,%edx
+ 16f:	89 fb                	mov    %edi,%ebx
+ 171:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 174:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 177:	90                   	nop
+ 178:	5b                   	pop    %ebx
+ 179:	5f                   	pop    %edi
+ 17a:	5d                   	pop    %ebp
+ 17b:	c3                   	ret    
+
+0000017c <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 17c:	f3 0f 1e fb          	endbr32 
+ 180:	55                   	push   %ebp
+ 181:	89 e5                	mov    %esp,%ebp
+ 183:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 186:	8b 45 08             	mov    0x8(%ebp),%eax
+ 189:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 18c:	90                   	nop
+ 18d:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 190:	8d 42 01             	lea    0x1(%edx),%eax
+ 193:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 196:	8b 45 08             	mov    0x8(%ebp),%eax
+ 199:	8d 48 01             	lea    0x1(%eax),%ecx
+ 19c:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 19f:	0f b6 12             	movzbl (%edx),%edx
+ 1a2:	88 10                	mov    %dl,(%eax)
+ 1a4:	0f b6 00             	movzbl (%eax),%eax
+ 1a7:	84 c0                	test   %al,%al
+ 1a9:	75 e2                	jne    18d <strcpy+0x11>
+    ;
+  return os;
+ 1ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 1ae:	c9                   	leave  
+ 1af:	c3                   	ret    
+
+000001b0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 1b0:	f3 0f 1e fb          	endbr32 
+ 1b4:	55                   	push   %ebp
+ 1b5:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 1b7:	eb 08                	jmp    1c1 <strcmp+0x11>
+    p++, q++;
+ 1b9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 1bd:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 1c1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1c4:	0f b6 00             	movzbl (%eax),%eax
+ 1c7:	84 c0                	test   %al,%al
+ 1c9:	74 10                	je     1db <strcmp+0x2b>
+ 1cb:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1ce:	0f b6 10             	movzbl (%eax),%edx
+ 1d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1d4:	0f b6 00             	movzbl (%eax),%eax
+ 1d7:	38 c2                	cmp    %al,%dl
+ 1d9:	74 de                	je     1b9 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 1db:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1de:	0f b6 00             	movzbl (%eax),%eax
+ 1e1:	0f b6 d0             	movzbl %al,%edx
+ 1e4:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1e7:	0f b6 00             	movzbl (%eax),%eax
+ 1ea:	0f b6 c0             	movzbl %al,%eax
+ 1ed:	29 c2                	sub    %eax,%edx
+ 1ef:	89 d0                	mov    %edx,%eax
+}
+ 1f1:	5d                   	pop    %ebp
+ 1f2:	c3                   	ret    
+
+000001f3 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 1f3:	f3 0f 1e fb          	endbr32 
+ 1f7:	55                   	push   %ebp
+ 1f8:	89 e5                	mov    %esp,%ebp
+ 1fa:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 204:	eb 04                	jmp    20a <strlen+0x17>
+ 206:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 20a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 20d:	8b 45 08             	mov    0x8(%ebp),%eax
+ 210:	01 d0                	add    %edx,%eax
+ 212:	0f b6 00             	movzbl (%eax),%eax
+ 215:	84 c0                	test   %al,%al
+ 217:	75 ed                	jne    206 <strlen+0x13>
+    ;
+  return n;
+ 219:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 21c:	c9                   	leave  
+ 21d:	c3                   	ret    
+
+0000021e <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 21e:	f3 0f 1e fb          	endbr32 
+ 222:	55                   	push   %ebp
+ 223:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 225:	8b 45 10             	mov    0x10(%ebp),%eax
+ 228:	50                   	push   %eax
+ 229:	ff 75 0c             	pushl  0xc(%ebp)
+ 22c:	ff 75 08             	pushl  0x8(%ebp)
+ 22f:	e8 22 ff ff ff       	call   156 <stosb>
+ 234:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 237:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 23a:	c9                   	leave  
+ 23b:	c3                   	ret    
+
+0000023c <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 23c:	f3 0f 1e fb          	endbr32 
+ 240:	55                   	push   %ebp
+ 241:	89 e5                	mov    %esp,%ebp
+ 243:	83 ec 04             	sub    $0x4,%esp
+ 246:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 249:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 24c:	eb 14                	jmp    262 <strchr+0x26>
+    if(*s == c)
+ 24e:	8b 45 08             	mov    0x8(%ebp),%eax
+ 251:	0f b6 00             	movzbl (%eax),%eax
+ 254:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 257:	75 05                	jne    25e <strchr+0x22>
+      return (char*)s;
+ 259:	8b 45 08             	mov    0x8(%ebp),%eax
+ 25c:	eb 13                	jmp    271 <strchr+0x35>
+  for(; *s; s++)
+ 25e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 262:	8b 45 08             	mov    0x8(%ebp),%eax
+ 265:	0f b6 00             	movzbl (%eax),%eax
+ 268:	84 c0                	test   %al,%al
+ 26a:	75 e2                	jne    24e <strchr+0x12>
+  return 0;
+ 26c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 271:	c9                   	leave  
+ 272:	c3                   	ret    
+
+00000273 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 273:	f3 0f 1e fb          	endbr32 
+ 277:	55                   	push   %ebp
+ 278:	89 e5                	mov    %esp,%ebp
+ 27a:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 27d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 284:	eb 42                	jmp    2c8 <gets+0x55>
+    cc = read(0, &c, 1);
+ 286:	83 ec 04             	sub    $0x4,%esp
+ 289:	6a 01                	push   $0x1
+ 28b:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 28e:	50                   	push   %eax
+ 28f:	6a 00                	push   $0x0
+ 291:	e8 53 01 00 00       	call   3e9 <read>
+ 296:	83 c4 10             	add    $0x10,%esp
+ 299:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 29c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 2a0:	7e 33                	jle    2d5 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 2a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2a5:	8d 50 01             	lea    0x1(%eax),%edx
+ 2a8:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 2ab:	89 c2                	mov    %eax,%edx
+ 2ad:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2b0:	01 c2                	add    %eax,%edx
+ 2b2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 2b6:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 2b8:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 2bc:	3c 0a                	cmp    $0xa,%al
+ 2be:	74 16                	je     2d6 <gets+0x63>
+ 2c0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 2c4:	3c 0d                	cmp    $0xd,%al
+ 2c6:	74 0e                	je     2d6 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 2c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 2cb:	83 c0 01             	add    $0x1,%eax
+ 2ce:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 2d1:	7f b3                	jg     286 <gets+0x13>
+ 2d3:	eb 01                	jmp    2d6 <gets+0x63>
+      break;
+ 2d5:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 2d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 2d9:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2dc:	01 d0                	add    %edx,%eax
+ 2de:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 2e1:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2e4:	c9                   	leave  
+ 2e5:	c3                   	ret    
+
+000002e6 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 2e6:	f3 0f 1e fb          	endbr32 
+ 2ea:	55                   	push   %ebp
+ 2eb:	89 e5                	mov    %esp,%ebp
+ 2ed:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2f0:	83 ec 08             	sub    $0x8,%esp
+ 2f3:	6a 00                	push   $0x0
+ 2f5:	ff 75 08             	pushl  0x8(%ebp)
+ 2f8:	e8 14 01 00 00       	call   411 <open>
+ 2fd:	83 c4 10             	add    $0x10,%esp
+ 300:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 303:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 307:	79 07                	jns    310 <stat+0x2a>
+    return -1;
+ 309:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 30e:	eb 25                	jmp    335 <stat+0x4f>
+  r = fstat(fd, st);
+ 310:	83 ec 08             	sub    $0x8,%esp
+ 313:	ff 75 0c             	pushl  0xc(%ebp)
+ 316:	ff 75 f4             	pushl  -0xc(%ebp)
+ 319:	e8 0b 01 00 00       	call   429 <fstat>
+ 31e:	83 c4 10             	add    $0x10,%esp
+ 321:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 324:	83 ec 0c             	sub    $0xc,%esp
+ 327:	ff 75 f4             	pushl  -0xc(%ebp)
+ 32a:	e8 ca 00 00 00       	call   3f9 <close>
+ 32f:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 332:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 335:	c9                   	leave  
+ 336:	c3                   	ret    
+
+00000337 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 337:	f3 0f 1e fb          	endbr32 
+ 33b:	55                   	push   %ebp
+ 33c:	89 e5                	mov    %esp,%ebp
+ 33e:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 341:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 348:	eb 25                	jmp    36f <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 34a:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 34d:	89 d0                	mov    %edx,%eax
+ 34f:	c1 e0 02             	shl    $0x2,%eax
+ 352:	01 d0                	add    %edx,%eax
+ 354:	01 c0                	add    %eax,%eax
+ 356:	89 c1                	mov    %eax,%ecx
+ 358:	8b 45 08             	mov    0x8(%ebp),%eax
+ 35b:	8d 50 01             	lea    0x1(%eax),%edx
+ 35e:	89 55 08             	mov    %edx,0x8(%ebp)
+ 361:	0f b6 00             	movzbl (%eax),%eax
+ 364:	0f be c0             	movsbl %al,%eax
+ 367:	01 c8                	add    %ecx,%eax
+ 369:	83 e8 30             	sub    $0x30,%eax
+ 36c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 36f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 372:	0f b6 00             	movzbl (%eax),%eax
+ 375:	3c 2f                	cmp    $0x2f,%al
+ 377:	7e 0a                	jle    383 <atoi+0x4c>
+ 379:	8b 45 08             	mov    0x8(%ebp),%eax
+ 37c:	0f b6 00             	movzbl (%eax),%eax
+ 37f:	3c 39                	cmp    $0x39,%al
+ 381:	7e c7                	jle    34a <atoi+0x13>
+  return n;
+ 383:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 386:	c9                   	leave  
+ 387:	c3                   	ret    
+
+00000388 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 388:	f3 0f 1e fb          	endbr32 
+ 38c:	55                   	push   %ebp
+ 38d:	89 e5                	mov    %esp,%ebp
+ 38f:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 392:	8b 45 08             	mov    0x8(%ebp),%eax
+ 395:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 398:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 39b:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 39e:	eb 17                	jmp    3b7 <memmove+0x2f>
+    *dst++ = *src++;
+ 3a0:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 3a3:	8d 42 01             	lea    0x1(%edx),%eax
+ 3a6:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 3a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 3ac:	8d 48 01             	lea    0x1(%eax),%ecx
+ 3af:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 3b2:	0f b6 12             	movzbl (%edx),%edx
+ 3b5:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 3b7:	8b 45 10             	mov    0x10(%ebp),%eax
+ 3ba:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 3bd:	89 55 10             	mov    %edx,0x10(%ebp)
+ 3c0:	85 c0                	test   %eax,%eax
+ 3c2:	7f dc                	jg     3a0 <memmove+0x18>
+  return vdst;
+ 3c4:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 3c7:	c9                   	leave  
+ 3c8:	c3                   	ret    
+
+000003c9 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 3c9:	b8 01 00 00 00       	mov    $0x1,%eax
+ 3ce:	cd 40                	int    $0x40
+ 3d0:	c3                   	ret    
+
+000003d1 <exit>:
+SYSCALL(exit)
+ 3d1:	b8 02 00 00 00       	mov    $0x2,%eax
+ 3d6:	cd 40                	int    $0x40
+ 3d8:	c3                   	ret    
+
+000003d9 <wait>:
+SYSCALL(wait)
+ 3d9:	b8 03 00 00 00       	mov    $0x3,%eax
+ 3de:	cd 40                	int    $0x40
+ 3e0:	c3                   	ret    
+
+000003e1 <pipe>:
+SYSCALL(pipe)
+ 3e1:	b8 04 00 00 00       	mov    $0x4,%eax
+ 3e6:	cd 40                	int    $0x40
+ 3e8:	c3                   	ret    
+
+000003e9 <read>:
+SYSCALL(read)
+ 3e9:	b8 05 00 00 00       	mov    $0x5,%eax
+ 3ee:	cd 40                	int    $0x40
+ 3f0:	c3                   	ret    
+
+000003f1 <write>:
+SYSCALL(write)
+ 3f1:	b8 10 00 00 00       	mov    $0x10,%eax
+ 3f6:	cd 40                	int    $0x40
+ 3f8:	c3                   	ret    
+
+000003f9 <close>:
+SYSCALL(close)
+ 3f9:	b8 15 00 00 00       	mov    $0x15,%eax
+ 3fe:	cd 40                	int    $0x40
+ 400:	c3                   	ret    
+
+00000401 <kill>:
+SYSCALL(kill)
+ 401:	b8 06 00 00 00       	mov    $0x6,%eax
+ 406:	cd 40                	int    $0x40
+ 408:	c3                   	ret    
+
+00000409 <exec>:
+SYSCALL(exec)
+ 409:	b8 07 00 00 00       	mov    $0x7,%eax
+ 40e:	cd 40                	int    $0x40
+ 410:	c3                   	ret    
+
+00000411 <open>:
+SYSCALL(open)
+ 411:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 416:	cd 40                	int    $0x40
+ 418:	c3                   	ret    
+
+00000419 <mknod>:
+SYSCALL(mknod)
+ 419:	b8 11 00 00 00       	mov    $0x11,%eax
+ 41e:	cd 40                	int    $0x40
+ 420:	c3                   	ret    
+
+00000421 <unlink>:
+SYSCALL(unlink)
+ 421:	b8 12 00 00 00       	mov    $0x12,%eax
+ 426:	cd 40                	int    $0x40
+ 428:	c3                   	ret    
+
+00000429 <fstat>:
+SYSCALL(fstat)
+ 429:	b8 08 00 00 00       	mov    $0x8,%eax
+ 42e:	cd 40                	int    $0x40
+ 430:	c3                   	ret    
+
+00000431 <link>:
+SYSCALL(link)
+ 431:	b8 13 00 00 00       	mov    $0x13,%eax
+ 436:	cd 40                	int    $0x40
+ 438:	c3                   	ret    
+
+00000439 <mkdir>:
+SYSCALL(mkdir)
+ 439:	b8 14 00 00 00       	mov    $0x14,%eax
+ 43e:	cd 40                	int    $0x40
+ 440:	c3                   	ret    
+
+00000441 <chdir>:
+SYSCALL(chdir)
+ 441:	b8 09 00 00 00       	mov    $0x9,%eax
+ 446:	cd 40                	int    $0x40
+ 448:	c3                   	ret    
+
+00000449 <dup>:
+SYSCALL(dup)
+ 449:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 44e:	cd 40                	int    $0x40
+ 450:	c3                   	ret    
+
+00000451 <getpid>:
+SYSCALL(getpid)
+ 451:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 456:	cd 40                	int    $0x40
+ 458:	c3                   	ret    
+
+00000459 <sbrk>:
+SYSCALL(sbrk)
+ 459:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 45e:	cd 40                	int    $0x40
+ 460:	c3                   	ret    
+
+00000461 <sleep>:
+SYSCALL(sleep)
+ 461:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 466:	cd 40                	int    $0x40
+ 468:	c3                   	ret    
+
+00000469 <uptime>:
+SYSCALL(uptime)
+ 469:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 46e:	cd 40                	int    $0x40
+ 470:	c3                   	ret    
+
+00000471 <draw>:
+SYSCALL(draw)
+ 471:	b8 16 00 00 00       	mov    $0x16,%eax
+ 476:	cd 40                	int    $0x40
+ 478:	c3                   	ret    
+
+00000479 <cps>:
+SYSCALL(cps)
+ 479:	b8 17 00 00 00       	mov    $0x17,%eax
+ 47e:	cd 40                	int    $0x40
+ 480:	c3                   	ret    
+
+00000481 <yield>:
+SYSCALL(yield)
+ 481:	b8 18 00 00 00       	mov    $0x18,%eax
+ 486:	cd 40                	int    $0x40
+ 488:	c3                   	ret    
+
+00000489 <wait2>:
+SYSCALL(wait2)
+ 489:	b8 19 00 00 00       	mov    $0x19,%eax
+ 48e:	cd 40                	int    $0x40
+ 490:	c3                   	ret    
+
+00000491 <set_prio>:
+SYSCALL(set_prio)
+ 491:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 496:	cd 40                	int    $0x40
+ 498:	c3                   	ret    
+
+00000499 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 499:	f3 0f 1e fb          	endbr32 
+ 49d:	55                   	push   %ebp
+ 49e:	89 e5                	mov    %esp,%ebp
+ 4a0:	83 ec 18             	sub    $0x18,%esp
+ 4a3:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4a6:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 4a9:	83 ec 04             	sub    $0x4,%esp
+ 4ac:	6a 01                	push   $0x1
+ 4ae:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 4b1:	50                   	push   %eax
+ 4b2:	ff 75 08             	pushl  0x8(%ebp)
+ 4b5:	e8 37 ff ff ff       	call   3f1 <write>
+ 4ba:	83 c4 10             	add    $0x10,%esp
+}
+ 4bd:	90                   	nop
+ 4be:	c9                   	leave  
+ 4bf:	c3                   	ret    
+
+000004c0 <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 4c0:	f3 0f 1e fb          	endbr32 
+ 4c4:	55                   	push   %ebp
+ 4c5:	89 e5                	mov    %esp,%ebp
+ 4c7:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 4ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 4d1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 4d5:	74 17                	je     4ee <printint+0x2e>
+ 4d7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 4db:	79 11                	jns    4ee <printint+0x2e>
+    neg = 1;
+ 4dd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 4e4:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4e7:	f7 d8                	neg    %eax
+ 4e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 4ec:	eb 06                	jmp    4f4 <printint+0x34>
+  } else {
+    x = xx;
+ 4ee:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 4f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 4f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 4fb:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 4fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 501:	ba 00 00 00 00       	mov    $0x0,%edx
+ 506:	f7 f1                	div    %ecx
+ 508:	89 d1                	mov    %edx,%ecx
+ 50a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 50d:	8d 50 01             	lea    0x1(%eax),%edx
+ 510:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 513:	0f b6 91 ac 0b 00 00 	movzbl 0xbac(%ecx),%edx
+ 51a:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 51e:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 521:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 524:	ba 00 00 00 00       	mov    $0x0,%edx
+ 529:	f7 f1                	div    %ecx
+ 52b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 52e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 532:	75 c7                	jne    4fb <printint+0x3b>
+  if(neg)
+ 534:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 538:	74 2d                	je     567 <printint+0xa7>
+    buf[i++] = '-';
+ 53a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 53d:	8d 50 01             	lea    0x1(%eax),%edx
+ 540:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 543:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 548:	eb 1d                	jmp    567 <printint+0xa7>
+    putc(fd, buf[i]);
+ 54a:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 54d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 550:	01 d0                	add    %edx,%eax
+ 552:	0f b6 00             	movzbl (%eax),%eax
+ 555:	0f be c0             	movsbl %al,%eax
+ 558:	83 ec 08             	sub    $0x8,%esp
+ 55b:	50                   	push   %eax
+ 55c:	ff 75 08             	pushl  0x8(%ebp)
+ 55f:	e8 35 ff ff ff       	call   499 <putc>
+ 564:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 567:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 56b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 56f:	79 d9                	jns    54a <printint+0x8a>
+}
+ 571:	90                   	nop
+ 572:	90                   	nop
+ 573:	c9                   	leave  
+ 574:	c3                   	ret    
+
+00000575 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 575:	f3 0f 1e fb          	endbr32 
+ 579:	55                   	push   %ebp
+ 57a:	89 e5                	mov    %esp,%ebp
+ 57c:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 57f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 586:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 589:	83 c0 04             	add    $0x4,%eax
+ 58c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 58f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 596:	e9 59 01 00 00       	jmp    6f4 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 59b:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 59e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 5a1:	01 d0                	add    %edx,%eax
+ 5a3:	0f b6 00             	movzbl (%eax),%eax
+ 5a6:	0f be c0             	movsbl %al,%eax
+ 5a9:	25 ff 00 00 00       	and    $0xff,%eax
+ 5ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 5b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 5b5:	75 2c                	jne    5e3 <printf+0x6e>
+      if(c == '%'){
+ 5b7:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 5bb:	75 0c                	jne    5c9 <printf+0x54>
+        state = '%';
+ 5bd:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 5c4:	e9 27 01 00 00       	jmp    6f0 <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 5c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5cc:	0f be c0             	movsbl %al,%eax
+ 5cf:	83 ec 08             	sub    $0x8,%esp
+ 5d2:	50                   	push   %eax
+ 5d3:	ff 75 08             	pushl  0x8(%ebp)
+ 5d6:	e8 be fe ff ff       	call   499 <putc>
+ 5db:	83 c4 10             	add    $0x10,%esp
+ 5de:	e9 0d 01 00 00       	jmp    6f0 <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 5e3:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 5e7:	0f 85 03 01 00 00    	jne    6f0 <printf+0x17b>
+      if(c == 'd'){
+ 5ed:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 5f1:	75 1e                	jne    611 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 5f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 5f6:	8b 00                	mov    (%eax),%eax
+ 5f8:	6a 01                	push   $0x1
+ 5fa:	6a 0a                	push   $0xa
+ 5fc:	50                   	push   %eax
+ 5fd:	ff 75 08             	pushl  0x8(%ebp)
+ 600:	e8 bb fe ff ff       	call   4c0 <printint>
+ 605:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 608:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 60c:	e9 d8 00 00 00       	jmp    6e9 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 611:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 615:	74 06                	je     61d <printf+0xa8>
+ 617:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 61b:	75 1e                	jne    63b <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 61d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 620:	8b 00                	mov    (%eax),%eax
+ 622:	6a 00                	push   $0x0
+ 624:	6a 10                	push   $0x10
+ 626:	50                   	push   %eax
+ 627:	ff 75 08             	pushl  0x8(%ebp)
+ 62a:	e8 91 fe ff ff       	call   4c0 <printint>
+ 62f:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 632:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 636:	e9 ae 00 00 00       	jmp    6e9 <printf+0x174>
+      } else if(c == 's'){
+ 63b:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 63f:	75 43                	jne    684 <printf+0x10f>
+        s = (char*)*ap;
+ 641:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 644:	8b 00                	mov    (%eax),%eax
+ 646:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 649:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 64d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 651:	75 25                	jne    678 <printf+0x103>
+          s = "(null)";
+ 653:	c7 45 f4 5f 09 00 00 	movl   $0x95f,-0xc(%ebp)
+        while(*s != 0){
+ 65a:	eb 1c                	jmp    678 <printf+0x103>
+          putc(fd, *s);
+ 65c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 65f:	0f b6 00             	movzbl (%eax),%eax
+ 662:	0f be c0             	movsbl %al,%eax
+ 665:	83 ec 08             	sub    $0x8,%esp
+ 668:	50                   	push   %eax
+ 669:	ff 75 08             	pushl  0x8(%ebp)
+ 66c:	e8 28 fe ff ff       	call   499 <putc>
+ 671:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 674:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 678:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 67b:	0f b6 00             	movzbl (%eax),%eax
+ 67e:	84 c0                	test   %al,%al
+ 680:	75 da                	jne    65c <printf+0xe7>
+ 682:	eb 65                	jmp    6e9 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 684:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 688:	75 1d                	jne    6a7 <printf+0x132>
+        putc(fd, *ap);
+ 68a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 68d:	8b 00                	mov    (%eax),%eax
+ 68f:	0f be c0             	movsbl %al,%eax
+ 692:	83 ec 08             	sub    $0x8,%esp
+ 695:	50                   	push   %eax
+ 696:	ff 75 08             	pushl  0x8(%ebp)
+ 699:	e8 fb fd ff ff       	call   499 <putc>
+ 69e:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 6a1:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 6a5:	eb 42                	jmp    6e9 <printf+0x174>
+      } else if(c == '%'){
+ 6a7:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 6ab:	75 17                	jne    6c4 <printf+0x14f>
+        putc(fd, c);
+ 6ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 6b0:	0f be c0             	movsbl %al,%eax
+ 6b3:	83 ec 08             	sub    $0x8,%esp
+ 6b6:	50                   	push   %eax
+ 6b7:	ff 75 08             	pushl  0x8(%ebp)
+ 6ba:	e8 da fd ff ff       	call   499 <putc>
+ 6bf:	83 c4 10             	add    $0x10,%esp
+ 6c2:	eb 25                	jmp    6e9 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 6c4:	83 ec 08             	sub    $0x8,%esp
+ 6c7:	6a 25                	push   $0x25
+ 6c9:	ff 75 08             	pushl  0x8(%ebp)
+ 6cc:	e8 c8 fd ff ff       	call   499 <putc>
+ 6d1:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 6d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 6d7:	0f be c0             	movsbl %al,%eax
+ 6da:	83 ec 08             	sub    $0x8,%esp
+ 6dd:	50                   	push   %eax
+ 6de:	ff 75 08             	pushl  0x8(%ebp)
+ 6e1:	e8 b3 fd ff ff       	call   499 <putc>
+ 6e6:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 6e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 6f0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 6f4:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 6f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 6fa:	01 d0                	add    %edx,%eax
+ 6fc:	0f b6 00             	movzbl (%eax),%eax
+ 6ff:	84 c0                	test   %al,%al
+ 701:	0f 85 94 fe ff ff    	jne    59b <printf+0x26>
+    }
+  }
+}
+ 707:	90                   	nop
+ 708:	90                   	nop
+ 709:	c9                   	leave  
+ 70a:	c3                   	ret    
+
+0000070b <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 70b:	f3 0f 1e fb          	endbr32 
+ 70f:	55                   	push   %ebp
+ 710:	89 e5                	mov    %esp,%ebp
+ 712:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 715:	8b 45 08             	mov    0x8(%ebp),%eax
+ 718:	83 e8 08             	sub    $0x8,%eax
+ 71b:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 71e:	a1 c8 0b 00 00       	mov    0xbc8,%eax
+ 723:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 726:	eb 24                	jmp    74c <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 728:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 72b:	8b 00                	mov    (%eax),%eax
+ 72d:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 730:	72 12                	jb     744 <free+0x39>
+ 732:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 735:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 738:	77 24                	ja     75e <free+0x53>
+ 73a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 73d:	8b 00                	mov    (%eax),%eax
+ 73f:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 742:	72 1a                	jb     75e <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 744:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 747:	8b 00                	mov    (%eax),%eax
+ 749:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 74c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 74f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 752:	76 d4                	jbe    728 <free+0x1d>
+ 754:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 757:	8b 00                	mov    (%eax),%eax
+ 759:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 75c:	73 ca                	jae    728 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 75e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 761:	8b 40 04             	mov    0x4(%eax),%eax
+ 764:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 76b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 76e:	01 c2                	add    %eax,%edx
+ 770:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 773:	8b 00                	mov    (%eax),%eax
+ 775:	39 c2                	cmp    %eax,%edx
+ 777:	75 24                	jne    79d <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 779:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 77c:	8b 50 04             	mov    0x4(%eax),%edx
+ 77f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 782:	8b 00                	mov    (%eax),%eax
+ 784:	8b 40 04             	mov    0x4(%eax),%eax
+ 787:	01 c2                	add    %eax,%edx
+ 789:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 78c:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 78f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 792:	8b 00                	mov    (%eax),%eax
+ 794:	8b 10                	mov    (%eax),%edx
+ 796:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 799:	89 10                	mov    %edx,(%eax)
+ 79b:	eb 0a                	jmp    7a7 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 79d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7a0:	8b 10                	mov    (%eax),%edx
+ 7a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7a5:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 7a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7aa:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ad:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 7b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7b7:	01 d0                	add    %edx,%eax
+ 7b9:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 7bc:	75 20                	jne    7de <free+0xd3>
+    p->s.size += bp->s.size;
+ 7be:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7c1:	8b 50 04             	mov    0x4(%eax),%edx
+ 7c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7c7:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ca:	01 c2                	add    %eax,%edx
+ 7cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7cf:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 7d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7d5:	8b 10                	mov    (%eax),%edx
+ 7d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7da:	89 10                	mov    %edx,(%eax)
+ 7dc:	eb 08                	jmp    7e6 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 7de:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7e1:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 7e4:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 7e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7e9:	a3 c8 0b 00 00       	mov    %eax,0xbc8
+}
+ 7ee:	90                   	nop
+ 7ef:	c9                   	leave  
+ 7f0:	c3                   	ret    
+
+000007f1 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 7f1:	f3 0f 1e fb          	endbr32 
+ 7f5:	55                   	push   %ebp
+ 7f6:	89 e5                	mov    %esp,%ebp
+ 7f8:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 7fb:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 802:	77 07                	ja     80b <morecore+0x1a>
+    nu = 4096;
+ 804:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 80b:	8b 45 08             	mov    0x8(%ebp),%eax
+ 80e:	c1 e0 03             	shl    $0x3,%eax
+ 811:	83 ec 0c             	sub    $0xc,%esp
+ 814:	50                   	push   %eax
+ 815:	e8 3f fc ff ff       	call   459 <sbrk>
+ 81a:	83 c4 10             	add    $0x10,%esp
+ 81d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 820:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 824:	75 07                	jne    82d <morecore+0x3c>
+    return 0;
+ 826:	b8 00 00 00 00       	mov    $0x0,%eax
+ 82b:	eb 26                	jmp    853 <morecore+0x62>
+  hp = (Header*)p;
+ 82d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 830:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 833:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 836:	8b 55 08             	mov    0x8(%ebp),%edx
+ 839:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 83c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 83f:	83 c0 08             	add    $0x8,%eax
+ 842:	83 ec 0c             	sub    $0xc,%esp
+ 845:	50                   	push   %eax
+ 846:	e8 c0 fe ff ff       	call   70b <free>
+ 84b:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 84e:	a1 c8 0b 00 00       	mov    0xbc8,%eax
+}
+ 853:	c9                   	leave  
+ 854:	c3                   	ret    
+
+00000855 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 855:	f3 0f 1e fb          	endbr32 
+ 859:	55                   	push   %ebp
+ 85a:	89 e5                	mov    %esp,%ebp
+ 85c:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 85f:	8b 45 08             	mov    0x8(%ebp),%eax
+ 862:	83 c0 07             	add    $0x7,%eax
+ 865:	c1 e8 03             	shr    $0x3,%eax
+ 868:	83 c0 01             	add    $0x1,%eax
+ 86b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 86e:	a1 c8 0b 00 00       	mov    0xbc8,%eax
+ 873:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 876:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 87a:	75 23                	jne    89f <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 87c:	c7 45 f0 c0 0b 00 00 	movl   $0xbc0,-0x10(%ebp)
+ 883:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 886:	a3 c8 0b 00 00       	mov    %eax,0xbc8
+ 88b:	a1 c8 0b 00 00       	mov    0xbc8,%eax
+ 890:	a3 c0 0b 00 00       	mov    %eax,0xbc0
+    base.s.size = 0;
+ 895:	c7 05 c4 0b 00 00 00 	movl   $0x0,0xbc4
+ 89c:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 89f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8a2:	8b 00                	mov    (%eax),%eax
+ 8a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 8a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8aa:	8b 40 04             	mov    0x4(%eax),%eax
+ 8ad:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 8b0:	77 4d                	ja     8ff <malloc+0xaa>
+      if(p->s.size == nunits)
+ 8b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8b5:	8b 40 04             	mov    0x4(%eax),%eax
+ 8b8:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 8bb:	75 0c                	jne    8c9 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 8bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8c0:	8b 10                	mov    (%eax),%edx
+ 8c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8c5:	89 10                	mov    %edx,(%eax)
+ 8c7:	eb 26                	jmp    8ef <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 8c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8cc:	8b 40 04             	mov    0x4(%eax),%eax
+ 8cf:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 8d2:	89 c2                	mov    %eax,%edx
+ 8d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8d7:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 8da:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8dd:	8b 40 04             	mov    0x4(%eax),%eax
+ 8e0:	c1 e0 03             	shl    $0x3,%eax
+ 8e3:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 8e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 8ec:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 8ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8f2:	a3 c8 0b 00 00       	mov    %eax,0xbc8
+      return (void*)(p + 1);
+ 8f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 8fa:	83 c0 08             	add    $0x8,%eax
+ 8fd:	eb 3b                	jmp    93a <malloc+0xe5>
+    }
+    if(p == freep)
+ 8ff:	a1 c8 0b 00 00       	mov    0xbc8,%eax
+ 904:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 907:	75 1e                	jne    927 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 909:	83 ec 0c             	sub    $0xc,%esp
+ 90c:	ff 75 ec             	pushl  -0x14(%ebp)
+ 90f:	e8 dd fe ff ff       	call   7f1 <morecore>
+ 914:	83 c4 10             	add    $0x10,%esp
+ 917:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 91a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 91e:	75 07                	jne    927 <malloc+0xd2>
+        return 0;
+ 920:	b8 00 00 00 00       	mov    $0x0,%eax
+ 925:	eb 13                	jmp    93a <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 927:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 92a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 92d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 930:	8b 00                	mov    (%eax),%eax
+ 932:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 935:	e9 6d ff ff ff       	jmp    8a7 <malloc+0x52>
+  }
+}
+ 93a:	c9                   	leave  
+ 93b:	c3                   	ret    
diff -ruN xv6-public/xv6-public/stressfs.c xv6-public_new/xv6-public/stressfs.c
--- xv6-public/xv6-public/stressfs.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/stressfs.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,49 @@
+// Demonstrate that moving the "acquire" in iderw after the loop that
+// appends to the idequeue results in a race.
+
+// For this to work, you should also add a spin within iderw's
+// idequeue traversal loop.  Adding the following demonstrated a panic
+// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
+//    for (i = 0; i < 40000; i++)
+//      asm volatile("");
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+
+int
+main(int argc, char *argv[])
+{
+  int fd, i;
+  char path[] = "stressfs0";
+  char data[512];
+
+  printf(1, "stressfs starting\n");
+  memset(data, 'a', sizeof(data));
+
+  for(i = 0; i < 4; i++)
+    if(fork() > 0)
+      break;
+
+  printf(1, "write %d\n", i);
+
+  path[8] += i;
+  fd = open(path, O_CREATE | O_RDWR);
+  for(i = 0; i < 20; i++)
+//    printf(fd, "%d\n", i);
+    write(fd, data, sizeof(data));
+  close(fd);
+
+  printf(1, "read\n");
+
+  fd = open(path, O_RDONLY);
+  for (i = 0; i < 20; i++)
+    read(fd, data, sizeof(data));
+  close(fd);
+
+  wait();
+
+  exit();
+}
diff -ruN xv6-public/xv6-public/stressfs.d xv6-public_new/xv6-public/stressfs.d
--- xv6-public/xv6-public/stressfs.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/stressfs.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,2 @@
+stressfs.o: stressfs.c /usr/include/stdc-predef.h types.h stat.h user.h \
+ fs.h fcntl.h
Binary files xv6-public/xv6-public/stressfs.o and xv6-public_new/xv6-public/stressfs.o differ
diff -ruN xv6-public/xv6-public/stressfs.sym xv6-public_new/xv6-public/stressfs.sym
--- xv6-public/xv6-public/stressfs.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/stressfs.sym	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+0000093c .rodata
+00000968 .eh_frame
+00000bac .data
+00000bc0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 stressfs.c
+00000000 ulib.c
+00000156 stosb
+00000000 printf.c
+00000499 putc
+000004c0 printint
+00000bac digits.1098
+00000000 umalloc.c
+00000bc0 base
+00000bc8 freep
+000007f1 morecore
+0000017c strcpy
+00000481 yield
+00000491 set_prio
+00000575 printf
+00000388 memmove
+00000419 mknod
+00000273 gets
+00000451 getpid
+00000855 malloc
+00000461 sleep
+00000489 wait2
+000003e1 pipe
+000003f1 write
+00000429 fstat
+00000401 kill
+00000441 chdir
+00000409 exec
+000003d9 wait
+000003e9 read
+00000421 unlink
+000003c9 fork
+00000459 sbrk
+00000469 uptime
+00000bbd __bss_start
+0000021e memset
+00000000 main
+000001b0 strcmp
+00000449 dup
+000002e6 stat
+00000bbd _edata
+00000bcc _end
+00000431 link
+000003d1 exit
+00000337 atoi
+00000471 draw
+000001f3 strlen
+00000411 open
+0000023c strchr
+00000479 cps
+00000439 mkdir
+000003f9 close
+0000070b free
diff -ruN xv6-public/xv6-public/string.c xv6-public_new/xv6-public/string.c
--- xv6-public/xv6-public/string.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/string.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,105 @@
+#include "types.h"
+#include "x86.h"
+
+void*
+memset(void *dst, int c, uint n)
+{
+  if ((int)dst%4 == 0 && n%4 == 0){
+    c &= 0xFF;
+    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
+  } else
+    stosb(dst, c, n);
+  return dst;
+}
+
+int
+memcmp(const void *v1, const void *v2, uint n)
+{
+  const uchar *s1, *s2;
+
+  s1 = v1;
+  s2 = v2;
+  while(n-- > 0){
+    if(*s1 != *s2)
+      return *s1 - *s2;
+    s1++, s2++;
+  }
+
+  return 0;
+}
+
+void*
+memmove(void *dst, const void *src, uint n)
+{
+  const char *s;
+  char *d;
+
+  s = src;
+  d = dst;
+  if(s < d && s + n > d){
+    s += n;
+    d += n;
+    while(n-- > 0)
+      *--d = *--s;
+  } else
+    while(n-- > 0)
+      *d++ = *s++;
+
+  return dst;
+}
+
+// memcpy exists to placate GCC.  Use memmove.
+void*
+memcpy(void *dst, const void *src, uint n)
+{
+  return memmove(dst, src, n);
+}
+
+int
+strncmp(const char *p, const char *q, uint n)
+{
+  while(n > 0 && *p && *p == *q)
+    n--, p++, q++;
+  if(n == 0)
+    return 0;
+  return (uchar)*p - (uchar)*q;
+}
+
+char*
+strncpy(char *s, const char *t, int n)
+{
+  char *os;
+
+  os = s;
+  while(n-- > 0 && (*s++ = *t++) != 0)
+    ;
+  while(n-- > 0)
+    *s++ = 0;
+  return os;
+}
+
+// Like strncpy but guaranteed to NUL-terminate.
+char*
+safestrcpy(char *s, const char *t, int n)
+{
+  char *os;
+
+  os = s;
+  if(n <= 0)
+    return os;
+  while(--n > 0 && (*s++ = *t++) != 0)
+    ;
+  *s = 0;
+  return os;
+}
+
+int
+strlen(const char *s)
+{
+  int n;
+
+  for(n = 0; s[n]; n++)
+    ;
+  return n;
+}
+
diff -ruN xv6-public/xv6-public/string.d xv6-public_new/xv6-public/string.d
--- xv6-public/xv6-public/string.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/string.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1 @@
+string.o: string.c /usr/include/stdc-predef.h types.h x86.h
Binary files xv6-public/xv6-public/string.o and xv6-public_new/xv6-public/string.o differ
diff -ruN xv6-public/xv6-public/swtch.S xv6-public_new/xv6-public/swtch.S
--- xv6-public/xv6-public/swtch.S	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/swtch.S	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,29 @@
+# Context switch
+#
+#   void swtch(struct context **old, struct context *new);
+# 
+# Save the current registers on the stack, creating
+# a struct context, and save its address in *old.
+# Switch stacks to new and pop previously-saved registers.
+
+.globl swtch
+swtch:
+  movl 4(%esp), %eax
+  movl 8(%esp), %edx
+
+  # Save old callee-saved registers
+  pushl %ebp
+  pushl %ebx
+  pushl %esi
+  pushl %edi
+
+  # Switch stacks
+  movl %esp, (%eax)
+  movl %edx, %esp
+
+  # Load new callee-saved registers
+  popl %edi
+  popl %esi
+  popl %ebx
+  popl %ebp
+  ret
Binary files xv6-public/xv6-public/swtch.o and xv6-public_new/xv6-public/swtch.o differ
diff -ruN xv6-public/xv6-public/syscall.c xv6-public_new/xv6-public/syscall.c
--- xv6-public/xv6-public/syscall.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/syscall.c	2021-09-30 17:18:20.000000000 +0530
@@ -0,0 +1,155 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+#include "syscall.h"
+
+// User code makes a system call with INT T_SYSCALL.
+// System call number in %eax.
+// Arguments on the stack, from the user call to the C
+// library system call function. The saved user %esp points
+// to a saved program counter, and then the first argument.
+
+// Fetch the int at addr from the current process.
+int
+fetchint(uint addr, int *ip)
+{
+  struct proc *curproc = myproc();
+
+  if(addr >= curproc->sz || addr+4 > curproc->sz)
+    return -1;
+  *ip = *(int*)(addr);
+  return 0;
+}
+
+// Fetch the nul-terminated string at addr from the current process.
+// Doesn't actually copy the string - just sets *pp to point at it.
+// Returns length of string, not including nul.
+int
+fetchstr(uint addr, char **pp)
+{
+  char *s, *ep;
+  struct proc *curproc = myproc();
+
+  if(addr >= curproc->sz)
+    return -1;
+  *pp = (char*)addr;
+  ep = (char*)curproc->sz;
+  for(s = *pp; s < ep; s++){
+    if(*s == 0)
+      return s - *pp;
+  }
+  return -1;
+}
+
+// Fetch the nth 32-bit system call argument.
+int
+argint(int n, int *ip)
+{
+  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
+}
+
+// Fetch the nth word-sized system call argument as a pointer
+// to a block of memory of size bytes.  Check that the pointer
+// lies within the process address space.
+int
+argptr(int n, char **pp, int size)
+{
+  int i;
+  struct proc *curproc = myproc();
+ 
+  if(argint(n, &i) < 0)
+    return -1;
+  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
+    return -1;
+  *pp = (char*)i;
+  return 0;
+}
+
+// Fetch the nth word-sized system call argument as a string pointer.
+// Check that the pointer is valid and the string is nul-terminated.
+// (There is no shared writable memory, so the string can't change
+// between this check and being used by the kernel.)
+int
+argstr(int n, char **pp)
+{
+  int addr;
+  if(argint(n, &addr) < 0)
+    return -1;
+  return fetchstr(addr, pp);
+}
+
+extern int sys_chdir(void);
+extern int sys_close(void);
+extern int sys_dup(void);
+extern int sys_exec(void);
+extern int sys_exit(void);
+extern int sys_fork(void);
+extern int sys_fstat(void);
+extern int sys_getpid(void);
+extern int sys_kill(void);
+extern int sys_link(void);
+extern int sys_mkdir(void);
+extern int sys_mknod(void);
+extern int sys_open(void);
+extern int sys_pipe(void);
+extern int sys_read(void);
+extern int sys_sbrk(void);
+extern int sys_sleep(void);
+extern int sys_unlink(void);
+extern int sys_wait(void);
+extern int sys_write(void);
+extern int sys_uptime(void);
+extern int sys_draw(void);
+extern int sys_cps(void);
+extern int sys_yield(void);
+extern int sys_wait2(void);
+extern int sys_set_prio(void);
+
+static int (*syscalls[])(void) = {
+[SYS_fork]    sys_fork,
+[SYS_exit]    sys_exit,
+[SYS_wait]    sys_wait,
+[SYS_pipe]    sys_pipe,
+[SYS_read]    sys_read,
+[SYS_kill]    sys_kill,
+[SYS_exec]    sys_exec,
+[SYS_fstat]   sys_fstat,
+[SYS_chdir]   sys_chdir,
+[SYS_dup]     sys_dup,
+[SYS_getpid]  sys_getpid,
+[SYS_sbrk]    sys_sbrk,
+[SYS_sleep]   sys_sleep,
+[SYS_uptime]  sys_uptime,
+[SYS_open]    sys_open,
+[SYS_write]   sys_write,
+[SYS_mknod]   sys_mknod,
+[SYS_unlink]  sys_unlink,
+[SYS_link]    sys_link,
+[SYS_mkdir]   sys_mkdir,
+[SYS_close]   sys_close,
+[SYS_draw]    sys_draw,
+[SYS_cps]     sys_cps,
+[SYS_yield]   sys_yield,
+[SYS_wait2]   sys_wait2,
+[SYS_set_prio] sys_set_prio,
+};
+
+void
+syscall(void)
+{
+  int num;
+  struct proc *curproc = myproc();
+
+  num = curproc->tf->eax;
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+    curproc->tf->eax = syscalls[num]();
+  } else {
+    cprintf("%d %s: unknown sys call %d\n",
+            curproc->pid, curproc->name, num);
+    curproc->tf->eax = -1;
+  }
+}
diff -ruN xv6-public/xv6-public/syscall.d xv6-public_new/xv6-public/syscall.d
--- xv6-public/xv6-public/syscall.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/syscall.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+syscall.o: syscall.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h syscall.h
diff -ruN xv6-public/xv6-public/syscall.h xv6-public_new/xv6-public/syscall.h
--- xv6-public/xv6-public/syscall.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/syscall.h	2021-09-30 17:16:58.000000000 +0530
@@ -0,0 +1,27 @@
+// System call numbers
+#define SYS_fork    1
+#define SYS_exit    2
+#define SYS_wait    3
+#define SYS_pipe    4
+#define SYS_read    5
+#define SYS_kill    6
+#define SYS_exec    7
+#define SYS_fstat   8
+#define SYS_chdir   9
+#define SYS_dup    10
+#define SYS_getpid 11
+#define SYS_sbrk   12
+#define SYS_sleep  13
+#define SYS_uptime 14
+#define SYS_open   15
+#define SYS_write  16
+#define SYS_mknod  17
+#define SYS_unlink 18
+#define SYS_link   19
+#define SYS_mkdir  20
+#define SYS_close  21
+#define SYS_draw   22
+#define SYS_cps    23
+#define SYS_yield  24
+#define SYS_wait2  25
+#define SYS_set_prio 26
Binary files xv6-public/xv6-public/syscall.o and xv6-public_new/xv6-public/syscall.o differ
diff -ruN xv6-public/xv6-public/sysfile.c xv6-public_new/xv6-public/sysfile.c
--- xv6-public/xv6-public/sysfile.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sysfile.c	2021-09-30 20:47:38.000000000 +0530
@@ -0,0 +1,445 @@
+//
+// File-system system calls.
+// Mostly argument checking, since we don't trust
+// user code, and calls into file.c and fs.c.
+//
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "stat.h"
+#include "mmu.h"
+#include "proc.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "file.h"
+#include "fcntl.h"
+
+// Fetch the nth word-sized system call argument as a file descriptor
+// and return both the descriptor and the corresponding struct file.
+static int
+argfd(int n, int *pfd, struct file **pf)
+{
+  int fd;
+  struct file *f;
+
+  if(argint(n, &fd) < 0)
+    return -1;
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+    return -1;
+  if(pfd)
+    *pfd = fd;
+  if(pf)
+    *pf = f;
+  return 0;
+}
+
+// Allocate a file descriptor for the given file.
+// Takes over file reference from caller on success.
+static int
+fdalloc(struct file *f)
+{
+  int fd;
+  struct proc *curproc = myproc();
+
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd] == 0){
+      curproc->ofile[fd] = f;
+      return fd;
+    }
+  }
+  return -1;
+}
+
+int
+sys_dup(void)
+{
+  struct file *f;
+  int fd;
+
+  if(argfd(0, 0, &f) < 0)
+    return -1;
+  if((fd=fdalloc(f)) < 0)
+    return -1;
+  filedup(f);
+  return fd;
+}
+
+int
+sys_read(void)
+{
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+    return -1;
+  return fileread(f, p, n);
+}
+
+int
+sys_write(void)
+{
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+    return -1;
+  return filewrite(f, p, n);
+}
+
+int
+sys_close(void)
+{
+  int fd;
+  struct file *f;
+
+  if(argfd(0, &fd, &f) < 0)
+    return -1;
+  myproc()->ofile[fd] = 0;
+  fileclose(f);
+  return 0;
+}
+
+int
+sys_fstat(void)
+{
+  struct file *f;
+  struct stat *st;
+
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+    return -1;
+  return filestat(f, st);
+}
+
+// Create the path new as a link to the same inode as old.
+int
+sys_link(void)
+{
+  char name[DIRSIZ], *new, *old;
+  struct inode *dp, *ip;
+
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+    return -1;
+
+  begin_op();
+  if((ip = namei(old)) == 0){
+    end_op();
+    return -1;
+  }
+
+  ilock(ip);
+  if(ip->type == T_DIR){
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+
+  ip->nlink++;
+  iupdate(ip);
+  iunlock(ip);
+
+  if((dp = nameiparent(new, name)) == 0)
+    goto bad;
+  ilock(dp);
+  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+    iunlockput(dp);
+    goto bad;
+  }
+  iunlockput(dp);
+  iput(ip);
+
+  end_op();
+
+  return 0;
+
+bad:
+  ilock(ip);
+  ip->nlink--;
+  iupdate(ip);
+  iunlockput(ip);
+  end_op();
+  return -1;
+}
+
+// Is the directory dp empty except for "." and ".." ?
+static int
+isdirempty(struct inode *dp)
+{
+  int off;
+  struct dirent de;
+
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("isdirempty: readi");
+    if(de.inum != 0)
+      return 0;
+  }
+  return 1;
+}
+
+//PAGEBREAK!
+int
+sys_unlink(void)
+{
+  struct inode *ip, *dp;
+  struct dirent de;
+  char name[DIRSIZ], *path;
+  uint off;
+
+  if(argstr(0, &path) < 0)
+    return -1;
+
+  begin_op();
+  if((dp = nameiparent(path, name)) == 0){
+    end_op();
+    return -1;
+  }
+
+  ilock(dp);
+
+  // Cannot unlink "." or "..".
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+    goto bad;
+
+  if((ip = dirlookup(dp, name, &off)) == 0)
+    goto bad;
+  ilock(ip);
+
+  if(ip->nlink < 1)
+    panic("unlink: nlink < 1");
+  if(ip->type == T_DIR && !isdirempty(ip)){
+    iunlockput(ip);
+    goto bad;
+  }
+
+  memset(&de, 0, sizeof(de));
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+    panic("unlink: writei");
+  if(ip->type == T_DIR){
+    dp->nlink--;
+    iupdate(dp);
+  }
+  iunlockput(dp);
+
+  ip->nlink--;
+  iupdate(ip);
+  iunlockput(ip);
+
+  end_op();
+
+  return 0;
+
+bad:
+  iunlockput(dp);
+  end_op();
+  return -1;
+}
+
+static struct inode*
+create(char *path, short type, short major, short minor)
+{
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+    return 0;
+  ilock(dp);
+
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    iunlockput(dp);
+    ilock(ip);
+    if(type == T_FILE && ip->type == T_FILE)
+      return ip;
+    iunlockput(ip);
+    return 0;
+  }
+
+  if((ip = ialloc(dp->dev, type)) == 0)
+    panic("create: ialloc");
+
+  ilock(ip);
+  ip->major = major;
+  ip->minor = minor;
+  ip->nlink = 1;
+  iupdate(ip);
+
+  if(type == T_DIR){  // Create . and .. entries.
+    dp->nlink++;  // for ".."
+    iupdate(dp);
+    // No ip->nlink++ for ".": avoid cyclic ref count.
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+      panic("create dots");
+  }
+
+  if(dirlink(dp, name, ip->inum) < 0)
+    panic("create: dirlink");
+
+  iunlockput(dp);
+
+  return ip;
+}
+
+int
+sys_open(void)
+{
+  char *path;
+  int fd, omode;
+  struct file *f;
+  struct inode *ip;
+
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+    return -1;
+
+  begin_op();
+
+  if(omode & O_CREATE){
+    ip = create(path, T_FILE, 0, 0);
+    if(ip == 0){
+      end_op();
+      return -1;
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+      end_op();
+      return -1;
+    }
+    ilock(ip);
+    if(ip->type == T_DIR && omode != O_RDONLY){
+      iunlockput(ip);
+      end_op();
+      return -1;
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+    if(f)
+      fileclose(f);
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+  end_op();
+
+  f->type = FD_INODE;
+  f->ip = ip;
+  f->off = 0;
+  f->readable = !(omode & O_WRONLY);
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+  return fd;
+}
+
+int
+sys_mkdir(void)
+{
+  char *path;
+  struct inode *ip;
+
+  begin_op();
+  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+  end_op();
+  return 0;
+}
+
+int
+sys_mknod(void)
+{
+  struct inode *ip;
+  char *path;
+  int major, minor;
+
+  begin_op();
+  if((argstr(0, &path)) < 0 ||
+     argint(1, &major) < 0 ||
+     argint(2, &minor) < 0 ||
+     (ip = create(path, T_DEV, major, minor)) == 0){
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+  end_op();
+  return 0;
+}
+
+int
+sys_chdir(void)
+{
+  char *path;
+  struct inode *ip;
+  struct proc *curproc = myproc();
+  
+  begin_op();
+  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+    end_op();
+    return -1;
+  }
+  ilock(ip);
+  if(ip->type != T_DIR){
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+  iput(curproc->cwd);
+  end_op();
+  curproc->cwd = ip;
+  return 0;
+}
+
+int
+sys_exec(void)
+{
+  char *path, *argv[MAXARG];
+  int i;
+  uint uargv, uarg;
+
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+    return -1;
+  }
+  memset(argv, 0, sizeof(argv));
+  for(i=0;; i++){
+    if(i >= NELEM(argv))
+      return -1;
+    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+      return -1;
+    if(uarg == 0){
+      argv[i] = 0;
+      break;
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+      return -1;
+  }
+  return exec(path, argv);
+  
+}
+
+int
+sys_pipe(void)
+{
+  int *fd;
+  struct file *rf, *wf;
+  int fd0, fd1;
+
+  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+    return -1;
+  if(pipealloc(&rf, &wf) < 0)
+    return -1;
+  fd0 = -1;
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+    if(fd0 >= 0)
+      myproc()->ofile[fd0] = 0;
+    fileclose(rf);
+    fileclose(wf);
+    return -1;
+  }
+  fd[0] = fd0;
+  fd[1] = fd1;
+  return 0;
+}
diff -ruN xv6-public/xv6-public/sysfile.d xv6-public_new/xv6-public/sysfile.d
--- xv6-public/xv6-public/sysfile.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sysfile.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+sysfile.o: sysfile.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ stat.h mmu.h proc.h fs.h spinlock.h sleeplock.h file.h fcntl.h
Binary files xv6-public/xv6-public/sysfile.o and xv6-public_new/xv6-public/sysfile.o differ
diff -ruN xv6-public/xv6-public/sysproc.c xv6-public_new/xv6-public/sysproc.c
--- xv6-public/xv6-public/sysproc.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sysproc.c	2021-09-30 15:35:36.000000000 +0530
@@ -0,0 +1,157 @@
+#include "types.h"
+#include "x86.h"
+#include "defs.h"
+#include "date.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+
+
+int
+sys_fork(void)
+{
+  return fork();
+}
+
+int
+sys_exit(void)
+{
+  exit();
+  return 0;  // not reached
+}
+
+int
+sys_wait(void)
+{
+  return wait();
+}
+
+int
+sys_kill(void)
+{
+  int pid;
+
+  if(argint(0, &pid) < 0)
+    return -1;
+  return kill(pid);
+}
+
+
+int
+sys_getpid(void)
+{
+  return myproc()->pid;
+}
+
+int
+sys_sbrk(void)
+{
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  addr = myproc()->sz;
+  if(growproc(n) < 0)
+    return -1;
+  return addr;
+}
+
+int
+sys_sleep(void)
+{
+  int n;
+  uint ticks0;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  acquire(&tickslock);
+  ticks0 = ticks;
+  while(ticks - ticks0 < n){
+    if(myproc()->killed){
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+  }
+  release(&tickslock);
+  return 0;
+}
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+  uint xticks;
+
+  acquire(&tickslock);
+  xticks = ticks;
+  release(&tickslock);
+  return xticks;
+}
+
+int sys_draw(void)
+{
+  char *buffer;
+  int size;
+  char *wolf = "               \t\t\t,ood8888booo,\n\
+                              ,od8           8bo,\n\
+                           ,od                   bo,\n\
+                         ,d8                       8b,\n\
+                        ,o                           o,    ,a8b\n\
+                       ,8                             8,,od8  8\n\
+                       8'                             d8'     8b\n\
+                       8                           d8'ba     aP'\n\
+                       Y,                       o8'         aP'\n\
+                        Y8,                      YaaaP'    ba\n\
+                         Y8o                   Y8'         88\n\
+                          `Y8               ,8\"           `P\n\
+                            Y8o        ,d8P'              ba\n\
+                       ooood8888888P\"\"\"'                  P'\n\
+                    ,od                                  8\n\
+                 ,dP     o88o                           o'\n\
+                ,dP          8                          8\n\
+               ,d'   oo       8                       ,8\n\
+               $    d$\"8      8           Y    Y  o   8\n\
+              d    d  d8    od  \"\"boooooooob   d\"\" 8   8\n\
+              $    8  d   ood' ,   8        b  8   '8  b\n\
+              $   $  8  8     d  d8        `b  d    '8  b\n\
+               $  $ 8   b    Y  d8          8 ,P     '8  b\n\
+               `$$  Yb  b     8b 8b         8 8,      '8  o,\n\
+                    `Y  b      8o  $$o      d  b        b   $o\n\
+                     8   '$     8$,,$\"      $   $o      '$o$$\n\
+                      $o$$P\"                 $$o$\n\n";
+  // Fetch the 1st 32 bit call argument and assign it to the variable size i.e.the max-size of the buffer
+  // Return -1 if an invalid address is accessed
+  if (argint(1, &size) == -1)
+  {
+    return -1;
+  }
+  // Fetch the 0th word-sized system call argument as a pointer
+  // to a block of memory of size bytes.Check that the pointer
+  // lies within the process address space if it does not then return -1.
+  if (argptr(0, (char **)&buffer, size) == -1)
+  {
+    return -1;
+  }
+  //Find the size of the wolfie picture;
+  int wolfsize = 0;
+  while (wolf[wolfsize] != '\0')
+  {
+    wolfsize++;
+  }
+  if (wolfsize > size)
+  {
+    //If the size of wolfie picture is greater than max size of the buffer return -1
+    return -1;
+  }
+  //copy the wolfie picture to the buffer
+  for (int i = 0; i < wolfsize; i++)
+  {
+    buffer[i] = wolf[i];
+  }
+  //return the size of wolfie pictue
+  return wolfsize;
+}
\ No newline at end of file
diff -ruN xv6-public/xv6-public/sysproc.d xv6-public_new/xv6-public/sysproc.d
--- xv6-public/xv6-public/sysproc.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/sysproc.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+sysproc.o: sysproc.c /usr/include/stdc-predef.h types.h x86.h defs.h \
+ date.h param.h memlayout.h mmu.h proc.h
Binary files xv6-public/xv6-public/sysproc.o and xv6-public_new/xv6-public/sysproc.o differ
diff -ruN xv6-public/xv6-public/toc.ftr xv6-public_new/xv6-public/toc.ftr
--- xv6-public/xv6-public/toc.ftr	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/toc.ftr	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,13 @@
+
+
+The source listing is preceded by a cross-reference that lists every defined 
+constant, struct, global variable, and function in xv6.  Each entry gives,
+on the same line as the name, the line number (or, in a few cases, numbers)
+where the name is defined.  Successive lines in an entry list the line
+numbers where the name is used.  For example, this entry:
+
+    swtch 2658
+        0374 2428 2466 2657 2658
+
+indicates that swtch is defined on line 2658 and is mentioned on five lines
+on sheets 03, 24, and 26.
diff -ruN xv6-public/xv6-public/toc.hdr xv6-public_new/xv6-public/toc.hdr
--- xv6-public/xv6-public/toc.hdr	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/toc.hdr	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,6 @@
+The numbers to the left of the file names in the table are sheet numbers.
+The source code has been printed in a double column format with fifty
+lines per column, giving one hundred lines per sheet (or page).
+Thus there is a convenient relationship between line numbers and sheet numbers.
+
+
diff -ruN xv6-public/xv6-public/trap.c xv6-public_new/xv6-public/trap.c
--- xv6-public/xv6-public/trap.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/trap.c	2021-09-30 22:21:14.000000000 +0530
@@ -0,0 +1,143 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+#include "traps.h"
+#include "spinlock.h"
+
+// Interrupt descriptor table (shared by all CPUs).
+struct gatedesc idt[256];
+extern uint vectors[];  // in vectors.S: array of 256 entry pointers
+struct spinlock tickslock;
+uint ticks;
+void updatestatistics();
+extern int inctickcounter(void);
+extern void decpriority(void);
+
+void
+tvinit(void)
+{
+  int i;
+
+  for(i = 0; i < 256; i++)
+    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+
+  initlock(&tickslock, "time");
+}
+
+void
+idtinit(void)
+{
+  lidt(idt, sizeof(idt));
+}
+
+//PAGEBREAK: 41
+void
+trap(struct trapframe *tf)
+{
+  if(tf->trapno == T_SYSCALL){
+    if(myproc()->killed)
+      exit();
+    myproc()->tf = tf;
+    syscall();
+    if(myproc()->killed)
+      exit();
+    return;
+  }
+
+  switch(tf->trapno){
+  case T_IRQ0 + IRQ_TIMER:
+    if(cpuid() == 0){
+      acquire(&tickslock);
+      ticks++;
+      updatestatistics(); //will update proc statistic every clock tick
+      wakeup(&ticks);
+      release(&tickslock);
+    }
+    lapiceoi();
+    break;
+  case T_IRQ0 + IRQ_IDE:
+    ideintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + IRQ_IDE+1:
+    // Bochs generates spurious IDE1 interrupts.
+    break;
+  case T_IRQ0 + IRQ_KBD:
+    kbdintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + IRQ_COM1:
+    uartintr();
+    lapiceoi();
+    break;
+  case T_IRQ0 + 7:
+  case T_IRQ0 + IRQ_SPURIOUS:
+    cprintf("cpu%d: spurious interrupt at %x:%x\n",
+            cpuid(), tf->cs, tf->eip);
+    lapiceoi();
+    break;
+
+  //PAGEBREAK: 13
+  default:
+    if(myproc() == 0 || (tf->cs&3) == 0){
+      // In kernel, it must be our mistake.
+      cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+              tf->trapno, cpuid(), tf->eip, rcr2());
+      panic("trap");
+    }
+    // In user space, assume process misbehaved.
+    cprintf("pid %d %s: trap %d err %d on cpu %d "
+            "eip 0x%x addr 0x%x--kill proc\n",
+            myproc()->pid, myproc()->name, tf->trapno,
+            tf->err, cpuid(), tf->eip, rcr2());
+    myproc()->killed = 1;
+  }
+
+  // Force process exit if it has been killed and is in user space.
+  // (If it is still executing in the kernel, let it keep running
+  // until it gets to the regular system call return.)
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+    exit();
+
+#ifdef DEFAULT
+  // Round Robin with time quanta = QUANTA (default = 5)
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if(myproc() && myproc()->state == RUNNING &&
+     tf->trapno == T_IRQ0+IRQ_TIMER && inctickcounter() == QUANTA){
+    myproc()->tickcounter = 0;
+    yield();
+  }
+#ifdef FCFS
+// do not yield
+#ifdef DML
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if(myproc() && myproc()->state == RUNNING && 
+    tf->trapno == T_IRQ0+IRQ_TIMER && inctickcounter() == QUANTA) {
+    myproc()->tickcounter = 0;
+    decpriority();
+    yield();
+  }
+#ifdef SML
+  // Force process to give up CPU on clock tick.
+  // If interrupts were on while locks held, would need to check nlock.
+  if(myproc() && myproc()->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER && inctickcounter() == QUANTA) {
+    myproc()->tickcounter = 0;
+    yield();
+  }
+#endif
+#endif
+#endif
+#endif
+
+
+  // Check if the process has been killed since we yielded
+  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
+    exit();
+}
diff -ruN xv6-public/xv6-public/trap.d xv6-public_new/xv6-public/trap.d
--- xv6-public/xv6-public/trap.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/trap.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+trap.o: trap.c /usr/include/stdc-predef.h types.h defs.h param.h \
+ memlayout.h mmu.h proc.h x86.h traps.h spinlock.h
Binary files xv6-public/xv6-public/trap.o and xv6-public_new/xv6-public/trap.o differ
diff -ruN xv6-public/xv6-public/trapasm.S xv6-public_new/xv6-public/trapasm.S
--- xv6-public/xv6-public/trapasm.S	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/trapasm.S	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,32 @@
+#include "mmu.h"
+
+  # vectors.S sends all traps here.
+.globl alltraps
+alltraps:
+  # Build trap frame.
+  pushl %ds
+  pushl %es
+  pushl %fs
+  pushl %gs
+  pushal
+  
+  # Set up data segments.
+  movw $(SEG_KDATA<<3), %ax
+  movw %ax, %ds
+  movw %ax, %es
+
+  # Call trap(tf), where tf=%esp
+  pushl %esp
+  call trap
+  addl $4, %esp
+
+  # Return falls through to trapret...
+.globl trapret
+trapret:
+  popal
+  popl %gs
+  popl %fs
+  popl %es
+  popl %ds
+  addl $0x8, %esp  # trapno and errcode
+  iret
Binary files xv6-public/xv6-public/trapasm.o and xv6-public_new/xv6-public/trapasm.o differ
diff -ruN xv6-public/xv6-public/traps.h xv6-public_new/xv6-public/traps.h
--- xv6-public/xv6-public/traps.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/traps.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,38 @@
+// x86 trap and interrupt constants.
+
+// Processor-defined:
+#define T_DIVIDE         0      // divide error
+#define T_DEBUG          1      // debug exception
+#define T_NMI            2      // non-maskable interrupt
+#define T_BRKPT          3      // breakpoint
+#define T_OFLOW          4      // overflow
+#define T_BOUND          5      // bounds check
+#define T_ILLOP          6      // illegal opcode
+#define T_DEVICE         7      // device not available
+#define T_DBLFLT         8      // double fault
+// #define T_COPROC      9      // reserved (not used since 486)
+#define T_TSS           10      // invalid task switch segment
+#define T_SEGNP         11      // segment not present
+#define T_STACK         12      // stack exception
+#define T_GPFLT         13      // general protection fault
+#define T_PGFLT         14      // page fault
+// #define T_RES        15      // reserved
+#define T_FPERR         16      // floating point error
+#define T_ALIGN         17      // aligment check
+#define T_MCHK          18      // machine check
+#define T_SIMDERR       19      // SIMD floating point error
+
+// These are arbitrarily chosen, but with care not to overlap
+// processor defined exceptions or interrupt vectors.
+#define T_SYSCALL       64      // system call
+#define T_DEFAULT      500      // catchall
+
+#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
+
+#define IRQ_TIMER        0
+#define IRQ_KBD          1
+#define IRQ_COM1         4
+#define IRQ_IDE         14
+#define IRQ_ERROR       19
+#define IRQ_SPURIOUS    31
+
diff -ruN xv6-public/xv6-public/types.h xv6-public_new/xv6-public/types.h
--- xv6-public/xv6-public/types.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/types.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,4 @@
+typedef unsigned int   uint;
+typedef unsigned short ushort;
+typedef unsigned char  uchar;
+typedef uint pde_t;
diff -ruN xv6-public/xv6-public/uart.c xv6-public_new/xv6-public/uart.c
--- xv6-public/xv6-public/uart.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/uart.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,77 @@
+// Intel 8250 serial port (UART).
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "traps.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "file.h"
+#include "mmu.h"
+#include "proc.h"
+#include "x86.h"
+
+#define COM1    0x3f8
+
+static int uart;    // is there a uart?
+
+void
+uartinit(void)
+{
+  char *p;
+
+  // Turn off the FIFO
+  outb(COM1+2, 0);
+
+  // 9600 baud, 8 data bits, 1 stop bit, parity off.
+  outb(COM1+3, 0x80);    // Unlock divisor
+  outb(COM1+0, 115200/9600);
+  outb(COM1+1, 0);
+  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
+  outb(COM1+4, 0);
+  outb(COM1+1, 0x01);    // Enable receive interrupts.
+
+  // If status is 0xFF, no serial port.
+  if(inb(COM1+5) == 0xFF)
+    return;
+  uart = 1;
+
+  // Acknowledge pre-existing interrupt conditions;
+  // enable interrupts.
+  inb(COM1+2);
+  inb(COM1+0);
+  ioapicenable(IRQ_COM1, 0);
+
+  // Announce that we're here.
+  for(p="xv6...\n"; *p; p++)
+    uartputc(*p);
+}
+
+void
+uartputc(int c)
+{
+  int i;
+
+  if(!uart)
+    return;
+  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
+    microdelay(10);
+  outb(COM1+0, c);
+}
+
+static int
+uartgetc(void)
+{
+  if(!uart)
+    return -1;
+  if(!(inb(COM1+5) & 0x01))
+    return -1;
+  return inb(COM1+0);
+}
+
+void
+uartintr(void)
+{
+  consoleintr(uartgetc);
+}
diff -ruN xv6-public/xv6-public/uart.d xv6-public_new/xv6-public/uart.d
--- xv6-public/xv6-public/uart.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/uart.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+uart.o: uart.c /usr/include/stdc-predef.h types.h defs.h param.h traps.h \
+ spinlock.h sleeplock.h fs.h file.h mmu.h proc.h x86.h
Binary files xv6-public/xv6-public/uart.o and xv6-public_new/xv6-public/uart.o differ
diff -ruN xv6-public/xv6-public/ulib.c xv6-public_new/xv6-public/ulib.c
--- xv6-public/xv6-public/ulib.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ulib.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,106 @@
+#include "types.h"
+#include "stat.h"
+#include "fcntl.h"
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    ;
+  return os;
+}
+
+int
+strcmp(const char *p, const char *q)
+{
+  while(*p && *p == *q)
+    p++, q++;
+  return (uchar)*p - (uchar)*q;
+}
+
+uint
+strlen(const char *s)
+{
+  int n;
+
+  for(n = 0; s[n]; n++)
+    ;
+  return n;
+}
+
+void*
+memset(void *dst, int c, uint n)
+{
+  stosb(dst, c, n);
+  return dst;
+}
+
+char*
+strchr(const char *s, char c)
+{
+  for(; *s; s++)
+    if(*s == c)
+      return (char*)s;
+  return 0;
+}
+
+char*
+gets(char *buf, int max)
+{
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+      break;
+  }
+  buf[i] = '\0';
+  return buf;
+}
+
+int
+stat(const char *n, struct stat *st)
+{
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+  if(fd < 0)
+    return -1;
+  r = fstat(fd, st);
+  close(fd);
+  return r;
+}
+
+int
+atoi(const char *s)
+{
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    n = n*10 + *s++ - '0';
+  return n;
+}
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  while(n-- > 0)
+    *dst++ = *src++;
+  return vdst;
+}
diff -ruN xv6-public/xv6-public/ulib.d xv6-public_new/xv6-public/ulib.d
--- xv6-public/xv6-public/ulib.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/ulib.d	2021-09-30 23:15:12.000000000 +0530
@@ -0,0 +1,2 @@
+ulib.o: ulib.c /usr/include/stdc-predef.h types.h stat.h fcntl.h user.h \
+ x86.h
Binary files xv6-public/xv6-public/ulib.o and xv6-public_new/xv6-public/ulib.o differ
diff -ruN xv6-public/xv6-public/umalloc.c xv6-public_new/xv6-public/umalloc.c
--- xv6-public/xv6-public/umalloc.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/umalloc.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,90 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "param.h"
+
+// Memory allocator by Kernighan and Ritchie,
+// The C programming Language, 2nd ed.  Section 8.7.
+
+typedef long Align;
+
+union header {
+  struct {
+    union header *ptr;
+    uint size;
+  } s;
+  Align x;
+};
+
+typedef union header Header;
+
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+    bp->s.ptr = p->s.ptr->s.ptr;
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+    p->s.ptr = bp->s.ptr;
+  } else
+    p->s.ptr = bp;
+  freep = p;
+}
+
+static Header*
+morecore(uint nu)
+{
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+    nu = 4096;
+  p = sbrk(nu * sizeof(Header));
+  if(p == (char*)-1)
+    return 0;
+  hp = (Header*)p;
+  hp->s.size = nu;
+  free((void*)(hp + 1));
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+  if((prevp = freep) == 0){
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    if(p->s.size >= nunits){
+      if(p->s.size == nunits)
+        prevp->s.ptr = p->s.ptr;
+      else {
+        p->s.size -= nunits;
+        p += p->s.size;
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+      if((p = morecore(nunits)) == 0)
+        return 0;
+  }
+}
diff -ruN xv6-public/xv6-public/umalloc.d xv6-public_new/xv6-public/umalloc.d
--- xv6-public/xv6-public/umalloc.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/umalloc.d	2021-09-30 23:15:12.000000000 +0530
@@ -0,0 +1,2 @@
+umalloc.o: umalloc.c /usr/include/stdc-predef.h types.h stat.h user.h \
+ param.h
Binary files xv6-public/xv6-public/umalloc.o and xv6-public_new/xv6-public/umalloc.o differ
diff -ruN xv6-public/xv6-public/user.h xv6-public_new/xv6-public/user.h
--- xv6-public/xv6-public/user.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/user.h	2021-09-30 17:22:02.000000000 +0530
@@ -0,0 +1,44 @@
+struct stat;
+struct rtcdate;
+
+// system calls
+int yield(void);
+int cps(void);
+int draw(void *buf, uint size);
+int fork(void);
+int exit(void) __attribute__((noreturn));
+int wait(void);
+int pipe(int*);
+int write(int, const void*, int);
+int read(int, void*, int);
+int close(int);
+int kill(int);
+int exec(char*, char**);
+int open(const char*, int);
+int mknod(const char*, short, short);
+int unlink(const char*);
+int fstat(int fd, struct stat*);
+int link(const char*, const char*);
+int mkdir(const char*);
+int chdir(const char*);
+int dup(int);
+int getpid(void);
+char* sbrk(int);
+int sleep(int);
+int uptime(void);
+int wait2(int*, int*, int*);
+int set_prio(int);
+
+// ulib.c
+int stat(const char*, struct stat*);
+char* strcpy(char*, const char*);
+void *memmove(void*, const void*, int);
+char* strchr(const char*, char c);
+int strcmp(const char*, const char*);
+void printf(int, const char*, ...);
+char* gets(char*, int max);
+uint strlen(const char*);
+void* memset(void*, int, uint);
+void* malloc(uint);
+void free(void*);
+int atoi(const char*);
\ No newline at end of file
diff -ruN xv6-public/xv6-public/usertests.asm xv6-public_new/xv6-public/usertests.asm
--- xv6-public/xv6-public/usertests.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/usertests.asm	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,7643 @@
+
+_usertests:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <iputtest>:
+int stdout = 1;
+
+// does chdir() call iput(p->cwd) in a transaction?
+void
+iputtest(void)
+{
+       0:	f3 0f 1e fb          	endbr32 
+       4:	55                   	push   %ebp
+       5:	89 e5                	mov    %esp,%ebp
+       7:	83 ec 08             	sub    $0x8,%esp
+  printf(stdout, "iput test\n");
+       a:	a1 70 65 00 00       	mov    0x6570,%eax
+       f:	83 ec 08             	sub    $0x8,%esp
+      12:	68 32 46 00 00       	push   $0x4632
+      17:	50                   	push   %eax
+      18:	e8 36 42 00 00       	call   4253 <printf>
+      1d:	83 c4 10             	add    $0x10,%esp
+
+  if(mkdir("iputdir") < 0){
+      20:	83 ec 0c             	sub    $0xc,%esp
+      23:	68 3d 46 00 00       	push   $0x463d
+      28:	e8 ea 40 00 00       	call   4117 <mkdir>
+      2d:	83 c4 10             	add    $0x10,%esp
+      30:	85 c0                	test   %eax,%eax
+      32:	79 1b                	jns    4f <iputtest+0x4f>
+    printf(stdout, "mkdir failed\n");
+      34:	a1 70 65 00 00       	mov    0x6570,%eax
+      39:	83 ec 08             	sub    $0x8,%esp
+      3c:	68 45 46 00 00       	push   $0x4645
+      41:	50                   	push   %eax
+      42:	e8 0c 42 00 00       	call   4253 <printf>
+      47:	83 c4 10             	add    $0x10,%esp
+    exit();
+      4a:	e8 60 40 00 00       	call   40af <exit>
+  }
+  if(chdir("iputdir") < 0){
+      4f:	83 ec 0c             	sub    $0xc,%esp
+      52:	68 3d 46 00 00       	push   $0x463d
+      57:	e8 c3 40 00 00       	call   411f <chdir>
+      5c:	83 c4 10             	add    $0x10,%esp
+      5f:	85 c0                	test   %eax,%eax
+      61:	79 1b                	jns    7e <iputtest+0x7e>
+    printf(stdout, "chdir iputdir failed\n");
+      63:	a1 70 65 00 00       	mov    0x6570,%eax
+      68:	83 ec 08             	sub    $0x8,%esp
+      6b:	68 53 46 00 00       	push   $0x4653
+      70:	50                   	push   %eax
+      71:	e8 dd 41 00 00       	call   4253 <printf>
+      76:	83 c4 10             	add    $0x10,%esp
+    exit();
+      79:	e8 31 40 00 00       	call   40af <exit>
+  }
+  if(unlink("../iputdir") < 0){
+      7e:	83 ec 0c             	sub    $0xc,%esp
+      81:	68 69 46 00 00       	push   $0x4669
+      86:	e8 74 40 00 00       	call   40ff <unlink>
+      8b:	83 c4 10             	add    $0x10,%esp
+      8e:	85 c0                	test   %eax,%eax
+      90:	79 1b                	jns    ad <iputtest+0xad>
+    printf(stdout, "unlink ../iputdir failed\n");
+      92:	a1 70 65 00 00       	mov    0x6570,%eax
+      97:	83 ec 08             	sub    $0x8,%esp
+      9a:	68 74 46 00 00       	push   $0x4674
+      9f:	50                   	push   %eax
+      a0:	e8 ae 41 00 00       	call   4253 <printf>
+      a5:	83 c4 10             	add    $0x10,%esp
+    exit();
+      a8:	e8 02 40 00 00       	call   40af <exit>
+  }
+  if(chdir("/") < 0){
+      ad:	83 ec 0c             	sub    $0xc,%esp
+      b0:	68 8e 46 00 00       	push   $0x468e
+      b5:	e8 65 40 00 00       	call   411f <chdir>
+      ba:	83 c4 10             	add    $0x10,%esp
+      bd:	85 c0                	test   %eax,%eax
+      bf:	79 1b                	jns    dc <iputtest+0xdc>
+    printf(stdout, "chdir / failed\n");
+      c1:	a1 70 65 00 00       	mov    0x6570,%eax
+      c6:	83 ec 08             	sub    $0x8,%esp
+      c9:	68 90 46 00 00       	push   $0x4690
+      ce:	50                   	push   %eax
+      cf:	e8 7f 41 00 00       	call   4253 <printf>
+      d4:	83 c4 10             	add    $0x10,%esp
+    exit();
+      d7:	e8 d3 3f 00 00       	call   40af <exit>
+  }
+  printf(stdout, "iput test ok\n");
+      dc:	a1 70 65 00 00       	mov    0x6570,%eax
+      e1:	83 ec 08             	sub    $0x8,%esp
+      e4:	68 a0 46 00 00       	push   $0x46a0
+      e9:	50                   	push   %eax
+      ea:	e8 64 41 00 00       	call   4253 <printf>
+      ef:	83 c4 10             	add    $0x10,%esp
+}
+      f2:	90                   	nop
+      f3:	c9                   	leave  
+      f4:	c3                   	ret    
+
+000000f5 <exitiputtest>:
+
+// does exit() call iput(p->cwd) in a transaction?
+void
+exitiputtest(void)
+{
+      f5:	f3 0f 1e fb          	endbr32 
+      f9:	55                   	push   %ebp
+      fa:	89 e5                	mov    %esp,%ebp
+      fc:	83 ec 18             	sub    $0x18,%esp
+  int pid;
+
+  printf(stdout, "exitiput test\n");
+      ff:	a1 70 65 00 00       	mov    0x6570,%eax
+     104:	83 ec 08             	sub    $0x8,%esp
+     107:	68 ae 46 00 00       	push   $0x46ae
+     10c:	50                   	push   %eax
+     10d:	e8 41 41 00 00       	call   4253 <printf>
+     112:	83 c4 10             	add    $0x10,%esp
+
+  pid = fork();
+     115:	e8 8d 3f 00 00       	call   40a7 <fork>
+     11a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pid < 0){
+     11d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     121:	79 1b                	jns    13e <exitiputtest+0x49>
+    printf(stdout, "fork failed\n");
+     123:	a1 70 65 00 00       	mov    0x6570,%eax
+     128:	83 ec 08             	sub    $0x8,%esp
+     12b:	68 bd 46 00 00       	push   $0x46bd
+     130:	50                   	push   %eax
+     131:	e8 1d 41 00 00       	call   4253 <printf>
+     136:	83 c4 10             	add    $0x10,%esp
+    exit();
+     139:	e8 71 3f 00 00       	call   40af <exit>
+  }
+  if(pid == 0){
+     13e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     142:	0f 85 92 00 00 00    	jne    1da <exitiputtest+0xe5>
+    if(mkdir("iputdir") < 0){
+     148:	83 ec 0c             	sub    $0xc,%esp
+     14b:	68 3d 46 00 00       	push   $0x463d
+     150:	e8 c2 3f 00 00       	call   4117 <mkdir>
+     155:	83 c4 10             	add    $0x10,%esp
+     158:	85 c0                	test   %eax,%eax
+     15a:	79 1b                	jns    177 <exitiputtest+0x82>
+      printf(stdout, "mkdir failed\n");
+     15c:	a1 70 65 00 00       	mov    0x6570,%eax
+     161:	83 ec 08             	sub    $0x8,%esp
+     164:	68 45 46 00 00       	push   $0x4645
+     169:	50                   	push   %eax
+     16a:	e8 e4 40 00 00       	call   4253 <printf>
+     16f:	83 c4 10             	add    $0x10,%esp
+      exit();
+     172:	e8 38 3f 00 00       	call   40af <exit>
+    }
+    if(chdir("iputdir") < 0){
+     177:	83 ec 0c             	sub    $0xc,%esp
+     17a:	68 3d 46 00 00       	push   $0x463d
+     17f:	e8 9b 3f 00 00       	call   411f <chdir>
+     184:	83 c4 10             	add    $0x10,%esp
+     187:	85 c0                	test   %eax,%eax
+     189:	79 1b                	jns    1a6 <exitiputtest+0xb1>
+      printf(stdout, "child chdir failed\n");
+     18b:	a1 70 65 00 00       	mov    0x6570,%eax
+     190:	83 ec 08             	sub    $0x8,%esp
+     193:	68 ca 46 00 00       	push   $0x46ca
+     198:	50                   	push   %eax
+     199:	e8 b5 40 00 00       	call   4253 <printf>
+     19e:	83 c4 10             	add    $0x10,%esp
+      exit();
+     1a1:	e8 09 3f 00 00       	call   40af <exit>
+    }
+    if(unlink("../iputdir") < 0){
+     1a6:	83 ec 0c             	sub    $0xc,%esp
+     1a9:	68 69 46 00 00       	push   $0x4669
+     1ae:	e8 4c 3f 00 00       	call   40ff <unlink>
+     1b3:	83 c4 10             	add    $0x10,%esp
+     1b6:	85 c0                	test   %eax,%eax
+     1b8:	79 1b                	jns    1d5 <exitiputtest+0xe0>
+      printf(stdout, "unlink ../iputdir failed\n");
+     1ba:	a1 70 65 00 00       	mov    0x6570,%eax
+     1bf:	83 ec 08             	sub    $0x8,%esp
+     1c2:	68 74 46 00 00       	push   $0x4674
+     1c7:	50                   	push   %eax
+     1c8:	e8 86 40 00 00       	call   4253 <printf>
+     1cd:	83 c4 10             	add    $0x10,%esp
+      exit();
+     1d0:	e8 da 3e 00 00       	call   40af <exit>
+    }
+    exit();
+     1d5:	e8 d5 3e 00 00       	call   40af <exit>
+  }
+  wait();
+     1da:	e8 d8 3e 00 00       	call   40b7 <wait>
+  printf(stdout, "exitiput test ok\n");
+     1df:	a1 70 65 00 00       	mov    0x6570,%eax
+     1e4:	83 ec 08             	sub    $0x8,%esp
+     1e7:	68 de 46 00 00       	push   $0x46de
+     1ec:	50                   	push   %eax
+     1ed:	e8 61 40 00 00       	call   4253 <printf>
+     1f2:	83 c4 10             	add    $0x10,%esp
+}
+     1f5:	90                   	nop
+     1f6:	c9                   	leave  
+     1f7:	c3                   	ret    
+
+000001f8 <openiputtest>:
+//      for(i = 0; i < 10000; i++)
+//        yield();
+//    }
+void
+openiputtest(void)
+{
+     1f8:	f3 0f 1e fb          	endbr32 
+     1fc:	55                   	push   %ebp
+     1fd:	89 e5                	mov    %esp,%ebp
+     1ff:	83 ec 18             	sub    $0x18,%esp
+  int pid;
+
+  printf(stdout, "openiput test\n");
+     202:	a1 70 65 00 00       	mov    0x6570,%eax
+     207:	83 ec 08             	sub    $0x8,%esp
+     20a:	68 f0 46 00 00       	push   $0x46f0
+     20f:	50                   	push   %eax
+     210:	e8 3e 40 00 00       	call   4253 <printf>
+     215:	83 c4 10             	add    $0x10,%esp
+  if(mkdir("oidir") < 0){
+     218:	83 ec 0c             	sub    $0xc,%esp
+     21b:	68 ff 46 00 00       	push   $0x46ff
+     220:	e8 f2 3e 00 00       	call   4117 <mkdir>
+     225:	83 c4 10             	add    $0x10,%esp
+     228:	85 c0                	test   %eax,%eax
+     22a:	79 1b                	jns    247 <openiputtest+0x4f>
+    printf(stdout, "mkdir oidir failed\n");
+     22c:	a1 70 65 00 00       	mov    0x6570,%eax
+     231:	83 ec 08             	sub    $0x8,%esp
+     234:	68 05 47 00 00       	push   $0x4705
+     239:	50                   	push   %eax
+     23a:	e8 14 40 00 00       	call   4253 <printf>
+     23f:	83 c4 10             	add    $0x10,%esp
+    exit();
+     242:	e8 68 3e 00 00       	call   40af <exit>
+  }
+  pid = fork();
+     247:	e8 5b 3e 00 00       	call   40a7 <fork>
+     24c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pid < 0){
+     24f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     253:	79 1b                	jns    270 <openiputtest+0x78>
+    printf(stdout, "fork failed\n");
+     255:	a1 70 65 00 00       	mov    0x6570,%eax
+     25a:	83 ec 08             	sub    $0x8,%esp
+     25d:	68 bd 46 00 00       	push   $0x46bd
+     262:	50                   	push   %eax
+     263:	e8 eb 3f 00 00       	call   4253 <printf>
+     268:	83 c4 10             	add    $0x10,%esp
+    exit();
+     26b:	e8 3f 3e 00 00       	call   40af <exit>
+  }
+  if(pid == 0){
+     270:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     274:	75 3b                	jne    2b1 <openiputtest+0xb9>
+    int fd = open("oidir", O_RDWR);
+     276:	83 ec 08             	sub    $0x8,%esp
+     279:	6a 02                	push   $0x2
+     27b:	68 ff 46 00 00       	push   $0x46ff
+     280:	e8 6a 3e 00 00       	call   40ef <open>
+     285:	83 c4 10             	add    $0x10,%esp
+     288:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(fd >= 0){
+     28b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     28f:	78 1b                	js     2ac <openiputtest+0xb4>
+      printf(stdout, "open directory for write succeeded\n");
+     291:	a1 70 65 00 00       	mov    0x6570,%eax
+     296:	83 ec 08             	sub    $0x8,%esp
+     299:	68 1c 47 00 00       	push   $0x471c
+     29e:	50                   	push   %eax
+     29f:	e8 af 3f 00 00       	call   4253 <printf>
+     2a4:	83 c4 10             	add    $0x10,%esp
+      exit();
+     2a7:	e8 03 3e 00 00       	call   40af <exit>
+    }
+    exit();
+     2ac:	e8 fe 3d 00 00       	call   40af <exit>
+  }
+  sleep(1);
+     2b1:	83 ec 0c             	sub    $0xc,%esp
+     2b4:	6a 01                	push   $0x1
+     2b6:	e8 84 3e 00 00       	call   413f <sleep>
+     2bb:	83 c4 10             	add    $0x10,%esp
+  if(unlink("oidir") != 0){
+     2be:	83 ec 0c             	sub    $0xc,%esp
+     2c1:	68 ff 46 00 00       	push   $0x46ff
+     2c6:	e8 34 3e 00 00       	call   40ff <unlink>
+     2cb:	83 c4 10             	add    $0x10,%esp
+     2ce:	85 c0                	test   %eax,%eax
+     2d0:	74 1b                	je     2ed <openiputtest+0xf5>
+    printf(stdout, "unlink failed\n");
+     2d2:	a1 70 65 00 00       	mov    0x6570,%eax
+     2d7:	83 ec 08             	sub    $0x8,%esp
+     2da:	68 40 47 00 00       	push   $0x4740
+     2df:	50                   	push   %eax
+     2e0:	e8 6e 3f 00 00       	call   4253 <printf>
+     2e5:	83 c4 10             	add    $0x10,%esp
+    exit();
+     2e8:	e8 c2 3d 00 00       	call   40af <exit>
+  }
+  wait();
+     2ed:	e8 c5 3d 00 00       	call   40b7 <wait>
+  printf(stdout, "openiput test ok\n");
+     2f2:	a1 70 65 00 00       	mov    0x6570,%eax
+     2f7:	83 ec 08             	sub    $0x8,%esp
+     2fa:	68 4f 47 00 00       	push   $0x474f
+     2ff:	50                   	push   %eax
+     300:	e8 4e 3f 00 00       	call   4253 <printf>
+     305:	83 c4 10             	add    $0x10,%esp
+}
+     308:	90                   	nop
+     309:	c9                   	leave  
+     30a:	c3                   	ret    
+
+0000030b <opentest>:
+
+// simple file system tests
+
+void
+opentest(void)
+{
+     30b:	f3 0f 1e fb          	endbr32 
+     30f:	55                   	push   %ebp
+     310:	89 e5                	mov    %esp,%ebp
+     312:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+
+  printf(stdout, "open test\n");
+     315:	a1 70 65 00 00       	mov    0x6570,%eax
+     31a:	83 ec 08             	sub    $0x8,%esp
+     31d:	68 61 47 00 00       	push   $0x4761
+     322:	50                   	push   %eax
+     323:	e8 2b 3f 00 00       	call   4253 <printf>
+     328:	83 c4 10             	add    $0x10,%esp
+  fd = open("echo", 0);
+     32b:	83 ec 08             	sub    $0x8,%esp
+     32e:	6a 00                	push   $0x0
+     330:	68 1c 46 00 00       	push   $0x461c
+     335:	e8 b5 3d 00 00       	call   40ef <open>
+     33a:	83 c4 10             	add    $0x10,%esp
+     33d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+     340:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     344:	79 1b                	jns    361 <opentest+0x56>
+    printf(stdout, "open echo failed!\n");
+     346:	a1 70 65 00 00       	mov    0x6570,%eax
+     34b:	83 ec 08             	sub    $0x8,%esp
+     34e:	68 6c 47 00 00       	push   $0x476c
+     353:	50                   	push   %eax
+     354:	e8 fa 3e 00 00       	call   4253 <printf>
+     359:	83 c4 10             	add    $0x10,%esp
+    exit();
+     35c:	e8 4e 3d 00 00       	call   40af <exit>
+  }
+  close(fd);
+     361:	83 ec 0c             	sub    $0xc,%esp
+     364:	ff 75 f4             	pushl  -0xc(%ebp)
+     367:	e8 6b 3d 00 00       	call   40d7 <close>
+     36c:	83 c4 10             	add    $0x10,%esp
+  fd = open("doesnotexist", 0);
+     36f:	83 ec 08             	sub    $0x8,%esp
+     372:	6a 00                	push   $0x0
+     374:	68 7f 47 00 00       	push   $0x477f
+     379:	e8 71 3d 00 00       	call   40ef <open>
+     37e:	83 c4 10             	add    $0x10,%esp
+     381:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd >= 0){
+     384:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     388:	78 1b                	js     3a5 <opentest+0x9a>
+    printf(stdout, "open doesnotexist succeeded!\n");
+     38a:	a1 70 65 00 00       	mov    0x6570,%eax
+     38f:	83 ec 08             	sub    $0x8,%esp
+     392:	68 8c 47 00 00       	push   $0x478c
+     397:	50                   	push   %eax
+     398:	e8 b6 3e 00 00       	call   4253 <printf>
+     39d:	83 c4 10             	add    $0x10,%esp
+    exit();
+     3a0:	e8 0a 3d 00 00       	call   40af <exit>
+  }
+  printf(stdout, "open test ok\n");
+     3a5:	a1 70 65 00 00       	mov    0x6570,%eax
+     3aa:	83 ec 08             	sub    $0x8,%esp
+     3ad:	68 aa 47 00 00       	push   $0x47aa
+     3b2:	50                   	push   %eax
+     3b3:	e8 9b 3e 00 00       	call   4253 <printf>
+     3b8:	83 c4 10             	add    $0x10,%esp
+}
+     3bb:	90                   	nop
+     3bc:	c9                   	leave  
+     3bd:	c3                   	ret    
+
+000003be <writetest>:
+
+void
+writetest(void)
+{
+     3be:	f3 0f 1e fb          	endbr32 
+     3c2:	55                   	push   %ebp
+     3c3:	89 e5                	mov    %esp,%ebp
+     3c5:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int i;
+
+  printf(stdout, "small file test\n");
+     3c8:	a1 70 65 00 00       	mov    0x6570,%eax
+     3cd:	83 ec 08             	sub    $0x8,%esp
+     3d0:	68 b8 47 00 00       	push   $0x47b8
+     3d5:	50                   	push   %eax
+     3d6:	e8 78 3e 00 00       	call   4253 <printf>
+     3db:	83 c4 10             	add    $0x10,%esp
+  fd = open("small", O_CREATE|O_RDWR);
+     3de:	83 ec 08             	sub    $0x8,%esp
+     3e1:	68 02 02 00 00       	push   $0x202
+     3e6:	68 c9 47 00 00       	push   $0x47c9
+     3eb:	e8 ff 3c 00 00       	call   40ef <open>
+     3f0:	83 c4 10             	add    $0x10,%esp
+     3f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(fd >= 0){
+     3f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     3fa:	78 22                	js     41e <writetest+0x60>
+    printf(stdout, "creat small succeeded; ok\n");
+     3fc:	a1 70 65 00 00       	mov    0x6570,%eax
+     401:	83 ec 08             	sub    $0x8,%esp
+     404:	68 cf 47 00 00       	push   $0x47cf
+     409:	50                   	push   %eax
+     40a:	e8 44 3e 00 00       	call   4253 <printf>
+     40f:	83 c4 10             	add    $0x10,%esp
+  } else {
+    printf(stdout, "error: creat small failed!\n");
+    exit();
+  }
+  for(i = 0; i < 100; i++){
+     412:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     419:	e9 8f 00 00 00       	jmp    4ad <writetest+0xef>
+    printf(stdout, "error: creat small failed!\n");
+     41e:	a1 70 65 00 00       	mov    0x6570,%eax
+     423:	83 ec 08             	sub    $0x8,%esp
+     426:	68 ea 47 00 00       	push   $0x47ea
+     42b:	50                   	push   %eax
+     42c:	e8 22 3e 00 00       	call   4253 <printf>
+     431:	83 c4 10             	add    $0x10,%esp
+    exit();
+     434:	e8 76 3c 00 00       	call   40af <exit>
+    if(write(fd, "aaaaaaaaaa", 10) != 10){
+     439:	83 ec 04             	sub    $0x4,%esp
+     43c:	6a 0a                	push   $0xa
+     43e:	68 06 48 00 00       	push   $0x4806
+     443:	ff 75 f0             	pushl  -0x10(%ebp)
+     446:	e8 84 3c 00 00       	call   40cf <write>
+     44b:	83 c4 10             	add    $0x10,%esp
+     44e:	83 f8 0a             	cmp    $0xa,%eax
+     451:	74 1e                	je     471 <writetest+0xb3>
+      printf(stdout, "error: write aa %d new file failed\n", i);
+     453:	a1 70 65 00 00       	mov    0x6570,%eax
+     458:	83 ec 04             	sub    $0x4,%esp
+     45b:	ff 75 f4             	pushl  -0xc(%ebp)
+     45e:	68 14 48 00 00       	push   $0x4814
+     463:	50                   	push   %eax
+     464:	e8 ea 3d 00 00       	call   4253 <printf>
+     469:	83 c4 10             	add    $0x10,%esp
+      exit();
+     46c:	e8 3e 3c 00 00       	call   40af <exit>
+    }
+    if(write(fd, "bbbbbbbbbb", 10) != 10){
+     471:	83 ec 04             	sub    $0x4,%esp
+     474:	6a 0a                	push   $0xa
+     476:	68 38 48 00 00       	push   $0x4838
+     47b:	ff 75 f0             	pushl  -0x10(%ebp)
+     47e:	e8 4c 3c 00 00       	call   40cf <write>
+     483:	83 c4 10             	add    $0x10,%esp
+     486:	83 f8 0a             	cmp    $0xa,%eax
+     489:	74 1e                	je     4a9 <writetest+0xeb>
+      printf(stdout, "error: write bb %d new file failed\n", i);
+     48b:	a1 70 65 00 00       	mov    0x6570,%eax
+     490:	83 ec 04             	sub    $0x4,%esp
+     493:	ff 75 f4             	pushl  -0xc(%ebp)
+     496:	68 44 48 00 00       	push   $0x4844
+     49b:	50                   	push   %eax
+     49c:	e8 b2 3d 00 00       	call   4253 <printf>
+     4a1:	83 c4 10             	add    $0x10,%esp
+      exit();
+     4a4:	e8 06 3c 00 00       	call   40af <exit>
+  for(i = 0; i < 100; i++){
+     4a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     4ad:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+     4b1:	7e 86                	jle    439 <writetest+0x7b>
+    }
+  }
+  printf(stdout, "writes ok\n");
+     4b3:	a1 70 65 00 00       	mov    0x6570,%eax
+     4b8:	83 ec 08             	sub    $0x8,%esp
+     4bb:	68 68 48 00 00       	push   $0x4868
+     4c0:	50                   	push   %eax
+     4c1:	e8 8d 3d 00 00       	call   4253 <printf>
+     4c6:	83 c4 10             	add    $0x10,%esp
+  close(fd);
+     4c9:	83 ec 0c             	sub    $0xc,%esp
+     4cc:	ff 75 f0             	pushl  -0x10(%ebp)
+     4cf:	e8 03 3c 00 00       	call   40d7 <close>
+     4d4:	83 c4 10             	add    $0x10,%esp
+  fd = open("small", O_RDONLY);
+     4d7:	83 ec 08             	sub    $0x8,%esp
+     4da:	6a 00                	push   $0x0
+     4dc:	68 c9 47 00 00       	push   $0x47c9
+     4e1:	e8 09 3c 00 00       	call   40ef <open>
+     4e6:	83 c4 10             	add    $0x10,%esp
+     4e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(fd >= 0){
+     4ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     4f0:	78 3c                	js     52e <writetest+0x170>
+    printf(stdout, "open small succeeded ok\n");
+     4f2:	a1 70 65 00 00       	mov    0x6570,%eax
+     4f7:	83 ec 08             	sub    $0x8,%esp
+     4fa:	68 73 48 00 00       	push   $0x4873
+     4ff:	50                   	push   %eax
+     500:	e8 4e 3d 00 00       	call   4253 <printf>
+     505:	83 c4 10             	add    $0x10,%esp
+  } else {
+    printf(stdout, "error: open small failed!\n");
+    exit();
+  }
+  i = read(fd, buf, 2000);
+     508:	83 ec 04             	sub    $0x4,%esp
+     50b:	68 d0 07 00 00       	push   $0x7d0
+     510:	68 60 8d 00 00       	push   $0x8d60
+     515:	ff 75 f0             	pushl  -0x10(%ebp)
+     518:	e8 aa 3b 00 00       	call   40c7 <read>
+     51d:	83 c4 10             	add    $0x10,%esp
+     520:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(i == 2000){
+     523:	81 7d f4 d0 07 00 00 	cmpl   $0x7d0,-0xc(%ebp)
+     52a:	75 57                	jne    583 <writetest+0x1c5>
+     52c:	eb 1b                	jmp    549 <writetest+0x18b>
+    printf(stdout, "error: open small failed!\n");
+     52e:	a1 70 65 00 00       	mov    0x6570,%eax
+     533:	83 ec 08             	sub    $0x8,%esp
+     536:	68 8c 48 00 00       	push   $0x488c
+     53b:	50                   	push   %eax
+     53c:	e8 12 3d 00 00       	call   4253 <printf>
+     541:	83 c4 10             	add    $0x10,%esp
+    exit();
+     544:	e8 66 3b 00 00       	call   40af <exit>
+    printf(stdout, "read succeeded ok\n");
+     549:	a1 70 65 00 00       	mov    0x6570,%eax
+     54e:	83 ec 08             	sub    $0x8,%esp
+     551:	68 a7 48 00 00       	push   $0x48a7
+     556:	50                   	push   %eax
+     557:	e8 f7 3c 00 00       	call   4253 <printf>
+     55c:	83 c4 10             	add    $0x10,%esp
+  } else {
+    printf(stdout, "read failed\n");
+    exit();
+  }
+  close(fd);
+     55f:	83 ec 0c             	sub    $0xc,%esp
+     562:	ff 75 f0             	pushl  -0x10(%ebp)
+     565:	e8 6d 3b 00 00       	call   40d7 <close>
+     56a:	83 c4 10             	add    $0x10,%esp
+
+  if(unlink("small") < 0){
+     56d:	83 ec 0c             	sub    $0xc,%esp
+     570:	68 c9 47 00 00       	push   $0x47c9
+     575:	e8 85 3b 00 00       	call   40ff <unlink>
+     57a:	83 c4 10             	add    $0x10,%esp
+     57d:	85 c0                	test   %eax,%eax
+     57f:	79 38                	jns    5b9 <writetest+0x1fb>
+     581:	eb 1b                	jmp    59e <writetest+0x1e0>
+    printf(stdout, "read failed\n");
+     583:	a1 70 65 00 00       	mov    0x6570,%eax
+     588:	83 ec 08             	sub    $0x8,%esp
+     58b:	68 ba 48 00 00       	push   $0x48ba
+     590:	50                   	push   %eax
+     591:	e8 bd 3c 00 00       	call   4253 <printf>
+     596:	83 c4 10             	add    $0x10,%esp
+    exit();
+     599:	e8 11 3b 00 00       	call   40af <exit>
+    printf(stdout, "unlink small failed\n");
+     59e:	a1 70 65 00 00       	mov    0x6570,%eax
+     5a3:	83 ec 08             	sub    $0x8,%esp
+     5a6:	68 c7 48 00 00       	push   $0x48c7
+     5ab:	50                   	push   %eax
+     5ac:	e8 a2 3c 00 00       	call   4253 <printf>
+     5b1:	83 c4 10             	add    $0x10,%esp
+    exit();
+     5b4:	e8 f6 3a 00 00       	call   40af <exit>
+  }
+  printf(stdout, "small file test ok\n");
+     5b9:	a1 70 65 00 00       	mov    0x6570,%eax
+     5be:	83 ec 08             	sub    $0x8,%esp
+     5c1:	68 dc 48 00 00       	push   $0x48dc
+     5c6:	50                   	push   %eax
+     5c7:	e8 87 3c 00 00       	call   4253 <printf>
+     5cc:	83 c4 10             	add    $0x10,%esp
+}
+     5cf:	90                   	nop
+     5d0:	c9                   	leave  
+     5d1:	c3                   	ret    
+
+000005d2 <writetest1>:
+
+void
+writetest1(void)
+{
+     5d2:	f3 0f 1e fb          	endbr32 
+     5d6:	55                   	push   %ebp
+     5d7:	89 e5                	mov    %esp,%ebp
+     5d9:	83 ec 18             	sub    $0x18,%esp
+  int i, fd, n;
+
+  printf(stdout, "big files test\n");
+     5dc:	a1 70 65 00 00       	mov    0x6570,%eax
+     5e1:	83 ec 08             	sub    $0x8,%esp
+     5e4:	68 f0 48 00 00       	push   $0x48f0
+     5e9:	50                   	push   %eax
+     5ea:	e8 64 3c 00 00       	call   4253 <printf>
+     5ef:	83 c4 10             	add    $0x10,%esp
+
+  fd = open("big", O_CREATE|O_RDWR);
+     5f2:	83 ec 08             	sub    $0x8,%esp
+     5f5:	68 02 02 00 00       	push   $0x202
+     5fa:	68 00 49 00 00       	push   $0x4900
+     5ff:	e8 eb 3a 00 00       	call   40ef <open>
+     604:	83 c4 10             	add    $0x10,%esp
+     607:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+     60a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     60e:	79 1b                	jns    62b <writetest1+0x59>
+    printf(stdout, "error: creat big failed!\n");
+     610:	a1 70 65 00 00       	mov    0x6570,%eax
+     615:	83 ec 08             	sub    $0x8,%esp
+     618:	68 04 49 00 00       	push   $0x4904
+     61d:	50                   	push   %eax
+     61e:	e8 30 3c 00 00       	call   4253 <printf>
+     623:	83 c4 10             	add    $0x10,%esp
+    exit();
+     626:	e8 84 3a 00 00       	call   40af <exit>
+  }
+
+  for(i = 0; i < MAXFILE; i++){
+     62b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     632:	eb 4b                	jmp    67f <writetest1+0xad>
+    ((int*)buf)[0] = i;
+     634:	ba 60 8d 00 00       	mov    $0x8d60,%edx
+     639:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     63c:	89 02                	mov    %eax,(%edx)
+    if(write(fd, buf, 512) != 512){
+     63e:	83 ec 04             	sub    $0x4,%esp
+     641:	68 00 02 00 00       	push   $0x200
+     646:	68 60 8d 00 00       	push   $0x8d60
+     64b:	ff 75 ec             	pushl  -0x14(%ebp)
+     64e:	e8 7c 3a 00 00       	call   40cf <write>
+     653:	83 c4 10             	add    $0x10,%esp
+     656:	3d 00 02 00 00       	cmp    $0x200,%eax
+     65b:	74 1e                	je     67b <writetest1+0xa9>
+      printf(stdout, "error: write big file failed\n", i);
+     65d:	a1 70 65 00 00       	mov    0x6570,%eax
+     662:	83 ec 04             	sub    $0x4,%esp
+     665:	ff 75 f4             	pushl  -0xc(%ebp)
+     668:	68 1e 49 00 00       	push   $0x491e
+     66d:	50                   	push   %eax
+     66e:	e8 e0 3b 00 00       	call   4253 <printf>
+     673:	83 c4 10             	add    $0x10,%esp
+      exit();
+     676:	e8 34 3a 00 00       	call   40af <exit>
+  for(i = 0; i < MAXFILE; i++){
+     67b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     67f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     682:	3d 8b 00 00 00       	cmp    $0x8b,%eax
+     687:	76 ab                	jbe    634 <writetest1+0x62>
+    }
+  }
+
+  close(fd);
+     689:	83 ec 0c             	sub    $0xc,%esp
+     68c:	ff 75 ec             	pushl  -0x14(%ebp)
+     68f:	e8 43 3a 00 00       	call   40d7 <close>
+     694:	83 c4 10             	add    $0x10,%esp
+
+  fd = open("big", O_RDONLY);
+     697:	83 ec 08             	sub    $0x8,%esp
+     69a:	6a 00                	push   $0x0
+     69c:	68 00 49 00 00       	push   $0x4900
+     6a1:	e8 49 3a 00 00       	call   40ef <open>
+     6a6:	83 c4 10             	add    $0x10,%esp
+     6a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+     6ac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     6b0:	79 1b                	jns    6cd <writetest1+0xfb>
+    printf(stdout, "error: open big failed!\n");
+     6b2:	a1 70 65 00 00       	mov    0x6570,%eax
+     6b7:	83 ec 08             	sub    $0x8,%esp
+     6ba:	68 3c 49 00 00       	push   $0x493c
+     6bf:	50                   	push   %eax
+     6c0:	e8 8e 3b 00 00       	call   4253 <printf>
+     6c5:	83 c4 10             	add    $0x10,%esp
+    exit();
+     6c8:	e8 e2 39 00 00       	call   40af <exit>
+  }
+
+  n = 0;
+     6cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  for(;;){
+    i = read(fd, buf, 512);
+     6d4:	83 ec 04             	sub    $0x4,%esp
+     6d7:	68 00 02 00 00       	push   $0x200
+     6dc:	68 60 8d 00 00       	push   $0x8d60
+     6e1:	ff 75 ec             	pushl  -0x14(%ebp)
+     6e4:	e8 de 39 00 00       	call   40c7 <read>
+     6e9:	83 c4 10             	add    $0x10,%esp
+     6ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(i == 0){
+     6ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     6f3:	75 27                	jne    71c <writetest1+0x14a>
+      if(n == MAXFILE - 1){
+     6f5:	81 7d f0 8b 00 00 00 	cmpl   $0x8b,-0x10(%ebp)
+     6fc:	75 7d                	jne    77b <writetest1+0x1a9>
+        printf(stdout, "read only %d blocks from big", n);
+     6fe:	a1 70 65 00 00       	mov    0x6570,%eax
+     703:	83 ec 04             	sub    $0x4,%esp
+     706:	ff 75 f0             	pushl  -0x10(%ebp)
+     709:	68 55 49 00 00       	push   $0x4955
+     70e:	50                   	push   %eax
+     70f:	e8 3f 3b 00 00       	call   4253 <printf>
+     714:	83 c4 10             	add    $0x10,%esp
+        exit();
+     717:	e8 93 39 00 00       	call   40af <exit>
+      }
+      break;
+    } else if(i != 512){
+     71c:	81 7d f4 00 02 00 00 	cmpl   $0x200,-0xc(%ebp)
+     723:	74 1e                	je     743 <writetest1+0x171>
+      printf(stdout, "read failed %d\n", i);
+     725:	a1 70 65 00 00       	mov    0x6570,%eax
+     72a:	83 ec 04             	sub    $0x4,%esp
+     72d:	ff 75 f4             	pushl  -0xc(%ebp)
+     730:	68 72 49 00 00       	push   $0x4972
+     735:	50                   	push   %eax
+     736:	e8 18 3b 00 00       	call   4253 <printf>
+     73b:	83 c4 10             	add    $0x10,%esp
+      exit();
+     73e:	e8 6c 39 00 00       	call   40af <exit>
+    }
+    if(((int*)buf)[0] != n){
+     743:	b8 60 8d 00 00       	mov    $0x8d60,%eax
+     748:	8b 00                	mov    (%eax),%eax
+     74a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+     74d:	74 23                	je     772 <writetest1+0x1a0>
+      printf(stdout, "read content of block %d is %d\n",
+             n, ((int*)buf)[0]);
+     74f:	b8 60 8d 00 00       	mov    $0x8d60,%eax
+      printf(stdout, "read content of block %d is %d\n",
+     754:	8b 10                	mov    (%eax),%edx
+     756:	a1 70 65 00 00       	mov    0x6570,%eax
+     75b:	52                   	push   %edx
+     75c:	ff 75 f0             	pushl  -0x10(%ebp)
+     75f:	68 84 49 00 00       	push   $0x4984
+     764:	50                   	push   %eax
+     765:	e8 e9 3a 00 00       	call   4253 <printf>
+     76a:	83 c4 10             	add    $0x10,%esp
+      exit();
+     76d:	e8 3d 39 00 00       	call   40af <exit>
+    }
+    n++;
+     772:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    i = read(fd, buf, 512);
+     776:	e9 59 ff ff ff       	jmp    6d4 <writetest1+0x102>
+      break;
+     77b:	90                   	nop
+  }
+  close(fd);
+     77c:	83 ec 0c             	sub    $0xc,%esp
+     77f:	ff 75 ec             	pushl  -0x14(%ebp)
+     782:	e8 50 39 00 00       	call   40d7 <close>
+     787:	83 c4 10             	add    $0x10,%esp
+  if(unlink("big") < 0){
+     78a:	83 ec 0c             	sub    $0xc,%esp
+     78d:	68 00 49 00 00       	push   $0x4900
+     792:	e8 68 39 00 00       	call   40ff <unlink>
+     797:	83 c4 10             	add    $0x10,%esp
+     79a:	85 c0                	test   %eax,%eax
+     79c:	79 1b                	jns    7b9 <writetest1+0x1e7>
+    printf(stdout, "unlink big failed\n");
+     79e:	a1 70 65 00 00       	mov    0x6570,%eax
+     7a3:	83 ec 08             	sub    $0x8,%esp
+     7a6:	68 a4 49 00 00       	push   $0x49a4
+     7ab:	50                   	push   %eax
+     7ac:	e8 a2 3a 00 00       	call   4253 <printf>
+     7b1:	83 c4 10             	add    $0x10,%esp
+    exit();
+     7b4:	e8 f6 38 00 00       	call   40af <exit>
+  }
+  printf(stdout, "big files ok\n");
+     7b9:	a1 70 65 00 00       	mov    0x6570,%eax
+     7be:	83 ec 08             	sub    $0x8,%esp
+     7c1:	68 b7 49 00 00       	push   $0x49b7
+     7c6:	50                   	push   %eax
+     7c7:	e8 87 3a 00 00       	call   4253 <printf>
+     7cc:	83 c4 10             	add    $0x10,%esp
+}
+     7cf:	90                   	nop
+     7d0:	c9                   	leave  
+     7d1:	c3                   	ret    
+
+000007d2 <createtest>:
+
+void
+createtest(void)
+{
+     7d2:	f3 0f 1e fb          	endbr32 
+     7d6:	55                   	push   %ebp
+     7d7:	89 e5                	mov    %esp,%ebp
+     7d9:	83 ec 18             	sub    $0x18,%esp
+  int i, fd;
+
+  printf(stdout, "many creates, followed by unlink test\n");
+     7dc:	a1 70 65 00 00       	mov    0x6570,%eax
+     7e1:	83 ec 08             	sub    $0x8,%esp
+     7e4:	68 c8 49 00 00       	push   $0x49c8
+     7e9:	50                   	push   %eax
+     7ea:	e8 64 3a 00 00       	call   4253 <printf>
+     7ef:	83 c4 10             	add    $0x10,%esp
+
+  name[0] = 'a';
+     7f2:	c6 05 60 ad 00 00 61 	movb   $0x61,0xad60
+  name[2] = '\0';
+     7f9:	c6 05 62 ad 00 00 00 	movb   $0x0,0xad62
+  for(i = 0; i < 52; i++){
+     800:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     807:	eb 35                	jmp    83e <createtest+0x6c>
+    name[1] = '0' + i;
+     809:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     80c:	83 c0 30             	add    $0x30,%eax
+     80f:	a2 61 ad 00 00       	mov    %al,0xad61
+    fd = open(name, O_CREATE|O_RDWR);
+     814:	83 ec 08             	sub    $0x8,%esp
+     817:	68 02 02 00 00       	push   $0x202
+     81c:	68 60 ad 00 00       	push   $0xad60
+     821:	e8 c9 38 00 00       	call   40ef <open>
+     826:	83 c4 10             	add    $0x10,%esp
+     829:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    close(fd);
+     82c:	83 ec 0c             	sub    $0xc,%esp
+     82f:	ff 75 f0             	pushl  -0x10(%ebp)
+     832:	e8 a0 38 00 00       	call   40d7 <close>
+     837:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 52; i++){
+     83a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     83e:	83 7d f4 33          	cmpl   $0x33,-0xc(%ebp)
+     842:	7e c5                	jle    809 <createtest+0x37>
+  }
+  name[0] = 'a';
+     844:	c6 05 60 ad 00 00 61 	movb   $0x61,0xad60
+  name[2] = '\0';
+     84b:	c6 05 62 ad 00 00 00 	movb   $0x0,0xad62
+  for(i = 0; i < 52; i++){
+     852:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     859:	eb 1f                	jmp    87a <createtest+0xa8>
+    name[1] = '0' + i;
+     85b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     85e:	83 c0 30             	add    $0x30,%eax
+     861:	a2 61 ad 00 00       	mov    %al,0xad61
+    unlink(name);
+     866:	83 ec 0c             	sub    $0xc,%esp
+     869:	68 60 ad 00 00       	push   $0xad60
+     86e:	e8 8c 38 00 00       	call   40ff <unlink>
+     873:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 52; i++){
+     876:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     87a:	83 7d f4 33          	cmpl   $0x33,-0xc(%ebp)
+     87e:	7e db                	jle    85b <createtest+0x89>
+  }
+  printf(stdout, "many creates, followed by unlink; ok\n");
+     880:	a1 70 65 00 00       	mov    0x6570,%eax
+     885:	83 ec 08             	sub    $0x8,%esp
+     888:	68 f0 49 00 00       	push   $0x49f0
+     88d:	50                   	push   %eax
+     88e:	e8 c0 39 00 00       	call   4253 <printf>
+     893:	83 c4 10             	add    $0x10,%esp
+}
+     896:	90                   	nop
+     897:	c9                   	leave  
+     898:	c3                   	ret    
+
+00000899 <dirtest>:
+
+void dirtest(void)
+{
+     899:	f3 0f 1e fb          	endbr32 
+     89d:	55                   	push   %ebp
+     89e:	89 e5                	mov    %esp,%ebp
+     8a0:	83 ec 08             	sub    $0x8,%esp
+  printf(stdout, "mkdir test\n");
+     8a3:	a1 70 65 00 00       	mov    0x6570,%eax
+     8a8:	83 ec 08             	sub    $0x8,%esp
+     8ab:	68 16 4a 00 00       	push   $0x4a16
+     8b0:	50                   	push   %eax
+     8b1:	e8 9d 39 00 00       	call   4253 <printf>
+     8b6:	83 c4 10             	add    $0x10,%esp
+
+  if(mkdir("dir0") < 0){
+     8b9:	83 ec 0c             	sub    $0xc,%esp
+     8bc:	68 22 4a 00 00       	push   $0x4a22
+     8c1:	e8 51 38 00 00       	call   4117 <mkdir>
+     8c6:	83 c4 10             	add    $0x10,%esp
+     8c9:	85 c0                	test   %eax,%eax
+     8cb:	79 1b                	jns    8e8 <dirtest+0x4f>
+    printf(stdout, "mkdir failed\n");
+     8cd:	a1 70 65 00 00       	mov    0x6570,%eax
+     8d2:	83 ec 08             	sub    $0x8,%esp
+     8d5:	68 45 46 00 00       	push   $0x4645
+     8da:	50                   	push   %eax
+     8db:	e8 73 39 00 00       	call   4253 <printf>
+     8e0:	83 c4 10             	add    $0x10,%esp
+    exit();
+     8e3:	e8 c7 37 00 00       	call   40af <exit>
+  }
+
+  if(chdir("dir0") < 0){
+     8e8:	83 ec 0c             	sub    $0xc,%esp
+     8eb:	68 22 4a 00 00       	push   $0x4a22
+     8f0:	e8 2a 38 00 00       	call   411f <chdir>
+     8f5:	83 c4 10             	add    $0x10,%esp
+     8f8:	85 c0                	test   %eax,%eax
+     8fa:	79 1b                	jns    917 <dirtest+0x7e>
+    printf(stdout, "chdir dir0 failed\n");
+     8fc:	a1 70 65 00 00       	mov    0x6570,%eax
+     901:	83 ec 08             	sub    $0x8,%esp
+     904:	68 27 4a 00 00       	push   $0x4a27
+     909:	50                   	push   %eax
+     90a:	e8 44 39 00 00       	call   4253 <printf>
+     90f:	83 c4 10             	add    $0x10,%esp
+    exit();
+     912:	e8 98 37 00 00       	call   40af <exit>
+  }
+
+  if(chdir("..") < 0){
+     917:	83 ec 0c             	sub    $0xc,%esp
+     91a:	68 3a 4a 00 00       	push   $0x4a3a
+     91f:	e8 fb 37 00 00       	call   411f <chdir>
+     924:	83 c4 10             	add    $0x10,%esp
+     927:	85 c0                	test   %eax,%eax
+     929:	79 1b                	jns    946 <dirtest+0xad>
+    printf(stdout, "chdir .. failed\n");
+     92b:	a1 70 65 00 00       	mov    0x6570,%eax
+     930:	83 ec 08             	sub    $0x8,%esp
+     933:	68 3d 4a 00 00       	push   $0x4a3d
+     938:	50                   	push   %eax
+     939:	e8 15 39 00 00       	call   4253 <printf>
+     93e:	83 c4 10             	add    $0x10,%esp
+    exit();
+     941:	e8 69 37 00 00       	call   40af <exit>
+  }
+
+  if(unlink("dir0") < 0){
+     946:	83 ec 0c             	sub    $0xc,%esp
+     949:	68 22 4a 00 00       	push   $0x4a22
+     94e:	e8 ac 37 00 00       	call   40ff <unlink>
+     953:	83 c4 10             	add    $0x10,%esp
+     956:	85 c0                	test   %eax,%eax
+     958:	79 1b                	jns    975 <dirtest+0xdc>
+    printf(stdout, "unlink dir0 failed\n");
+     95a:	a1 70 65 00 00       	mov    0x6570,%eax
+     95f:	83 ec 08             	sub    $0x8,%esp
+     962:	68 4e 4a 00 00       	push   $0x4a4e
+     967:	50                   	push   %eax
+     968:	e8 e6 38 00 00       	call   4253 <printf>
+     96d:	83 c4 10             	add    $0x10,%esp
+    exit();
+     970:	e8 3a 37 00 00       	call   40af <exit>
+  }
+  printf(stdout, "mkdir test ok\n");
+     975:	a1 70 65 00 00       	mov    0x6570,%eax
+     97a:	83 ec 08             	sub    $0x8,%esp
+     97d:	68 62 4a 00 00       	push   $0x4a62
+     982:	50                   	push   %eax
+     983:	e8 cb 38 00 00       	call   4253 <printf>
+     988:	83 c4 10             	add    $0x10,%esp
+}
+     98b:	90                   	nop
+     98c:	c9                   	leave  
+     98d:	c3                   	ret    
+
+0000098e <exectest>:
+
+void
+exectest(void)
+{
+     98e:	f3 0f 1e fb          	endbr32 
+     992:	55                   	push   %ebp
+     993:	89 e5                	mov    %esp,%ebp
+     995:	83 ec 08             	sub    $0x8,%esp
+  printf(stdout, "exec test\n");
+     998:	a1 70 65 00 00       	mov    0x6570,%eax
+     99d:	83 ec 08             	sub    $0x8,%esp
+     9a0:	68 71 4a 00 00       	push   $0x4a71
+     9a5:	50                   	push   %eax
+     9a6:	e8 a8 38 00 00       	call   4253 <printf>
+     9ab:	83 c4 10             	add    $0x10,%esp
+  if(exec("echo", echoargv) < 0){
+     9ae:	83 ec 08             	sub    $0x8,%esp
+     9b1:	68 5c 65 00 00       	push   $0x655c
+     9b6:	68 1c 46 00 00       	push   $0x461c
+     9bb:	e8 27 37 00 00       	call   40e7 <exec>
+     9c0:	83 c4 10             	add    $0x10,%esp
+     9c3:	85 c0                	test   %eax,%eax
+     9c5:	79 1b                	jns    9e2 <exectest+0x54>
+    printf(stdout, "exec echo failed\n");
+     9c7:	a1 70 65 00 00       	mov    0x6570,%eax
+     9cc:	83 ec 08             	sub    $0x8,%esp
+     9cf:	68 7c 4a 00 00       	push   $0x4a7c
+     9d4:	50                   	push   %eax
+     9d5:	e8 79 38 00 00       	call   4253 <printf>
+     9da:	83 c4 10             	add    $0x10,%esp
+    exit();
+     9dd:	e8 cd 36 00 00       	call   40af <exit>
+  }
+}
+     9e2:	90                   	nop
+     9e3:	c9                   	leave  
+     9e4:	c3                   	ret    
+
+000009e5 <pipe1>:
+
+// simple fork and pipe read/write
+
+void
+pipe1(void)
+{
+     9e5:	f3 0f 1e fb          	endbr32 
+     9e9:	55                   	push   %ebp
+     9ea:	89 e5                	mov    %esp,%ebp
+     9ec:	83 ec 28             	sub    $0x28,%esp
+  int fds[2], pid;
+  int seq, i, n, cc, total;
+
+  if(pipe(fds) != 0){
+     9ef:	83 ec 0c             	sub    $0xc,%esp
+     9f2:	8d 45 d8             	lea    -0x28(%ebp),%eax
+     9f5:	50                   	push   %eax
+     9f6:	e8 c4 36 00 00       	call   40bf <pipe>
+     9fb:	83 c4 10             	add    $0x10,%esp
+     9fe:	85 c0                	test   %eax,%eax
+     a00:	74 17                	je     a19 <pipe1+0x34>
+    printf(1, "pipe() failed\n");
+     a02:	83 ec 08             	sub    $0x8,%esp
+     a05:	68 8e 4a 00 00       	push   $0x4a8e
+     a0a:	6a 01                	push   $0x1
+     a0c:	e8 42 38 00 00       	call   4253 <printf>
+     a11:	83 c4 10             	add    $0x10,%esp
+    exit();
+     a14:	e8 96 36 00 00       	call   40af <exit>
+  }
+  pid = fork();
+     a19:	e8 89 36 00 00       	call   40a7 <fork>
+     a1e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  seq = 0;
+     a21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  if(pid == 0){
+     a28:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+     a2c:	0f 85 89 00 00 00    	jne    abb <pipe1+0xd6>
+    close(fds[0]);
+     a32:	8b 45 d8             	mov    -0x28(%ebp),%eax
+     a35:	83 ec 0c             	sub    $0xc,%esp
+     a38:	50                   	push   %eax
+     a39:	e8 99 36 00 00       	call   40d7 <close>
+     a3e:	83 c4 10             	add    $0x10,%esp
+    for(n = 0; n < 5; n++){
+     a41:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+     a48:	eb 66                	jmp    ab0 <pipe1+0xcb>
+      for(i = 0; i < 1033; i++)
+     a4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+     a51:	eb 19                	jmp    a6c <pipe1+0x87>
+        buf[i] = seq++;
+     a53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     a56:	8d 50 01             	lea    0x1(%eax),%edx
+     a59:	89 55 f4             	mov    %edx,-0xc(%ebp)
+     a5c:	89 c2                	mov    %eax,%edx
+     a5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     a61:	05 60 8d 00 00       	add    $0x8d60,%eax
+     a66:	88 10                	mov    %dl,(%eax)
+      for(i = 0; i < 1033; i++)
+     a68:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+     a6c:	81 7d f0 08 04 00 00 	cmpl   $0x408,-0x10(%ebp)
+     a73:	7e de                	jle    a53 <pipe1+0x6e>
+      if(write(fds[1], buf, 1033) != 1033){
+     a75:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     a78:	83 ec 04             	sub    $0x4,%esp
+     a7b:	68 09 04 00 00       	push   $0x409
+     a80:	68 60 8d 00 00       	push   $0x8d60
+     a85:	50                   	push   %eax
+     a86:	e8 44 36 00 00       	call   40cf <write>
+     a8b:	83 c4 10             	add    $0x10,%esp
+     a8e:	3d 09 04 00 00       	cmp    $0x409,%eax
+     a93:	74 17                	je     aac <pipe1+0xc7>
+        printf(1, "pipe1 oops 1\n");
+     a95:	83 ec 08             	sub    $0x8,%esp
+     a98:	68 9d 4a 00 00       	push   $0x4a9d
+     a9d:	6a 01                	push   $0x1
+     a9f:	e8 af 37 00 00       	call   4253 <printf>
+     aa4:	83 c4 10             	add    $0x10,%esp
+        exit();
+     aa7:	e8 03 36 00 00       	call   40af <exit>
+    for(n = 0; n < 5; n++){
+     aac:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+     ab0:	83 7d ec 04          	cmpl   $0x4,-0x14(%ebp)
+     ab4:	7e 94                	jle    a4a <pipe1+0x65>
+      }
+    }
+    exit();
+     ab6:	e8 f4 35 00 00       	call   40af <exit>
+  } else if(pid > 0){
+     abb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+     abf:	0f 8e f4 00 00 00    	jle    bb9 <pipe1+0x1d4>
+    close(fds[1]);
+     ac5:	8b 45 dc             	mov    -0x24(%ebp),%eax
+     ac8:	83 ec 0c             	sub    $0xc,%esp
+     acb:	50                   	push   %eax
+     acc:	e8 06 36 00 00       	call   40d7 <close>
+     ad1:	83 c4 10             	add    $0x10,%esp
+    total = 0;
+     ad4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+    cc = 1;
+     adb:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
+    while((n = read(fds[0], buf, cc)) > 0){
+     ae2:	eb 66                	jmp    b4a <pipe1+0x165>
+      for(i = 0; i < n; i++){
+     ae4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+     aeb:	eb 3b                	jmp    b28 <pipe1+0x143>
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+     aed:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     af0:	05 60 8d 00 00       	add    $0x8d60,%eax
+     af5:	0f b6 00             	movzbl (%eax),%eax
+     af8:	0f be c8             	movsbl %al,%ecx
+     afb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     afe:	8d 50 01             	lea    0x1(%eax),%edx
+     b01:	89 55 f4             	mov    %edx,-0xc(%ebp)
+     b04:	31 c8                	xor    %ecx,%eax
+     b06:	0f b6 c0             	movzbl %al,%eax
+     b09:	85 c0                	test   %eax,%eax
+     b0b:	74 17                	je     b24 <pipe1+0x13f>
+          printf(1, "pipe1 oops 2\n");
+     b0d:	83 ec 08             	sub    $0x8,%esp
+     b10:	68 ab 4a 00 00       	push   $0x4aab
+     b15:	6a 01                	push   $0x1
+     b17:	e8 37 37 00 00       	call   4253 <printf>
+     b1c:	83 c4 10             	add    $0x10,%esp
+     b1f:	e9 ac 00 00 00       	jmp    bd0 <pipe1+0x1eb>
+      for(i = 0; i < n; i++){
+     b24:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+     b28:	8b 45 f0             	mov    -0x10(%ebp),%eax
+     b2b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+     b2e:	7c bd                	jl     aed <pipe1+0x108>
+          return;
+        }
+      }
+      total += n;
+     b30:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     b33:	01 45 e4             	add    %eax,-0x1c(%ebp)
+      cc = cc * 2;
+     b36:	d1 65 e8             	shll   -0x18(%ebp)
+      if(cc > sizeof(buf))
+     b39:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     b3c:	3d 00 20 00 00       	cmp    $0x2000,%eax
+     b41:	76 07                	jbe    b4a <pipe1+0x165>
+        cc = sizeof(buf);
+     b43:	c7 45 e8 00 20 00 00 	movl   $0x2000,-0x18(%ebp)
+    while((n = read(fds[0], buf, cc)) > 0){
+     b4a:	8b 45 d8             	mov    -0x28(%ebp),%eax
+     b4d:	83 ec 04             	sub    $0x4,%esp
+     b50:	ff 75 e8             	pushl  -0x18(%ebp)
+     b53:	68 60 8d 00 00       	push   $0x8d60
+     b58:	50                   	push   %eax
+     b59:	e8 69 35 00 00       	call   40c7 <read>
+     b5e:	83 c4 10             	add    $0x10,%esp
+     b61:	89 45 ec             	mov    %eax,-0x14(%ebp)
+     b64:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     b68:	0f 8f 76 ff ff ff    	jg     ae4 <pipe1+0xff>
+    }
+    if(total != 5 * 1033){
+     b6e:	81 7d e4 2d 14 00 00 	cmpl   $0x142d,-0x1c(%ebp)
+     b75:	74 1a                	je     b91 <pipe1+0x1ac>
+      printf(1, "pipe1 oops 3 total %d\n", total);
+     b77:	83 ec 04             	sub    $0x4,%esp
+     b7a:	ff 75 e4             	pushl  -0x1c(%ebp)
+     b7d:	68 b9 4a 00 00       	push   $0x4ab9
+     b82:	6a 01                	push   $0x1
+     b84:	e8 ca 36 00 00       	call   4253 <printf>
+     b89:	83 c4 10             	add    $0x10,%esp
+      exit();
+     b8c:	e8 1e 35 00 00       	call   40af <exit>
+    }
+    close(fds[0]);
+     b91:	8b 45 d8             	mov    -0x28(%ebp),%eax
+     b94:	83 ec 0c             	sub    $0xc,%esp
+     b97:	50                   	push   %eax
+     b98:	e8 3a 35 00 00       	call   40d7 <close>
+     b9d:	83 c4 10             	add    $0x10,%esp
+    wait();
+     ba0:	e8 12 35 00 00       	call   40b7 <wait>
+  } else {
+    printf(1, "fork() failed\n");
+    exit();
+  }
+  printf(1, "pipe1 ok\n");
+     ba5:	83 ec 08             	sub    $0x8,%esp
+     ba8:	68 df 4a 00 00       	push   $0x4adf
+     bad:	6a 01                	push   $0x1
+     baf:	e8 9f 36 00 00       	call   4253 <printf>
+     bb4:	83 c4 10             	add    $0x10,%esp
+     bb7:	eb 17                	jmp    bd0 <pipe1+0x1eb>
+    printf(1, "fork() failed\n");
+     bb9:	83 ec 08             	sub    $0x8,%esp
+     bbc:	68 d0 4a 00 00       	push   $0x4ad0
+     bc1:	6a 01                	push   $0x1
+     bc3:	e8 8b 36 00 00       	call   4253 <printf>
+     bc8:	83 c4 10             	add    $0x10,%esp
+    exit();
+     bcb:	e8 df 34 00 00       	call   40af <exit>
+}
+     bd0:	c9                   	leave  
+     bd1:	c3                   	ret    
+
+00000bd2 <preempt>:
+
+// meant to be run w/ at most two CPUs
+void
+preempt(void)
+{
+     bd2:	f3 0f 1e fb          	endbr32 
+     bd6:	55                   	push   %ebp
+     bd7:	89 e5                	mov    %esp,%ebp
+     bd9:	83 ec 28             	sub    $0x28,%esp
+  int pid1, pid2, pid3;
+  int pfds[2];
+
+  printf(1, "preempt: ");
+     bdc:	83 ec 08             	sub    $0x8,%esp
+     bdf:	68 e9 4a 00 00       	push   $0x4ae9
+     be4:	6a 01                	push   $0x1
+     be6:	e8 68 36 00 00       	call   4253 <printf>
+     beb:	83 c4 10             	add    $0x10,%esp
+  pid1 = fork();
+     bee:	e8 b4 34 00 00       	call   40a7 <fork>
+     bf3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(pid1 == 0)
+     bf6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     bfa:	75 02                	jne    bfe <preempt+0x2c>
+    for(;;)
+     bfc:	eb fe                	jmp    bfc <preempt+0x2a>
+      ;
+
+  pid2 = fork();
+     bfe:	e8 a4 34 00 00       	call   40a7 <fork>
+     c03:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(pid2 == 0)
+     c06:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     c0a:	75 02                	jne    c0e <preempt+0x3c>
+    for(;;)
+     c0c:	eb fe                	jmp    c0c <preempt+0x3a>
+      ;
+
+  pipe(pfds);
+     c0e:	83 ec 0c             	sub    $0xc,%esp
+     c11:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+     c14:	50                   	push   %eax
+     c15:	e8 a5 34 00 00       	call   40bf <pipe>
+     c1a:	83 c4 10             	add    $0x10,%esp
+  pid3 = fork();
+     c1d:	e8 85 34 00 00       	call   40a7 <fork>
+     c22:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(pid3 == 0){
+     c25:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     c29:	75 4d                	jne    c78 <preempt+0xa6>
+    close(pfds[0]);
+     c2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     c2e:	83 ec 0c             	sub    $0xc,%esp
+     c31:	50                   	push   %eax
+     c32:	e8 a0 34 00 00       	call   40d7 <close>
+     c37:	83 c4 10             	add    $0x10,%esp
+    if(write(pfds[1], "x", 1) != 1)
+     c3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     c3d:	83 ec 04             	sub    $0x4,%esp
+     c40:	6a 01                	push   $0x1
+     c42:	68 f3 4a 00 00       	push   $0x4af3
+     c47:	50                   	push   %eax
+     c48:	e8 82 34 00 00       	call   40cf <write>
+     c4d:	83 c4 10             	add    $0x10,%esp
+     c50:	83 f8 01             	cmp    $0x1,%eax
+     c53:	74 12                	je     c67 <preempt+0x95>
+      printf(1, "preempt write error");
+     c55:	83 ec 08             	sub    $0x8,%esp
+     c58:	68 f5 4a 00 00       	push   $0x4af5
+     c5d:	6a 01                	push   $0x1
+     c5f:	e8 ef 35 00 00       	call   4253 <printf>
+     c64:	83 c4 10             	add    $0x10,%esp
+    close(pfds[1]);
+     c67:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     c6a:	83 ec 0c             	sub    $0xc,%esp
+     c6d:	50                   	push   %eax
+     c6e:	e8 64 34 00 00       	call   40d7 <close>
+     c73:	83 c4 10             	add    $0x10,%esp
+    for(;;)
+     c76:	eb fe                	jmp    c76 <preempt+0xa4>
+      ;
+  }
+
+  close(pfds[1]);
+     c78:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     c7b:	83 ec 0c             	sub    $0xc,%esp
+     c7e:	50                   	push   %eax
+     c7f:	e8 53 34 00 00       	call   40d7 <close>
+     c84:	83 c4 10             	add    $0x10,%esp
+  if(read(pfds[0], buf, sizeof(buf)) != 1){
+     c87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     c8a:	83 ec 04             	sub    $0x4,%esp
+     c8d:	68 00 20 00 00       	push   $0x2000
+     c92:	68 60 8d 00 00       	push   $0x8d60
+     c97:	50                   	push   %eax
+     c98:	e8 2a 34 00 00       	call   40c7 <read>
+     c9d:	83 c4 10             	add    $0x10,%esp
+     ca0:	83 f8 01             	cmp    $0x1,%eax
+     ca3:	74 14                	je     cb9 <preempt+0xe7>
+    printf(1, "preempt read error");
+     ca5:	83 ec 08             	sub    $0x8,%esp
+     ca8:	68 09 4b 00 00       	push   $0x4b09
+     cad:	6a 01                	push   $0x1
+     caf:	e8 9f 35 00 00       	call   4253 <printf>
+     cb4:	83 c4 10             	add    $0x10,%esp
+     cb7:	eb 7e                	jmp    d37 <preempt+0x165>
+    return;
+  }
+  close(pfds[0]);
+     cb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+     cbc:	83 ec 0c             	sub    $0xc,%esp
+     cbf:	50                   	push   %eax
+     cc0:	e8 12 34 00 00       	call   40d7 <close>
+     cc5:	83 c4 10             	add    $0x10,%esp
+  printf(1, "kill... ");
+     cc8:	83 ec 08             	sub    $0x8,%esp
+     ccb:	68 1c 4b 00 00       	push   $0x4b1c
+     cd0:	6a 01                	push   $0x1
+     cd2:	e8 7c 35 00 00       	call   4253 <printf>
+     cd7:	83 c4 10             	add    $0x10,%esp
+  kill(pid1);
+     cda:	83 ec 0c             	sub    $0xc,%esp
+     cdd:	ff 75 f4             	pushl  -0xc(%ebp)
+     ce0:	e8 fa 33 00 00       	call   40df <kill>
+     ce5:	83 c4 10             	add    $0x10,%esp
+  kill(pid2);
+     ce8:	83 ec 0c             	sub    $0xc,%esp
+     ceb:	ff 75 f0             	pushl  -0x10(%ebp)
+     cee:	e8 ec 33 00 00       	call   40df <kill>
+     cf3:	83 c4 10             	add    $0x10,%esp
+  kill(pid3);
+     cf6:	83 ec 0c             	sub    $0xc,%esp
+     cf9:	ff 75 ec             	pushl  -0x14(%ebp)
+     cfc:	e8 de 33 00 00       	call   40df <kill>
+     d01:	83 c4 10             	add    $0x10,%esp
+  printf(1, "wait... ");
+     d04:	83 ec 08             	sub    $0x8,%esp
+     d07:	68 25 4b 00 00       	push   $0x4b25
+     d0c:	6a 01                	push   $0x1
+     d0e:	e8 40 35 00 00       	call   4253 <printf>
+     d13:	83 c4 10             	add    $0x10,%esp
+  wait();
+     d16:	e8 9c 33 00 00       	call   40b7 <wait>
+  wait();
+     d1b:	e8 97 33 00 00       	call   40b7 <wait>
+  wait();
+     d20:	e8 92 33 00 00       	call   40b7 <wait>
+  printf(1, "preempt ok\n");
+     d25:	83 ec 08             	sub    $0x8,%esp
+     d28:	68 2e 4b 00 00       	push   $0x4b2e
+     d2d:	6a 01                	push   $0x1
+     d2f:	e8 1f 35 00 00       	call   4253 <printf>
+     d34:	83 c4 10             	add    $0x10,%esp
+}
+     d37:	c9                   	leave  
+     d38:	c3                   	ret    
+
+00000d39 <exitwait>:
+
+// try to find any races between exit and wait
+void
+exitwait(void)
+{
+     d39:	f3 0f 1e fb          	endbr32 
+     d3d:	55                   	push   %ebp
+     d3e:	89 e5                	mov    %esp,%ebp
+     d40:	83 ec 18             	sub    $0x18,%esp
+  int i, pid;
+
+  for(i = 0; i < 100; i++){
+     d43:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     d4a:	eb 4f                	jmp    d9b <exitwait+0x62>
+    pid = fork();
+     d4c:	e8 56 33 00 00       	call   40a7 <fork>
+     d51:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(pid < 0){
+     d54:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     d58:	79 14                	jns    d6e <exitwait+0x35>
+      printf(1, "fork failed\n");
+     d5a:	83 ec 08             	sub    $0x8,%esp
+     d5d:	68 bd 46 00 00       	push   $0x46bd
+     d62:	6a 01                	push   $0x1
+     d64:	e8 ea 34 00 00       	call   4253 <printf>
+     d69:	83 c4 10             	add    $0x10,%esp
+      return;
+     d6c:	eb 45                	jmp    db3 <exitwait+0x7a>
+    }
+    if(pid){
+     d6e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+     d72:	74 1e                	je     d92 <exitwait+0x59>
+      if(wait() != pid){
+     d74:	e8 3e 33 00 00       	call   40b7 <wait>
+     d79:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+     d7c:	74 19                	je     d97 <exitwait+0x5e>
+        printf(1, "wait wrong pid\n");
+     d7e:	83 ec 08             	sub    $0x8,%esp
+     d81:	68 3a 4b 00 00       	push   $0x4b3a
+     d86:	6a 01                	push   $0x1
+     d88:	e8 c6 34 00 00       	call   4253 <printf>
+     d8d:	83 c4 10             	add    $0x10,%esp
+        return;
+     d90:	eb 21                	jmp    db3 <exitwait+0x7a>
+      }
+    } else {
+      exit();
+     d92:	e8 18 33 00 00       	call   40af <exit>
+  for(i = 0; i < 100; i++){
+     d97:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     d9b:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+     d9f:	7e ab                	jle    d4c <exitwait+0x13>
+    }
+  }
+  printf(1, "exitwait ok\n");
+     da1:	83 ec 08             	sub    $0x8,%esp
+     da4:	68 4a 4b 00 00       	push   $0x4b4a
+     da9:	6a 01                	push   $0x1
+     dab:	e8 a3 34 00 00       	call   4253 <printf>
+     db0:	83 c4 10             	add    $0x10,%esp
+}
+     db3:	c9                   	leave  
+     db4:	c3                   	ret    
+
+00000db5 <mem>:
+
+void
+mem(void)
+{
+     db5:	f3 0f 1e fb          	endbr32 
+     db9:	55                   	push   %ebp
+     dba:	89 e5                	mov    %esp,%ebp
+     dbc:	83 ec 18             	sub    $0x18,%esp
+  void *m1, *m2;
+  int pid, ppid;
+
+  printf(1, "mem test\n");
+     dbf:	83 ec 08             	sub    $0x8,%esp
+     dc2:	68 57 4b 00 00       	push   $0x4b57
+     dc7:	6a 01                	push   $0x1
+     dc9:	e8 85 34 00 00       	call   4253 <printf>
+     dce:	83 c4 10             	add    $0x10,%esp
+  ppid = getpid();
+     dd1:	e8 59 33 00 00       	call   412f <getpid>
+     dd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if((pid = fork()) == 0){
+     dd9:	e8 c9 32 00 00       	call   40a7 <fork>
+     dde:	89 45 ec             	mov    %eax,-0x14(%ebp)
+     de1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+     de5:	0f 85 b7 00 00 00    	jne    ea2 <mem+0xed>
+    m1 = 0;
+     deb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while((m2 = malloc(10001)) != 0){
+     df2:	eb 0e                	jmp    e02 <mem+0x4d>
+      *(char**)m2 = m1;
+     df4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     df7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+     dfa:	89 10                	mov    %edx,(%eax)
+      m1 = m2;
+     dfc:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     dff:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    while((m2 = malloc(10001)) != 0){
+     e02:	83 ec 0c             	sub    $0xc,%esp
+     e05:	68 11 27 00 00       	push   $0x2711
+     e0a:	e8 24 37 00 00       	call   4533 <malloc>
+     e0f:	83 c4 10             	add    $0x10,%esp
+     e12:	89 45 e8             	mov    %eax,-0x18(%ebp)
+     e15:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+     e19:	75 d9                	jne    df4 <mem+0x3f>
+    }
+    while(m1){
+     e1b:	eb 1c                	jmp    e39 <mem+0x84>
+      m2 = *(char**)m1;
+     e1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     e20:	8b 00                	mov    (%eax),%eax
+     e22:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      free(m1);
+     e25:	83 ec 0c             	sub    $0xc,%esp
+     e28:	ff 75 f4             	pushl  -0xc(%ebp)
+     e2b:	e8 b9 35 00 00       	call   43e9 <free>
+     e30:	83 c4 10             	add    $0x10,%esp
+      m1 = m2;
+     e33:	8b 45 e8             	mov    -0x18(%ebp),%eax
+     e36:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    while(m1){
+     e39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     e3d:	75 de                	jne    e1d <mem+0x68>
+    }
+    m1 = malloc(1024*20);
+     e3f:	83 ec 0c             	sub    $0xc,%esp
+     e42:	68 00 50 00 00       	push   $0x5000
+     e47:	e8 e7 36 00 00       	call   4533 <malloc>
+     e4c:	83 c4 10             	add    $0x10,%esp
+     e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(m1 == 0){
+     e52:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+     e56:	75 25                	jne    e7d <mem+0xc8>
+      printf(1, "couldn't allocate mem?!!\n");
+     e58:	83 ec 08             	sub    $0x8,%esp
+     e5b:	68 61 4b 00 00       	push   $0x4b61
+     e60:	6a 01                	push   $0x1
+     e62:	e8 ec 33 00 00       	call   4253 <printf>
+     e67:	83 c4 10             	add    $0x10,%esp
+      kill(ppid);
+     e6a:	83 ec 0c             	sub    $0xc,%esp
+     e6d:	ff 75 f0             	pushl  -0x10(%ebp)
+     e70:	e8 6a 32 00 00       	call   40df <kill>
+     e75:	83 c4 10             	add    $0x10,%esp
+      exit();
+     e78:	e8 32 32 00 00       	call   40af <exit>
+    }
+    free(m1);
+     e7d:	83 ec 0c             	sub    $0xc,%esp
+     e80:	ff 75 f4             	pushl  -0xc(%ebp)
+     e83:	e8 61 35 00 00       	call   43e9 <free>
+     e88:	83 c4 10             	add    $0x10,%esp
+    printf(1, "mem ok\n");
+     e8b:	83 ec 08             	sub    $0x8,%esp
+     e8e:	68 7b 4b 00 00       	push   $0x4b7b
+     e93:	6a 01                	push   $0x1
+     e95:	e8 b9 33 00 00       	call   4253 <printf>
+     e9a:	83 c4 10             	add    $0x10,%esp
+    exit();
+     e9d:	e8 0d 32 00 00       	call   40af <exit>
+  } else {
+    wait();
+     ea2:	e8 10 32 00 00       	call   40b7 <wait>
+  }
+}
+     ea7:	90                   	nop
+     ea8:	c9                   	leave  
+     ea9:	c3                   	ret    
+
+00000eaa <sharedfd>:
+
+// two processes write to the same file descriptor
+// is the offset shared? does inode locking work?
+void
+sharedfd(void)
+{
+     eaa:	f3 0f 1e fb          	endbr32 
+     eae:	55                   	push   %ebp
+     eaf:	89 e5                	mov    %esp,%ebp
+     eb1:	83 ec 38             	sub    $0x38,%esp
+  int fd, pid, i, n, nc, np;
+  char buf[10];
+
+  printf(1, "sharedfd test\n");
+     eb4:	83 ec 08             	sub    $0x8,%esp
+     eb7:	68 83 4b 00 00       	push   $0x4b83
+     ebc:	6a 01                	push   $0x1
+     ebe:	e8 90 33 00 00       	call   4253 <printf>
+     ec3:	83 c4 10             	add    $0x10,%esp
+
+  unlink("sharedfd");
+     ec6:	83 ec 0c             	sub    $0xc,%esp
+     ec9:	68 92 4b 00 00       	push   $0x4b92
+     ece:	e8 2c 32 00 00       	call   40ff <unlink>
+     ed3:	83 c4 10             	add    $0x10,%esp
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+     ed6:	83 ec 08             	sub    $0x8,%esp
+     ed9:	68 02 02 00 00       	push   $0x202
+     ede:	68 92 4b 00 00       	push   $0x4b92
+     ee3:	e8 07 32 00 00       	call   40ef <open>
+     ee8:	83 c4 10             	add    $0x10,%esp
+     eeb:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  if(fd < 0){
+     eee:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+     ef2:	79 17                	jns    f0b <sharedfd+0x61>
+    printf(1, "fstests: cannot open sharedfd for writing");
+     ef4:	83 ec 08             	sub    $0x8,%esp
+     ef7:	68 9c 4b 00 00       	push   $0x4b9c
+     efc:	6a 01                	push   $0x1
+     efe:	e8 50 33 00 00       	call   4253 <printf>
+     f03:	83 c4 10             	add    $0x10,%esp
+    return;
+     f06:	e9 84 01 00 00       	jmp    108f <sharedfd+0x1e5>
+  }
+  pid = fork();
+     f0b:	e8 97 31 00 00       	call   40a7 <fork>
+     f10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+     f13:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+     f17:	75 07                	jne    f20 <sharedfd+0x76>
+     f19:	b8 63 00 00 00       	mov    $0x63,%eax
+     f1e:	eb 05                	jmp    f25 <sharedfd+0x7b>
+     f20:	b8 70 00 00 00       	mov    $0x70,%eax
+     f25:	83 ec 04             	sub    $0x4,%esp
+     f28:	6a 0a                	push   $0xa
+     f2a:	50                   	push   %eax
+     f2b:	8d 45 d6             	lea    -0x2a(%ebp),%eax
+     f2e:	50                   	push   %eax
+     f2f:	e8 c8 2f 00 00       	call   3efc <memset>
+     f34:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 1000; i++){
+     f37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     f3e:	eb 31                	jmp    f71 <sharedfd+0xc7>
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+     f40:	83 ec 04             	sub    $0x4,%esp
+     f43:	6a 0a                	push   $0xa
+     f45:	8d 45 d6             	lea    -0x2a(%ebp),%eax
+     f48:	50                   	push   %eax
+     f49:	ff 75 e8             	pushl  -0x18(%ebp)
+     f4c:	e8 7e 31 00 00       	call   40cf <write>
+     f51:	83 c4 10             	add    $0x10,%esp
+     f54:	83 f8 0a             	cmp    $0xa,%eax
+     f57:	74 14                	je     f6d <sharedfd+0xc3>
+      printf(1, "fstests: write sharedfd failed\n");
+     f59:	83 ec 08             	sub    $0x8,%esp
+     f5c:	68 c8 4b 00 00       	push   $0x4bc8
+     f61:	6a 01                	push   $0x1
+     f63:	e8 eb 32 00 00       	call   4253 <printf>
+     f68:	83 c4 10             	add    $0x10,%esp
+      break;
+     f6b:	eb 0d                	jmp    f7a <sharedfd+0xd0>
+  for(i = 0; i < 1000; i++){
+     f6d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+     f71:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
+     f78:	7e c6                	jle    f40 <sharedfd+0x96>
+    }
+  }
+  if(pid == 0)
+     f7a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+     f7e:	75 05                	jne    f85 <sharedfd+0xdb>
+    exit();
+     f80:	e8 2a 31 00 00       	call   40af <exit>
+  else
+    wait();
+     f85:	e8 2d 31 00 00       	call   40b7 <wait>
+  close(fd);
+     f8a:	83 ec 0c             	sub    $0xc,%esp
+     f8d:	ff 75 e8             	pushl  -0x18(%ebp)
+     f90:	e8 42 31 00 00       	call   40d7 <close>
+     f95:	83 c4 10             	add    $0x10,%esp
+  fd = open("sharedfd", 0);
+     f98:	83 ec 08             	sub    $0x8,%esp
+     f9b:	6a 00                	push   $0x0
+     f9d:	68 92 4b 00 00       	push   $0x4b92
+     fa2:	e8 48 31 00 00       	call   40ef <open>
+     fa7:	83 c4 10             	add    $0x10,%esp
+     faa:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  if(fd < 0){
+     fad:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+     fb1:	79 17                	jns    fca <sharedfd+0x120>
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+     fb3:	83 ec 08             	sub    $0x8,%esp
+     fb6:	68 e8 4b 00 00       	push   $0x4be8
+     fbb:	6a 01                	push   $0x1
+     fbd:	e8 91 32 00 00       	call   4253 <printf>
+     fc2:	83 c4 10             	add    $0x10,%esp
+    return;
+     fc5:	e9 c5 00 00 00       	jmp    108f <sharedfd+0x1e5>
+  }
+  nc = np = 0;
+     fca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+     fd1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+     fd4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+     fd7:	eb 3b                	jmp    1014 <sharedfd+0x16a>
+    for(i = 0; i < sizeof(buf); i++){
+     fd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+     fe0:	eb 2a                	jmp    100c <sharedfd+0x162>
+      if(buf[i] == 'c')
+     fe2:	8d 55 d6             	lea    -0x2a(%ebp),%edx
+     fe5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     fe8:	01 d0                	add    %edx,%eax
+     fea:	0f b6 00             	movzbl (%eax),%eax
+     fed:	3c 63                	cmp    $0x63,%al
+     fef:	75 04                	jne    ff5 <sharedfd+0x14b>
+        nc++;
+     ff1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+      if(buf[i] == 'p')
+     ff5:	8d 55 d6             	lea    -0x2a(%ebp),%edx
+     ff8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+     ffb:	01 d0                	add    %edx,%eax
+     ffd:	0f b6 00             	movzbl (%eax),%eax
+    1000:	3c 70                	cmp    $0x70,%al
+    1002:	75 04                	jne    1008 <sharedfd+0x15e>
+        np++;
+    1004:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+    for(i = 0; i < sizeof(buf); i++){
+    1008:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    100c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    100f:	83 f8 09             	cmp    $0x9,%eax
+    1012:	76 ce                	jbe    fe2 <sharedfd+0x138>
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    1014:	83 ec 04             	sub    $0x4,%esp
+    1017:	6a 0a                	push   $0xa
+    1019:	8d 45 d6             	lea    -0x2a(%ebp),%eax
+    101c:	50                   	push   %eax
+    101d:	ff 75 e8             	pushl  -0x18(%ebp)
+    1020:	e8 a2 30 00 00       	call   40c7 <read>
+    1025:	83 c4 10             	add    $0x10,%esp
+    1028:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    102b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+    102f:	7f a8                	jg     fd9 <sharedfd+0x12f>
+    }
+  }
+  close(fd);
+    1031:	83 ec 0c             	sub    $0xc,%esp
+    1034:	ff 75 e8             	pushl  -0x18(%ebp)
+    1037:	e8 9b 30 00 00       	call   40d7 <close>
+    103c:	83 c4 10             	add    $0x10,%esp
+  unlink("sharedfd");
+    103f:	83 ec 0c             	sub    $0xc,%esp
+    1042:	68 92 4b 00 00       	push   $0x4b92
+    1047:	e8 b3 30 00 00       	call   40ff <unlink>
+    104c:	83 c4 10             	add    $0x10,%esp
+  if(nc == 10000 && np == 10000){
+    104f:	81 7d f0 10 27 00 00 	cmpl   $0x2710,-0x10(%ebp)
+    1056:	75 1d                	jne    1075 <sharedfd+0x1cb>
+    1058:	81 7d ec 10 27 00 00 	cmpl   $0x2710,-0x14(%ebp)
+    105f:	75 14                	jne    1075 <sharedfd+0x1cb>
+    printf(1, "sharedfd ok\n");
+    1061:	83 ec 08             	sub    $0x8,%esp
+    1064:	68 13 4c 00 00       	push   $0x4c13
+    1069:	6a 01                	push   $0x1
+    106b:	e8 e3 31 00 00       	call   4253 <printf>
+    1070:	83 c4 10             	add    $0x10,%esp
+    1073:	eb 1a                	jmp    108f <sharedfd+0x1e5>
+  } else {
+    printf(1, "sharedfd oops %d %d\n", nc, np);
+    1075:	ff 75 ec             	pushl  -0x14(%ebp)
+    1078:	ff 75 f0             	pushl  -0x10(%ebp)
+    107b:	68 20 4c 00 00       	push   $0x4c20
+    1080:	6a 01                	push   $0x1
+    1082:	e8 cc 31 00 00       	call   4253 <printf>
+    1087:	83 c4 10             	add    $0x10,%esp
+    exit();
+    108a:	e8 20 30 00 00       	call   40af <exit>
+  }
+}
+    108f:	c9                   	leave  
+    1090:	c3                   	ret    
+
+00001091 <fourfiles>:
+
+// four processes write different files at the same
+// time, to test block allocation.
+void
+fourfiles(void)
+{
+    1091:	f3 0f 1e fb          	endbr32 
+    1095:	55                   	push   %ebp
+    1096:	89 e5                	mov    %esp,%ebp
+    1098:	83 ec 38             	sub    $0x38,%esp
+  int fd, pid, i, j, n, total, pi;
+  char *names[] = { "f0", "f1", "f2", "f3" };
+    109b:	c7 45 c8 35 4c 00 00 	movl   $0x4c35,-0x38(%ebp)
+    10a2:	c7 45 cc 38 4c 00 00 	movl   $0x4c38,-0x34(%ebp)
+    10a9:	c7 45 d0 3b 4c 00 00 	movl   $0x4c3b,-0x30(%ebp)
+    10b0:	c7 45 d4 3e 4c 00 00 	movl   $0x4c3e,-0x2c(%ebp)
+  char *fname;
+
+  printf(1, "fourfiles test\n");
+    10b7:	83 ec 08             	sub    $0x8,%esp
+    10ba:	68 41 4c 00 00       	push   $0x4c41
+    10bf:	6a 01                	push   $0x1
+    10c1:	e8 8d 31 00 00       	call   4253 <printf>
+    10c6:	83 c4 10             	add    $0x10,%esp
+
+  for(pi = 0; pi < 4; pi++){
+    10c9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+    10d0:	e9 f0 00 00 00       	jmp    11c5 <fourfiles+0x134>
+    fname = names[pi];
+    10d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    10d8:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
+    10dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    unlink(fname);
+    10df:	83 ec 0c             	sub    $0xc,%esp
+    10e2:	ff 75 e4             	pushl  -0x1c(%ebp)
+    10e5:	e8 15 30 00 00       	call   40ff <unlink>
+    10ea:	83 c4 10             	add    $0x10,%esp
+
+    pid = fork();
+    10ed:	e8 b5 2f 00 00       	call   40a7 <fork>
+    10f2:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    if(pid < 0){
+    10f5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+    10f9:	79 17                	jns    1112 <fourfiles+0x81>
+      printf(1, "fork failed\n");
+    10fb:	83 ec 08             	sub    $0x8,%esp
+    10fe:	68 bd 46 00 00       	push   $0x46bd
+    1103:	6a 01                	push   $0x1
+    1105:	e8 49 31 00 00       	call   4253 <printf>
+    110a:	83 c4 10             	add    $0x10,%esp
+      exit();
+    110d:	e8 9d 2f 00 00       	call   40af <exit>
+    }
+
+    if(pid == 0){
+    1112:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+    1116:	0f 85 a5 00 00 00    	jne    11c1 <fourfiles+0x130>
+      fd = open(fname, O_CREATE | O_RDWR);
+    111c:	83 ec 08             	sub    $0x8,%esp
+    111f:	68 02 02 00 00       	push   $0x202
+    1124:	ff 75 e4             	pushl  -0x1c(%ebp)
+    1127:	e8 c3 2f 00 00       	call   40ef <open>
+    112c:	83 c4 10             	add    $0x10,%esp
+    112f:	89 45 e0             	mov    %eax,-0x20(%ebp)
+      if(fd < 0){
+    1132:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+    1136:	79 17                	jns    114f <fourfiles+0xbe>
+        printf(1, "create failed\n");
+    1138:	83 ec 08             	sub    $0x8,%esp
+    113b:	68 51 4c 00 00       	push   $0x4c51
+    1140:	6a 01                	push   $0x1
+    1142:	e8 0c 31 00 00       	call   4253 <printf>
+    1147:	83 c4 10             	add    $0x10,%esp
+        exit();
+    114a:	e8 60 2f 00 00       	call   40af <exit>
+      }
+
+      memset(buf, '0'+pi, 512);
+    114f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    1152:	83 c0 30             	add    $0x30,%eax
+    1155:	83 ec 04             	sub    $0x4,%esp
+    1158:	68 00 02 00 00       	push   $0x200
+    115d:	50                   	push   %eax
+    115e:	68 60 8d 00 00       	push   $0x8d60
+    1163:	e8 94 2d 00 00       	call   3efc <memset>
+    1168:	83 c4 10             	add    $0x10,%esp
+      for(i = 0; i < 12; i++){
+    116b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1172:	eb 42                	jmp    11b6 <fourfiles+0x125>
+        if((n = write(fd, buf, 500)) != 500){
+    1174:	83 ec 04             	sub    $0x4,%esp
+    1177:	68 f4 01 00 00       	push   $0x1f4
+    117c:	68 60 8d 00 00       	push   $0x8d60
+    1181:	ff 75 e0             	pushl  -0x20(%ebp)
+    1184:	e8 46 2f 00 00       	call   40cf <write>
+    1189:	83 c4 10             	add    $0x10,%esp
+    118c:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    118f:	81 7d dc f4 01 00 00 	cmpl   $0x1f4,-0x24(%ebp)
+    1196:	74 1a                	je     11b2 <fourfiles+0x121>
+          printf(1, "write failed %d\n", n);
+    1198:	83 ec 04             	sub    $0x4,%esp
+    119b:	ff 75 dc             	pushl  -0x24(%ebp)
+    119e:	68 60 4c 00 00       	push   $0x4c60
+    11a3:	6a 01                	push   $0x1
+    11a5:	e8 a9 30 00 00       	call   4253 <printf>
+    11aa:	83 c4 10             	add    $0x10,%esp
+          exit();
+    11ad:	e8 fd 2e 00 00       	call   40af <exit>
+      for(i = 0; i < 12; i++){
+    11b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    11b6:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
+    11ba:	7e b8                	jle    1174 <fourfiles+0xe3>
+        }
+      }
+      exit();
+    11bc:	e8 ee 2e 00 00       	call   40af <exit>
+  for(pi = 0; pi < 4; pi++){
+    11c1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+    11c5:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
+    11c9:	0f 8e 06 ff ff ff    	jle    10d5 <fourfiles+0x44>
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    11cf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+    11d6:	eb 09                	jmp    11e1 <fourfiles+0x150>
+    wait();
+    11d8:	e8 da 2e 00 00       	call   40b7 <wait>
+  for(pi = 0; pi < 4; pi++){
+    11dd:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+    11e1:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
+    11e5:	7e f1                	jle    11d8 <fourfiles+0x147>
+  }
+
+  for(i = 0; i < 2; i++){
+    11e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    11ee:	e9 d4 00 00 00       	jmp    12c7 <fourfiles+0x236>
+    fname = names[i];
+    11f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    11f6:	8b 44 85 c8          	mov    -0x38(%ebp,%eax,4),%eax
+    11fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    fd = open(fname, 0);
+    11fd:	83 ec 08             	sub    $0x8,%esp
+    1200:	6a 00                	push   $0x0
+    1202:	ff 75 e4             	pushl  -0x1c(%ebp)
+    1205:	e8 e5 2e 00 00       	call   40ef <open>
+    120a:	83 c4 10             	add    $0x10,%esp
+    120d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    total = 0;
+    1210:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    1217:	eb 4a                	jmp    1263 <fourfiles+0x1d2>
+      for(j = 0; j < n; j++){
+    1219:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    1220:	eb 33                	jmp    1255 <fourfiles+0x1c4>
+        if(buf[j] != '0'+i){
+    1222:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1225:	05 60 8d 00 00       	add    $0x8d60,%eax
+    122a:	0f b6 00             	movzbl (%eax),%eax
+    122d:	0f be c0             	movsbl %al,%eax
+    1230:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    1233:	83 c2 30             	add    $0x30,%edx
+    1236:	39 d0                	cmp    %edx,%eax
+    1238:	74 17                	je     1251 <fourfiles+0x1c0>
+          printf(1, "wrong char\n");
+    123a:	83 ec 08             	sub    $0x8,%esp
+    123d:	68 71 4c 00 00       	push   $0x4c71
+    1242:	6a 01                	push   $0x1
+    1244:	e8 0a 30 00 00       	call   4253 <printf>
+    1249:	83 c4 10             	add    $0x10,%esp
+          exit();
+    124c:	e8 5e 2e 00 00       	call   40af <exit>
+      for(j = 0; j < n; j++){
+    1251:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    1255:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1258:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+    125b:	7c c5                	jl     1222 <fourfiles+0x191>
+        }
+      }
+      total += n;
+    125d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+    1260:	01 45 ec             	add    %eax,-0x14(%ebp)
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    1263:	83 ec 04             	sub    $0x4,%esp
+    1266:	68 00 20 00 00       	push   $0x2000
+    126b:	68 60 8d 00 00       	push   $0x8d60
+    1270:	ff 75 e0             	pushl  -0x20(%ebp)
+    1273:	e8 4f 2e 00 00       	call   40c7 <read>
+    1278:	83 c4 10             	add    $0x10,%esp
+    127b:	89 45 dc             	mov    %eax,-0x24(%ebp)
+    127e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+    1282:	7f 95                	jg     1219 <fourfiles+0x188>
+    }
+    close(fd);
+    1284:	83 ec 0c             	sub    $0xc,%esp
+    1287:	ff 75 e0             	pushl  -0x20(%ebp)
+    128a:	e8 48 2e 00 00       	call   40d7 <close>
+    128f:	83 c4 10             	add    $0x10,%esp
+    if(total != 12*500){
+    1292:	81 7d ec 70 17 00 00 	cmpl   $0x1770,-0x14(%ebp)
+    1299:	74 1a                	je     12b5 <fourfiles+0x224>
+      printf(1, "wrong length %d\n", total);
+    129b:	83 ec 04             	sub    $0x4,%esp
+    129e:	ff 75 ec             	pushl  -0x14(%ebp)
+    12a1:	68 7d 4c 00 00       	push   $0x4c7d
+    12a6:	6a 01                	push   $0x1
+    12a8:	e8 a6 2f 00 00       	call   4253 <printf>
+    12ad:	83 c4 10             	add    $0x10,%esp
+      exit();
+    12b0:	e8 fa 2d 00 00       	call   40af <exit>
+    }
+    unlink(fname);
+    12b5:	83 ec 0c             	sub    $0xc,%esp
+    12b8:	ff 75 e4             	pushl  -0x1c(%ebp)
+    12bb:	e8 3f 2e 00 00       	call   40ff <unlink>
+    12c0:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 2; i++){
+    12c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    12c7:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
+    12cb:	0f 8e 22 ff ff ff    	jle    11f3 <fourfiles+0x162>
+  }
+
+  printf(1, "fourfiles ok\n");
+    12d1:	83 ec 08             	sub    $0x8,%esp
+    12d4:	68 8e 4c 00 00       	push   $0x4c8e
+    12d9:	6a 01                	push   $0x1
+    12db:	e8 73 2f 00 00       	call   4253 <printf>
+    12e0:	83 c4 10             	add    $0x10,%esp
+}
+    12e3:	90                   	nop
+    12e4:	c9                   	leave  
+    12e5:	c3                   	ret    
+
+000012e6 <createdelete>:
+
+// four processes create and delete different files in same directory
+void
+createdelete(void)
+{
+    12e6:	f3 0f 1e fb          	endbr32 
+    12ea:	55                   	push   %ebp
+    12eb:	89 e5                	mov    %esp,%ebp
+    12ed:	83 ec 38             	sub    $0x38,%esp
+  enum { N = 20 };
+  int pid, i, fd, pi;
+  char name[32];
+
+  printf(1, "createdelete test\n");
+    12f0:	83 ec 08             	sub    $0x8,%esp
+    12f3:	68 9c 4c 00 00       	push   $0x4c9c
+    12f8:	6a 01                	push   $0x1
+    12fa:	e8 54 2f 00 00       	call   4253 <printf>
+    12ff:	83 c4 10             	add    $0x10,%esp
+
+  for(pi = 0; pi < 4; pi++){
+    1302:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    1309:	e9 f6 00 00 00       	jmp    1404 <createdelete+0x11e>
+    pid = fork();
+    130e:	e8 94 2d 00 00       	call   40a7 <fork>
+    1313:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(pid < 0){
+    1316:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    131a:	79 17                	jns    1333 <createdelete+0x4d>
+      printf(1, "fork failed\n");
+    131c:	83 ec 08             	sub    $0x8,%esp
+    131f:	68 bd 46 00 00       	push   $0x46bd
+    1324:	6a 01                	push   $0x1
+    1326:	e8 28 2f 00 00       	call   4253 <printf>
+    132b:	83 c4 10             	add    $0x10,%esp
+      exit();
+    132e:	e8 7c 2d 00 00       	call   40af <exit>
+    }
+
+    if(pid == 0){
+    1333:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1337:	0f 85 c3 00 00 00    	jne    1400 <createdelete+0x11a>
+      name[0] = 'p' + pi;
+    133d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1340:	83 c0 70             	add    $0x70,%eax
+    1343:	88 45 c8             	mov    %al,-0x38(%ebp)
+      name[2] = '\0';
+    1346:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
+      for(i = 0; i < N; i++){
+    134a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1351:	e9 9b 00 00 00       	jmp    13f1 <createdelete+0x10b>
+        name[1] = '0' + i;
+    1356:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1359:	83 c0 30             	add    $0x30,%eax
+    135c:	88 45 c9             	mov    %al,-0x37(%ebp)
+        fd = open(name, O_CREATE | O_RDWR);
+    135f:	83 ec 08             	sub    $0x8,%esp
+    1362:	68 02 02 00 00       	push   $0x202
+    1367:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    136a:	50                   	push   %eax
+    136b:	e8 7f 2d 00 00       	call   40ef <open>
+    1370:	83 c4 10             	add    $0x10,%esp
+    1373:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        if(fd < 0){
+    1376:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    137a:	79 17                	jns    1393 <createdelete+0xad>
+          printf(1, "create failed\n");
+    137c:	83 ec 08             	sub    $0x8,%esp
+    137f:	68 51 4c 00 00       	push   $0x4c51
+    1384:	6a 01                	push   $0x1
+    1386:	e8 c8 2e 00 00       	call   4253 <printf>
+    138b:	83 c4 10             	add    $0x10,%esp
+          exit();
+    138e:	e8 1c 2d 00 00       	call   40af <exit>
+        }
+        close(fd);
+    1393:	83 ec 0c             	sub    $0xc,%esp
+    1396:	ff 75 ec             	pushl  -0x14(%ebp)
+    1399:	e8 39 2d 00 00       	call   40d7 <close>
+    139e:	83 c4 10             	add    $0x10,%esp
+        if(i > 0 && (i % 2 ) == 0){
+    13a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    13a5:	7e 46                	jle    13ed <createdelete+0x107>
+    13a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    13aa:	83 e0 01             	and    $0x1,%eax
+    13ad:	85 c0                	test   %eax,%eax
+    13af:	75 3c                	jne    13ed <createdelete+0x107>
+          name[1] = '0' + (i / 2);
+    13b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    13b4:	89 c2                	mov    %eax,%edx
+    13b6:	c1 ea 1f             	shr    $0x1f,%edx
+    13b9:	01 d0                	add    %edx,%eax
+    13bb:	d1 f8                	sar    %eax
+    13bd:	83 c0 30             	add    $0x30,%eax
+    13c0:	88 45 c9             	mov    %al,-0x37(%ebp)
+          if(unlink(name) < 0){
+    13c3:	83 ec 0c             	sub    $0xc,%esp
+    13c6:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    13c9:	50                   	push   %eax
+    13ca:	e8 30 2d 00 00       	call   40ff <unlink>
+    13cf:	83 c4 10             	add    $0x10,%esp
+    13d2:	85 c0                	test   %eax,%eax
+    13d4:	79 17                	jns    13ed <createdelete+0x107>
+            printf(1, "unlink failed\n");
+    13d6:	83 ec 08             	sub    $0x8,%esp
+    13d9:	68 40 47 00 00       	push   $0x4740
+    13de:	6a 01                	push   $0x1
+    13e0:	e8 6e 2e 00 00       	call   4253 <printf>
+    13e5:	83 c4 10             	add    $0x10,%esp
+            exit();
+    13e8:	e8 c2 2c 00 00       	call   40af <exit>
+      for(i = 0; i < N; i++){
+    13ed:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    13f1:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+    13f5:	0f 8e 5b ff ff ff    	jle    1356 <createdelete+0x70>
+          }
+        }
+      }
+      exit();
+    13fb:	e8 af 2c 00 00       	call   40af <exit>
+  for(pi = 0; pi < 4; pi++){
+    1400:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    1404:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
+    1408:	0f 8e 00 ff ff ff    	jle    130e <createdelete+0x28>
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    140e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    1415:	eb 09                	jmp    1420 <createdelete+0x13a>
+    wait();
+    1417:	e8 9b 2c 00 00       	call   40b7 <wait>
+  for(pi = 0; pi < 4; pi++){
+    141c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    1420:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
+    1424:	7e f1                	jle    1417 <createdelete+0x131>
+  }
+
+  name[0] = name[1] = name[2] = 0;
+    1426:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
+    142a:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
+    142e:	88 45 c9             	mov    %al,-0x37(%ebp)
+    1431:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
+    1435:	88 45 c8             	mov    %al,-0x38(%ebp)
+  for(i = 0; i < N; i++){
+    1438:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    143f:	e9 b2 00 00 00       	jmp    14f6 <createdelete+0x210>
+    for(pi = 0; pi < 4; pi++){
+    1444:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    144b:	e9 98 00 00 00       	jmp    14e8 <createdelete+0x202>
+      name[0] = 'p' + pi;
+    1450:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1453:	83 c0 70             	add    $0x70,%eax
+    1456:	88 45 c8             	mov    %al,-0x38(%ebp)
+      name[1] = '0' + i;
+    1459:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    145c:	83 c0 30             	add    $0x30,%eax
+    145f:	88 45 c9             	mov    %al,-0x37(%ebp)
+      fd = open(name, 0);
+    1462:	83 ec 08             	sub    $0x8,%esp
+    1465:	6a 00                	push   $0x0
+    1467:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    146a:	50                   	push   %eax
+    146b:	e8 7f 2c 00 00       	call   40ef <open>
+    1470:	83 c4 10             	add    $0x10,%esp
+    1473:	89 45 ec             	mov    %eax,-0x14(%ebp)
+      if((i == 0 || i >= N/2) && fd < 0){
+    1476:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    147a:	74 06                	je     1482 <createdelete+0x19c>
+    147c:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+    1480:	7e 21                	jle    14a3 <createdelete+0x1bd>
+    1482:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1486:	79 1b                	jns    14a3 <createdelete+0x1bd>
+        printf(1, "oops createdelete %s didn't exist\n", name);
+    1488:	83 ec 04             	sub    $0x4,%esp
+    148b:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    148e:	50                   	push   %eax
+    148f:	68 b0 4c 00 00       	push   $0x4cb0
+    1494:	6a 01                	push   $0x1
+    1496:	e8 b8 2d 00 00       	call   4253 <printf>
+    149b:	83 c4 10             	add    $0x10,%esp
+        exit();
+    149e:	e8 0c 2c 00 00       	call   40af <exit>
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    14a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    14a7:	7e 27                	jle    14d0 <createdelete+0x1ea>
+    14a9:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
+    14ad:	7f 21                	jg     14d0 <createdelete+0x1ea>
+    14af:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    14b3:	78 1b                	js     14d0 <createdelete+0x1ea>
+        printf(1, "oops createdelete %s did exist\n", name);
+    14b5:	83 ec 04             	sub    $0x4,%esp
+    14b8:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    14bb:	50                   	push   %eax
+    14bc:	68 d4 4c 00 00       	push   $0x4cd4
+    14c1:	6a 01                	push   $0x1
+    14c3:	e8 8b 2d 00 00       	call   4253 <printf>
+    14c8:	83 c4 10             	add    $0x10,%esp
+        exit();
+    14cb:	e8 df 2b 00 00       	call   40af <exit>
+      }
+      if(fd >= 0)
+    14d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    14d4:	78 0e                	js     14e4 <createdelete+0x1fe>
+        close(fd);
+    14d6:	83 ec 0c             	sub    $0xc,%esp
+    14d9:	ff 75 ec             	pushl  -0x14(%ebp)
+    14dc:	e8 f6 2b 00 00       	call   40d7 <close>
+    14e1:	83 c4 10             	add    $0x10,%esp
+    for(pi = 0; pi < 4; pi++){
+    14e4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    14e8:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
+    14ec:	0f 8e 5e ff ff ff    	jle    1450 <createdelete+0x16a>
+  for(i = 0; i < N; i++){
+    14f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    14f6:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+    14fa:	0f 8e 44 ff ff ff    	jle    1444 <createdelete+0x15e>
+    }
+  }
+
+  for(i = 0; i < N; i++){
+    1500:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1507:	eb 38                	jmp    1541 <createdelete+0x25b>
+    for(pi = 0; pi < 4; pi++){
+    1509:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    1510:	eb 25                	jmp    1537 <createdelete+0x251>
+      name[0] = 'p' + i;
+    1512:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1515:	83 c0 70             	add    $0x70,%eax
+    1518:	88 45 c8             	mov    %al,-0x38(%ebp)
+      name[1] = '0' + i;
+    151b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    151e:	83 c0 30             	add    $0x30,%eax
+    1521:	88 45 c9             	mov    %al,-0x37(%ebp)
+      unlink(name);
+    1524:	83 ec 0c             	sub    $0xc,%esp
+    1527:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    152a:	50                   	push   %eax
+    152b:	e8 cf 2b 00 00       	call   40ff <unlink>
+    1530:	83 c4 10             	add    $0x10,%esp
+    for(pi = 0; pi < 4; pi++){
+    1533:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    1537:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
+    153b:	7e d5                	jle    1512 <createdelete+0x22c>
+  for(i = 0; i < N; i++){
+    153d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1541:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+    1545:	7e c2                	jle    1509 <createdelete+0x223>
+    }
+  }
+
+  printf(1, "createdelete ok\n");
+    1547:	83 ec 08             	sub    $0x8,%esp
+    154a:	68 f4 4c 00 00       	push   $0x4cf4
+    154f:	6a 01                	push   $0x1
+    1551:	e8 fd 2c 00 00       	call   4253 <printf>
+    1556:	83 c4 10             	add    $0x10,%esp
+}
+    1559:	90                   	nop
+    155a:	c9                   	leave  
+    155b:	c3                   	ret    
+
+0000155c <unlinkread>:
+
+// can I unlink a file and still read it?
+void
+unlinkread(void)
+{
+    155c:	f3 0f 1e fb          	endbr32 
+    1560:	55                   	push   %ebp
+    1561:	89 e5                	mov    %esp,%ebp
+    1563:	83 ec 18             	sub    $0x18,%esp
+  int fd, fd1;
+
+  printf(1, "unlinkread test\n");
+    1566:	83 ec 08             	sub    $0x8,%esp
+    1569:	68 05 4d 00 00       	push   $0x4d05
+    156e:	6a 01                	push   $0x1
+    1570:	e8 de 2c 00 00       	call   4253 <printf>
+    1575:	83 c4 10             	add    $0x10,%esp
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+    1578:	83 ec 08             	sub    $0x8,%esp
+    157b:	68 02 02 00 00       	push   $0x202
+    1580:	68 16 4d 00 00       	push   $0x4d16
+    1585:	e8 65 2b 00 00       	call   40ef <open>
+    158a:	83 c4 10             	add    $0x10,%esp
+    158d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    1590:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1594:	79 17                	jns    15ad <unlinkread+0x51>
+    printf(1, "create unlinkread failed\n");
+    1596:	83 ec 08             	sub    $0x8,%esp
+    1599:	68 21 4d 00 00       	push   $0x4d21
+    159e:	6a 01                	push   $0x1
+    15a0:	e8 ae 2c 00 00       	call   4253 <printf>
+    15a5:	83 c4 10             	add    $0x10,%esp
+    exit();
+    15a8:	e8 02 2b 00 00       	call   40af <exit>
+  }
+  write(fd, "hello", 5);
+    15ad:	83 ec 04             	sub    $0x4,%esp
+    15b0:	6a 05                	push   $0x5
+    15b2:	68 3b 4d 00 00       	push   $0x4d3b
+    15b7:	ff 75 f4             	pushl  -0xc(%ebp)
+    15ba:	e8 10 2b 00 00       	call   40cf <write>
+    15bf:	83 c4 10             	add    $0x10,%esp
+  close(fd);
+    15c2:	83 ec 0c             	sub    $0xc,%esp
+    15c5:	ff 75 f4             	pushl  -0xc(%ebp)
+    15c8:	e8 0a 2b 00 00       	call   40d7 <close>
+    15cd:	83 c4 10             	add    $0x10,%esp
+
+  fd = open("unlinkread", O_RDWR);
+    15d0:	83 ec 08             	sub    $0x8,%esp
+    15d3:	6a 02                	push   $0x2
+    15d5:	68 16 4d 00 00       	push   $0x4d16
+    15da:	e8 10 2b 00 00       	call   40ef <open>
+    15df:	83 c4 10             	add    $0x10,%esp
+    15e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    15e5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    15e9:	79 17                	jns    1602 <unlinkread+0xa6>
+    printf(1, "open unlinkread failed\n");
+    15eb:	83 ec 08             	sub    $0x8,%esp
+    15ee:	68 41 4d 00 00       	push   $0x4d41
+    15f3:	6a 01                	push   $0x1
+    15f5:	e8 59 2c 00 00       	call   4253 <printf>
+    15fa:	83 c4 10             	add    $0x10,%esp
+    exit();
+    15fd:	e8 ad 2a 00 00       	call   40af <exit>
+  }
+  if(unlink("unlinkread") != 0){
+    1602:	83 ec 0c             	sub    $0xc,%esp
+    1605:	68 16 4d 00 00       	push   $0x4d16
+    160a:	e8 f0 2a 00 00       	call   40ff <unlink>
+    160f:	83 c4 10             	add    $0x10,%esp
+    1612:	85 c0                	test   %eax,%eax
+    1614:	74 17                	je     162d <unlinkread+0xd1>
+    printf(1, "unlink unlinkread failed\n");
+    1616:	83 ec 08             	sub    $0x8,%esp
+    1619:	68 59 4d 00 00       	push   $0x4d59
+    161e:	6a 01                	push   $0x1
+    1620:	e8 2e 2c 00 00       	call   4253 <printf>
+    1625:	83 c4 10             	add    $0x10,%esp
+    exit();
+    1628:	e8 82 2a 00 00       	call   40af <exit>
+  }
+
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+    162d:	83 ec 08             	sub    $0x8,%esp
+    1630:	68 02 02 00 00       	push   $0x202
+    1635:	68 16 4d 00 00       	push   $0x4d16
+    163a:	e8 b0 2a 00 00       	call   40ef <open>
+    163f:	83 c4 10             	add    $0x10,%esp
+    1642:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  write(fd1, "yyy", 3);
+    1645:	83 ec 04             	sub    $0x4,%esp
+    1648:	6a 03                	push   $0x3
+    164a:	68 73 4d 00 00       	push   $0x4d73
+    164f:	ff 75 f0             	pushl  -0x10(%ebp)
+    1652:	e8 78 2a 00 00       	call   40cf <write>
+    1657:	83 c4 10             	add    $0x10,%esp
+  close(fd1);
+    165a:	83 ec 0c             	sub    $0xc,%esp
+    165d:	ff 75 f0             	pushl  -0x10(%ebp)
+    1660:	e8 72 2a 00 00       	call   40d7 <close>
+    1665:	83 c4 10             	add    $0x10,%esp
+
+  if(read(fd, buf, sizeof(buf)) != 5){
+    1668:	83 ec 04             	sub    $0x4,%esp
+    166b:	68 00 20 00 00       	push   $0x2000
+    1670:	68 60 8d 00 00       	push   $0x8d60
+    1675:	ff 75 f4             	pushl  -0xc(%ebp)
+    1678:	e8 4a 2a 00 00       	call   40c7 <read>
+    167d:	83 c4 10             	add    $0x10,%esp
+    1680:	83 f8 05             	cmp    $0x5,%eax
+    1683:	74 17                	je     169c <unlinkread+0x140>
+    printf(1, "unlinkread read failed");
+    1685:	83 ec 08             	sub    $0x8,%esp
+    1688:	68 77 4d 00 00       	push   $0x4d77
+    168d:	6a 01                	push   $0x1
+    168f:	e8 bf 2b 00 00       	call   4253 <printf>
+    1694:	83 c4 10             	add    $0x10,%esp
+    exit();
+    1697:	e8 13 2a 00 00       	call   40af <exit>
+  }
+  if(buf[0] != 'h'){
+    169c:	0f b6 05 60 8d 00 00 	movzbl 0x8d60,%eax
+    16a3:	3c 68                	cmp    $0x68,%al
+    16a5:	74 17                	je     16be <unlinkread+0x162>
+    printf(1, "unlinkread wrong data\n");
+    16a7:	83 ec 08             	sub    $0x8,%esp
+    16aa:	68 8e 4d 00 00       	push   $0x4d8e
+    16af:	6a 01                	push   $0x1
+    16b1:	e8 9d 2b 00 00       	call   4253 <printf>
+    16b6:	83 c4 10             	add    $0x10,%esp
+    exit();
+    16b9:	e8 f1 29 00 00       	call   40af <exit>
+  }
+  if(write(fd, buf, 10) != 10){
+    16be:	83 ec 04             	sub    $0x4,%esp
+    16c1:	6a 0a                	push   $0xa
+    16c3:	68 60 8d 00 00       	push   $0x8d60
+    16c8:	ff 75 f4             	pushl  -0xc(%ebp)
+    16cb:	e8 ff 29 00 00       	call   40cf <write>
+    16d0:	83 c4 10             	add    $0x10,%esp
+    16d3:	83 f8 0a             	cmp    $0xa,%eax
+    16d6:	74 17                	je     16ef <unlinkread+0x193>
+    printf(1, "unlinkread write failed\n");
+    16d8:	83 ec 08             	sub    $0x8,%esp
+    16db:	68 a5 4d 00 00       	push   $0x4da5
+    16e0:	6a 01                	push   $0x1
+    16e2:	e8 6c 2b 00 00       	call   4253 <printf>
+    16e7:	83 c4 10             	add    $0x10,%esp
+    exit();
+    16ea:	e8 c0 29 00 00       	call   40af <exit>
+  }
+  close(fd);
+    16ef:	83 ec 0c             	sub    $0xc,%esp
+    16f2:	ff 75 f4             	pushl  -0xc(%ebp)
+    16f5:	e8 dd 29 00 00       	call   40d7 <close>
+    16fa:	83 c4 10             	add    $0x10,%esp
+  unlink("unlinkread");
+    16fd:	83 ec 0c             	sub    $0xc,%esp
+    1700:	68 16 4d 00 00       	push   $0x4d16
+    1705:	e8 f5 29 00 00       	call   40ff <unlink>
+    170a:	83 c4 10             	add    $0x10,%esp
+  printf(1, "unlinkread ok\n");
+    170d:	83 ec 08             	sub    $0x8,%esp
+    1710:	68 be 4d 00 00       	push   $0x4dbe
+    1715:	6a 01                	push   $0x1
+    1717:	e8 37 2b 00 00       	call   4253 <printf>
+    171c:	83 c4 10             	add    $0x10,%esp
+}
+    171f:	90                   	nop
+    1720:	c9                   	leave  
+    1721:	c3                   	ret    
+
+00001722 <linktest>:
+
+void
+linktest(void)
+{
+    1722:	f3 0f 1e fb          	endbr32 
+    1726:	55                   	push   %ebp
+    1727:	89 e5                	mov    %esp,%ebp
+    1729:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+
+  printf(1, "linktest\n");
+    172c:	83 ec 08             	sub    $0x8,%esp
+    172f:	68 cd 4d 00 00       	push   $0x4dcd
+    1734:	6a 01                	push   $0x1
+    1736:	e8 18 2b 00 00       	call   4253 <printf>
+    173b:	83 c4 10             	add    $0x10,%esp
+
+  unlink("lf1");
+    173e:	83 ec 0c             	sub    $0xc,%esp
+    1741:	68 d7 4d 00 00       	push   $0x4dd7
+    1746:	e8 b4 29 00 00       	call   40ff <unlink>
+    174b:	83 c4 10             	add    $0x10,%esp
+  unlink("lf2");
+    174e:	83 ec 0c             	sub    $0xc,%esp
+    1751:	68 db 4d 00 00       	push   $0x4ddb
+    1756:	e8 a4 29 00 00       	call   40ff <unlink>
+    175b:	83 c4 10             	add    $0x10,%esp
+
+  fd = open("lf1", O_CREATE|O_RDWR);
+    175e:	83 ec 08             	sub    $0x8,%esp
+    1761:	68 02 02 00 00       	push   $0x202
+    1766:	68 d7 4d 00 00       	push   $0x4dd7
+    176b:	e8 7f 29 00 00       	call   40ef <open>
+    1770:	83 c4 10             	add    $0x10,%esp
+    1773:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    1776:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    177a:	79 17                	jns    1793 <linktest+0x71>
+    printf(1, "create lf1 failed\n");
+    177c:	83 ec 08             	sub    $0x8,%esp
+    177f:	68 df 4d 00 00       	push   $0x4ddf
+    1784:	6a 01                	push   $0x1
+    1786:	e8 c8 2a 00 00       	call   4253 <printf>
+    178b:	83 c4 10             	add    $0x10,%esp
+    exit();
+    178e:	e8 1c 29 00 00       	call   40af <exit>
+  }
+  if(write(fd, "hello", 5) != 5){
+    1793:	83 ec 04             	sub    $0x4,%esp
+    1796:	6a 05                	push   $0x5
+    1798:	68 3b 4d 00 00       	push   $0x4d3b
+    179d:	ff 75 f4             	pushl  -0xc(%ebp)
+    17a0:	e8 2a 29 00 00       	call   40cf <write>
+    17a5:	83 c4 10             	add    $0x10,%esp
+    17a8:	83 f8 05             	cmp    $0x5,%eax
+    17ab:	74 17                	je     17c4 <linktest+0xa2>
+    printf(1, "write lf1 failed\n");
+    17ad:	83 ec 08             	sub    $0x8,%esp
+    17b0:	68 f2 4d 00 00       	push   $0x4df2
+    17b5:	6a 01                	push   $0x1
+    17b7:	e8 97 2a 00 00       	call   4253 <printf>
+    17bc:	83 c4 10             	add    $0x10,%esp
+    exit();
+    17bf:	e8 eb 28 00 00       	call   40af <exit>
+  }
+  close(fd);
+    17c4:	83 ec 0c             	sub    $0xc,%esp
+    17c7:	ff 75 f4             	pushl  -0xc(%ebp)
+    17ca:	e8 08 29 00 00       	call   40d7 <close>
+    17cf:	83 c4 10             	add    $0x10,%esp
+
+  if(link("lf1", "lf2") < 0){
+    17d2:	83 ec 08             	sub    $0x8,%esp
+    17d5:	68 db 4d 00 00       	push   $0x4ddb
+    17da:	68 d7 4d 00 00       	push   $0x4dd7
+    17df:	e8 2b 29 00 00       	call   410f <link>
+    17e4:	83 c4 10             	add    $0x10,%esp
+    17e7:	85 c0                	test   %eax,%eax
+    17e9:	79 17                	jns    1802 <linktest+0xe0>
+    printf(1, "link lf1 lf2 failed\n");
+    17eb:	83 ec 08             	sub    $0x8,%esp
+    17ee:	68 04 4e 00 00       	push   $0x4e04
+    17f3:	6a 01                	push   $0x1
+    17f5:	e8 59 2a 00 00       	call   4253 <printf>
+    17fa:	83 c4 10             	add    $0x10,%esp
+    exit();
+    17fd:	e8 ad 28 00 00       	call   40af <exit>
+  }
+  unlink("lf1");
+    1802:	83 ec 0c             	sub    $0xc,%esp
+    1805:	68 d7 4d 00 00       	push   $0x4dd7
+    180a:	e8 f0 28 00 00       	call   40ff <unlink>
+    180f:	83 c4 10             	add    $0x10,%esp
+
+  if(open("lf1", 0) >= 0){
+    1812:	83 ec 08             	sub    $0x8,%esp
+    1815:	6a 00                	push   $0x0
+    1817:	68 d7 4d 00 00       	push   $0x4dd7
+    181c:	e8 ce 28 00 00       	call   40ef <open>
+    1821:	83 c4 10             	add    $0x10,%esp
+    1824:	85 c0                	test   %eax,%eax
+    1826:	78 17                	js     183f <linktest+0x11d>
+    printf(1, "unlinked lf1 but it is still there!\n");
+    1828:	83 ec 08             	sub    $0x8,%esp
+    182b:	68 1c 4e 00 00       	push   $0x4e1c
+    1830:	6a 01                	push   $0x1
+    1832:	e8 1c 2a 00 00       	call   4253 <printf>
+    1837:	83 c4 10             	add    $0x10,%esp
+    exit();
+    183a:	e8 70 28 00 00       	call   40af <exit>
+  }
+
+  fd = open("lf2", 0);
+    183f:	83 ec 08             	sub    $0x8,%esp
+    1842:	6a 00                	push   $0x0
+    1844:	68 db 4d 00 00       	push   $0x4ddb
+    1849:	e8 a1 28 00 00       	call   40ef <open>
+    184e:	83 c4 10             	add    $0x10,%esp
+    1851:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    1854:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1858:	79 17                	jns    1871 <linktest+0x14f>
+    printf(1, "open lf2 failed\n");
+    185a:	83 ec 08             	sub    $0x8,%esp
+    185d:	68 41 4e 00 00       	push   $0x4e41
+    1862:	6a 01                	push   $0x1
+    1864:	e8 ea 29 00 00       	call   4253 <printf>
+    1869:	83 c4 10             	add    $0x10,%esp
+    exit();
+    186c:	e8 3e 28 00 00       	call   40af <exit>
+  }
+  if(read(fd, buf, sizeof(buf)) != 5){
+    1871:	83 ec 04             	sub    $0x4,%esp
+    1874:	68 00 20 00 00       	push   $0x2000
+    1879:	68 60 8d 00 00       	push   $0x8d60
+    187e:	ff 75 f4             	pushl  -0xc(%ebp)
+    1881:	e8 41 28 00 00       	call   40c7 <read>
+    1886:	83 c4 10             	add    $0x10,%esp
+    1889:	83 f8 05             	cmp    $0x5,%eax
+    188c:	74 17                	je     18a5 <linktest+0x183>
+    printf(1, "read lf2 failed\n");
+    188e:	83 ec 08             	sub    $0x8,%esp
+    1891:	68 52 4e 00 00       	push   $0x4e52
+    1896:	6a 01                	push   $0x1
+    1898:	e8 b6 29 00 00       	call   4253 <printf>
+    189d:	83 c4 10             	add    $0x10,%esp
+    exit();
+    18a0:	e8 0a 28 00 00       	call   40af <exit>
+  }
+  close(fd);
+    18a5:	83 ec 0c             	sub    $0xc,%esp
+    18a8:	ff 75 f4             	pushl  -0xc(%ebp)
+    18ab:	e8 27 28 00 00       	call   40d7 <close>
+    18b0:	83 c4 10             	add    $0x10,%esp
+
+  if(link("lf2", "lf2") >= 0){
+    18b3:	83 ec 08             	sub    $0x8,%esp
+    18b6:	68 db 4d 00 00       	push   $0x4ddb
+    18bb:	68 db 4d 00 00       	push   $0x4ddb
+    18c0:	e8 4a 28 00 00       	call   410f <link>
+    18c5:	83 c4 10             	add    $0x10,%esp
+    18c8:	85 c0                	test   %eax,%eax
+    18ca:	78 17                	js     18e3 <linktest+0x1c1>
+    printf(1, "link lf2 lf2 succeeded! oops\n");
+    18cc:	83 ec 08             	sub    $0x8,%esp
+    18cf:	68 63 4e 00 00       	push   $0x4e63
+    18d4:	6a 01                	push   $0x1
+    18d6:	e8 78 29 00 00       	call   4253 <printf>
+    18db:	83 c4 10             	add    $0x10,%esp
+    exit();
+    18de:	e8 cc 27 00 00       	call   40af <exit>
+  }
+
+  unlink("lf2");
+    18e3:	83 ec 0c             	sub    $0xc,%esp
+    18e6:	68 db 4d 00 00       	push   $0x4ddb
+    18eb:	e8 0f 28 00 00       	call   40ff <unlink>
+    18f0:	83 c4 10             	add    $0x10,%esp
+  if(link("lf2", "lf1") >= 0){
+    18f3:	83 ec 08             	sub    $0x8,%esp
+    18f6:	68 d7 4d 00 00       	push   $0x4dd7
+    18fb:	68 db 4d 00 00       	push   $0x4ddb
+    1900:	e8 0a 28 00 00       	call   410f <link>
+    1905:	83 c4 10             	add    $0x10,%esp
+    1908:	85 c0                	test   %eax,%eax
+    190a:	78 17                	js     1923 <linktest+0x201>
+    printf(1, "link non-existant succeeded! oops\n");
+    190c:	83 ec 08             	sub    $0x8,%esp
+    190f:	68 84 4e 00 00       	push   $0x4e84
+    1914:	6a 01                	push   $0x1
+    1916:	e8 38 29 00 00       	call   4253 <printf>
+    191b:	83 c4 10             	add    $0x10,%esp
+    exit();
+    191e:	e8 8c 27 00 00       	call   40af <exit>
+  }
+
+  if(link(".", "lf1") >= 0){
+    1923:	83 ec 08             	sub    $0x8,%esp
+    1926:	68 d7 4d 00 00       	push   $0x4dd7
+    192b:	68 a7 4e 00 00       	push   $0x4ea7
+    1930:	e8 da 27 00 00       	call   410f <link>
+    1935:	83 c4 10             	add    $0x10,%esp
+    1938:	85 c0                	test   %eax,%eax
+    193a:	78 17                	js     1953 <linktest+0x231>
+    printf(1, "link . lf1 succeeded! oops\n");
+    193c:	83 ec 08             	sub    $0x8,%esp
+    193f:	68 a9 4e 00 00       	push   $0x4ea9
+    1944:	6a 01                	push   $0x1
+    1946:	e8 08 29 00 00       	call   4253 <printf>
+    194b:	83 c4 10             	add    $0x10,%esp
+    exit();
+    194e:	e8 5c 27 00 00       	call   40af <exit>
+  }
+
+  printf(1, "linktest ok\n");
+    1953:	83 ec 08             	sub    $0x8,%esp
+    1956:	68 c5 4e 00 00       	push   $0x4ec5
+    195b:	6a 01                	push   $0x1
+    195d:	e8 f1 28 00 00       	call   4253 <printf>
+    1962:	83 c4 10             	add    $0x10,%esp
+}
+    1965:	90                   	nop
+    1966:	c9                   	leave  
+    1967:	c3                   	ret    
+
+00001968 <concreate>:
+
+// test concurrent create/link/unlink of the same file
+void
+concreate(void)
+{
+    1968:	f3 0f 1e fb          	endbr32 
+    196c:	55                   	push   %ebp
+    196d:	89 e5                	mov    %esp,%ebp
+    196f:	83 ec 58             	sub    $0x58,%esp
+  struct {
+    ushort inum;
+    char name[14];
+  } de;
+
+  printf(1, "concreate test\n");
+    1972:	83 ec 08             	sub    $0x8,%esp
+    1975:	68 d2 4e 00 00       	push   $0x4ed2
+    197a:	6a 01                	push   $0x1
+    197c:	e8 d2 28 00 00       	call   4253 <printf>
+    1981:	83 c4 10             	add    $0x10,%esp
+  file[0] = 'C';
+    1984:	c6 45 e5 43          	movb   $0x43,-0x1b(%ebp)
+  file[2] = '\0';
+    1988:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
+  for(i = 0; i < 40; i++){
+    198c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1993:	e9 fc 00 00 00       	jmp    1a94 <concreate+0x12c>
+    file[1] = '0' + i;
+    1998:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    199b:	83 c0 30             	add    $0x30,%eax
+    199e:	88 45 e6             	mov    %al,-0x1a(%ebp)
+    unlink(file);
+    19a1:	83 ec 0c             	sub    $0xc,%esp
+    19a4:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    19a7:	50                   	push   %eax
+    19a8:	e8 52 27 00 00       	call   40ff <unlink>
+    19ad:	83 c4 10             	add    $0x10,%esp
+    pid = fork();
+    19b0:	e8 f2 26 00 00       	call   40a7 <fork>
+    19b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(pid && (i % 3) == 1){
+    19b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    19bc:	74 3b                	je     19f9 <concreate+0x91>
+    19be:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    19c1:	ba 56 55 55 55       	mov    $0x55555556,%edx
+    19c6:	89 c8                	mov    %ecx,%eax
+    19c8:	f7 ea                	imul   %edx
+    19ca:	89 c8                	mov    %ecx,%eax
+    19cc:	c1 f8 1f             	sar    $0x1f,%eax
+    19cf:	29 c2                	sub    %eax,%edx
+    19d1:	89 d0                	mov    %edx,%eax
+    19d3:	01 c0                	add    %eax,%eax
+    19d5:	01 d0                	add    %edx,%eax
+    19d7:	29 c1                	sub    %eax,%ecx
+    19d9:	89 ca                	mov    %ecx,%edx
+    19db:	83 fa 01             	cmp    $0x1,%edx
+    19de:	75 19                	jne    19f9 <concreate+0x91>
+      link("C0", file);
+    19e0:	83 ec 08             	sub    $0x8,%esp
+    19e3:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    19e6:	50                   	push   %eax
+    19e7:	68 e2 4e 00 00       	push   $0x4ee2
+    19ec:	e8 1e 27 00 00       	call   410f <link>
+    19f1:	83 c4 10             	add    $0x10,%esp
+    19f4:	e9 87 00 00 00       	jmp    1a80 <concreate+0x118>
+    } else if(pid == 0 && (i % 5) == 1){
+    19f9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    19fd:	75 3b                	jne    1a3a <concreate+0xd2>
+    19ff:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    1a02:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    1a07:	89 c8                	mov    %ecx,%eax
+    1a09:	f7 ea                	imul   %edx
+    1a0b:	d1 fa                	sar    %edx
+    1a0d:	89 c8                	mov    %ecx,%eax
+    1a0f:	c1 f8 1f             	sar    $0x1f,%eax
+    1a12:	29 c2                	sub    %eax,%edx
+    1a14:	89 d0                	mov    %edx,%eax
+    1a16:	c1 e0 02             	shl    $0x2,%eax
+    1a19:	01 d0                	add    %edx,%eax
+    1a1b:	29 c1                	sub    %eax,%ecx
+    1a1d:	89 ca                	mov    %ecx,%edx
+    1a1f:	83 fa 01             	cmp    $0x1,%edx
+    1a22:	75 16                	jne    1a3a <concreate+0xd2>
+      link("C0", file);
+    1a24:	83 ec 08             	sub    $0x8,%esp
+    1a27:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1a2a:	50                   	push   %eax
+    1a2b:	68 e2 4e 00 00       	push   $0x4ee2
+    1a30:	e8 da 26 00 00       	call   410f <link>
+    1a35:	83 c4 10             	add    $0x10,%esp
+    1a38:	eb 46                	jmp    1a80 <concreate+0x118>
+    } else {
+      fd = open(file, O_CREATE | O_RDWR);
+    1a3a:	83 ec 08             	sub    $0x8,%esp
+    1a3d:	68 02 02 00 00       	push   $0x202
+    1a42:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1a45:	50                   	push   %eax
+    1a46:	e8 a4 26 00 00       	call   40ef <open>
+    1a4b:	83 c4 10             	add    $0x10,%esp
+    1a4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+      if(fd < 0){
+    1a51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1a55:	79 1b                	jns    1a72 <concreate+0x10a>
+        printf(1, "concreate create %s failed\n", file);
+    1a57:	83 ec 04             	sub    $0x4,%esp
+    1a5a:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1a5d:	50                   	push   %eax
+    1a5e:	68 e5 4e 00 00       	push   $0x4ee5
+    1a63:	6a 01                	push   $0x1
+    1a65:	e8 e9 27 00 00       	call   4253 <printf>
+    1a6a:	83 c4 10             	add    $0x10,%esp
+        exit();
+    1a6d:	e8 3d 26 00 00       	call   40af <exit>
+      }
+      close(fd);
+    1a72:	83 ec 0c             	sub    $0xc,%esp
+    1a75:	ff 75 ec             	pushl  -0x14(%ebp)
+    1a78:	e8 5a 26 00 00       	call   40d7 <close>
+    1a7d:	83 c4 10             	add    $0x10,%esp
+    }
+    if(pid == 0)
+    1a80:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1a84:	75 05                	jne    1a8b <concreate+0x123>
+      exit();
+    1a86:	e8 24 26 00 00       	call   40af <exit>
+    else
+      wait();
+    1a8b:	e8 27 26 00 00       	call   40b7 <wait>
+  for(i = 0; i < 40; i++){
+    1a90:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1a94:	83 7d f4 27          	cmpl   $0x27,-0xc(%ebp)
+    1a98:	0f 8e fa fe ff ff    	jle    1998 <concreate+0x30>
+  }
+
+  memset(fa, 0, sizeof(fa));
+    1a9e:	83 ec 04             	sub    $0x4,%esp
+    1aa1:	6a 28                	push   $0x28
+    1aa3:	6a 00                	push   $0x0
+    1aa5:	8d 45 bd             	lea    -0x43(%ebp),%eax
+    1aa8:	50                   	push   %eax
+    1aa9:	e8 4e 24 00 00       	call   3efc <memset>
+    1aae:	83 c4 10             	add    $0x10,%esp
+  fd = open(".", 0);
+    1ab1:	83 ec 08             	sub    $0x8,%esp
+    1ab4:	6a 00                	push   $0x0
+    1ab6:	68 a7 4e 00 00       	push   $0x4ea7
+    1abb:	e8 2f 26 00 00       	call   40ef <open>
+    1ac0:	83 c4 10             	add    $0x10,%esp
+    1ac3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  n = 0;
+    1ac6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  while(read(fd, &de, sizeof(de)) > 0){
+    1acd:	e9 93 00 00 00       	jmp    1b65 <concreate+0x1fd>
+    if(de.inum == 0)
+    1ad2:	0f b7 45 ac          	movzwl -0x54(%ebp),%eax
+    1ad6:	66 85 c0             	test   %ax,%ax
+    1ad9:	75 05                	jne    1ae0 <concreate+0x178>
+      continue;
+    1adb:	e9 85 00 00 00       	jmp    1b65 <concreate+0x1fd>
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+    1ae0:	0f b6 45 ae          	movzbl -0x52(%ebp),%eax
+    1ae4:	3c 43                	cmp    $0x43,%al
+    1ae6:	75 7d                	jne    1b65 <concreate+0x1fd>
+    1ae8:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
+    1aec:	84 c0                	test   %al,%al
+    1aee:	75 75                	jne    1b65 <concreate+0x1fd>
+      i = de.name[1] - '0';
+    1af0:	0f b6 45 af          	movzbl -0x51(%ebp),%eax
+    1af4:	0f be c0             	movsbl %al,%eax
+    1af7:	83 e8 30             	sub    $0x30,%eax
+    1afa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+      if(i < 0 || i >= sizeof(fa)){
+    1afd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    1b01:	78 08                	js     1b0b <concreate+0x1a3>
+    1b03:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1b06:	83 f8 27             	cmp    $0x27,%eax
+    1b09:	76 1e                	jbe    1b29 <concreate+0x1c1>
+        printf(1, "concreate weird file %s\n", de.name);
+    1b0b:	83 ec 04             	sub    $0x4,%esp
+    1b0e:	8d 45 ac             	lea    -0x54(%ebp),%eax
+    1b11:	83 c0 02             	add    $0x2,%eax
+    1b14:	50                   	push   %eax
+    1b15:	68 01 4f 00 00       	push   $0x4f01
+    1b1a:	6a 01                	push   $0x1
+    1b1c:	e8 32 27 00 00       	call   4253 <printf>
+    1b21:	83 c4 10             	add    $0x10,%esp
+        exit();
+    1b24:	e8 86 25 00 00       	call   40af <exit>
+      }
+      if(fa[i]){
+    1b29:	8d 55 bd             	lea    -0x43(%ebp),%edx
+    1b2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1b2f:	01 d0                	add    %edx,%eax
+    1b31:	0f b6 00             	movzbl (%eax),%eax
+    1b34:	84 c0                	test   %al,%al
+    1b36:	74 1e                	je     1b56 <concreate+0x1ee>
+        printf(1, "concreate duplicate file %s\n", de.name);
+    1b38:	83 ec 04             	sub    $0x4,%esp
+    1b3b:	8d 45 ac             	lea    -0x54(%ebp),%eax
+    1b3e:	83 c0 02             	add    $0x2,%eax
+    1b41:	50                   	push   %eax
+    1b42:	68 1a 4f 00 00       	push   $0x4f1a
+    1b47:	6a 01                	push   $0x1
+    1b49:	e8 05 27 00 00       	call   4253 <printf>
+    1b4e:	83 c4 10             	add    $0x10,%esp
+        exit();
+    1b51:	e8 59 25 00 00       	call   40af <exit>
+      }
+      fa[i] = 1;
+    1b56:	8d 55 bd             	lea    -0x43(%ebp),%edx
+    1b59:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1b5c:	01 d0                	add    %edx,%eax
+    1b5e:	c6 00 01             	movb   $0x1,(%eax)
+      n++;
+    1b61:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+  while(read(fd, &de, sizeof(de)) > 0){
+    1b65:	83 ec 04             	sub    $0x4,%esp
+    1b68:	6a 10                	push   $0x10
+    1b6a:	8d 45 ac             	lea    -0x54(%ebp),%eax
+    1b6d:	50                   	push   %eax
+    1b6e:	ff 75 ec             	pushl  -0x14(%ebp)
+    1b71:	e8 51 25 00 00       	call   40c7 <read>
+    1b76:	83 c4 10             	add    $0x10,%esp
+    1b79:	85 c0                	test   %eax,%eax
+    1b7b:	0f 8f 51 ff ff ff    	jg     1ad2 <concreate+0x16a>
+    }
+  }
+  close(fd);
+    1b81:	83 ec 0c             	sub    $0xc,%esp
+    1b84:	ff 75 ec             	pushl  -0x14(%ebp)
+    1b87:	e8 4b 25 00 00       	call   40d7 <close>
+    1b8c:	83 c4 10             	add    $0x10,%esp
+
+  if(n != 40){
+    1b8f:	83 7d f0 28          	cmpl   $0x28,-0x10(%ebp)
+    1b93:	74 17                	je     1bac <concreate+0x244>
+    printf(1, "concreate not enough files in directory listing\n");
+    1b95:	83 ec 08             	sub    $0x8,%esp
+    1b98:	68 38 4f 00 00       	push   $0x4f38
+    1b9d:	6a 01                	push   $0x1
+    1b9f:	e8 af 26 00 00       	call   4253 <printf>
+    1ba4:	83 c4 10             	add    $0x10,%esp
+    exit();
+    1ba7:	e8 03 25 00 00       	call   40af <exit>
+  }
+
+  for(i = 0; i < 40; i++){
+    1bac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1bb3:	e9 45 01 00 00       	jmp    1cfd <concreate+0x395>
+    file[1] = '0' + i;
+    1bb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1bbb:	83 c0 30             	add    $0x30,%eax
+    1bbe:	88 45 e6             	mov    %al,-0x1a(%ebp)
+    pid = fork();
+    1bc1:	e8 e1 24 00 00       	call   40a7 <fork>
+    1bc6:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(pid < 0){
+    1bc9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1bcd:	79 17                	jns    1be6 <concreate+0x27e>
+      printf(1, "fork failed\n");
+    1bcf:	83 ec 08             	sub    $0x8,%esp
+    1bd2:	68 bd 46 00 00       	push   $0x46bd
+    1bd7:	6a 01                	push   $0x1
+    1bd9:	e8 75 26 00 00       	call   4253 <printf>
+    1bde:	83 c4 10             	add    $0x10,%esp
+      exit();
+    1be1:	e8 c9 24 00 00       	call   40af <exit>
+    }
+    if(((i % 3) == 0 && pid == 0) ||
+    1be6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    1be9:	ba 56 55 55 55       	mov    $0x55555556,%edx
+    1bee:	89 c8                	mov    %ecx,%eax
+    1bf0:	f7 ea                	imul   %edx
+    1bf2:	89 c8                	mov    %ecx,%eax
+    1bf4:	c1 f8 1f             	sar    $0x1f,%eax
+    1bf7:	29 c2                	sub    %eax,%edx
+    1bf9:	89 d0                	mov    %edx,%eax
+    1bfb:	89 c2                	mov    %eax,%edx
+    1bfd:	01 d2                	add    %edx,%edx
+    1bff:	01 c2                	add    %eax,%edx
+    1c01:	89 c8                	mov    %ecx,%eax
+    1c03:	29 d0                	sub    %edx,%eax
+    1c05:	85 c0                	test   %eax,%eax
+    1c07:	75 06                	jne    1c0f <concreate+0x2a7>
+    1c09:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1c0d:	74 28                	je     1c37 <concreate+0x2cf>
+       ((i % 3) == 1 && pid != 0)){
+    1c0f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    1c12:	ba 56 55 55 55       	mov    $0x55555556,%edx
+    1c17:	89 c8                	mov    %ecx,%eax
+    1c19:	f7 ea                	imul   %edx
+    1c1b:	89 c8                	mov    %ecx,%eax
+    1c1d:	c1 f8 1f             	sar    $0x1f,%eax
+    1c20:	29 c2                	sub    %eax,%edx
+    1c22:	89 d0                	mov    %edx,%eax
+    1c24:	01 c0                	add    %eax,%eax
+    1c26:	01 d0                	add    %edx,%eax
+    1c28:	29 c1                	sub    %eax,%ecx
+    1c2a:	89 ca                	mov    %ecx,%edx
+    if(((i % 3) == 0 && pid == 0) ||
+    1c2c:	83 fa 01             	cmp    $0x1,%edx
+    1c2f:	75 7c                	jne    1cad <concreate+0x345>
+       ((i % 3) == 1 && pid != 0)){
+    1c31:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1c35:	74 76                	je     1cad <concreate+0x345>
+      close(open(file, 0));
+    1c37:	83 ec 08             	sub    $0x8,%esp
+    1c3a:	6a 00                	push   $0x0
+    1c3c:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c3f:	50                   	push   %eax
+    1c40:	e8 aa 24 00 00       	call   40ef <open>
+    1c45:	83 c4 10             	add    $0x10,%esp
+    1c48:	83 ec 0c             	sub    $0xc,%esp
+    1c4b:	50                   	push   %eax
+    1c4c:	e8 86 24 00 00       	call   40d7 <close>
+    1c51:	83 c4 10             	add    $0x10,%esp
+      close(open(file, 0));
+    1c54:	83 ec 08             	sub    $0x8,%esp
+    1c57:	6a 00                	push   $0x0
+    1c59:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c5c:	50                   	push   %eax
+    1c5d:	e8 8d 24 00 00       	call   40ef <open>
+    1c62:	83 c4 10             	add    $0x10,%esp
+    1c65:	83 ec 0c             	sub    $0xc,%esp
+    1c68:	50                   	push   %eax
+    1c69:	e8 69 24 00 00       	call   40d7 <close>
+    1c6e:	83 c4 10             	add    $0x10,%esp
+      close(open(file, 0));
+    1c71:	83 ec 08             	sub    $0x8,%esp
+    1c74:	6a 00                	push   $0x0
+    1c76:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c79:	50                   	push   %eax
+    1c7a:	e8 70 24 00 00       	call   40ef <open>
+    1c7f:	83 c4 10             	add    $0x10,%esp
+    1c82:	83 ec 0c             	sub    $0xc,%esp
+    1c85:	50                   	push   %eax
+    1c86:	e8 4c 24 00 00       	call   40d7 <close>
+    1c8b:	83 c4 10             	add    $0x10,%esp
+      close(open(file, 0));
+    1c8e:	83 ec 08             	sub    $0x8,%esp
+    1c91:	6a 00                	push   $0x0
+    1c93:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1c96:	50                   	push   %eax
+    1c97:	e8 53 24 00 00       	call   40ef <open>
+    1c9c:	83 c4 10             	add    $0x10,%esp
+    1c9f:	83 ec 0c             	sub    $0xc,%esp
+    1ca2:	50                   	push   %eax
+    1ca3:	e8 2f 24 00 00       	call   40d7 <close>
+    1ca8:	83 c4 10             	add    $0x10,%esp
+    1cab:	eb 3c                	jmp    1ce9 <concreate+0x381>
+    } else {
+      unlink(file);
+    1cad:	83 ec 0c             	sub    $0xc,%esp
+    1cb0:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1cb3:	50                   	push   %eax
+    1cb4:	e8 46 24 00 00       	call   40ff <unlink>
+    1cb9:	83 c4 10             	add    $0x10,%esp
+      unlink(file);
+    1cbc:	83 ec 0c             	sub    $0xc,%esp
+    1cbf:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1cc2:	50                   	push   %eax
+    1cc3:	e8 37 24 00 00       	call   40ff <unlink>
+    1cc8:	83 c4 10             	add    $0x10,%esp
+      unlink(file);
+    1ccb:	83 ec 0c             	sub    $0xc,%esp
+    1cce:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1cd1:	50                   	push   %eax
+    1cd2:	e8 28 24 00 00       	call   40ff <unlink>
+    1cd7:	83 c4 10             	add    $0x10,%esp
+      unlink(file);
+    1cda:	83 ec 0c             	sub    $0xc,%esp
+    1cdd:	8d 45 e5             	lea    -0x1b(%ebp),%eax
+    1ce0:	50                   	push   %eax
+    1ce1:	e8 19 24 00 00       	call   40ff <unlink>
+    1ce6:	83 c4 10             	add    $0x10,%esp
+    }
+    if(pid == 0)
+    1ce9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    1ced:	75 05                	jne    1cf4 <concreate+0x38c>
+      exit();
+    1cef:	e8 bb 23 00 00       	call   40af <exit>
+    else
+      wait();
+    1cf4:	e8 be 23 00 00       	call   40b7 <wait>
+  for(i = 0; i < 40; i++){
+    1cf9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1cfd:	83 7d f4 27          	cmpl   $0x27,-0xc(%ebp)
+    1d01:	0f 8e b1 fe ff ff    	jle    1bb8 <concreate+0x250>
+  }
+
+  printf(1, "concreate ok\n");
+    1d07:	83 ec 08             	sub    $0x8,%esp
+    1d0a:	68 69 4f 00 00       	push   $0x4f69
+    1d0f:	6a 01                	push   $0x1
+    1d11:	e8 3d 25 00 00       	call   4253 <printf>
+    1d16:	83 c4 10             	add    $0x10,%esp
+}
+    1d19:	90                   	nop
+    1d1a:	c9                   	leave  
+    1d1b:	c3                   	ret    
+
+00001d1c <linkunlink>:
+
+// another concurrent link/unlink/create test,
+// to look for deadlocks.
+void
+linkunlink()
+{
+    1d1c:	f3 0f 1e fb          	endbr32 
+    1d20:	55                   	push   %ebp
+    1d21:	89 e5                	mov    %esp,%ebp
+    1d23:	83 ec 18             	sub    $0x18,%esp
+  int pid, i;
+
+  printf(1, "linkunlink test\n");
+    1d26:	83 ec 08             	sub    $0x8,%esp
+    1d29:	68 77 4f 00 00       	push   $0x4f77
+    1d2e:	6a 01                	push   $0x1
+    1d30:	e8 1e 25 00 00       	call   4253 <printf>
+    1d35:	83 c4 10             	add    $0x10,%esp
+
+  unlink("x");
+    1d38:	83 ec 0c             	sub    $0xc,%esp
+    1d3b:	68 f3 4a 00 00       	push   $0x4af3
+    1d40:	e8 ba 23 00 00       	call   40ff <unlink>
+    1d45:	83 c4 10             	add    $0x10,%esp
+  pid = fork();
+    1d48:	e8 5a 23 00 00       	call   40a7 <fork>
+    1d4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(pid < 0){
+    1d50:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1d54:	79 17                	jns    1d6d <linkunlink+0x51>
+    printf(1, "fork failed\n");
+    1d56:	83 ec 08             	sub    $0x8,%esp
+    1d59:	68 bd 46 00 00       	push   $0x46bd
+    1d5e:	6a 01                	push   $0x1
+    1d60:	e8 ee 24 00 00       	call   4253 <printf>
+    1d65:	83 c4 10             	add    $0x10,%esp
+    exit();
+    1d68:	e8 42 23 00 00       	call   40af <exit>
+  }
+
+  unsigned int x = (pid ? 1 : 97);
+    1d6d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1d71:	74 07                	je     1d7a <linkunlink+0x5e>
+    1d73:	b8 01 00 00 00       	mov    $0x1,%eax
+    1d78:	eb 05                	jmp    1d7f <linkunlink+0x63>
+    1d7a:	b8 61 00 00 00       	mov    $0x61,%eax
+    1d7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  for(i = 0; i < 100; i++){
+    1d82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1d89:	e9 9a 00 00 00       	jmp    1e28 <linkunlink+0x10c>
+    x = x * 1103515245 + 12345;
+    1d8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    1d91:	69 c0 6d 4e c6 41    	imul   $0x41c64e6d,%eax,%eax
+    1d97:	05 39 30 00 00       	add    $0x3039,%eax
+    1d9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if((x % 3) == 0){
+    1d9f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+    1da2:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
+    1da7:	89 c8                	mov    %ecx,%eax
+    1da9:	f7 e2                	mul    %edx
+    1dab:	89 d0                	mov    %edx,%eax
+    1dad:	d1 e8                	shr    %eax
+    1daf:	89 c2                	mov    %eax,%edx
+    1db1:	01 d2                	add    %edx,%edx
+    1db3:	01 c2                	add    %eax,%edx
+    1db5:	89 c8                	mov    %ecx,%eax
+    1db7:	29 d0                	sub    %edx,%eax
+    1db9:	85 c0                	test   %eax,%eax
+    1dbb:	75 23                	jne    1de0 <linkunlink+0xc4>
+      close(open("x", O_RDWR | O_CREATE));
+    1dbd:	83 ec 08             	sub    $0x8,%esp
+    1dc0:	68 02 02 00 00       	push   $0x202
+    1dc5:	68 f3 4a 00 00       	push   $0x4af3
+    1dca:	e8 20 23 00 00       	call   40ef <open>
+    1dcf:	83 c4 10             	add    $0x10,%esp
+    1dd2:	83 ec 0c             	sub    $0xc,%esp
+    1dd5:	50                   	push   %eax
+    1dd6:	e8 fc 22 00 00       	call   40d7 <close>
+    1ddb:	83 c4 10             	add    $0x10,%esp
+    1dde:	eb 44                	jmp    1e24 <linkunlink+0x108>
+    } else if((x % 3) == 1){
+    1de0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+    1de3:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
+    1de8:	89 c8                	mov    %ecx,%eax
+    1dea:	f7 e2                	mul    %edx
+    1dec:	d1 ea                	shr    %edx
+    1dee:	89 d0                	mov    %edx,%eax
+    1df0:	01 c0                	add    %eax,%eax
+    1df2:	01 d0                	add    %edx,%eax
+    1df4:	29 c1                	sub    %eax,%ecx
+    1df6:	89 ca                	mov    %ecx,%edx
+    1df8:	83 fa 01             	cmp    $0x1,%edx
+    1dfb:	75 17                	jne    1e14 <linkunlink+0xf8>
+      link("cat", "x");
+    1dfd:	83 ec 08             	sub    $0x8,%esp
+    1e00:	68 f3 4a 00 00       	push   $0x4af3
+    1e05:	68 88 4f 00 00       	push   $0x4f88
+    1e0a:	e8 00 23 00 00       	call   410f <link>
+    1e0f:	83 c4 10             	add    $0x10,%esp
+    1e12:	eb 10                	jmp    1e24 <linkunlink+0x108>
+    } else {
+      unlink("x");
+    1e14:	83 ec 0c             	sub    $0xc,%esp
+    1e17:	68 f3 4a 00 00       	push   $0x4af3
+    1e1c:	e8 de 22 00 00       	call   40ff <unlink>
+    1e21:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 100; i++){
+    1e24:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1e28:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+    1e2c:	0f 8e 5c ff ff ff    	jle    1d8e <linkunlink+0x72>
+    }
+  }
+
+  if(pid)
+    1e32:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    1e36:	74 07                	je     1e3f <linkunlink+0x123>
+    wait();
+    1e38:	e8 7a 22 00 00       	call   40b7 <wait>
+    1e3d:	eb 05                	jmp    1e44 <linkunlink+0x128>
+  else
+    exit();
+    1e3f:	e8 6b 22 00 00       	call   40af <exit>
+
+  printf(1, "linkunlink ok\n");
+    1e44:	83 ec 08             	sub    $0x8,%esp
+    1e47:	68 8c 4f 00 00       	push   $0x4f8c
+    1e4c:	6a 01                	push   $0x1
+    1e4e:	e8 00 24 00 00       	call   4253 <printf>
+    1e53:	83 c4 10             	add    $0x10,%esp
+}
+    1e56:	90                   	nop
+    1e57:	c9                   	leave  
+    1e58:	c3                   	ret    
+
+00001e59 <bigdir>:
+
+// directory that uses indirect blocks
+void
+bigdir(void)
+{
+    1e59:	f3 0f 1e fb          	endbr32 
+    1e5d:	55                   	push   %ebp
+    1e5e:	89 e5                	mov    %esp,%ebp
+    1e60:	83 ec 28             	sub    $0x28,%esp
+  int i, fd;
+  char name[10];
+
+  printf(1, "bigdir test\n");
+    1e63:	83 ec 08             	sub    $0x8,%esp
+    1e66:	68 9b 4f 00 00       	push   $0x4f9b
+    1e6b:	6a 01                	push   $0x1
+    1e6d:	e8 e1 23 00 00       	call   4253 <printf>
+    1e72:	83 c4 10             	add    $0x10,%esp
+  unlink("bd");
+    1e75:	83 ec 0c             	sub    $0xc,%esp
+    1e78:	68 a8 4f 00 00       	push   $0x4fa8
+    1e7d:	e8 7d 22 00 00       	call   40ff <unlink>
+    1e82:	83 c4 10             	add    $0x10,%esp
+
+  fd = open("bd", O_CREATE);
+    1e85:	83 ec 08             	sub    $0x8,%esp
+    1e88:	68 00 02 00 00       	push   $0x200
+    1e8d:	68 a8 4f 00 00       	push   $0x4fa8
+    1e92:	e8 58 22 00 00       	call   40ef <open>
+    1e97:	83 c4 10             	add    $0x10,%esp
+    1e9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(fd < 0){
+    1e9d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    1ea1:	79 17                	jns    1eba <bigdir+0x61>
+    printf(1, "bigdir create failed\n");
+    1ea3:	83 ec 08             	sub    $0x8,%esp
+    1ea6:	68 ab 4f 00 00       	push   $0x4fab
+    1eab:	6a 01                	push   $0x1
+    1ead:	e8 a1 23 00 00       	call   4253 <printf>
+    1eb2:	83 c4 10             	add    $0x10,%esp
+    exit();
+    1eb5:	e8 f5 21 00 00       	call   40af <exit>
+  }
+  close(fd);
+    1eba:	83 ec 0c             	sub    $0xc,%esp
+    1ebd:	ff 75 f0             	pushl  -0x10(%ebp)
+    1ec0:	e8 12 22 00 00       	call   40d7 <close>
+    1ec5:	83 c4 10             	add    $0x10,%esp
+
+  for(i = 0; i < 500; i++){
+    1ec8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1ecf:	eb 63                	jmp    1f34 <bigdir+0xdb>
+    name[0] = 'x';
+    1ed1:	c6 45 e6 78          	movb   $0x78,-0x1a(%ebp)
+    name[1] = '0' + (i / 64);
+    1ed5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1ed8:	8d 50 3f             	lea    0x3f(%eax),%edx
+    1edb:	85 c0                	test   %eax,%eax
+    1edd:	0f 48 c2             	cmovs  %edx,%eax
+    1ee0:	c1 f8 06             	sar    $0x6,%eax
+    1ee3:	83 c0 30             	add    $0x30,%eax
+    1ee6:	88 45 e7             	mov    %al,-0x19(%ebp)
+    name[2] = '0' + (i % 64);
+    1ee9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1eec:	99                   	cltd   
+    1eed:	c1 ea 1a             	shr    $0x1a,%edx
+    1ef0:	01 d0                	add    %edx,%eax
+    1ef2:	83 e0 3f             	and    $0x3f,%eax
+    1ef5:	29 d0                	sub    %edx,%eax
+    1ef7:	83 c0 30             	add    $0x30,%eax
+    1efa:	88 45 e8             	mov    %al,-0x18(%ebp)
+    name[3] = '\0';
+    1efd:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
+    if(link("bd", name) != 0){
+    1f01:	83 ec 08             	sub    $0x8,%esp
+    1f04:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    1f07:	50                   	push   %eax
+    1f08:	68 a8 4f 00 00       	push   $0x4fa8
+    1f0d:	e8 fd 21 00 00       	call   410f <link>
+    1f12:	83 c4 10             	add    $0x10,%esp
+    1f15:	85 c0                	test   %eax,%eax
+    1f17:	74 17                	je     1f30 <bigdir+0xd7>
+      printf(1, "bigdir link failed\n");
+    1f19:	83 ec 08             	sub    $0x8,%esp
+    1f1c:	68 c1 4f 00 00       	push   $0x4fc1
+    1f21:	6a 01                	push   $0x1
+    1f23:	e8 2b 23 00 00       	call   4253 <printf>
+    1f28:	83 c4 10             	add    $0x10,%esp
+      exit();
+    1f2b:	e8 7f 21 00 00       	call   40af <exit>
+  for(i = 0; i < 500; i++){
+    1f30:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1f34:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
+    1f3b:	7e 94                	jle    1ed1 <bigdir+0x78>
+    }
+  }
+
+  unlink("bd");
+    1f3d:	83 ec 0c             	sub    $0xc,%esp
+    1f40:	68 a8 4f 00 00       	push   $0x4fa8
+    1f45:	e8 b5 21 00 00       	call   40ff <unlink>
+    1f4a:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 500; i++){
+    1f4d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    1f54:	eb 5e                	jmp    1fb4 <bigdir+0x15b>
+    name[0] = 'x';
+    1f56:	c6 45 e6 78          	movb   $0x78,-0x1a(%ebp)
+    name[1] = '0' + (i / 64);
+    1f5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1f5d:	8d 50 3f             	lea    0x3f(%eax),%edx
+    1f60:	85 c0                	test   %eax,%eax
+    1f62:	0f 48 c2             	cmovs  %edx,%eax
+    1f65:	c1 f8 06             	sar    $0x6,%eax
+    1f68:	83 c0 30             	add    $0x30,%eax
+    1f6b:	88 45 e7             	mov    %al,-0x19(%ebp)
+    name[2] = '0' + (i % 64);
+    1f6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    1f71:	99                   	cltd   
+    1f72:	c1 ea 1a             	shr    $0x1a,%edx
+    1f75:	01 d0                	add    %edx,%eax
+    1f77:	83 e0 3f             	and    $0x3f,%eax
+    1f7a:	29 d0                	sub    %edx,%eax
+    1f7c:	83 c0 30             	add    $0x30,%eax
+    1f7f:	88 45 e8             	mov    %al,-0x18(%ebp)
+    name[3] = '\0';
+    1f82:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
+    if(unlink(name) != 0){
+    1f86:	83 ec 0c             	sub    $0xc,%esp
+    1f89:	8d 45 e6             	lea    -0x1a(%ebp),%eax
+    1f8c:	50                   	push   %eax
+    1f8d:	e8 6d 21 00 00       	call   40ff <unlink>
+    1f92:	83 c4 10             	add    $0x10,%esp
+    1f95:	85 c0                	test   %eax,%eax
+    1f97:	74 17                	je     1fb0 <bigdir+0x157>
+      printf(1, "bigdir unlink failed");
+    1f99:	83 ec 08             	sub    $0x8,%esp
+    1f9c:	68 d5 4f 00 00       	push   $0x4fd5
+    1fa1:	6a 01                	push   $0x1
+    1fa3:	e8 ab 22 00 00       	call   4253 <printf>
+    1fa8:	83 c4 10             	add    $0x10,%esp
+      exit();
+    1fab:	e8 ff 20 00 00       	call   40af <exit>
+  for(i = 0; i < 500; i++){
+    1fb0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    1fb4:	81 7d f4 f3 01 00 00 	cmpl   $0x1f3,-0xc(%ebp)
+    1fbb:	7e 99                	jle    1f56 <bigdir+0xfd>
+    }
+  }
+
+  printf(1, "bigdir ok\n");
+    1fbd:	83 ec 08             	sub    $0x8,%esp
+    1fc0:	68 ea 4f 00 00       	push   $0x4fea
+    1fc5:	6a 01                	push   $0x1
+    1fc7:	e8 87 22 00 00       	call   4253 <printf>
+    1fcc:	83 c4 10             	add    $0x10,%esp
+}
+    1fcf:	90                   	nop
+    1fd0:	c9                   	leave  
+    1fd1:	c3                   	ret    
+
+00001fd2 <subdir>:
+
+void
+subdir(void)
+{
+    1fd2:	f3 0f 1e fb          	endbr32 
+    1fd6:	55                   	push   %ebp
+    1fd7:	89 e5                	mov    %esp,%ebp
+    1fd9:	83 ec 18             	sub    $0x18,%esp
+  int fd, cc;
+
+  printf(1, "subdir test\n");
+    1fdc:	83 ec 08             	sub    $0x8,%esp
+    1fdf:	68 f5 4f 00 00       	push   $0x4ff5
+    1fe4:	6a 01                	push   $0x1
+    1fe6:	e8 68 22 00 00       	call   4253 <printf>
+    1feb:	83 c4 10             	add    $0x10,%esp
+
+  unlink("ff");
+    1fee:	83 ec 0c             	sub    $0xc,%esp
+    1ff1:	68 02 50 00 00       	push   $0x5002
+    1ff6:	e8 04 21 00 00       	call   40ff <unlink>
+    1ffb:	83 c4 10             	add    $0x10,%esp
+  if(mkdir("dd") != 0){
+    1ffe:	83 ec 0c             	sub    $0xc,%esp
+    2001:	68 05 50 00 00       	push   $0x5005
+    2006:	e8 0c 21 00 00       	call   4117 <mkdir>
+    200b:	83 c4 10             	add    $0x10,%esp
+    200e:	85 c0                	test   %eax,%eax
+    2010:	74 17                	je     2029 <subdir+0x57>
+    printf(1, "subdir mkdir dd failed\n");
+    2012:	83 ec 08             	sub    $0x8,%esp
+    2015:	68 08 50 00 00       	push   $0x5008
+    201a:	6a 01                	push   $0x1
+    201c:	e8 32 22 00 00       	call   4253 <printf>
+    2021:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2024:	e8 86 20 00 00       	call   40af <exit>
+  }
+
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+    2029:	83 ec 08             	sub    $0x8,%esp
+    202c:	68 02 02 00 00       	push   $0x202
+    2031:	68 20 50 00 00       	push   $0x5020
+    2036:	e8 b4 20 00 00       	call   40ef <open>
+    203b:	83 c4 10             	add    $0x10,%esp
+    203e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    2041:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2045:	79 17                	jns    205e <subdir+0x8c>
+    printf(1, "create dd/ff failed\n");
+    2047:	83 ec 08             	sub    $0x8,%esp
+    204a:	68 26 50 00 00       	push   $0x5026
+    204f:	6a 01                	push   $0x1
+    2051:	e8 fd 21 00 00       	call   4253 <printf>
+    2056:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2059:	e8 51 20 00 00       	call   40af <exit>
+  }
+  write(fd, "ff", 2);
+    205e:	83 ec 04             	sub    $0x4,%esp
+    2061:	6a 02                	push   $0x2
+    2063:	68 02 50 00 00       	push   $0x5002
+    2068:	ff 75 f4             	pushl  -0xc(%ebp)
+    206b:	e8 5f 20 00 00       	call   40cf <write>
+    2070:	83 c4 10             	add    $0x10,%esp
+  close(fd);
+    2073:	83 ec 0c             	sub    $0xc,%esp
+    2076:	ff 75 f4             	pushl  -0xc(%ebp)
+    2079:	e8 59 20 00 00       	call   40d7 <close>
+    207e:	83 c4 10             	add    $0x10,%esp
+
+  if(unlink("dd") >= 0){
+    2081:	83 ec 0c             	sub    $0xc,%esp
+    2084:	68 05 50 00 00       	push   $0x5005
+    2089:	e8 71 20 00 00       	call   40ff <unlink>
+    208e:	83 c4 10             	add    $0x10,%esp
+    2091:	85 c0                	test   %eax,%eax
+    2093:	78 17                	js     20ac <subdir+0xda>
+    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+    2095:	83 ec 08             	sub    $0x8,%esp
+    2098:	68 3c 50 00 00       	push   $0x503c
+    209d:	6a 01                	push   $0x1
+    209f:	e8 af 21 00 00       	call   4253 <printf>
+    20a4:	83 c4 10             	add    $0x10,%esp
+    exit();
+    20a7:	e8 03 20 00 00       	call   40af <exit>
+  }
+
+  if(mkdir("/dd/dd") != 0){
+    20ac:	83 ec 0c             	sub    $0xc,%esp
+    20af:	68 62 50 00 00       	push   $0x5062
+    20b4:	e8 5e 20 00 00       	call   4117 <mkdir>
+    20b9:	83 c4 10             	add    $0x10,%esp
+    20bc:	85 c0                	test   %eax,%eax
+    20be:	74 17                	je     20d7 <subdir+0x105>
+    printf(1, "subdir mkdir dd/dd failed\n");
+    20c0:	83 ec 08             	sub    $0x8,%esp
+    20c3:	68 69 50 00 00       	push   $0x5069
+    20c8:	6a 01                	push   $0x1
+    20ca:	e8 84 21 00 00       	call   4253 <printf>
+    20cf:	83 c4 10             	add    $0x10,%esp
+    exit();
+    20d2:	e8 d8 1f 00 00       	call   40af <exit>
+  }
+
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+    20d7:	83 ec 08             	sub    $0x8,%esp
+    20da:	68 02 02 00 00       	push   $0x202
+    20df:	68 84 50 00 00       	push   $0x5084
+    20e4:	e8 06 20 00 00       	call   40ef <open>
+    20e9:	83 c4 10             	add    $0x10,%esp
+    20ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    20ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    20f3:	79 17                	jns    210c <subdir+0x13a>
+    printf(1, "create dd/dd/ff failed\n");
+    20f5:	83 ec 08             	sub    $0x8,%esp
+    20f8:	68 8d 50 00 00       	push   $0x508d
+    20fd:	6a 01                	push   $0x1
+    20ff:	e8 4f 21 00 00       	call   4253 <printf>
+    2104:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2107:	e8 a3 1f 00 00       	call   40af <exit>
+  }
+  write(fd, "FF", 2);
+    210c:	83 ec 04             	sub    $0x4,%esp
+    210f:	6a 02                	push   $0x2
+    2111:	68 a5 50 00 00       	push   $0x50a5
+    2116:	ff 75 f4             	pushl  -0xc(%ebp)
+    2119:	e8 b1 1f 00 00       	call   40cf <write>
+    211e:	83 c4 10             	add    $0x10,%esp
+  close(fd);
+    2121:	83 ec 0c             	sub    $0xc,%esp
+    2124:	ff 75 f4             	pushl  -0xc(%ebp)
+    2127:	e8 ab 1f 00 00       	call   40d7 <close>
+    212c:	83 c4 10             	add    $0x10,%esp
+
+  fd = open("dd/dd/../ff", 0);
+    212f:	83 ec 08             	sub    $0x8,%esp
+    2132:	6a 00                	push   $0x0
+    2134:	68 a8 50 00 00       	push   $0x50a8
+    2139:	e8 b1 1f 00 00       	call   40ef <open>
+    213e:	83 c4 10             	add    $0x10,%esp
+    2141:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    2144:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2148:	79 17                	jns    2161 <subdir+0x18f>
+    printf(1, "open dd/dd/../ff failed\n");
+    214a:	83 ec 08             	sub    $0x8,%esp
+    214d:	68 b4 50 00 00       	push   $0x50b4
+    2152:	6a 01                	push   $0x1
+    2154:	e8 fa 20 00 00       	call   4253 <printf>
+    2159:	83 c4 10             	add    $0x10,%esp
+    exit();
+    215c:	e8 4e 1f 00 00       	call   40af <exit>
+  }
+  cc = read(fd, buf, sizeof(buf));
+    2161:	83 ec 04             	sub    $0x4,%esp
+    2164:	68 00 20 00 00       	push   $0x2000
+    2169:	68 60 8d 00 00       	push   $0x8d60
+    216e:	ff 75 f4             	pushl  -0xc(%ebp)
+    2171:	e8 51 1f 00 00       	call   40c7 <read>
+    2176:	83 c4 10             	add    $0x10,%esp
+    2179:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(cc != 2 || buf[0] != 'f'){
+    217c:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
+    2180:	75 0b                	jne    218d <subdir+0x1bb>
+    2182:	0f b6 05 60 8d 00 00 	movzbl 0x8d60,%eax
+    2189:	3c 66                	cmp    $0x66,%al
+    218b:	74 17                	je     21a4 <subdir+0x1d2>
+    printf(1, "dd/dd/../ff wrong content\n");
+    218d:	83 ec 08             	sub    $0x8,%esp
+    2190:	68 cd 50 00 00       	push   $0x50cd
+    2195:	6a 01                	push   $0x1
+    2197:	e8 b7 20 00 00       	call   4253 <printf>
+    219c:	83 c4 10             	add    $0x10,%esp
+    exit();
+    219f:	e8 0b 1f 00 00       	call   40af <exit>
+  }
+  close(fd);
+    21a4:	83 ec 0c             	sub    $0xc,%esp
+    21a7:	ff 75 f4             	pushl  -0xc(%ebp)
+    21aa:	e8 28 1f 00 00       	call   40d7 <close>
+    21af:	83 c4 10             	add    $0x10,%esp
+
+  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+    21b2:	83 ec 08             	sub    $0x8,%esp
+    21b5:	68 e8 50 00 00       	push   $0x50e8
+    21ba:	68 84 50 00 00       	push   $0x5084
+    21bf:	e8 4b 1f 00 00       	call   410f <link>
+    21c4:	83 c4 10             	add    $0x10,%esp
+    21c7:	85 c0                	test   %eax,%eax
+    21c9:	74 17                	je     21e2 <subdir+0x210>
+    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+    21cb:	83 ec 08             	sub    $0x8,%esp
+    21ce:	68 f4 50 00 00       	push   $0x50f4
+    21d3:	6a 01                	push   $0x1
+    21d5:	e8 79 20 00 00       	call   4253 <printf>
+    21da:	83 c4 10             	add    $0x10,%esp
+    exit();
+    21dd:	e8 cd 1e 00 00       	call   40af <exit>
+  }
+
+  if(unlink("dd/dd/ff") != 0){
+    21e2:	83 ec 0c             	sub    $0xc,%esp
+    21e5:	68 84 50 00 00       	push   $0x5084
+    21ea:	e8 10 1f 00 00       	call   40ff <unlink>
+    21ef:	83 c4 10             	add    $0x10,%esp
+    21f2:	85 c0                	test   %eax,%eax
+    21f4:	74 17                	je     220d <subdir+0x23b>
+    printf(1, "unlink dd/dd/ff failed\n");
+    21f6:	83 ec 08             	sub    $0x8,%esp
+    21f9:	68 15 51 00 00       	push   $0x5115
+    21fe:	6a 01                	push   $0x1
+    2200:	e8 4e 20 00 00       	call   4253 <printf>
+    2205:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2208:	e8 a2 1e 00 00       	call   40af <exit>
+  }
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    220d:	83 ec 08             	sub    $0x8,%esp
+    2210:	6a 00                	push   $0x0
+    2212:	68 84 50 00 00       	push   $0x5084
+    2217:	e8 d3 1e 00 00       	call   40ef <open>
+    221c:	83 c4 10             	add    $0x10,%esp
+    221f:	85 c0                	test   %eax,%eax
+    2221:	78 17                	js     223a <subdir+0x268>
+    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+    2223:	83 ec 08             	sub    $0x8,%esp
+    2226:	68 30 51 00 00       	push   $0x5130
+    222b:	6a 01                	push   $0x1
+    222d:	e8 21 20 00 00       	call   4253 <printf>
+    2232:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2235:	e8 75 1e 00 00       	call   40af <exit>
+  }
+
+  if(chdir("dd") != 0){
+    223a:	83 ec 0c             	sub    $0xc,%esp
+    223d:	68 05 50 00 00       	push   $0x5005
+    2242:	e8 d8 1e 00 00       	call   411f <chdir>
+    2247:	83 c4 10             	add    $0x10,%esp
+    224a:	85 c0                	test   %eax,%eax
+    224c:	74 17                	je     2265 <subdir+0x293>
+    printf(1, "chdir dd failed\n");
+    224e:	83 ec 08             	sub    $0x8,%esp
+    2251:	68 54 51 00 00       	push   $0x5154
+    2256:	6a 01                	push   $0x1
+    2258:	e8 f6 1f 00 00       	call   4253 <printf>
+    225d:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2260:	e8 4a 1e 00 00       	call   40af <exit>
+  }
+  if(chdir("dd/../../dd") != 0){
+    2265:	83 ec 0c             	sub    $0xc,%esp
+    2268:	68 65 51 00 00       	push   $0x5165
+    226d:	e8 ad 1e 00 00       	call   411f <chdir>
+    2272:	83 c4 10             	add    $0x10,%esp
+    2275:	85 c0                	test   %eax,%eax
+    2277:	74 17                	je     2290 <subdir+0x2be>
+    printf(1, "chdir dd/../../dd failed\n");
+    2279:	83 ec 08             	sub    $0x8,%esp
+    227c:	68 71 51 00 00       	push   $0x5171
+    2281:	6a 01                	push   $0x1
+    2283:	e8 cb 1f 00 00       	call   4253 <printf>
+    2288:	83 c4 10             	add    $0x10,%esp
+    exit();
+    228b:	e8 1f 1e 00 00       	call   40af <exit>
+  }
+  if(chdir("dd/../../../dd") != 0){
+    2290:	83 ec 0c             	sub    $0xc,%esp
+    2293:	68 8b 51 00 00       	push   $0x518b
+    2298:	e8 82 1e 00 00       	call   411f <chdir>
+    229d:	83 c4 10             	add    $0x10,%esp
+    22a0:	85 c0                	test   %eax,%eax
+    22a2:	74 17                	je     22bb <subdir+0x2e9>
+    printf(1, "chdir dd/../../dd failed\n");
+    22a4:	83 ec 08             	sub    $0x8,%esp
+    22a7:	68 71 51 00 00       	push   $0x5171
+    22ac:	6a 01                	push   $0x1
+    22ae:	e8 a0 1f 00 00       	call   4253 <printf>
+    22b3:	83 c4 10             	add    $0x10,%esp
+    exit();
+    22b6:	e8 f4 1d 00 00       	call   40af <exit>
+  }
+  if(chdir("./..") != 0){
+    22bb:	83 ec 0c             	sub    $0xc,%esp
+    22be:	68 9a 51 00 00       	push   $0x519a
+    22c3:	e8 57 1e 00 00       	call   411f <chdir>
+    22c8:	83 c4 10             	add    $0x10,%esp
+    22cb:	85 c0                	test   %eax,%eax
+    22cd:	74 17                	je     22e6 <subdir+0x314>
+    printf(1, "chdir ./.. failed\n");
+    22cf:	83 ec 08             	sub    $0x8,%esp
+    22d2:	68 9f 51 00 00       	push   $0x519f
+    22d7:	6a 01                	push   $0x1
+    22d9:	e8 75 1f 00 00       	call   4253 <printf>
+    22de:	83 c4 10             	add    $0x10,%esp
+    exit();
+    22e1:	e8 c9 1d 00 00       	call   40af <exit>
+  }
+
+  fd = open("dd/dd/ffff", 0);
+    22e6:	83 ec 08             	sub    $0x8,%esp
+    22e9:	6a 00                	push   $0x0
+    22eb:	68 e8 50 00 00       	push   $0x50e8
+    22f0:	e8 fa 1d 00 00       	call   40ef <open>
+    22f5:	83 c4 10             	add    $0x10,%esp
+    22f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    22fb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    22ff:	79 17                	jns    2318 <subdir+0x346>
+    printf(1, "open dd/dd/ffff failed\n");
+    2301:	83 ec 08             	sub    $0x8,%esp
+    2304:	68 b2 51 00 00       	push   $0x51b2
+    2309:	6a 01                	push   $0x1
+    230b:	e8 43 1f 00 00       	call   4253 <printf>
+    2310:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2313:	e8 97 1d 00 00       	call   40af <exit>
+  }
+  if(read(fd, buf, sizeof(buf)) != 2){
+    2318:	83 ec 04             	sub    $0x4,%esp
+    231b:	68 00 20 00 00       	push   $0x2000
+    2320:	68 60 8d 00 00       	push   $0x8d60
+    2325:	ff 75 f4             	pushl  -0xc(%ebp)
+    2328:	e8 9a 1d 00 00       	call   40c7 <read>
+    232d:	83 c4 10             	add    $0x10,%esp
+    2330:	83 f8 02             	cmp    $0x2,%eax
+    2333:	74 17                	je     234c <subdir+0x37a>
+    printf(1, "read dd/dd/ffff wrong len\n");
+    2335:	83 ec 08             	sub    $0x8,%esp
+    2338:	68 ca 51 00 00       	push   $0x51ca
+    233d:	6a 01                	push   $0x1
+    233f:	e8 0f 1f 00 00       	call   4253 <printf>
+    2344:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2347:	e8 63 1d 00 00       	call   40af <exit>
+  }
+  close(fd);
+    234c:	83 ec 0c             	sub    $0xc,%esp
+    234f:	ff 75 f4             	pushl  -0xc(%ebp)
+    2352:	e8 80 1d 00 00       	call   40d7 <close>
+    2357:	83 c4 10             	add    $0x10,%esp
+
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    235a:	83 ec 08             	sub    $0x8,%esp
+    235d:	6a 00                	push   $0x0
+    235f:	68 84 50 00 00       	push   $0x5084
+    2364:	e8 86 1d 00 00       	call   40ef <open>
+    2369:	83 c4 10             	add    $0x10,%esp
+    236c:	85 c0                	test   %eax,%eax
+    236e:	78 17                	js     2387 <subdir+0x3b5>
+    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+    2370:	83 ec 08             	sub    $0x8,%esp
+    2373:	68 e8 51 00 00       	push   $0x51e8
+    2378:	6a 01                	push   $0x1
+    237a:	e8 d4 1e 00 00       	call   4253 <printf>
+    237f:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2382:	e8 28 1d 00 00       	call   40af <exit>
+  }
+
+  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+    2387:	83 ec 08             	sub    $0x8,%esp
+    238a:	68 02 02 00 00       	push   $0x202
+    238f:	68 0d 52 00 00       	push   $0x520d
+    2394:	e8 56 1d 00 00       	call   40ef <open>
+    2399:	83 c4 10             	add    $0x10,%esp
+    239c:	85 c0                	test   %eax,%eax
+    239e:	78 17                	js     23b7 <subdir+0x3e5>
+    printf(1, "create dd/ff/ff succeeded!\n");
+    23a0:	83 ec 08             	sub    $0x8,%esp
+    23a3:	68 16 52 00 00       	push   $0x5216
+    23a8:	6a 01                	push   $0x1
+    23aa:	e8 a4 1e 00 00       	call   4253 <printf>
+    23af:	83 c4 10             	add    $0x10,%esp
+    exit();
+    23b2:	e8 f8 1c 00 00       	call   40af <exit>
+  }
+  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+    23b7:	83 ec 08             	sub    $0x8,%esp
+    23ba:	68 02 02 00 00       	push   $0x202
+    23bf:	68 32 52 00 00       	push   $0x5232
+    23c4:	e8 26 1d 00 00       	call   40ef <open>
+    23c9:	83 c4 10             	add    $0x10,%esp
+    23cc:	85 c0                	test   %eax,%eax
+    23ce:	78 17                	js     23e7 <subdir+0x415>
+    printf(1, "create dd/xx/ff succeeded!\n");
+    23d0:	83 ec 08             	sub    $0x8,%esp
+    23d3:	68 3b 52 00 00       	push   $0x523b
+    23d8:	6a 01                	push   $0x1
+    23da:	e8 74 1e 00 00       	call   4253 <printf>
+    23df:	83 c4 10             	add    $0x10,%esp
+    exit();
+    23e2:	e8 c8 1c 00 00       	call   40af <exit>
+  }
+  if(open("dd", O_CREATE) >= 0){
+    23e7:	83 ec 08             	sub    $0x8,%esp
+    23ea:	68 00 02 00 00       	push   $0x200
+    23ef:	68 05 50 00 00       	push   $0x5005
+    23f4:	e8 f6 1c 00 00       	call   40ef <open>
+    23f9:	83 c4 10             	add    $0x10,%esp
+    23fc:	85 c0                	test   %eax,%eax
+    23fe:	78 17                	js     2417 <subdir+0x445>
+    printf(1, "create dd succeeded!\n");
+    2400:	83 ec 08             	sub    $0x8,%esp
+    2403:	68 57 52 00 00       	push   $0x5257
+    2408:	6a 01                	push   $0x1
+    240a:	e8 44 1e 00 00       	call   4253 <printf>
+    240f:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2412:	e8 98 1c 00 00       	call   40af <exit>
+  }
+  if(open("dd", O_RDWR) >= 0){
+    2417:	83 ec 08             	sub    $0x8,%esp
+    241a:	6a 02                	push   $0x2
+    241c:	68 05 50 00 00       	push   $0x5005
+    2421:	e8 c9 1c 00 00       	call   40ef <open>
+    2426:	83 c4 10             	add    $0x10,%esp
+    2429:	85 c0                	test   %eax,%eax
+    242b:	78 17                	js     2444 <subdir+0x472>
+    printf(1, "open dd rdwr succeeded!\n");
+    242d:	83 ec 08             	sub    $0x8,%esp
+    2430:	68 6d 52 00 00       	push   $0x526d
+    2435:	6a 01                	push   $0x1
+    2437:	e8 17 1e 00 00       	call   4253 <printf>
+    243c:	83 c4 10             	add    $0x10,%esp
+    exit();
+    243f:	e8 6b 1c 00 00       	call   40af <exit>
+  }
+  if(open("dd", O_WRONLY) >= 0){
+    2444:	83 ec 08             	sub    $0x8,%esp
+    2447:	6a 01                	push   $0x1
+    2449:	68 05 50 00 00       	push   $0x5005
+    244e:	e8 9c 1c 00 00       	call   40ef <open>
+    2453:	83 c4 10             	add    $0x10,%esp
+    2456:	85 c0                	test   %eax,%eax
+    2458:	78 17                	js     2471 <subdir+0x49f>
+    printf(1, "open dd wronly succeeded!\n");
+    245a:	83 ec 08             	sub    $0x8,%esp
+    245d:	68 86 52 00 00       	push   $0x5286
+    2462:	6a 01                	push   $0x1
+    2464:	e8 ea 1d 00 00       	call   4253 <printf>
+    2469:	83 c4 10             	add    $0x10,%esp
+    exit();
+    246c:	e8 3e 1c 00 00       	call   40af <exit>
+  }
+  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+    2471:	83 ec 08             	sub    $0x8,%esp
+    2474:	68 a1 52 00 00       	push   $0x52a1
+    2479:	68 0d 52 00 00       	push   $0x520d
+    247e:	e8 8c 1c 00 00       	call   410f <link>
+    2483:	83 c4 10             	add    $0x10,%esp
+    2486:	85 c0                	test   %eax,%eax
+    2488:	75 17                	jne    24a1 <subdir+0x4cf>
+    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+    248a:	83 ec 08             	sub    $0x8,%esp
+    248d:	68 ac 52 00 00       	push   $0x52ac
+    2492:	6a 01                	push   $0x1
+    2494:	e8 ba 1d 00 00       	call   4253 <printf>
+    2499:	83 c4 10             	add    $0x10,%esp
+    exit();
+    249c:	e8 0e 1c 00 00       	call   40af <exit>
+  }
+  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+    24a1:	83 ec 08             	sub    $0x8,%esp
+    24a4:	68 a1 52 00 00       	push   $0x52a1
+    24a9:	68 32 52 00 00       	push   $0x5232
+    24ae:	e8 5c 1c 00 00       	call   410f <link>
+    24b3:	83 c4 10             	add    $0x10,%esp
+    24b6:	85 c0                	test   %eax,%eax
+    24b8:	75 17                	jne    24d1 <subdir+0x4ff>
+    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+    24ba:	83 ec 08             	sub    $0x8,%esp
+    24bd:	68 d0 52 00 00       	push   $0x52d0
+    24c2:	6a 01                	push   $0x1
+    24c4:	e8 8a 1d 00 00       	call   4253 <printf>
+    24c9:	83 c4 10             	add    $0x10,%esp
+    exit();
+    24cc:	e8 de 1b 00 00       	call   40af <exit>
+  }
+  if(link("dd/ff", "dd/dd/ffff") == 0){
+    24d1:	83 ec 08             	sub    $0x8,%esp
+    24d4:	68 e8 50 00 00       	push   $0x50e8
+    24d9:	68 20 50 00 00       	push   $0x5020
+    24de:	e8 2c 1c 00 00       	call   410f <link>
+    24e3:	83 c4 10             	add    $0x10,%esp
+    24e6:	85 c0                	test   %eax,%eax
+    24e8:	75 17                	jne    2501 <subdir+0x52f>
+    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+    24ea:	83 ec 08             	sub    $0x8,%esp
+    24ed:	68 f4 52 00 00       	push   $0x52f4
+    24f2:	6a 01                	push   $0x1
+    24f4:	e8 5a 1d 00 00       	call   4253 <printf>
+    24f9:	83 c4 10             	add    $0x10,%esp
+    exit();
+    24fc:	e8 ae 1b 00 00       	call   40af <exit>
+  }
+  if(mkdir("dd/ff/ff") == 0){
+    2501:	83 ec 0c             	sub    $0xc,%esp
+    2504:	68 0d 52 00 00       	push   $0x520d
+    2509:	e8 09 1c 00 00       	call   4117 <mkdir>
+    250e:	83 c4 10             	add    $0x10,%esp
+    2511:	85 c0                	test   %eax,%eax
+    2513:	75 17                	jne    252c <subdir+0x55a>
+    printf(1, "mkdir dd/ff/ff succeeded!\n");
+    2515:	83 ec 08             	sub    $0x8,%esp
+    2518:	68 16 53 00 00       	push   $0x5316
+    251d:	6a 01                	push   $0x1
+    251f:	e8 2f 1d 00 00       	call   4253 <printf>
+    2524:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2527:	e8 83 1b 00 00       	call   40af <exit>
+  }
+  if(mkdir("dd/xx/ff") == 0){
+    252c:	83 ec 0c             	sub    $0xc,%esp
+    252f:	68 32 52 00 00       	push   $0x5232
+    2534:	e8 de 1b 00 00       	call   4117 <mkdir>
+    2539:	83 c4 10             	add    $0x10,%esp
+    253c:	85 c0                	test   %eax,%eax
+    253e:	75 17                	jne    2557 <subdir+0x585>
+    printf(1, "mkdir dd/xx/ff succeeded!\n");
+    2540:	83 ec 08             	sub    $0x8,%esp
+    2543:	68 31 53 00 00       	push   $0x5331
+    2548:	6a 01                	push   $0x1
+    254a:	e8 04 1d 00 00       	call   4253 <printf>
+    254f:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2552:	e8 58 1b 00 00       	call   40af <exit>
+  }
+  if(mkdir("dd/dd/ffff") == 0){
+    2557:	83 ec 0c             	sub    $0xc,%esp
+    255a:	68 e8 50 00 00       	push   $0x50e8
+    255f:	e8 b3 1b 00 00       	call   4117 <mkdir>
+    2564:	83 c4 10             	add    $0x10,%esp
+    2567:	85 c0                	test   %eax,%eax
+    2569:	75 17                	jne    2582 <subdir+0x5b0>
+    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+    256b:	83 ec 08             	sub    $0x8,%esp
+    256e:	68 4c 53 00 00       	push   $0x534c
+    2573:	6a 01                	push   $0x1
+    2575:	e8 d9 1c 00 00       	call   4253 <printf>
+    257a:	83 c4 10             	add    $0x10,%esp
+    exit();
+    257d:	e8 2d 1b 00 00       	call   40af <exit>
+  }
+  if(unlink("dd/xx/ff") == 0){
+    2582:	83 ec 0c             	sub    $0xc,%esp
+    2585:	68 32 52 00 00       	push   $0x5232
+    258a:	e8 70 1b 00 00       	call   40ff <unlink>
+    258f:	83 c4 10             	add    $0x10,%esp
+    2592:	85 c0                	test   %eax,%eax
+    2594:	75 17                	jne    25ad <subdir+0x5db>
+    printf(1, "unlink dd/xx/ff succeeded!\n");
+    2596:	83 ec 08             	sub    $0x8,%esp
+    2599:	68 69 53 00 00       	push   $0x5369
+    259e:	6a 01                	push   $0x1
+    25a0:	e8 ae 1c 00 00       	call   4253 <printf>
+    25a5:	83 c4 10             	add    $0x10,%esp
+    exit();
+    25a8:	e8 02 1b 00 00       	call   40af <exit>
+  }
+  if(unlink("dd/ff/ff") == 0){
+    25ad:	83 ec 0c             	sub    $0xc,%esp
+    25b0:	68 0d 52 00 00       	push   $0x520d
+    25b5:	e8 45 1b 00 00       	call   40ff <unlink>
+    25ba:	83 c4 10             	add    $0x10,%esp
+    25bd:	85 c0                	test   %eax,%eax
+    25bf:	75 17                	jne    25d8 <subdir+0x606>
+    printf(1, "unlink dd/ff/ff succeeded!\n");
+    25c1:	83 ec 08             	sub    $0x8,%esp
+    25c4:	68 85 53 00 00       	push   $0x5385
+    25c9:	6a 01                	push   $0x1
+    25cb:	e8 83 1c 00 00       	call   4253 <printf>
+    25d0:	83 c4 10             	add    $0x10,%esp
+    exit();
+    25d3:	e8 d7 1a 00 00       	call   40af <exit>
+  }
+  if(chdir("dd/ff") == 0){
+    25d8:	83 ec 0c             	sub    $0xc,%esp
+    25db:	68 20 50 00 00       	push   $0x5020
+    25e0:	e8 3a 1b 00 00       	call   411f <chdir>
+    25e5:	83 c4 10             	add    $0x10,%esp
+    25e8:	85 c0                	test   %eax,%eax
+    25ea:	75 17                	jne    2603 <subdir+0x631>
+    printf(1, "chdir dd/ff succeeded!\n");
+    25ec:	83 ec 08             	sub    $0x8,%esp
+    25ef:	68 a1 53 00 00       	push   $0x53a1
+    25f4:	6a 01                	push   $0x1
+    25f6:	e8 58 1c 00 00       	call   4253 <printf>
+    25fb:	83 c4 10             	add    $0x10,%esp
+    exit();
+    25fe:	e8 ac 1a 00 00       	call   40af <exit>
+  }
+  if(chdir("dd/xx") == 0){
+    2603:	83 ec 0c             	sub    $0xc,%esp
+    2606:	68 b9 53 00 00       	push   $0x53b9
+    260b:	e8 0f 1b 00 00       	call   411f <chdir>
+    2610:	83 c4 10             	add    $0x10,%esp
+    2613:	85 c0                	test   %eax,%eax
+    2615:	75 17                	jne    262e <subdir+0x65c>
+    printf(1, "chdir dd/xx succeeded!\n");
+    2617:	83 ec 08             	sub    $0x8,%esp
+    261a:	68 bf 53 00 00       	push   $0x53bf
+    261f:	6a 01                	push   $0x1
+    2621:	e8 2d 1c 00 00       	call   4253 <printf>
+    2626:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2629:	e8 81 1a 00 00       	call   40af <exit>
+  }
+
+  if(unlink("dd/dd/ffff") != 0){
+    262e:	83 ec 0c             	sub    $0xc,%esp
+    2631:	68 e8 50 00 00       	push   $0x50e8
+    2636:	e8 c4 1a 00 00       	call   40ff <unlink>
+    263b:	83 c4 10             	add    $0x10,%esp
+    263e:	85 c0                	test   %eax,%eax
+    2640:	74 17                	je     2659 <subdir+0x687>
+    printf(1, "unlink dd/dd/ff failed\n");
+    2642:	83 ec 08             	sub    $0x8,%esp
+    2645:	68 15 51 00 00       	push   $0x5115
+    264a:	6a 01                	push   $0x1
+    264c:	e8 02 1c 00 00       	call   4253 <printf>
+    2651:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2654:	e8 56 1a 00 00       	call   40af <exit>
+  }
+  if(unlink("dd/ff") != 0){
+    2659:	83 ec 0c             	sub    $0xc,%esp
+    265c:	68 20 50 00 00       	push   $0x5020
+    2661:	e8 99 1a 00 00       	call   40ff <unlink>
+    2666:	83 c4 10             	add    $0x10,%esp
+    2669:	85 c0                	test   %eax,%eax
+    266b:	74 17                	je     2684 <subdir+0x6b2>
+    printf(1, "unlink dd/ff failed\n");
+    266d:	83 ec 08             	sub    $0x8,%esp
+    2670:	68 d7 53 00 00       	push   $0x53d7
+    2675:	6a 01                	push   $0x1
+    2677:	e8 d7 1b 00 00       	call   4253 <printf>
+    267c:	83 c4 10             	add    $0x10,%esp
+    exit();
+    267f:	e8 2b 1a 00 00       	call   40af <exit>
+  }
+  if(unlink("dd") == 0){
+    2684:	83 ec 0c             	sub    $0xc,%esp
+    2687:	68 05 50 00 00       	push   $0x5005
+    268c:	e8 6e 1a 00 00       	call   40ff <unlink>
+    2691:	83 c4 10             	add    $0x10,%esp
+    2694:	85 c0                	test   %eax,%eax
+    2696:	75 17                	jne    26af <subdir+0x6dd>
+    printf(1, "unlink non-empty dd succeeded!\n");
+    2698:	83 ec 08             	sub    $0x8,%esp
+    269b:	68 ec 53 00 00       	push   $0x53ec
+    26a0:	6a 01                	push   $0x1
+    26a2:	e8 ac 1b 00 00       	call   4253 <printf>
+    26a7:	83 c4 10             	add    $0x10,%esp
+    exit();
+    26aa:	e8 00 1a 00 00       	call   40af <exit>
+  }
+  if(unlink("dd/dd") < 0){
+    26af:	83 ec 0c             	sub    $0xc,%esp
+    26b2:	68 0c 54 00 00       	push   $0x540c
+    26b7:	e8 43 1a 00 00       	call   40ff <unlink>
+    26bc:	83 c4 10             	add    $0x10,%esp
+    26bf:	85 c0                	test   %eax,%eax
+    26c1:	79 17                	jns    26da <subdir+0x708>
+    printf(1, "unlink dd/dd failed\n");
+    26c3:	83 ec 08             	sub    $0x8,%esp
+    26c6:	68 12 54 00 00       	push   $0x5412
+    26cb:	6a 01                	push   $0x1
+    26cd:	e8 81 1b 00 00       	call   4253 <printf>
+    26d2:	83 c4 10             	add    $0x10,%esp
+    exit();
+    26d5:	e8 d5 19 00 00       	call   40af <exit>
+  }
+  if(unlink("dd") < 0){
+    26da:	83 ec 0c             	sub    $0xc,%esp
+    26dd:	68 05 50 00 00       	push   $0x5005
+    26e2:	e8 18 1a 00 00       	call   40ff <unlink>
+    26e7:	83 c4 10             	add    $0x10,%esp
+    26ea:	85 c0                	test   %eax,%eax
+    26ec:	79 17                	jns    2705 <subdir+0x733>
+    printf(1, "unlink dd failed\n");
+    26ee:	83 ec 08             	sub    $0x8,%esp
+    26f1:	68 27 54 00 00       	push   $0x5427
+    26f6:	6a 01                	push   $0x1
+    26f8:	e8 56 1b 00 00       	call   4253 <printf>
+    26fd:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2700:	e8 aa 19 00 00       	call   40af <exit>
+  }
+
+  printf(1, "subdir ok\n");
+    2705:	83 ec 08             	sub    $0x8,%esp
+    2708:	68 39 54 00 00       	push   $0x5439
+    270d:	6a 01                	push   $0x1
+    270f:	e8 3f 1b 00 00       	call   4253 <printf>
+    2714:	83 c4 10             	add    $0x10,%esp
+}
+    2717:	90                   	nop
+    2718:	c9                   	leave  
+    2719:	c3                   	ret    
+
+0000271a <bigwrite>:
+
+// test writes that are larger than the log.
+void
+bigwrite(void)
+{
+    271a:	f3 0f 1e fb          	endbr32 
+    271e:	55                   	push   %ebp
+    271f:	89 e5                	mov    %esp,%ebp
+    2721:	83 ec 18             	sub    $0x18,%esp
+  int fd, sz;
+
+  printf(1, "bigwrite test\n");
+    2724:	83 ec 08             	sub    $0x8,%esp
+    2727:	68 44 54 00 00       	push   $0x5444
+    272c:	6a 01                	push   $0x1
+    272e:	e8 20 1b 00 00       	call   4253 <printf>
+    2733:	83 c4 10             	add    $0x10,%esp
+
+  unlink("bigwrite");
+    2736:	83 ec 0c             	sub    $0xc,%esp
+    2739:	68 53 54 00 00       	push   $0x5453
+    273e:	e8 bc 19 00 00       	call   40ff <unlink>
+    2743:	83 c4 10             	add    $0x10,%esp
+  for(sz = 499; sz < 12*512; sz += 471){
+    2746:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%ebp)
+    274d:	e9 a8 00 00 00       	jmp    27fa <bigwrite+0xe0>
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+    2752:	83 ec 08             	sub    $0x8,%esp
+    2755:	68 02 02 00 00       	push   $0x202
+    275a:	68 53 54 00 00       	push   $0x5453
+    275f:	e8 8b 19 00 00       	call   40ef <open>
+    2764:	83 c4 10             	add    $0x10,%esp
+    2767:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    if(fd < 0){
+    276a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    276e:	79 17                	jns    2787 <bigwrite+0x6d>
+      printf(1, "cannot create bigwrite\n");
+    2770:	83 ec 08             	sub    $0x8,%esp
+    2773:	68 5c 54 00 00       	push   $0x545c
+    2778:	6a 01                	push   $0x1
+    277a:	e8 d4 1a 00 00       	call   4253 <printf>
+    277f:	83 c4 10             	add    $0x10,%esp
+      exit();
+    2782:	e8 28 19 00 00       	call   40af <exit>
+    }
+    int i;
+    for(i = 0; i < 2; i++){
+    2787:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    278e:	eb 3f                	jmp    27cf <bigwrite+0xb5>
+      int cc = write(fd, buf, sz);
+    2790:	83 ec 04             	sub    $0x4,%esp
+    2793:	ff 75 f4             	pushl  -0xc(%ebp)
+    2796:	68 60 8d 00 00       	push   $0x8d60
+    279b:	ff 75 ec             	pushl  -0x14(%ebp)
+    279e:	e8 2c 19 00 00       	call   40cf <write>
+    27a3:	83 c4 10             	add    $0x10,%esp
+    27a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
+      if(cc != sz){
+    27a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    27ac:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    27af:	74 1a                	je     27cb <bigwrite+0xb1>
+        printf(1, "write(%d) ret %d\n", sz, cc);
+    27b1:	ff 75 e8             	pushl  -0x18(%ebp)
+    27b4:	ff 75 f4             	pushl  -0xc(%ebp)
+    27b7:	68 74 54 00 00       	push   $0x5474
+    27bc:	6a 01                	push   $0x1
+    27be:	e8 90 1a 00 00       	call   4253 <printf>
+    27c3:	83 c4 10             	add    $0x10,%esp
+        exit();
+    27c6:	e8 e4 18 00 00       	call   40af <exit>
+    for(i = 0; i < 2; i++){
+    27cb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    27cf:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
+    27d3:	7e bb                	jle    2790 <bigwrite+0x76>
+      }
+    }
+    close(fd);
+    27d5:	83 ec 0c             	sub    $0xc,%esp
+    27d8:	ff 75 ec             	pushl  -0x14(%ebp)
+    27db:	e8 f7 18 00 00       	call   40d7 <close>
+    27e0:	83 c4 10             	add    $0x10,%esp
+    unlink("bigwrite");
+    27e3:	83 ec 0c             	sub    $0xc,%esp
+    27e6:	68 53 54 00 00       	push   $0x5453
+    27eb:	e8 0f 19 00 00       	call   40ff <unlink>
+    27f0:	83 c4 10             	add    $0x10,%esp
+  for(sz = 499; sz < 12*512; sz += 471){
+    27f3:	81 45 f4 d7 01 00 00 	addl   $0x1d7,-0xc(%ebp)
+    27fa:	81 7d f4 ff 17 00 00 	cmpl   $0x17ff,-0xc(%ebp)
+    2801:	0f 8e 4b ff ff ff    	jle    2752 <bigwrite+0x38>
+  }
+
+  printf(1, "bigwrite ok\n");
+    2807:	83 ec 08             	sub    $0x8,%esp
+    280a:	68 86 54 00 00       	push   $0x5486
+    280f:	6a 01                	push   $0x1
+    2811:	e8 3d 1a 00 00       	call   4253 <printf>
+    2816:	83 c4 10             	add    $0x10,%esp
+}
+    2819:	90                   	nop
+    281a:	c9                   	leave  
+    281b:	c3                   	ret    
+
+0000281c <bigfile>:
+
+void
+bigfile(void)
+{
+    281c:	f3 0f 1e fb          	endbr32 
+    2820:	55                   	push   %ebp
+    2821:	89 e5                	mov    %esp,%ebp
+    2823:	83 ec 18             	sub    $0x18,%esp
+  int fd, i, total, cc;
+
+  printf(1, "bigfile test\n");
+    2826:	83 ec 08             	sub    $0x8,%esp
+    2829:	68 93 54 00 00       	push   $0x5493
+    282e:	6a 01                	push   $0x1
+    2830:	e8 1e 1a 00 00       	call   4253 <printf>
+    2835:	83 c4 10             	add    $0x10,%esp
+
+  unlink("bigfile");
+    2838:	83 ec 0c             	sub    $0xc,%esp
+    283b:	68 a1 54 00 00       	push   $0x54a1
+    2840:	e8 ba 18 00 00       	call   40ff <unlink>
+    2845:	83 c4 10             	add    $0x10,%esp
+  fd = open("bigfile", O_CREATE | O_RDWR);
+    2848:	83 ec 08             	sub    $0x8,%esp
+    284b:	68 02 02 00 00       	push   $0x202
+    2850:	68 a1 54 00 00       	push   $0x54a1
+    2855:	e8 95 18 00 00       	call   40ef <open>
+    285a:	83 c4 10             	add    $0x10,%esp
+    285d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+    2860:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    2864:	79 17                	jns    287d <bigfile+0x61>
+    printf(1, "cannot create bigfile");
+    2866:	83 ec 08             	sub    $0x8,%esp
+    2869:	68 a9 54 00 00       	push   $0x54a9
+    286e:	6a 01                	push   $0x1
+    2870:	e8 de 19 00 00       	call   4253 <printf>
+    2875:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2878:	e8 32 18 00 00       	call   40af <exit>
+  }
+  for(i = 0; i < 20; i++){
+    287d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    2884:	eb 52                	jmp    28d8 <bigfile+0xbc>
+    memset(buf, i, 600);
+    2886:	83 ec 04             	sub    $0x4,%esp
+    2889:	68 58 02 00 00       	push   $0x258
+    288e:	ff 75 f4             	pushl  -0xc(%ebp)
+    2891:	68 60 8d 00 00       	push   $0x8d60
+    2896:	e8 61 16 00 00       	call   3efc <memset>
+    289b:	83 c4 10             	add    $0x10,%esp
+    if(write(fd, buf, 600) != 600){
+    289e:	83 ec 04             	sub    $0x4,%esp
+    28a1:	68 58 02 00 00       	push   $0x258
+    28a6:	68 60 8d 00 00       	push   $0x8d60
+    28ab:	ff 75 ec             	pushl  -0x14(%ebp)
+    28ae:	e8 1c 18 00 00       	call   40cf <write>
+    28b3:	83 c4 10             	add    $0x10,%esp
+    28b6:	3d 58 02 00 00       	cmp    $0x258,%eax
+    28bb:	74 17                	je     28d4 <bigfile+0xb8>
+      printf(1, "write bigfile failed\n");
+    28bd:	83 ec 08             	sub    $0x8,%esp
+    28c0:	68 bf 54 00 00       	push   $0x54bf
+    28c5:	6a 01                	push   $0x1
+    28c7:	e8 87 19 00 00       	call   4253 <printf>
+    28cc:	83 c4 10             	add    $0x10,%esp
+      exit();
+    28cf:	e8 db 17 00 00       	call   40af <exit>
+  for(i = 0; i < 20; i++){
+    28d4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    28d8:	83 7d f4 13          	cmpl   $0x13,-0xc(%ebp)
+    28dc:	7e a8                	jle    2886 <bigfile+0x6a>
+    }
+  }
+  close(fd);
+    28de:	83 ec 0c             	sub    $0xc,%esp
+    28e1:	ff 75 ec             	pushl  -0x14(%ebp)
+    28e4:	e8 ee 17 00 00       	call   40d7 <close>
+    28e9:	83 c4 10             	add    $0x10,%esp
+
+  fd = open("bigfile", 0);
+    28ec:	83 ec 08             	sub    $0x8,%esp
+    28ef:	6a 00                	push   $0x0
+    28f1:	68 a1 54 00 00       	push   $0x54a1
+    28f6:	e8 f4 17 00 00       	call   40ef <open>
+    28fb:	83 c4 10             	add    $0x10,%esp
+    28fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+    2901:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    2905:	79 17                	jns    291e <bigfile+0x102>
+    printf(1, "cannot open bigfile\n");
+    2907:	83 ec 08             	sub    $0x8,%esp
+    290a:	68 d5 54 00 00       	push   $0x54d5
+    290f:	6a 01                	push   $0x1
+    2911:	e8 3d 19 00 00       	call   4253 <printf>
+    2916:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2919:	e8 91 17 00 00       	call   40af <exit>
+  }
+  total = 0;
+    291e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  for(i = 0; ; i++){
+    2925:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    cc = read(fd, buf, 300);
+    292c:	83 ec 04             	sub    $0x4,%esp
+    292f:	68 2c 01 00 00       	push   $0x12c
+    2934:	68 60 8d 00 00       	push   $0x8d60
+    2939:	ff 75 ec             	pushl  -0x14(%ebp)
+    293c:	e8 86 17 00 00       	call   40c7 <read>
+    2941:	83 c4 10             	add    $0x10,%esp
+    2944:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(cc < 0){
+    2947:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    294b:	79 17                	jns    2964 <bigfile+0x148>
+      printf(1, "read bigfile failed\n");
+    294d:	83 ec 08             	sub    $0x8,%esp
+    2950:	68 ea 54 00 00       	push   $0x54ea
+    2955:	6a 01                	push   $0x1
+    2957:	e8 f7 18 00 00       	call   4253 <printf>
+    295c:	83 c4 10             	add    $0x10,%esp
+      exit();
+    295f:	e8 4b 17 00 00       	call   40af <exit>
+    }
+    if(cc == 0)
+    2964:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    2968:	74 7a                	je     29e4 <bigfile+0x1c8>
+      break;
+    if(cc != 300){
+    296a:	81 7d e8 2c 01 00 00 	cmpl   $0x12c,-0x18(%ebp)
+    2971:	74 17                	je     298a <bigfile+0x16e>
+      printf(1, "short read bigfile\n");
+    2973:	83 ec 08             	sub    $0x8,%esp
+    2976:	68 ff 54 00 00       	push   $0x54ff
+    297b:	6a 01                	push   $0x1
+    297d:	e8 d1 18 00 00       	call   4253 <printf>
+    2982:	83 c4 10             	add    $0x10,%esp
+      exit();
+    2985:	e8 25 17 00 00       	call   40af <exit>
+    }
+    if(buf[0] != i/2 || buf[299] != i/2){
+    298a:	0f b6 05 60 8d 00 00 	movzbl 0x8d60,%eax
+    2991:	0f be d0             	movsbl %al,%edx
+    2994:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    2997:	89 c1                	mov    %eax,%ecx
+    2999:	c1 e9 1f             	shr    $0x1f,%ecx
+    299c:	01 c8                	add    %ecx,%eax
+    299e:	d1 f8                	sar    %eax
+    29a0:	39 c2                	cmp    %eax,%edx
+    29a2:	75 1a                	jne    29be <bigfile+0x1a2>
+    29a4:	0f b6 05 8b 8e 00 00 	movzbl 0x8e8b,%eax
+    29ab:	0f be d0             	movsbl %al,%edx
+    29ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    29b1:	89 c1                	mov    %eax,%ecx
+    29b3:	c1 e9 1f             	shr    $0x1f,%ecx
+    29b6:	01 c8                	add    %ecx,%eax
+    29b8:	d1 f8                	sar    %eax
+    29ba:	39 c2                	cmp    %eax,%edx
+    29bc:	74 17                	je     29d5 <bigfile+0x1b9>
+      printf(1, "read bigfile wrong data\n");
+    29be:	83 ec 08             	sub    $0x8,%esp
+    29c1:	68 13 55 00 00       	push   $0x5513
+    29c6:	6a 01                	push   $0x1
+    29c8:	e8 86 18 00 00       	call   4253 <printf>
+    29cd:	83 c4 10             	add    $0x10,%esp
+      exit();
+    29d0:	e8 da 16 00 00       	call   40af <exit>
+    }
+    total += cc;
+    29d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    29d8:	01 45 f0             	add    %eax,-0x10(%ebp)
+  for(i = 0; ; i++){
+    29db:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    cc = read(fd, buf, 300);
+    29df:	e9 48 ff ff ff       	jmp    292c <bigfile+0x110>
+      break;
+    29e4:	90                   	nop
+  }
+  close(fd);
+    29e5:	83 ec 0c             	sub    $0xc,%esp
+    29e8:	ff 75 ec             	pushl  -0x14(%ebp)
+    29eb:	e8 e7 16 00 00       	call   40d7 <close>
+    29f0:	83 c4 10             	add    $0x10,%esp
+  if(total != 20*600){
+    29f3:	81 7d f0 e0 2e 00 00 	cmpl   $0x2ee0,-0x10(%ebp)
+    29fa:	74 17                	je     2a13 <bigfile+0x1f7>
+    printf(1, "read bigfile wrong total\n");
+    29fc:	83 ec 08             	sub    $0x8,%esp
+    29ff:	68 2c 55 00 00       	push   $0x552c
+    2a04:	6a 01                	push   $0x1
+    2a06:	e8 48 18 00 00       	call   4253 <printf>
+    2a0b:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2a0e:	e8 9c 16 00 00       	call   40af <exit>
+  }
+  unlink("bigfile");
+    2a13:	83 ec 0c             	sub    $0xc,%esp
+    2a16:	68 a1 54 00 00       	push   $0x54a1
+    2a1b:	e8 df 16 00 00       	call   40ff <unlink>
+    2a20:	83 c4 10             	add    $0x10,%esp
+
+  printf(1, "bigfile test ok\n");
+    2a23:	83 ec 08             	sub    $0x8,%esp
+    2a26:	68 46 55 00 00       	push   $0x5546
+    2a2b:	6a 01                	push   $0x1
+    2a2d:	e8 21 18 00 00       	call   4253 <printf>
+    2a32:	83 c4 10             	add    $0x10,%esp
+}
+    2a35:	90                   	nop
+    2a36:	c9                   	leave  
+    2a37:	c3                   	ret    
+
+00002a38 <fourteen>:
+
+void
+fourteen(void)
+{
+    2a38:	f3 0f 1e fb          	endbr32 
+    2a3c:	55                   	push   %ebp
+    2a3d:	89 e5                	mov    %esp,%ebp
+    2a3f:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+
+  // DIRSIZ is 14.
+  printf(1, "fourteen test\n");
+    2a42:	83 ec 08             	sub    $0x8,%esp
+    2a45:	68 57 55 00 00       	push   $0x5557
+    2a4a:	6a 01                	push   $0x1
+    2a4c:	e8 02 18 00 00       	call   4253 <printf>
+    2a51:	83 c4 10             	add    $0x10,%esp
+
+  if(mkdir("12345678901234") != 0){
+    2a54:	83 ec 0c             	sub    $0xc,%esp
+    2a57:	68 66 55 00 00       	push   $0x5566
+    2a5c:	e8 b6 16 00 00       	call   4117 <mkdir>
+    2a61:	83 c4 10             	add    $0x10,%esp
+    2a64:	85 c0                	test   %eax,%eax
+    2a66:	74 17                	je     2a7f <fourteen+0x47>
+    printf(1, "mkdir 12345678901234 failed\n");
+    2a68:	83 ec 08             	sub    $0x8,%esp
+    2a6b:	68 75 55 00 00       	push   $0x5575
+    2a70:	6a 01                	push   $0x1
+    2a72:	e8 dc 17 00 00       	call   4253 <printf>
+    2a77:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2a7a:	e8 30 16 00 00       	call   40af <exit>
+  }
+  if(mkdir("12345678901234/123456789012345") != 0){
+    2a7f:	83 ec 0c             	sub    $0xc,%esp
+    2a82:	68 94 55 00 00       	push   $0x5594
+    2a87:	e8 8b 16 00 00       	call   4117 <mkdir>
+    2a8c:	83 c4 10             	add    $0x10,%esp
+    2a8f:	85 c0                	test   %eax,%eax
+    2a91:	74 17                	je     2aaa <fourteen+0x72>
+    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+    2a93:	83 ec 08             	sub    $0x8,%esp
+    2a96:	68 b4 55 00 00       	push   $0x55b4
+    2a9b:	6a 01                	push   $0x1
+    2a9d:	e8 b1 17 00 00       	call   4253 <printf>
+    2aa2:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2aa5:	e8 05 16 00 00       	call   40af <exit>
+  }
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+    2aaa:	83 ec 08             	sub    $0x8,%esp
+    2aad:	68 00 02 00 00       	push   $0x200
+    2ab2:	68 e4 55 00 00       	push   $0x55e4
+    2ab7:	e8 33 16 00 00       	call   40ef <open>
+    2abc:	83 c4 10             	add    $0x10,%esp
+    2abf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    2ac2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2ac6:	79 17                	jns    2adf <fourteen+0xa7>
+    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+    2ac8:	83 ec 08             	sub    $0x8,%esp
+    2acb:	68 14 56 00 00       	push   $0x5614
+    2ad0:	6a 01                	push   $0x1
+    2ad2:	e8 7c 17 00 00       	call   4253 <printf>
+    2ad7:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2ada:	e8 d0 15 00 00       	call   40af <exit>
+  }
+  close(fd);
+    2adf:	83 ec 0c             	sub    $0xc,%esp
+    2ae2:	ff 75 f4             	pushl  -0xc(%ebp)
+    2ae5:	e8 ed 15 00 00       	call   40d7 <close>
+    2aea:	83 c4 10             	add    $0x10,%esp
+  fd = open("12345678901234/12345678901234/12345678901234", 0);
+    2aed:	83 ec 08             	sub    $0x8,%esp
+    2af0:	6a 00                	push   $0x0
+    2af2:	68 54 56 00 00       	push   $0x5654
+    2af7:	e8 f3 15 00 00       	call   40ef <open>
+    2afc:	83 c4 10             	add    $0x10,%esp
+    2aff:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    2b02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2b06:	79 17                	jns    2b1f <fourteen+0xe7>
+    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+    2b08:	83 ec 08             	sub    $0x8,%esp
+    2b0b:	68 84 56 00 00       	push   $0x5684
+    2b10:	6a 01                	push   $0x1
+    2b12:	e8 3c 17 00 00       	call   4253 <printf>
+    2b17:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2b1a:	e8 90 15 00 00       	call   40af <exit>
+  }
+  close(fd);
+    2b1f:	83 ec 0c             	sub    $0xc,%esp
+    2b22:	ff 75 f4             	pushl  -0xc(%ebp)
+    2b25:	e8 ad 15 00 00       	call   40d7 <close>
+    2b2a:	83 c4 10             	add    $0x10,%esp
+
+  if(mkdir("12345678901234/12345678901234") == 0){
+    2b2d:	83 ec 0c             	sub    $0xc,%esp
+    2b30:	68 be 56 00 00       	push   $0x56be
+    2b35:	e8 dd 15 00 00       	call   4117 <mkdir>
+    2b3a:	83 c4 10             	add    $0x10,%esp
+    2b3d:	85 c0                	test   %eax,%eax
+    2b3f:	75 17                	jne    2b58 <fourteen+0x120>
+    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+    2b41:	83 ec 08             	sub    $0x8,%esp
+    2b44:	68 dc 56 00 00       	push   $0x56dc
+    2b49:	6a 01                	push   $0x1
+    2b4b:	e8 03 17 00 00       	call   4253 <printf>
+    2b50:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2b53:	e8 57 15 00 00       	call   40af <exit>
+  }
+  if(mkdir("123456789012345/12345678901234") == 0){
+    2b58:	83 ec 0c             	sub    $0xc,%esp
+    2b5b:	68 0c 57 00 00       	push   $0x570c
+    2b60:	e8 b2 15 00 00       	call   4117 <mkdir>
+    2b65:	83 c4 10             	add    $0x10,%esp
+    2b68:	85 c0                	test   %eax,%eax
+    2b6a:	75 17                	jne    2b83 <fourteen+0x14b>
+    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+    2b6c:	83 ec 08             	sub    $0x8,%esp
+    2b6f:	68 2c 57 00 00       	push   $0x572c
+    2b74:	6a 01                	push   $0x1
+    2b76:	e8 d8 16 00 00       	call   4253 <printf>
+    2b7b:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2b7e:	e8 2c 15 00 00       	call   40af <exit>
+  }
+
+  printf(1, "fourteen ok\n");
+    2b83:	83 ec 08             	sub    $0x8,%esp
+    2b86:	68 5d 57 00 00       	push   $0x575d
+    2b8b:	6a 01                	push   $0x1
+    2b8d:	e8 c1 16 00 00       	call   4253 <printf>
+    2b92:	83 c4 10             	add    $0x10,%esp
+}
+    2b95:	90                   	nop
+    2b96:	c9                   	leave  
+    2b97:	c3                   	ret    
+
+00002b98 <rmdot>:
+
+void
+rmdot(void)
+{
+    2b98:	f3 0f 1e fb          	endbr32 
+    2b9c:	55                   	push   %ebp
+    2b9d:	89 e5                	mov    %esp,%ebp
+    2b9f:	83 ec 08             	sub    $0x8,%esp
+  printf(1, "rmdot test\n");
+    2ba2:	83 ec 08             	sub    $0x8,%esp
+    2ba5:	68 6a 57 00 00       	push   $0x576a
+    2baa:	6a 01                	push   $0x1
+    2bac:	e8 a2 16 00 00       	call   4253 <printf>
+    2bb1:	83 c4 10             	add    $0x10,%esp
+  if(mkdir("dots") != 0){
+    2bb4:	83 ec 0c             	sub    $0xc,%esp
+    2bb7:	68 76 57 00 00       	push   $0x5776
+    2bbc:	e8 56 15 00 00       	call   4117 <mkdir>
+    2bc1:	83 c4 10             	add    $0x10,%esp
+    2bc4:	85 c0                	test   %eax,%eax
+    2bc6:	74 17                	je     2bdf <rmdot+0x47>
+    printf(1, "mkdir dots failed\n");
+    2bc8:	83 ec 08             	sub    $0x8,%esp
+    2bcb:	68 7b 57 00 00       	push   $0x577b
+    2bd0:	6a 01                	push   $0x1
+    2bd2:	e8 7c 16 00 00       	call   4253 <printf>
+    2bd7:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2bda:	e8 d0 14 00 00       	call   40af <exit>
+  }
+  if(chdir("dots") != 0){
+    2bdf:	83 ec 0c             	sub    $0xc,%esp
+    2be2:	68 76 57 00 00       	push   $0x5776
+    2be7:	e8 33 15 00 00       	call   411f <chdir>
+    2bec:	83 c4 10             	add    $0x10,%esp
+    2bef:	85 c0                	test   %eax,%eax
+    2bf1:	74 17                	je     2c0a <rmdot+0x72>
+    printf(1, "chdir dots failed\n");
+    2bf3:	83 ec 08             	sub    $0x8,%esp
+    2bf6:	68 8e 57 00 00       	push   $0x578e
+    2bfb:	6a 01                	push   $0x1
+    2bfd:	e8 51 16 00 00       	call   4253 <printf>
+    2c02:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2c05:	e8 a5 14 00 00       	call   40af <exit>
+  }
+  if(unlink(".") == 0){
+    2c0a:	83 ec 0c             	sub    $0xc,%esp
+    2c0d:	68 a7 4e 00 00       	push   $0x4ea7
+    2c12:	e8 e8 14 00 00       	call   40ff <unlink>
+    2c17:	83 c4 10             	add    $0x10,%esp
+    2c1a:	85 c0                	test   %eax,%eax
+    2c1c:	75 17                	jne    2c35 <rmdot+0x9d>
+    printf(1, "rm . worked!\n");
+    2c1e:	83 ec 08             	sub    $0x8,%esp
+    2c21:	68 a1 57 00 00       	push   $0x57a1
+    2c26:	6a 01                	push   $0x1
+    2c28:	e8 26 16 00 00       	call   4253 <printf>
+    2c2d:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2c30:	e8 7a 14 00 00       	call   40af <exit>
+  }
+  if(unlink("..") == 0){
+    2c35:	83 ec 0c             	sub    $0xc,%esp
+    2c38:	68 3a 4a 00 00       	push   $0x4a3a
+    2c3d:	e8 bd 14 00 00       	call   40ff <unlink>
+    2c42:	83 c4 10             	add    $0x10,%esp
+    2c45:	85 c0                	test   %eax,%eax
+    2c47:	75 17                	jne    2c60 <rmdot+0xc8>
+    printf(1, "rm .. worked!\n");
+    2c49:	83 ec 08             	sub    $0x8,%esp
+    2c4c:	68 af 57 00 00       	push   $0x57af
+    2c51:	6a 01                	push   $0x1
+    2c53:	e8 fb 15 00 00       	call   4253 <printf>
+    2c58:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2c5b:	e8 4f 14 00 00       	call   40af <exit>
+  }
+  if(chdir("/") != 0){
+    2c60:	83 ec 0c             	sub    $0xc,%esp
+    2c63:	68 8e 46 00 00       	push   $0x468e
+    2c68:	e8 b2 14 00 00       	call   411f <chdir>
+    2c6d:	83 c4 10             	add    $0x10,%esp
+    2c70:	85 c0                	test   %eax,%eax
+    2c72:	74 17                	je     2c8b <rmdot+0xf3>
+    printf(1, "chdir / failed\n");
+    2c74:	83 ec 08             	sub    $0x8,%esp
+    2c77:	68 90 46 00 00       	push   $0x4690
+    2c7c:	6a 01                	push   $0x1
+    2c7e:	e8 d0 15 00 00       	call   4253 <printf>
+    2c83:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2c86:	e8 24 14 00 00       	call   40af <exit>
+  }
+  if(unlink("dots/.") == 0){
+    2c8b:	83 ec 0c             	sub    $0xc,%esp
+    2c8e:	68 be 57 00 00       	push   $0x57be
+    2c93:	e8 67 14 00 00       	call   40ff <unlink>
+    2c98:	83 c4 10             	add    $0x10,%esp
+    2c9b:	85 c0                	test   %eax,%eax
+    2c9d:	75 17                	jne    2cb6 <rmdot+0x11e>
+    printf(1, "unlink dots/. worked!\n");
+    2c9f:	83 ec 08             	sub    $0x8,%esp
+    2ca2:	68 c5 57 00 00       	push   $0x57c5
+    2ca7:	6a 01                	push   $0x1
+    2ca9:	e8 a5 15 00 00       	call   4253 <printf>
+    2cae:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2cb1:	e8 f9 13 00 00       	call   40af <exit>
+  }
+  if(unlink("dots/..") == 0){
+    2cb6:	83 ec 0c             	sub    $0xc,%esp
+    2cb9:	68 dc 57 00 00       	push   $0x57dc
+    2cbe:	e8 3c 14 00 00       	call   40ff <unlink>
+    2cc3:	83 c4 10             	add    $0x10,%esp
+    2cc6:	85 c0                	test   %eax,%eax
+    2cc8:	75 17                	jne    2ce1 <rmdot+0x149>
+    printf(1, "unlink dots/.. worked!\n");
+    2cca:	83 ec 08             	sub    $0x8,%esp
+    2ccd:	68 e4 57 00 00       	push   $0x57e4
+    2cd2:	6a 01                	push   $0x1
+    2cd4:	e8 7a 15 00 00       	call   4253 <printf>
+    2cd9:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2cdc:	e8 ce 13 00 00       	call   40af <exit>
+  }
+  if(unlink("dots") != 0){
+    2ce1:	83 ec 0c             	sub    $0xc,%esp
+    2ce4:	68 76 57 00 00       	push   $0x5776
+    2ce9:	e8 11 14 00 00       	call   40ff <unlink>
+    2cee:	83 c4 10             	add    $0x10,%esp
+    2cf1:	85 c0                	test   %eax,%eax
+    2cf3:	74 17                	je     2d0c <rmdot+0x174>
+    printf(1, "unlink dots failed!\n");
+    2cf5:	83 ec 08             	sub    $0x8,%esp
+    2cf8:	68 fc 57 00 00       	push   $0x57fc
+    2cfd:	6a 01                	push   $0x1
+    2cff:	e8 4f 15 00 00       	call   4253 <printf>
+    2d04:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2d07:	e8 a3 13 00 00       	call   40af <exit>
+  }
+  printf(1, "rmdot ok\n");
+    2d0c:	83 ec 08             	sub    $0x8,%esp
+    2d0f:	68 11 58 00 00       	push   $0x5811
+    2d14:	6a 01                	push   $0x1
+    2d16:	e8 38 15 00 00       	call   4253 <printf>
+    2d1b:	83 c4 10             	add    $0x10,%esp
+}
+    2d1e:	90                   	nop
+    2d1f:	c9                   	leave  
+    2d20:	c3                   	ret    
+
+00002d21 <dirfile>:
+
+void
+dirfile(void)
+{
+    2d21:	f3 0f 1e fb          	endbr32 
+    2d25:	55                   	push   %ebp
+    2d26:	89 e5                	mov    %esp,%ebp
+    2d28:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+
+  printf(1, "dir vs file\n");
+    2d2b:	83 ec 08             	sub    $0x8,%esp
+    2d2e:	68 1b 58 00 00       	push   $0x581b
+    2d33:	6a 01                	push   $0x1
+    2d35:	e8 19 15 00 00       	call   4253 <printf>
+    2d3a:	83 c4 10             	add    $0x10,%esp
+
+  fd = open("dirfile", O_CREATE);
+    2d3d:	83 ec 08             	sub    $0x8,%esp
+    2d40:	68 00 02 00 00       	push   $0x200
+    2d45:	68 28 58 00 00       	push   $0x5828
+    2d4a:	e8 a0 13 00 00       	call   40ef <open>
+    2d4f:	83 c4 10             	add    $0x10,%esp
+    2d52:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0){
+    2d55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2d59:	79 17                	jns    2d72 <dirfile+0x51>
+    printf(1, "create dirfile failed\n");
+    2d5b:	83 ec 08             	sub    $0x8,%esp
+    2d5e:	68 30 58 00 00       	push   $0x5830
+    2d63:	6a 01                	push   $0x1
+    2d65:	e8 e9 14 00 00       	call   4253 <printf>
+    2d6a:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2d6d:	e8 3d 13 00 00       	call   40af <exit>
+  }
+  close(fd);
+    2d72:	83 ec 0c             	sub    $0xc,%esp
+    2d75:	ff 75 f4             	pushl  -0xc(%ebp)
+    2d78:	e8 5a 13 00 00       	call   40d7 <close>
+    2d7d:	83 c4 10             	add    $0x10,%esp
+  if(chdir("dirfile") == 0){
+    2d80:	83 ec 0c             	sub    $0xc,%esp
+    2d83:	68 28 58 00 00       	push   $0x5828
+    2d88:	e8 92 13 00 00       	call   411f <chdir>
+    2d8d:	83 c4 10             	add    $0x10,%esp
+    2d90:	85 c0                	test   %eax,%eax
+    2d92:	75 17                	jne    2dab <dirfile+0x8a>
+    printf(1, "chdir dirfile succeeded!\n");
+    2d94:	83 ec 08             	sub    $0x8,%esp
+    2d97:	68 47 58 00 00       	push   $0x5847
+    2d9c:	6a 01                	push   $0x1
+    2d9e:	e8 b0 14 00 00       	call   4253 <printf>
+    2da3:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2da6:	e8 04 13 00 00       	call   40af <exit>
+  }
+  fd = open("dirfile/xx", 0);
+    2dab:	83 ec 08             	sub    $0x8,%esp
+    2dae:	6a 00                	push   $0x0
+    2db0:	68 61 58 00 00       	push   $0x5861
+    2db5:	e8 35 13 00 00       	call   40ef <open>
+    2dba:	83 c4 10             	add    $0x10,%esp
+    2dbd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd >= 0){
+    2dc0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2dc4:	78 17                	js     2ddd <dirfile+0xbc>
+    printf(1, "create dirfile/xx succeeded!\n");
+    2dc6:	83 ec 08             	sub    $0x8,%esp
+    2dc9:	68 6c 58 00 00       	push   $0x586c
+    2dce:	6a 01                	push   $0x1
+    2dd0:	e8 7e 14 00 00       	call   4253 <printf>
+    2dd5:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2dd8:	e8 d2 12 00 00       	call   40af <exit>
+  }
+  fd = open("dirfile/xx", O_CREATE);
+    2ddd:	83 ec 08             	sub    $0x8,%esp
+    2de0:	68 00 02 00 00       	push   $0x200
+    2de5:	68 61 58 00 00       	push   $0x5861
+    2dea:	e8 00 13 00 00       	call   40ef <open>
+    2def:	83 c4 10             	add    $0x10,%esp
+    2df2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd >= 0){
+    2df5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2df9:	78 17                	js     2e12 <dirfile+0xf1>
+    printf(1, "create dirfile/xx succeeded!\n");
+    2dfb:	83 ec 08             	sub    $0x8,%esp
+    2dfe:	68 6c 58 00 00       	push   $0x586c
+    2e03:	6a 01                	push   $0x1
+    2e05:	e8 49 14 00 00       	call   4253 <printf>
+    2e0a:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2e0d:	e8 9d 12 00 00       	call   40af <exit>
+  }
+  if(mkdir("dirfile/xx") == 0){
+    2e12:	83 ec 0c             	sub    $0xc,%esp
+    2e15:	68 61 58 00 00       	push   $0x5861
+    2e1a:	e8 f8 12 00 00       	call   4117 <mkdir>
+    2e1f:	83 c4 10             	add    $0x10,%esp
+    2e22:	85 c0                	test   %eax,%eax
+    2e24:	75 17                	jne    2e3d <dirfile+0x11c>
+    printf(1, "mkdir dirfile/xx succeeded!\n");
+    2e26:	83 ec 08             	sub    $0x8,%esp
+    2e29:	68 8a 58 00 00       	push   $0x588a
+    2e2e:	6a 01                	push   $0x1
+    2e30:	e8 1e 14 00 00       	call   4253 <printf>
+    2e35:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2e38:	e8 72 12 00 00       	call   40af <exit>
+  }
+  if(unlink("dirfile/xx") == 0){
+    2e3d:	83 ec 0c             	sub    $0xc,%esp
+    2e40:	68 61 58 00 00       	push   $0x5861
+    2e45:	e8 b5 12 00 00       	call   40ff <unlink>
+    2e4a:	83 c4 10             	add    $0x10,%esp
+    2e4d:	85 c0                	test   %eax,%eax
+    2e4f:	75 17                	jne    2e68 <dirfile+0x147>
+    printf(1, "unlink dirfile/xx succeeded!\n");
+    2e51:	83 ec 08             	sub    $0x8,%esp
+    2e54:	68 a7 58 00 00       	push   $0x58a7
+    2e59:	6a 01                	push   $0x1
+    2e5b:	e8 f3 13 00 00       	call   4253 <printf>
+    2e60:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2e63:	e8 47 12 00 00       	call   40af <exit>
+  }
+  if(link("README", "dirfile/xx") == 0){
+    2e68:	83 ec 08             	sub    $0x8,%esp
+    2e6b:	68 61 58 00 00       	push   $0x5861
+    2e70:	68 c5 58 00 00       	push   $0x58c5
+    2e75:	e8 95 12 00 00       	call   410f <link>
+    2e7a:	83 c4 10             	add    $0x10,%esp
+    2e7d:	85 c0                	test   %eax,%eax
+    2e7f:	75 17                	jne    2e98 <dirfile+0x177>
+    printf(1, "link to dirfile/xx succeeded!\n");
+    2e81:	83 ec 08             	sub    $0x8,%esp
+    2e84:	68 cc 58 00 00       	push   $0x58cc
+    2e89:	6a 01                	push   $0x1
+    2e8b:	e8 c3 13 00 00       	call   4253 <printf>
+    2e90:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2e93:	e8 17 12 00 00       	call   40af <exit>
+  }
+  if(unlink("dirfile") != 0){
+    2e98:	83 ec 0c             	sub    $0xc,%esp
+    2e9b:	68 28 58 00 00       	push   $0x5828
+    2ea0:	e8 5a 12 00 00       	call   40ff <unlink>
+    2ea5:	83 c4 10             	add    $0x10,%esp
+    2ea8:	85 c0                	test   %eax,%eax
+    2eaa:	74 17                	je     2ec3 <dirfile+0x1a2>
+    printf(1, "unlink dirfile failed!\n");
+    2eac:	83 ec 08             	sub    $0x8,%esp
+    2eaf:	68 eb 58 00 00       	push   $0x58eb
+    2eb4:	6a 01                	push   $0x1
+    2eb6:	e8 98 13 00 00       	call   4253 <printf>
+    2ebb:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2ebe:	e8 ec 11 00 00       	call   40af <exit>
+  }
+
+  fd = open(".", O_RDWR);
+    2ec3:	83 ec 08             	sub    $0x8,%esp
+    2ec6:	6a 02                	push   $0x2
+    2ec8:	68 a7 4e 00 00       	push   $0x4ea7
+    2ecd:	e8 1d 12 00 00       	call   40ef <open>
+    2ed2:	83 c4 10             	add    $0x10,%esp
+    2ed5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd >= 0){
+    2ed8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    2edc:	78 17                	js     2ef5 <dirfile+0x1d4>
+    printf(1, "open . for writing succeeded!\n");
+    2ede:	83 ec 08             	sub    $0x8,%esp
+    2ee1:	68 04 59 00 00       	push   $0x5904
+    2ee6:	6a 01                	push   $0x1
+    2ee8:	e8 66 13 00 00       	call   4253 <printf>
+    2eed:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2ef0:	e8 ba 11 00 00       	call   40af <exit>
+  }
+  fd = open(".", 0);
+    2ef5:	83 ec 08             	sub    $0x8,%esp
+    2ef8:	6a 00                	push   $0x0
+    2efa:	68 a7 4e 00 00       	push   $0x4ea7
+    2eff:	e8 eb 11 00 00       	call   40ef <open>
+    2f04:	83 c4 10             	add    $0x10,%esp
+    2f07:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(write(fd, "x", 1) > 0){
+    2f0a:	83 ec 04             	sub    $0x4,%esp
+    2f0d:	6a 01                	push   $0x1
+    2f0f:	68 f3 4a 00 00       	push   $0x4af3
+    2f14:	ff 75 f4             	pushl  -0xc(%ebp)
+    2f17:	e8 b3 11 00 00       	call   40cf <write>
+    2f1c:	83 c4 10             	add    $0x10,%esp
+    2f1f:	85 c0                	test   %eax,%eax
+    2f21:	7e 17                	jle    2f3a <dirfile+0x219>
+    printf(1, "write . succeeded!\n");
+    2f23:	83 ec 08             	sub    $0x8,%esp
+    2f26:	68 23 59 00 00       	push   $0x5923
+    2f2b:	6a 01                	push   $0x1
+    2f2d:	e8 21 13 00 00       	call   4253 <printf>
+    2f32:	83 c4 10             	add    $0x10,%esp
+    exit();
+    2f35:	e8 75 11 00 00       	call   40af <exit>
+  }
+  close(fd);
+    2f3a:	83 ec 0c             	sub    $0xc,%esp
+    2f3d:	ff 75 f4             	pushl  -0xc(%ebp)
+    2f40:	e8 92 11 00 00       	call   40d7 <close>
+    2f45:	83 c4 10             	add    $0x10,%esp
+
+  printf(1, "dir vs file OK\n");
+    2f48:	83 ec 08             	sub    $0x8,%esp
+    2f4b:	68 37 59 00 00       	push   $0x5937
+    2f50:	6a 01                	push   $0x1
+    2f52:	e8 fc 12 00 00       	call   4253 <printf>
+    2f57:	83 c4 10             	add    $0x10,%esp
+}
+    2f5a:	90                   	nop
+    2f5b:	c9                   	leave  
+    2f5c:	c3                   	ret    
+
+00002f5d <iref>:
+
+// test that iput() is called at the end of _namei()
+void
+iref(void)
+{
+    2f5d:	f3 0f 1e fb          	endbr32 
+    2f61:	55                   	push   %ebp
+    2f62:	89 e5                	mov    %esp,%ebp
+    2f64:	83 ec 18             	sub    $0x18,%esp
+  int i, fd;
+
+  printf(1, "empty file name\n");
+    2f67:	83 ec 08             	sub    $0x8,%esp
+    2f6a:	68 47 59 00 00       	push   $0x5947
+    2f6f:	6a 01                	push   $0x1
+    2f71:	e8 dd 12 00 00       	call   4253 <printf>
+    2f76:	83 c4 10             	add    $0x10,%esp
+
+  // the 50 is NINODE
+  for(i = 0; i < 50 + 1; i++){
+    2f79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    2f80:	e9 e7 00 00 00       	jmp    306c <iref+0x10f>
+    if(mkdir("irefd") != 0){
+    2f85:	83 ec 0c             	sub    $0xc,%esp
+    2f88:	68 58 59 00 00       	push   $0x5958
+    2f8d:	e8 85 11 00 00       	call   4117 <mkdir>
+    2f92:	83 c4 10             	add    $0x10,%esp
+    2f95:	85 c0                	test   %eax,%eax
+    2f97:	74 17                	je     2fb0 <iref+0x53>
+      printf(1, "mkdir irefd failed\n");
+    2f99:	83 ec 08             	sub    $0x8,%esp
+    2f9c:	68 5e 59 00 00       	push   $0x595e
+    2fa1:	6a 01                	push   $0x1
+    2fa3:	e8 ab 12 00 00       	call   4253 <printf>
+    2fa8:	83 c4 10             	add    $0x10,%esp
+      exit();
+    2fab:	e8 ff 10 00 00       	call   40af <exit>
+    }
+    if(chdir("irefd") != 0){
+    2fb0:	83 ec 0c             	sub    $0xc,%esp
+    2fb3:	68 58 59 00 00       	push   $0x5958
+    2fb8:	e8 62 11 00 00       	call   411f <chdir>
+    2fbd:	83 c4 10             	add    $0x10,%esp
+    2fc0:	85 c0                	test   %eax,%eax
+    2fc2:	74 17                	je     2fdb <iref+0x7e>
+      printf(1, "chdir irefd failed\n");
+    2fc4:	83 ec 08             	sub    $0x8,%esp
+    2fc7:	68 72 59 00 00       	push   $0x5972
+    2fcc:	6a 01                	push   $0x1
+    2fce:	e8 80 12 00 00       	call   4253 <printf>
+    2fd3:	83 c4 10             	add    $0x10,%esp
+      exit();
+    2fd6:	e8 d4 10 00 00       	call   40af <exit>
+    }
+
+    mkdir("");
+    2fdb:	83 ec 0c             	sub    $0xc,%esp
+    2fde:	68 86 59 00 00       	push   $0x5986
+    2fe3:	e8 2f 11 00 00       	call   4117 <mkdir>
+    2fe8:	83 c4 10             	add    $0x10,%esp
+    link("README", "");
+    2feb:	83 ec 08             	sub    $0x8,%esp
+    2fee:	68 86 59 00 00       	push   $0x5986
+    2ff3:	68 c5 58 00 00       	push   $0x58c5
+    2ff8:	e8 12 11 00 00       	call   410f <link>
+    2ffd:	83 c4 10             	add    $0x10,%esp
+    fd = open("", O_CREATE);
+    3000:	83 ec 08             	sub    $0x8,%esp
+    3003:	68 00 02 00 00       	push   $0x200
+    3008:	68 86 59 00 00       	push   $0x5986
+    300d:	e8 dd 10 00 00       	call   40ef <open>
+    3012:	83 c4 10             	add    $0x10,%esp
+    3015:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(fd >= 0)
+    3018:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    301c:	78 0e                	js     302c <iref+0xcf>
+      close(fd);
+    301e:	83 ec 0c             	sub    $0xc,%esp
+    3021:	ff 75 f0             	pushl  -0x10(%ebp)
+    3024:	e8 ae 10 00 00       	call   40d7 <close>
+    3029:	83 c4 10             	add    $0x10,%esp
+    fd = open("xx", O_CREATE);
+    302c:	83 ec 08             	sub    $0x8,%esp
+    302f:	68 00 02 00 00       	push   $0x200
+    3034:	68 87 59 00 00       	push   $0x5987
+    3039:	e8 b1 10 00 00       	call   40ef <open>
+    303e:	83 c4 10             	add    $0x10,%esp
+    3041:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(fd >= 0)
+    3044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    3048:	78 0e                	js     3058 <iref+0xfb>
+      close(fd);
+    304a:	83 ec 0c             	sub    $0xc,%esp
+    304d:	ff 75 f0             	pushl  -0x10(%ebp)
+    3050:	e8 82 10 00 00       	call   40d7 <close>
+    3055:	83 c4 10             	add    $0x10,%esp
+    unlink("xx");
+    3058:	83 ec 0c             	sub    $0xc,%esp
+    305b:	68 87 59 00 00       	push   $0x5987
+    3060:	e8 9a 10 00 00       	call   40ff <unlink>
+    3065:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < 50 + 1; i++){
+    3068:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    306c:	83 7d f4 32          	cmpl   $0x32,-0xc(%ebp)
+    3070:	0f 8e 0f ff ff ff    	jle    2f85 <iref+0x28>
+  }
+
+  chdir("/");
+    3076:	83 ec 0c             	sub    $0xc,%esp
+    3079:	68 8e 46 00 00       	push   $0x468e
+    307e:	e8 9c 10 00 00       	call   411f <chdir>
+    3083:	83 c4 10             	add    $0x10,%esp
+  printf(1, "empty file name OK\n");
+    3086:	83 ec 08             	sub    $0x8,%esp
+    3089:	68 8a 59 00 00       	push   $0x598a
+    308e:	6a 01                	push   $0x1
+    3090:	e8 be 11 00 00       	call   4253 <printf>
+    3095:	83 c4 10             	add    $0x10,%esp
+}
+    3098:	90                   	nop
+    3099:	c9                   	leave  
+    309a:	c3                   	ret    
+
+0000309b <forktest>:
+// test that fork fails gracefully
+// the forktest binary also does this, but it runs out of proc entries first.
+// inside the bigger usertests binary, we run out of memory first.
+void
+forktest(void)
+{
+    309b:	f3 0f 1e fb          	endbr32 
+    309f:	55                   	push   %ebp
+    30a0:	89 e5                	mov    %esp,%ebp
+    30a2:	83 ec 18             	sub    $0x18,%esp
+  int n, pid;
+
+  printf(1, "fork test\n");
+    30a5:	83 ec 08             	sub    $0x8,%esp
+    30a8:	68 9e 59 00 00       	push   $0x599e
+    30ad:	6a 01                	push   $0x1
+    30af:	e8 9f 11 00 00       	call   4253 <printf>
+    30b4:	83 c4 10             	add    $0x10,%esp
+
+  for(n=0; n<1000; n++){
+    30b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    30be:	eb 1d                	jmp    30dd <forktest+0x42>
+    pid = fork();
+    30c0:	e8 e2 0f 00 00       	call   40a7 <fork>
+    30c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(pid < 0)
+    30c8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    30cc:	78 1a                	js     30e8 <forktest+0x4d>
+      break;
+    if(pid == 0)
+    30ce:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    30d2:	75 05                	jne    30d9 <forktest+0x3e>
+      exit();
+    30d4:	e8 d6 0f 00 00       	call   40af <exit>
+  for(n=0; n<1000; n++){
+    30d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    30dd:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
+    30e4:	7e da                	jle    30c0 <forktest+0x25>
+    30e6:	eb 01                	jmp    30e9 <forktest+0x4e>
+      break;
+    30e8:	90                   	nop
+  }
+
+  if(n == 1000){
+    30e9:	81 7d f4 e8 03 00 00 	cmpl   $0x3e8,-0xc(%ebp)
+    30f0:	75 3b                	jne    312d <forktest+0x92>
+    printf(1, "fork claimed to work 1000 times!\n");
+    30f2:	83 ec 08             	sub    $0x8,%esp
+    30f5:	68 ac 59 00 00       	push   $0x59ac
+    30fa:	6a 01                	push   $0x1
+    30fc:	e8 52 11 00 00       	call   4253 <printf>
+    3101:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3104:	e8 a6 0f 00 00       	call   40af <exit>
+  }
+
+  for(; n > 0; n--){
+    if(wait() < 0){
+    3109:	e8 a9 0f 00 00       	call   40b7 <wait>
+    310e:	85 c0                	test   %eax,%eax
+    3110:	79 17                	jns    3129 <forktest+0x8e>
+      printf(1, "wait stopped early\n");
+    3112:	83 ec 08             	sub    $0x8,%esp
+    3115:	68 ce 59 00 00       	push   $0x59ce
+    311a:	6a 01                	push   $0x1
+    311c:	e8 32 11 00 00       	call   4253 <printf>
+    3121:	83 c4 10             	add    $0x10,%esp
+      exit();
+    3124:	e8 86 0f 00 00       	call   40af <exit>
+  for(; n > 0; n--){
+    3129:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+    312d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    3131:	7f d6                	jg     3109 <forktest+0x6e>
+    }
+  }
+
+  if(wait() != -1){
+    3133:	e8 7f 0f 00 00       	call   40b7 <wait>
+    3138:	83 f8 ff             	cmp    $0xffffffff,%eax
+    313b:	74 17                	je     3154 <forktest+0xb9>
+    printf(1, "wait got too many\n");
+    313d:	83 ec 08             	sub    $0x8,%esp
+    3140:	68 e2 59 00 00       	push   $0x59e2
+    3145:	6a 01                	push   $0x1
+    3147:	e8 07 11 00 00       	call   4253 <printf>
+    314c:	83 c4 10             	add    $0x10,%esp
+    exit();
+    314f:	e8 5b 0f 00 00       	call   40af <exit>
+  }
+
+  printf(1, "fork test OK\n");
+    3154:	83 ec 08             	sub    $0x8,%esp
+    3157:	68 f5 59 00 00       	push   $0x59f5
+    315c:	6a 01                	push   $0x1
+    315e:	e8 f0 10 00 00       	call   4253 <printf>
+    3163:	83 c4 10             	add    $0x10,%esp
+}
+    3166:	90                   	nop
+    3167:	c9                   	leave  
+    3168:	c3                   	ret    
+
+00003169 <sbrktest>:
+
+void
+sbrktest(void)
+{
+    3169:	f3 0f 1e fb          	endbr32 
+    316d:	55                   	push   %ebp
+    316e:	89 e5                	mov    %esp,%ebp
+    3170:	83 ec 68             	sub    $0x68,%esp
+  int fds[2], pid, pids[10], ppid;
+  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+  uint amt;
+
+  printf(stdout, "sbrk test\n");
+    3173:	a1 70 65 00 00       	mov    0x6570,%eax
+    3178:	83 ec 08             	sub    $0x8,%esp
+    317b:	68 03 5a 00 00       	push   $0x5a03
+    3180:	50                   	push   %eax
+    3181:	e8 cd 10 00 00       	call   4253 <printf>
+    3186:	83 c4 10             	add    $0x10,%esp
+  oldbrk = sbrk(0);
+    3189:	83 ec 0c             	sub    $0xc,%esp
+    318c:	6a 00                	push   $0x0
+    318e:	e8 a4 0f 00 00       	call   4137 <sbrk>
+    3193:	83 c4 10             	add    $0x10,%esp
+    3196:	89 45 ec             	mov    %eax,-0x14(%ebp)
+
+  // can one sbrk() less than a page?
+  a = sbrk(0);
+    3199:	83 ec 0c             	sub    $0xc,%esp
+    319c:	6a 00                	push   $0x0
+    319e:	e8 94 0f 00 00       	call   4137 <sbrk>
+    31a3:	83 c4 10             	add    $0x10,%esp
+    31a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  int i;
+  for(i = 0; i < 5000; i++){
+    31a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    31b0:	eb 4f                	jmp    3201 <sbrktest+0x98>
+    b = sbrk(1);
+    31b2:	83 ec 0c             	sub    $0xc,%esp
+    31b5:	6a 01                	push   $0x1
+    31b7:	e8 7b 0f 00 00       	call   4137 <sbrk>
+    31bc:	83 c4 10             	add    $0x10,%esp
+    31bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    if(b != a){
+    31c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    31c5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    31c8:	74 24                	je     31ee <sbrktest+0x85>
+      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+    31ca:	a1 70 65 00 00       	mov    0x6570,%eax
+    31cf:	83 ec 0c             	sub    $0xc,%esp
+    31d2:	ff 75 d0             	pushl  -0x30(%ebp)
+    31d5:	ff 75 f4             	pushl  -0xc(%ebp)
+    31d8:	ff 75 f0             	pushl  -0x10(%ebp)
+    31db:	68 0e 5a 00 00       	push   $0x5a0e
+    31e0:	50                   	push   %eax
+    31e1:	e8 6d 10 00 00       	call   4253 <printf>
+    31e6:	83 c4 20             	add    $0x20,%esp
+      exit();
+    31e9:	e8 c1 0e 00 00       	call   40af <exit>
+    }
+    *b = 1;
+    31ee:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    31f1:	c6 00 01             	movb   $0x1,(%eax)
+    a = b + 1;
+    31f4:	8b 45 d0             	mov    -0x30(%ebp),%eax
+    31f7:	83 c0 01             	add    $0x1,%eax
+    31fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  for(i = 0; i < 5000; i++){
+    31fd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    3201:	81 7d f0 87 13 00 00 	cmpl   $0x1387,-0x10(%ebp)
+    3208:	7e a8                	jle    31b2 <sbrktest+0x49>
+  }
+  pid = fork();
+    320a:	e8 98 0e 00 00       	call   40a7 <fork>
+    320f:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  if(pid < 0){
+    3212:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    3216:	79 1b                	jns    3233 <sbrktest+0xca>
+    printf(stdout, "sbrk test fork failed\n");
+    3218:	a1 70 65 00 00       	mov    0x6570,%eax
+    321d:	83 ec 08             	sub    $0x8,%esp
+    3220:	68 29 5a 00 00       	push   $0x5a29
+    3225:	50                   	push   %eax
+    3226:	e8 28 10 00 00       	call   4253 <printf>
+    322b:	83 c4 10             	add    $0x10,%esp
+    exit();
+    322e:	e8 7c 0e 00 00       	call   40af <exit>
+  }
+  c = sbrk(1);
+    3233:	83 ec 0c             	sub    $0xc,%esp
+    3236:	6a 01                	push   $0x1
+    3238:	e8 fa 0e 00 00       	call   4137 <sbrk>
+    323d:	83 c4 10             	add    $0x10,%esp
+    3240:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  c = sbrk(1);
+    3243:	83 ec 0c             	sub    $0xc,%esp
+    3246:	6a 01                	push   $0x1
+    3248:	e8 ea 0e 00 00       	call   4137 <sbrk>
+    324d:	83 c4 10             	add    $0x10,%esp
+    3250:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(c != a + 1){
+    3253:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3256:	83 c0 01             	add    $0x1,%eax
+    3259:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+    325c:	74 1b                	je     3279 <sbrktest+0x110>
+    printf(stdout, "sbrk test failed post-fork\n");
+    325e:	a1 70 65 00 00       	mov    0x6570,%eax
+    3263:	83 ec 08             	sub    $0x8,%esp
+    3266:	68 40 5a 00 00       	push   $0x5a40
+    326b:	50                   	push   %eax
+    326c:	e8 e2 0f 00 00       	call   4253 <printf>
+    3271:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3274:	e8 36 0e 00 00       	call   40af <exit>
+  }
+  if(pid == 0)
+    3279:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    327d:	75 05                	jne    3284 <sbrktest+0x11b>
+    exit();
+    327f:	e8 2b 0e 00 00       	call   40af <exit>
+  wait();
+    3284:	e8 2e 0e 00 00       	call   40b7 <wait>
+
+  // can one grow address space to something big?
+#define BIG (100*1024*1024)
+  a = sbrk(0);
+    3289:	83 ec 0c             	sub    $0xc,%esp
+    328c:	6a 00                	push   $0x0
+    328e:	e8 a4 0e 00 00       	call   4137 <sbrk>
+    3293:	83 c4 10             	add    $0x10,%esp
+    3296:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  amt = (BIG) - (uint)a;
+    3299:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    329c:	ba 00 00 40 06       	mov    $0x6400000,%edx
+    32a1:	29 c2                	sub    %eax,%edx
+    32a3:	89 d0                	mov    %edx,%eax
+    32a5:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  p = sbrk(amt);
+    32a8:	8b 45 e0             	mov    -0x20(%ebp),%eax
+    32ab:	83 ec 0c             	sub    $0xc,%esp
+    32ae:	50                   	push   %eax
+    32af:	e8 83 0e 00 00       	call   4137 <sbrk>
+    32b4:	83 c4 10             	add    $0x10,%esp
+    32b7:	89 45 dc             	mov    %eax,-0x24(%ebp)
+  if (p != a) {
+    32ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
+    32bd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    32c0:	74 1b                	je     32dd <sbrktest+0x174>
+    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+    32c2:	a1 70 65 00 00       	mov    0x6570,%eax
+    32c7:	83 ec 08             	sub    $0x8,%esp
+    32ca:	68 5c 5a 00 00       	push   $0x5a5c
+    32cf:	50                   	push   %eax
+    32d0:	e8 7e 0f 00 00       	call   4253 <printf>
+    32d5:	83 c4 10             	add    $0x10,%esp
+    exit();
+    32d8:	e8 d2 0d 00 00       	call   40af <exit>
+  }
+  lastaddr = (char*) (BIG-1);
+    32dd:	c7 45 d8 ff ff 3f 06 	movl   $0x63fffff,-0x28(%ebp)
+  *lastaddr = 99;
+    32e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
+    32e7:	c6 00 63             	movb   $0x63,(%eax)
+
+  // can one de-allocate?
+  a = sbrk(0);
+    32ea:	83 ec 0c             	sub    $0xc,%esp
+    32ed:	6a 00                	push   $0x0
+    32ef:	e8 43 0e 00 00       	call   4137 <sbrk>
+    32f4:	83 c4 10             	add    $0x10,%esp
+    32f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  c = sbrk(-4096);
+    32fa:	83 ec 0c             	sub    $0xc,%esp
+    32fd:	68 00 f0 ff ff       	push   $0xfffff000
+    3302:	e8 30 0e 00 00       	call   4137 <sbrk>
+    3307:	83 c4 10             	add    $0x10,%esp
+    330a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(c == (char*)0xffffffff){
+    330d:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
+    3311:	75 1b                	jne    332e <sbrktest+0x1c5>
+    printf(stdout, "sbrk could not deallocate\n");
+    3313:	a1 70 65 00 00       	mov    0x6570,%eax
+    3318:	83 ec 08             	sub    $0x8,%esp
+    331b:	68 9a 5a 00 00       	push   $0x5a9a
+    3320:	50                   	push   %eax
+    3321:	e8 2d 0f 00 00       	call   4253 <printf>
+    3326:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3329:	e8 81 0d 00 00       	call   40af <exit>
+  }
+  c = sbrk(0);
+    332e:	83 ec 0c             	sub    $0xc,%esp
+    3331:	6a 00                	push   $0x0
+    3333:	e8 ff 0d 00 00       	call   4137 <sbrk>
+    3338:	83 c4 10             	add    $0x10,%esp
+    333b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(c != a - 4096){
+    333e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3341:	2d 00 10 00 00       	sub    $0x1000,%eax
+    3346:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+    3349:	74 1e                	je     3369 <sbrktest+0x200>
+    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+    334b:	a1 70 65 00 00       	mov    0x6570,%eax
+    3350:	ff 75 e4             	pushl  -0x1c(%ebp)
+    3353:	ff 75 f4             	pushl  -0xc(%ebp)
+    3356:	68 b8 5a 00 00       	push   $0x5ab8
+    335b:	50                   	push   %eax
+    335c:	e8 f2 0e 00 00       	call   4253 <printf>
+    3361:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3364:	e8 46 0d 00 00       	call   40af <exit>
+  }
+
+  // can one re-allocate that page?
+  a = sbrk(0);
+    3369:	83 ec 0c             	sub    $0xc,%esp
+    336c:	6a 00                	push   $0x0
+    336e:	e8 c4 0d 00 00       	call   4137 <sbrk>
+    3373:	83 c4 10             	add    $0x10,%esp
+    3376:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  c = sbrk(4096);
+    3379:	83 ec 0c             	sub    $0xc,%esp
+    337c:	68 00 10 00 00       	push   $0x1000
+    3381:	e8 b1 0d 00 00       	call   4137 <sbrk>
+    3386:	83 c4 10             	add    $0x10,%esp
+    3389:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(c != a || sbrk(0) != a + 4096){
+    338c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    338f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    3392:	75 1a                	jne    33ae <sbrktest+0x245>
+    3394:	83 ec 0c             	sub    $0xc,%esp
+    3397:	6a 00                	push   $0x0
+    3399:	e8 99 0d 00 00       	call   4137 <sbrk>
+    339e:	83 c4 10             	add    $0x10,%esp
+    33a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    33a4:	81 c2 00 10 00 00    	add    $0x1000,%edx
+    33aa:	39 d0                	cmp    %edx,%eax
+    33ac:	74 1e                	je     33cc <sbrktest+0x263>
+    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+    33ae:	a1 70 65 00 00       	mov    0x6570,%eax
+    33b3:	ff 75 e4             	pushl  -0x1c(%ebp)
+    33b6:	ff 75 f4             	pushl  -0xc(%ebp)
+    33b9:	68 f0 5a 00 00       	push   $0x5af0
+    33be:	50                   	push   %eax
+    33bf:	e8 8f 0e 00 00       	call   4253 <printf>
+    33c4:	83 c4 10             	add    $0x10,%esp
+    exit();
+    33c7:	e8 e3 0c 00 00       	call   40af <exit>
+  }
+  if(*lastaddr == 99){
+    33cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
+    33cf:	0f b6 00             	movzbl (%eax),%eax
+    33d2:	3c 63                	cmp    $0x63,%al
+    33d4:	75 1b                	jne    33f1 <sbrktest+0x288>
+    // should be zero
+    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+    33d6:	a1 70 65 00 00       	mov    0x6570,%eax
+    33db:	83 ec 08             	sub    $0x8,%esp
+    33de:	68 18 5b 00 00       	push   $0x5b18
+    33e3:	50                   	push   %eax
+    33e4:	e8 6a 0e 00 00       	call   4253 <printf>
+    33e9:	83 c4 10             	add    $0x10,%esp
+    exit();
+    33ec:	e8 be 0c 00 00       	call   40af <exit>
+  }
+
+  a = sbrk(0);
+    33f1:	83 ec 0c             	sub    $0xc,%esp
+    33f4:	6a 00                	push   $0x0
+    33f6:	e8 3c 0d 00 00       	call   4137 <sbrk>
+    33fb:	83 c4 10             	add    $0x10,%esp
+    33fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  c = sbrk(-(sbrk(0) - oldbrk));
+    3401:	83 ec 0c             	sub    $0xc,%esp
+    3404:	6a 00                	push   $0x0
+    3406:	e8 2c 0d 00 00       	call   4137 <sbrk>
+    340b:	83 c4 10             	add    $0x10,%esp
+    340e:	8b 55 ec             	mov    -0x14(%ebp),%edx
+    3411:	29 c2                	sub    %eax,%edx
+    3413:	89 d0                	mov    %edx,%eax
+    3415:	83 ec 0c             	sub    $0xc,%esp
+    3418:	50                   	push   %eax
+    3419:	e8 19 0d 00 00       	call   4137 <sbrk>
+    341e:	83 c4 10             	add    $0x10,%esp
+    3421:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  if(c != a){
+    3424:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    3427:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+    342a:	74 1e                	je     344a <sbrktest+0x2e1>
+    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+    342c:	a1 70 65 00 00       	mov    0x6570,%eax
+    3431:	ff 75 e4             	pushl  -0x1c(%ebp)
+    3434:	ff 75 f4             	pushl  -0xc(%ebp)
+    3437:	68 48 5b 00 00       	push   $0x5b48
+    343c:	50                   	push   %eax
+    343d:	e8 11 0e 00 00       	call   4253 <printf>
+    3442:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3445:	e8 65 0c 00 00       	call   40af <exit>
+  }
+
+  // can we read the kernel's memory?
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    344a:	c7 45 f4 00 00 00 80 	movl   $0x80000000,-0xc(%ebp)
+    3451:	eb 76                	jmp    34c9 <sbrktest+0x360>
+    ppid = getpid();
+    3453:	e8 d7 0c 00 00       	call   412f <getpid>
+    3458:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    pid = fork();
+    345b:	e8 47 0c 00 00       	call   40a7 <fork>
+    3460:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(pid < 0){
+    3463:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    3467:	79 1b                	jns    3484 <sbrktest+0x31b>
+      printf(stdout, "fork failed\n");
+    3469:	a1 70 65 00 00       	mov    0x6570,%eax
+    346e:	83 ec 08             	sub    $0x8,%esp
+    3471:	68 bd 46 00 00       	push   $0x46bd
+    3476:	50                   	push   %eax
+    3477:	e8 d7 0d 00 00       	call   4253 <printf>
+    347c:	83 c4 10             	add    $0x10,%esp
+      exit();
+    347f:	e8 2b 0c 00 00       	call   40af <exit>
+    }
+    if(pid == 0){
+    3484:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    3488:	75 33                	jne    34bd <sbrktest+0x354>
+      printf(stdout, "oops could read %x = %x\n", a, *a);
+    348a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    348d:	0f b6 00             	movzbl (%eax),%eax
+    3490:	0f be d0             	movsbl %al,%edx
+    3493:	a1 70 65 00 00       	mov    0x6570,%eax
+    3498:	52                   	push   %edx
+    3499:	ff 75 f4             	pushl  -0xc(%ebp)
+    349c:	68 69 5b 00 00       	push   $0x5b69
+    34a1:	50                   	push   %eax
+    34a2:	e8 ac 0d 00 00       	call   4253 <printf>
+    34a7:	83 c4 10             	add    $0x10,%esp
+      kill(ppid);
+    34aa:	83 ec 0c             	sub    $0xc,%esp
+    34ad:	ff 75 d4             	pushl  -0x2c(%ebp)
+    34b0:	e8 2a 0c 00 00       	call   40df <kill>
+    34b5:	83 c4 10             	add    $0x10,%esp
+      exit();
+    34b8:	e8 f2 0b 00 00       	call   40af <exit>
+    }
+    wait();
+    34bd:	e8 f5 0b 00 00       	call   40b7 <wait>
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    34c2:	81 45 f4 50 c3 00 00 	addl   $0xc350,-0xc(%ebp)
+    34c9:	81 7d f4 7f 84 1e 80 	cmpl   $0x801e847f,-0xc(%ebp)
+    34d0:	76 81                	jbe    3453 <sbrktest+0x2ea>
+  }
+
+  // if we run the system out of memory, does it clean up the last
+  // failed allocation?
+  if(pipe(fds) != 0){
+    34d2:	83 ec 0c             	sub    $0xc,%esp
+    34d5:	8d 45 c8             	lea    -0x38(%ebp),%eax
+    34d8:	50                   	push   %eax
+    34d9:	e8 e1 0b 00 00       	call   40bf <pipe>
+    34de:	83 c4 10             	add    $0x10,%esp
+    34e1:	85 c0                	test   %eax,%eax
+    34e3:	74 17                	je     34fc <sbrktest+0x393>
+    printf(1, "pipe() failed\n");
+    34e5:	83 ec 08             	sub    $0x8,%esp
+    34e8:	68 8e 4a 00 00       	push   $0x4a8e
+    34ed:	6a 01                	push   $0x1
+    34ef:	e8 5f 0d 00 00       	call   4253 <printf>
+    34f4:	83 c4 10             	add    $0x10,%esp
+    exit();
+    34f7:	e8 b3 0b 00 00       	call   40af <exit>
+  }
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    34fc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    3503:	e9 86 00 00 00       	jmp    358e <sbrktest+0x425>
+    if((pids[i] = fork()) == 0){
+    3508:	e8 9a 0b 00 00       	call   40a7 <fork>
+    350d:	8b 55 f0             	mov    -0x10(%ebp),%edx
+    3510:	89 44 95 a0          	mov    %eax,-0x60(%ebp,%edx,4)
+    3514:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    3517:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
+    351b:	85 c0                	test   %eax,%eax
+    351d:	75 4a                	jne    3569 <sbrktest+0x400>
+      // allocate a lot of memory
+      sbrk(BIG - (uint)sbrk(0));
+    351f:	83 ec 0c             	sub    $0xc,%esp
+    3522:	6a 00                	push   $0x0
+    3524:	e8 0e 0c 00 00       	call   4137 <sbrk>
+    3529:	83 c4 10             	add    $0x10,%esp
+    352c:	ba 00 00 40 06       	mov    $0x6400000,%edx
+    3531:	29 c2                	sub    %eax,%edx
+    3533:	89 d0                	mov    %edx,%eax
+    3535:	83 ec 0c             	sub    $0xc,%esp
+    3538:	50                   	push   %eax
+    3539:	e8 f9 0b 00 00       	call   4137 <sbrk>
+    353e:	83 c4 10             	add    $0x10,%esp
+      write(fds[1], "x", 1);
+    3541:	8b 45 cc             	mov    -0x34(%ebp),%eax
+    3544:	83 ec 04             	sub    $0x4,%esp
+    3547:	6a 01                	push   $0x1
+    3549:	68 f3 4a 00 00       	push   $0x4af3
+    354e:	50                   	push   %eax
+    354f:	e8 7b 0b 00 00       	call   40cf <write>
+    3554:	83 c4 10             	add    $0x10,%esp
+      // sit around until killed
+      for(;;) sleep(1000);
+    3557:	83 ec 0c             	sub    $0xc,%esp
+    355a:	68 e8 03 00 00       	push   $0x3e8
+    355f:	e8 db 0b 00 00       	call   413f <sleep>
+    3564:	83 c4 10             	add    $0x10,%esp
+    3567:	eb ee                	jmp    3557 <sbrktest+0x3ee>
+    }
+    if(pids[i] != -1)
+    3569:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    356c:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
+    3570:	83 f8 ff             	cmp    $0xffffffff,%eax
+    3573:	74 15                	je     358a <sbrktest+0x421>
+      read(fds[0], &scratch, 1);
+    3575:	8b 45 c8             	mov    -0x38(%ebp),%eax
+    3578:	83 ec 04             	sub    $0x4,%esp
+    357b:	6a 01                	push   $0x1
+    357d:	8d 55 9f             	lea    -0x61(%ebp),%edx
+    3580:	52                   	push   %edx
+    3581:	50                   	push   %eax
+    3582:	e8 40 0b 00 00       	call   40c7 <read>
+    3587:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    358a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    358e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    3591:	83 f8 09             	cmp    $0x9,%eax
+    3594:	0f 86 6e ff ff ff    	jbe    3508 <sbrktest+0x39f>
+  }
+  // if those failed allocations freed up the pages they did allocate,
+  // we'll be able to allocate here
+  c = sbrk(4096);
+    359a:	83 ec 0c             	sub    $0xc,%esp
+    359d:	68 00 10 00 00       	push   $0x1000
+    35a2:	e8 90 0b 00 00       	call   4137 <sbrk>
+    35a7:	83 c4 10             	add    $0x10,%esp
+    35aa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    35ad:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    35b4:	eb 2b                	jmp    35e1 <sbrktest+0x478>
+    if(pids[i] == -1)
+    35b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    35b9:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
+    35bd:	83 f8 ff             	cmp    $0xffffffff,%eax
+    35c0:	74 1a                	je     35dc <sbrktest+0x473>
+      continue;
+    kill(pids[i]);
+    35c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    35c5:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
+    35c9:	83 ec 0c             	sub    $0xc,%esp
+    35cc:	50                   	push   %eax
+    35cd:	e8 0d 0b 00 00       	call   40df <kill>
+    35d2:	83 c4 10             	add    $0x10,%esp
+    wait();
+    35d5:	e8 dd 0a 00 00       	call   40b7 <wait>
+    35da:	eb 01                	jmp    35dd <sbrktest+0x474>
+      continue;
+    35dc:	90                   	nop
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    35dd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    35e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    35e4:	83 f8 09             	cmp    $0x9,%eax
+    35e7:	76 cd                	jbe    35b6 <sbrktest+0x44d>
+  }
+  if(c == (char*)0xffffffff){
+    35e9:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
+    35ed:	75 1b                	jne    360a <sbrktest+0x4a1>
+    printf(stdout, "failed sbrk leaked memory\n");
+    35ef:	a1 70 65 00 00       	mov    0x6570,%eax
+    35f4:	83 ec 08             	sub    $0x8,%esp
+    35f7:	68 82 5b 00 00       	push   $0x5b82
+    35fc:	50                   	push   %eax
+    35fd:	e8 51 0c 00 00       	call   4253 <printf>
+    3602:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3605:	e8 a5 0a 00 00       	call   40af <exit>
+  }
+
+  if(sbrk(0) > oldbrk)
+    360a:	83 ec 0c             	sub    $0xc,%esp
+    360d:	6a 00                	push   $0x0
+    360f:	e8 23 0b 00 00       	call   4137 <sbrk>
+    3614:	83 c4 10             	add    $0x10,%esp
+    3617:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+    361a:	73 20                	jae    363c <sbrktest+0x4d3>
+    sbrk(-(sbrk(0) - oldbrk));
+    361c:	83 ec 0c             	sub    $0xc,%esp
+    361f:	6a 00                	push   $0x0
+    3621:	e8 11 0b 00 00       	call   4137 <sbrk>
+    3626:	83 c4 10             	add    $0x10,%esp
+    3629:	8b 55 ec             	mov    -0x14(%ebp),%edx
+    362c:	29 c2                	sub    %eax,%edx
+    362e:	89 d0                	mov    %edx,%eax
+    3630:	83 ec 0c             	sub    $0xc,%esp
+    3633:	50                   	push   %eax
+    3634:	e8 fe 0a 00 00       	call   4137 <sbrk>
+    3639:	83 c4 10             	add    $0x10,%esp
+
+  printf(stdout, "sbrk test OK\n");
+    363c:	a1 70 65 00 00       	mov    0x6570,%eax
+    3641:	83 ec 08             	sub    $0x8,%esp
+    3644:	68 9d 5b 00 00       	push   $0x5b9d
+    3649:	50                   	push   %eax
+    364a:	e8 04 0c 00 00       	call   4253 <printf>
+    364f:	83 c4 10             	add    $0x10,%esp
+}
+    3652:	90                   	nop
+    3653:	c9                   	leave  
+    3654:	c3                   	ret    
+
+00003655 <validateint>:
+
+void
+validateint(int *p)
+{
+    3655:	f3 0f 1e fb          	endbr32 
+    3659:	55                   	push   %ebp
+    365a:	89 e5                	mov    %esp,%ebp
+    365c:	53                   	push   %ebx
+    365d:	83 ec 10             	sub    $0x10,%esp
+  int res;
+  asm("mov %%esp, %%ebx\n\t"
+    3660:	b8 0d 00 00 00       	mov    $0xd,%eax
+    3665:	8b 55 08             	mov    0x8(%ebp),%edx
+    3668:	89 d1                	mov    %edx,%ecx
+    366a:	89 e3                	mov    %esp,%ebx
+    366c:	89 cc                	mov    %ecx,%esp
+    366e:	cd 40                	int    $0x40
+    3670:	89 dc                	mov    %ebx,%esp
+    3672:	89 45 f8             	mov    %eax,-0x8(%ebp)
+      "int %2\n\t"
+      "mov %%ebx, %%esp" :
+      "=a" (res) :
+      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
+      "ebx");
+}
+    3675:	90                   	nop
+    3676:	83 c4 10             	add    $0x10,%esp
+    3679:	5b                   	pop    %ebx
+    367a:	5d                   	pop    %ebp
+    367b:	c3                   	ret    
+
+0000367c <validatetest>:
+
+void
+validatetest(void)
+{
+    367c:	f3 0f 1e fb          	endbr32 
+    3680:	55                   	push   %ebp
+    3681:	89 e5                	mov    %esp,%ebp
+    3683:	83 ec 18             	sub    $0x18,%esp
+  int hi, pid;
+  uint p;
+
+  printf(stdout, "validate test\n");
+    3686:	a1 70 65 00 00       	mov    0x6570,%eax
+    368b:	83 ec 08             	sub    $0x8,%esp
+    368e:	68 ab 5b 00 00       	push   $0x5bab
+    3693:	50                   	push   %eax
+    3694:	e8 ba 0b 00 00       	call   4253 <printf>
+    3699:	83 c4 10             	add    $0x10,%esp
+  hi = 1100*1024;
+    369c:	c7 45 f0 00 30 11 00 	movl   $0x113000,-0x10(%ebp)
+
+  for(p = 0; p <= (uint)hi; p += 4096){
+    36a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    36aa:	e9 8a 00 00 00       	jmp    3739 <validatetest+0xbd>
+    if((pid = fork()) == 0){
+    36af:	e8 f3 09 00 00       	call   40a7 <fork>
+    36b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    36b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    36bb:	75 14                	jne    36d1 <validatetest+0x55>
+      // try to crash the kernel by passing in a badly placed integer
+      validateint((int*)p);
+    36bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    36c0:	83 ec 0c             	sub    $0xc,%esp
+    36c3:	50                   	push   %eax
+    36c4:	e8 8c ff ff ff       	call   3655 <validateint>
+    36c9:	83 c4 10             	add    $0x10,%esp
+      exit();
+    36cc:	e8 de 09 00 00       	call   40af <exit>
+    }
+    sleep(0);
+    36d1:	83 ec 0c             	sub    $0xc,%esp
+    36d4:	6a 00                	push   $0x0
+    36d6:	e8 64 0a 00 00       	call   413f <sleep>
+    36db:	83 c4 10             	add    $0x10,%esp
+    sleep(0);
+    36de:	83 ec 0c             	sub    $0xc,%esp
+    36e1:	6a 00                	push   $0x0
+    36e3:	e8 57 0a 00 00       	call   413f <sleep>
+    36e8:	83 c4 10             	add    $0x10,%esp
+    kill(pid);
+    36eb:	83 ec 0c             	sub    $0xc,%esp
+    36ee:	ff 75 ec             	pushl  -0x14(%ebp)
+    36f1:	e8 e9 09 00 00       	call   40df <kill>
+    36f6:	83 c4 10             	add    $0x10,%esp
+    wait();
+    36f9:	e8 b9 09 00 00       	call   40b7 <wait>
+
+    // try to crash the kernel by passing in a bad string pointer
+    if(link("nosuchfile", (char*)p) != -1){
+    36fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3701:	83 ec 08             	sub    $0x8,%esp
+    3704:	50                   	push   %eax
+    3705:	68 ba 5b 00 00       	push   $0x5bba
+    370a:	e8 00 0a 00 00       	call   410f <link>
+    370f:	83 c4 10             	add    $0x10,%esp
+    3712:	83 f8 ff             	cmp    $0xffffffff,%eax
+    3715:	74 1b                	je     3732 <validatetest+0xb6>
+      printf(stdout, "link should not succeed\n");
+    3717:	a1 70 65 00 00       	mov    0x6570,%eax
+    371c:	83 ec 08             	sub    $0x8,%esp
+    371f:	68 c5 5b 00 00       	push   $0x5bc5
+    3724:	50                   	push   %eax
+    3725:	e8 29 0b 00 00       	call   4253 <printf>
+    372a:	83 c4 10             	add    $0x10,%esp
+      exit();
+    372d:	e8 7d 09 00 00       	call   40af <exit>
+  for(p = 0; p <= (uint)hi; p += 4096){
+    3732:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+    3739:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    373c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+    373f:	0f 86 6a ff ff ff    	jbe    36af <validatetest+0x33>
+    }
+  }
+
+  printf(stdout, "validate ok\n");
+    3745:	a1 70 65 00 00       	mov    0x6570,%eax
+    374a:	83 ec 08             	sub    $0x8,%esp
+    374d:	68 de 5b 00 00       	push   $0x5bde
+    3752:	50                   	push   %eax
+    3753:	e8 fb 0a 00 00       	call   4253 <printf>
+    3758:	83 c4 10             	add    $0x10,%esp
+}
+    375b:	90                   	nop
+    375c:	c9                   	leave  
+    375d:	c3                   	ret    
+
+0000375e <bsstest>:
+
+// does unintialized data start out zero?
+char uninit[10000];
+void
+bsstest(void)
+{
+    375e:	f3 0f 1e fb          	endbr32 
+    3762:	55                   	push   %ebp
+    3763:	89 e5                	mov    %esp,%ebp
+    3765:	83 ec 18             	sub    $0x18,%esp
+  int i;
+
+  printf(stdout, "bss test\n");
+    3768:	a1 70 65 00 00       	mov    0x6570,%eax
+    376d:	83 ec 08             	sub    $0x8,%esp
+    3770:	68 eb 5b 00 00       	push   $0x5beb
+    3775:	50                   	push   %eax
+    3776:	e8 d8 0a 00 00       	call   4253 <printf>
+    377b:	83 c4 10             	add    $0x10,%esp
+  for(i = 0; i < sizeof(uninit); i++){
+    377e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    3785:	eb 2e                	jmp    37b5 <bsstest+0x57>
+    if(uninit[i] != '\0'){
+    3787:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    378a:	05 40 66 00 00       	add    $0x6640,%eax
+    378f:	0f b6 00             	movzbl (%eax),%eax
+    3792:	84 c0                	test   %al,%al
+    3794:	74 1b                	je     37b1 <bsstest+0x53>
+      printf(stdout, "bss test failed\n");
+    3796:	a1 70 65 00 00       	mov    0x6570,%eax
+    379b:	83 ec 08             	sub    $0x8,%esp
+    379e:	68 f5 5b 00 00       	push   $0x5bf5
+    37a3:	50                   	push   %eax
+    37a4:	e8 aa 0a 00 00       	call   4253 <printf>
+    37a9:	83 c4 10             	add    $0x10,%esp
+      exit();
+    37ac:	e8 fe 08 00 00       	call   40af <exit>
+  for(i = 0; i < sizeof(uninit); i++){
+    37b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    37b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    37b8:	3d 0f 27 00 00       	cmp    $0x270f,%eax
+    37bd:	76 c8                	jbe    3787 <bsstest+0x29>
+    }
+  }
+  printf(stdout, "bss test ok\n");
+    37bf:	a1 70 65 00 00       	mov    0x6570,%eax
+    37c4:	83 ec 08             	sub    $0x8,%esp
+    37c7:	68 06 5c 00 00       	push   $0x5c06
+    37cc:	50                   	push   %eax
+    37cd:	e8 81 0a 00 00       	call   4253 <printf>
+    37d2:	83 c4 10             	add    $0x10,%esp
+}
+    37d5:	90                   	nop
+    37d6:	c9                   	leave  
+    37d7:	c3                   	ret    
+
+000037d8 <bigargtest>:
+// does exec return an error if the arguments
+// are larger than a page? or does it write
+// below the stack and wreck the instructions/data?
+void
+bigargtest(void)
+{
+    37d8:	f3 0f 1e fb          	endbr32 
+    37dc:	55                   	push   %ebp
+    37dd:	89 e5                	mov    %esp,%ebp
+    37df:	83 ec 18             	sub    $0x18,%esp
+  int pid, fd;
+
+  unlink("bigarg-ok");
+    37e2:	83 ec 0c             	sub    $0xc,%esp
+    37e5:	68 13 5c 00 00       	push   $0x5c13
+    37ea:	e8 10 09 00 00       	call   40ff <unlink>
+    37ef:	83 c4 10             	add    $0x10,%esp
+  pid = fork();
+    37f2:	e8 b0 08 00 00       	call   40a7 <fork>
+    37f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(pid == 0){
+    37fa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    37fe:	0f 85 97 00 00 00    	jne    389b <bigargtest+0xc3>
+    static char *args[MAXARG];
+    int i;
+    for(i = 0; i < MAXARG-1; i++)
+    3804:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    380b:	eb 12                	jmp    381f <bigargtest+0x47>
+      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+    380d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3810:	c7 04 85 a0 65 00 00 	movl   $0x5c20,0x65a0(,%eax,4)
+    3817:	20 5c 00 00 
+    for(i = 0; i < MAXARG-1; i++)
+    381b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    381f:	83 7d f4 1e          	cmpl   $0x1e,-0xc(%ebp)
+    3823:	7e e8                	jle    380d <bigargtest+0x35>
+    args[MAXARG-1] = 0;
+    3825:	c7 05 1c 66 00 00 00 	movl   $0x0,0x661c
+    382c:	00 00 00 
+    printf(stdout, "bigarg test\n");
+    382f:	a1 70 65 00 00       	mov    0x6570,%eax
+    3834:	83 ec 08             	sub    $0x8,%esp
+    3837:	68 fd 5c 00 00       	push   $0x5cfd
+    383c:	50                   	push   %eax
+    383d:	e8 11 0a 00 00       	call   4253 <printf>
+    3842:	83 c4 10             	add    $0x10,%esp
+    exec("echo", args);
+    3845:	83 ec 08             	sub    $0x8,%esp
+    3848:	68 a0 65 00 00       	push   $0x65a0
+    384d:	68 1c 46 00 00       	push   $0x461c
+    3852:	e8 90 08 00 00       	call   40e7 <exec>
+    3857:	83 c4 10             	add    $0x10,%esp
+    printf(stdout, "bigarg test ok\n");
+    385a:	a1 70 65 00 00       	mov    0x6570,%eax
+    385f:	83 ec 08             	sub    $0x8,%esp
+    3862:	68 0a 5d 00 00       	push   $0x5d0a
+    3867:	50                   	push   %eax
+    3868:	e8 e6 09 00 00       	call   4253 <printf>
+    386d:	83 c4 10             	add    $0x10,%esp
+    fd = open("bigarg-ok", O_CREATE);
+    3870:	83 ec 08             	sub    $0x8,%esp
+    3873:	68 00 02 00 00       	push   $0x200
+    3878:	68 13 5c 00 00       	push   $0x5c13
+    387d:	e8 6d 08 00 00       	call   40ef <open>
+    3882:	83 c4 10             	add    $0x10,%esp
+    3885:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    close(fd);
+    3888:	83 ec 0c             	sub    $0xc,%esp
+    388b:	ff 75 ec             	pushl  -0x14(%ebp)
+    388e:	e8 44 08 00 00       	call   40d7 <close>
+    3893:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3896:	e8 14 08 00 00       	call   40af <exit>
+  } else if(pid < 0){
+    389b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    389f:	79 1b                	jns    38bc <bigargtest+0xe4>
+    printf(stdout, "bigargtest: fork failed\n");
+    38a1:	a1 70 65 00 00       	mov    0x6570,%eax
+    38a6:	83 ec 08             	sub    $0x8,%esp
+    38a9:	68 1a 5d 00 00       	push   $0x5d1a
+    38ae:	50                   	push   %eax
+    38af:	e8 9f 09 00 00       	call   4253 <printf>
+    38b4:	83 c4 10             	add    $0x10,%esp
+    exit();
+    38b7:	e8 f3 07 00 00       	call   40af <exit>
+  }
+  wait();
+    38bc:	e8 f6 07 00 00       	call   40b7 <wait>
+  fd = open("bigarg-ok", 0);
+    38c1:	83 ec 08             	sub    $0x8,%esp
+    38c4:	6a 00                	push   $0x0
+    38c6:	68 13 5c 00 00       	push   $0x5c13
+    38cb:	e8 1f 08 00 00       	call   40ef <open>
+    38d0:	83 c4 10             	add    $0x10,%esp
+    38d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if(fd < 0){
+    38d6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    38da:	79 1b                	jns    38f7 <bigargtest+0x11f>
+    printf(stdout, "bigarg test failed!\n");
+    38dc:	a1 70 65 00 00       	mov    0x6570,%eax
+    38e1:	83 ec 08             	sub    $0x8,%esp
+    38e4:	68 33 5d 00 00       	push   $0x5d33
+    38e9:	50                   	push   %eax
+    38ea:	e8 64 09 00 00       	call   4253 <printf>
+    38ef:	83 c4 10             	add    $0x10,%esp
+    exit();
+    38f2:	e8 b8 07 00 00       	call   40af <exit>
+  }
+  close(fd);
+    38f7:	83 ec 0c             	sub    $0xc,%esp
+    38fa:	ff 75 ec             	pushl  -0x14(%ebp)
+    38fd:	e8 d5 07 00 00       	call   40d7 <close>
+    3902:	83 c4 10             	add    $0x10,%esp
+  unlink("bigarg-ok");
+    3905:	83 ec 0c             	sub    $0xc,%esp
+    3908:	68 13 5c 00 00       	push   $0x5c13
+    390d:	e8 ed 07 00 00       	call   40ff <unlink>
+    3912:	83 c4 10             	add    $0x10,%esp
+}
+    3915:	90                   	nop
+    3916:	c9                   	leave  
+    3917:	c3                   	ret    
+
+00003918 <fsfull>:
+
+// what happens when the file system runs out of blocks?
+// answer: balloc panics, so this test is not useful.
+void
+fsfull()
+{
+    3918:	f3 0f 1e fb          	endbr32 
+    391c:	55                   	push   %ebp
+    391d:	89 e5                	mov    %esp,%ebp
+    391f:	53                   	push   %ebx
+    3920:	83 ec 64             	sub    $0x64,%esp
+  int nfiles;
+  int fsblocks = 0;
+    3923:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+
+  printf(1, "fsfull test\n");
+    392a:	83 ec 08             	sub    $0x8,%esp
+    392d:	68 48 5d 00 00       	push   $0x5d48
+    3932:	6a 01                	push   $0x1
+    3934:	e8 1a 09 00 00       	call   4253 <printf>
+    3939:	83 c4 10             	add    $0x10,%esp
+
+  for(nfiles = 0; ; nfiles++){
+    393c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    char name[64];
+    name[0] = 'f';
+    3943:	c6 45 a4 66          	movb   $0x66,-0x5c(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    3947:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    394a:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+    394f:	89 c8                	mov    %ecx,%eax
+    3951:	f7 ea                	imul   %edx
+    3953:	c1 fa 06             	sar    $0x6,%edx
+    3956:	89 c8                	mov    %ecx,%eax
+    3958:	c1 f8 1f             	sar    $0x1f,%eax
+    395b:	29 c2                	sub    %eax,%edx
+    395d:	89 d0                	mov    %edx,%eax
+    395f:	83 c0 30             	add    $0x30,%eax
+    3962:	88 45 a5             	mov    %al,-0x5b(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    3965:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+    3968:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+    396d:	89 d8                	mov    %ebx,%eax
+    396f:	f7 ea                	imul   %edx
+    3971:	c1 fa 06             	sar    $0x6,%edx
+    3974:	89 d8                	mov    %ebx,%eax
+    3976:	c1 f8 1f             	sar    $0x1f,%eax
+    3979:	89 d1                	mov    %edx,%ecx
+    397b:	29 c1                	sub    %eax,%ecx
+    397d:	69 c1 e8 03 00 00    	imul   $0x3e8,%ecx,%eax
+    3983:	29 c3                	sub    %eax,%ebx
+    3985:	89 d9                	mov    %ebx,%ecx
+    3987:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+    398c:	89 c8                	mov    %ecx,%eax
+    398e:	f7 ea                	imul   %edx
+    3990:	c1 fa 05             	sar    $0x5,%edx
+    3993:	89 c8                	mov    %ecx,%eax
+    3995:	c1 f8 1f             	sar    $0x1f,%eax
+    3998:	29 c2                	sub    %eax,%edx
+    399a:	89 d0                	mov    %edx,%eax
+    399c:	83 c0 30             	add    $0x30,%eax
+    399f:	88 45 a6             	mov    %al,-0x5a(%ebp)
+    name[3] = '0' + (nfiles % 100) / 10;
+    39a2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+    39a5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+    39aa:	89 d8                	mov    %ebx,%eax
+    39ac:	f7 ea                	imul   %edx
+    39ae:	c1 fa 05             	sar    $0x5,%edx
+    39b1:	89 d8                	mov    %ebx,%eax
+    39b3:	c1 f8 1f             	sar    $0x1f,%eax
+    39b6:	89 d1                	mov    %edx,%ecx
+    39b8:	29 c1                	sub    %eax,%ecx
+    39ba:	6b c1 64             	imul   $0x64,%ecx,%eax
+    39bd:	29 c3                	sub    %eax,%ebx
+    39bf:	89 d9                	mov    %ebx,%ecx
+    39c1:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    39c6:	89 c8                	mov    %ecx,%eax
+    39c8:	f7 ea                	imul   %edx
+    39ca:	c1 fa 02             	sar    $0x2,%edx
+    39cd:	89 c8                	mov    %ecx,%eax
+    39cf:	c1 f8 1f             	sar    $0x1f,%eax
+    39d2:	29 c2                	sub    %eax,%edx
+    39d4:	89 d0                	mov    %edx,%eax
+    39d6:	83 c0 30             	add    $0x30,%eax
+    39d9:	88 45 a7             	mov    %al,-0x59(%ebp)
+    name[4] = '0' + (nfiles % 10);
+    39dc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    39df:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    39e4:	89 c8                	mov    %ecx,%eax
+    39e6:	f7 ea                	imul   %edx
+    39e8:	c1 fa 02             	sar    $0x2,%edx
+    39eb:	89 c8                	mov    %ecx,%eax
+    39ed:	c1 f8 1f             	sar    $0x1f,%eax
+    39f0:	29 c2                	sub    %eax,%edx
+    39f2:	89 d0                	mov    %edx,%eax
+    39f4:	c1 e0 02             	shl    $0x2,%eax
+    39f7:	01 d0                	add    %edx,%eax
+    39f9:	01 c0                	add    %eax,%eax
+    39fb:	29 c1                	sub    %eax,%ecx
+    39fd:	89 ca                	mov    %ecx,%edx
+    39ff:	89 d0                	mov    %edx,%eax
+    3a01:	83 c0 30             	add    $0x30,%eax
+    3a04:	88 45 a8             	mov    %al,-0x58(%ebp)
+    name[5] = '\0';
+    3a07:	c6 45 a9 00          	movb   $0x0,-0x57(%ebp)
+    printf(1, "writing %s\n", name);
+    3a0b:	83 ec 04             	sub    $0x4,%esp
+    3a0e:	8d 45 a4             	lea    -0x5c(%ebp),%eax
+    3a11:	50                   	push   %eax
+    3a12:	68 55 5d 00 00       	push   $0x5d55
+    3a17:	6a 01                	push   $0x1
+    3a19:	e8 35 08 00 00       	call   4253 <printf>
+    3a1e:	83 c4 10             	add    $0x10,%esp
+    int fd = open(name, O_CREATE|O_RDWR);
+    3a21:	83 ec 08             	sub    $0x8,%esp
+    3a24:	68 02 02 00 00       	push   $0x202
+    3a29:	8d 45 a4             	lea    -0x5c(%ebp),%eax
+    3a2c:	50                   	push   %eax
+    3a2d:	e8 bd 06 00 00       	call   40ef <open>
+    3a32:	83 c4 10             	add    $0x10,%esp
+    3a35:	89 45 e8             	mov    %eax,-0x18(%ebp)
+    if(fd < 0){
+    3a38:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+    3a3c:	79 18                	jns    3a56 <fsfull+0x13e>
+      printf(1, "open %s failed\n", name);
+    3a3e:	83 ec 04             	sub    $0x4,%esp
+    3a41:	8d 45 a4             	lea    -0x5c(%ebp),%eax
+    3a44:	50                   	push   %eax
+    3a45:	68 61 5d 00 00       	push   $0x5d61
+    3a4a:	6a 01                	push   $0x1
+    3a4c:	e8 02 08 00 00       	call   4253 <printf>
+    3a51:	83 c4 10             	add    $0x10,%esp
+      break;
+    3a54:	eb 6b                	jmp    3ac1 <fsfull+0x1a9>
+    }
+    int total = 0;
+    3a56:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+    while(1){
+      int cc = write(fd, buf, 512);
+    3a5d:	83 ec 04             	sub    $0x4,%esp
+    3a60:	68 00 02 00 00       	push   $0x200
+    3a65:	68 60 8d 00 00       	push   $0x8d60
+    3a6a:	ff 75 e8             	pushl  -0x18(%ebp)
+    3a6d:	e8 5d 06 00 00       	call   40cf <write>
+    3a72:	83 c4 10             	add    $0x10,%esp
+    3a75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+      if(cc < 512)
+    3a78:	81 7d e4 ff 01 00 00 	cmpl   $0x1ff,-0x1c(%ebp)
+    3a7f:	7e 0c                	jle    3a8d <fsfull+0x175>
+        break;
+      total += cc;
+    3a81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    3a84:	01 45 ec             	add    %eax,-0x14(%ebp)
+      fsblocks++;
+    3a87:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    while(1){
+    3a8b:	eb d0                	jmp    3a5d <fsfull+0x145>
+        break;
+    3a8d:	90                   	nop
+    }
+    printf(1, "wrote %d bytes\n", total);
+    3a8e:	83 ec 04             	sub    $0x4,%esp
+    3a91:	ff 75 ec             	pushl  -0x14(%ebp)
+    3a94:	68 71 5d 00 00       	push   $0x5d71
+    3a99:	6a 01                	push   $0x1
+    3a9b:	e8 b3 07 00 00       	call   4253 <printf>
+    3aa0:	83 c4 10             	add    $0x10,%esp
+    close(fd);
+    3aa3:	83 ec 0c             	sub    $0xc,%esp
+    3aa6:	ff 75 e8             	pushl  -0x18(%ebp)
+    3aa9:	e8 29 06 00 00       	call   40d7 <close>
+    3aae:	83 c4 10             	add    $0x10,%esp
+    if(total == 0)
+    3ab1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    3ab5:	74 09                	je     3ac0 <fsfull+0x1a8>
+  for(nfiles = 0; ; nfiles++){
+    3ab7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+    3abb:	e9 83 fe ff ff       	jmp    3943 <fsfull+0x2b>
+      break;
+    3ac0:	90                   	nop
+  }
+
+  while(nfiles >= 0){
+    3ac1:	e9 db 00 00 00       	jmp    3ba1 <fsfull+0x289>
+    char name[64];
+    name[0] = 'f';
+    3ac6:	c6 45 a4 66          	movb   $0x66,-0x5c(%ebp)
+    name[1] = '0' + nfiles / 1000;
+    3aca:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    3acd:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+    3ad2:	89 c8                	mov    %ecx,%eax
+    3ad4:	f7 ea                	imul   %edx
+    3ad6:	c1 fa 06             	sar    $0x6,%edx
+    3ad9:	89 c8                	mov    %ecx,%eax
+    3adb:	c1 f8 1f             	sar    $0x1f,%eax
+    3ade:	29 c2                	sub    %eax,%edx
+    3ae0:	89 d0                	mov    %edx,%eax
+    3ae2:	83 c0 30             	add    $0x30,%eax
+    3ae5:	88 45 a5             	mov    %al,-0x5b(%ebp)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    3ae8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+    3aeb:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
+    3af0:	89 d8                	mov    %ebx,%eax
+    3af2:	f7 ea                	imul   %edx
+    3af4:	c1 fa 06             	sar    $0x6,%edx
+    3af7:	89 d8                	mov    %ebx,%eax
+    3af9:	c1 f8 1f             	sar    $0x1f,%eax
+    3afc:	89 d1                	mov    %edx,%ecx
+    3afe:	29 c1                	sub    %eax,%ecx
+    3b00:	69 c1 e8 03 00 00    	imul   $0x3e8,%ecx,%eax
+    3b06:	29 c3                	sub    %eax,%ebx
+    3b08:	89 d9                	mov    %ebx,%ecx
+    3b0a:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+    3b0f:	89 c8                	mov    %ecx,%eax
+    3b11:	f7 ea                	imul   %edx
+    3b13:	c1 fa 05             	sar    $0x5,%edx
+    3b16:	89 c8                	mov    %ecx,%eax
+    3b18:	c1 f8 1f             	sar    $0x1f,%eax
+    3b1b:	29 c2                	sub    %eax,%edx
+    3b1d:	89 d0                	mov    %edx,%eax
+    3b1f:	83 c0 30             	add    $0x30,%eax
+    3b22:	88 45 a6             	mov    %al,-0x5a(%ebp)
+    name[3] = '0' + (nfiles % 100) / 10;
+    3b25:	8b 5d f4             	mov    -0xc(%ebp),%ebx
+    3b28:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
+    3b2d:	89 d8                	mov    %ebx,%eax
+    3b2f:	f7 ea                	imul   %edx
+    3b31:	c1 fa 05             	sar    $0x5,%edx
+    3b34:	89 d8                	mov    %ebx,%eax
+    3b36:	c1 f8 1f             	sar    $0x1f,%eax
+    3b39:	89 d1                	mov    %edx,%ecx
+    3b3b:	29 c1                	sub    %eax,%ecx
+    3b3d:	6b c1 64             	imul   $0x64,%ecx,%eax
+    3b40:	29 c3                	sub    %eax,%ebx
+    3b42:	89 d9                	mov    %ebx,%ecx
+    3b44:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    3b49:	89 c8                	mov    %ecx,%eax
+    3b4b:	f7 ea                	imul   %edx
+    3b4d:	c1 fa 02             	sar    $0x2,%edx
+    3b50:	89 c8                	mov    %ecx,%eax
+    3b52:	c1 f8 1f             	sar    $0x1f,%eax
+    3b55:	29 c2                	sub    %eax,%edx
+    3b57:	89 d0                	mov    %edx,%eax
+    3b59:	83 c0 30             	add    $0x30,%eax
+    3b5c:	88 45 a7             	mov    %al,-0x59(%ebp)
+    name[4] = '0' + (nfiles % 10);
+    3b5f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+    3b62:	ba 67 66 66 66       	mov    $0x66666667,%edx
+    3b67:	89 c8                	mov    %ecx,%eax
+    3b69:	f7 ea                	imul   %edx
+    3b6b:	c1 fa 02             	sar    $0x2,%edx
+    3b6e:	89 c8                	mov    %ecx,%eax
+    3b70:	c1 f8 1f             	sar    $0x1f,%eax
+    3b73:	29 c2                	sub    %eax,%edx
+    3b75:	89 d0                	mov    %edx,%eax
+    3b77:	c1 e0 02             	shl    $0x2,%eax
+    3b7a:	01 d0                	add    %edx,%eax
+    3b7c:	01 c0                	add    %eax,%eax
+    3b7e:	29 c1                	sub    %eax,%ecx
+    3b80:	89 ca                	mov    %ecx,%edx
+    3b82:	89 d0                	mov    %edx,%eax
+    3b84:	83 c0 30             	add    $0x30,%eax
+    3b87:	88 45 a8             	mov    %al,-0x58(%ebp)
+    name[5] = '\0';
+    3b8a:	c6 45 a9 00          	movb   $0x0,-0x57(%ebp)
+    unlink(name);
+    3b8e:	83 ec 0c             	sub    $0xc,%esp
+    3b91:	8d 45 a4             	lea    -0x5c(%ebp),%eax
+    3b94:	50                   	push   %eax
+    3b95:	e8 65 05 00 00       	call   40ff <unlink>
+    3b9a:	83 c4 10             	add    $0x10,%esp
+    nfiles--;
+    3b9d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  while(nfiles >= 0){
+    3ba1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    3ba5:	0f 89 1b ff ff ff    	jns    3ac6 <fsfull+0x1ae>
+  }
+
+  printf(1, "fsfull test finished\n");
+    3bab:	83 ec 08             	sub    $0x8,%esp
+    3bae:	68 81 5d 00 00       	push   $0x5d81
+    3bb3:	6a 01                	push   $0x1
+    3bb5:	e8 99 06 00 00       	call   4253 <printf>
+    3bba:	83 c4 10             	add    $0x10,%esp
+}
+    3bbd:	90                   	nop
+    3bbe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
+    3bc1:	c9                   	leave  
+    3bc2:	c3                   	ret    
+
+00003bc3 <uio>:
+
+void
+uio()
+{
+    3bc3:	f3 0f 1e fb          	endbr32 
+    3bc7:	55                   	push   %ebp
+    3bc8:	89 e5                	mov    %esp,%ebp
+    3bca:	83 ec 18             	sub    $0x18,%esp
+  #define RTC_ADDR 0x70
+  #define RTC_DATA 0x71
+
+  ushort port = 0;
+    3bcd:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
+  uchar val = 0;
+    3bd3:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
+  int pid;
+
+  printf(1, "uio test\n");
+    3bd7:	83 ec 08             	sub    $0x8,%esp
+    3bda:	68 97 5d 00 00       	push   $0x5d97
+    3bdf:	6a 01                	push   $0x1
+    3be1:	e8 6d 06 00 00       	call   4253 <printf>
+    3be6:	83 c4 10             	add    $0x10,%esp
+  pid = fork();
+    3be9:	e8 b9 04 00 00       	call   40a7 <fork>
+    3bee:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  if(pid == 0){
+    3bf1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    3bf5:	75 3a                	jne    3c31 <uio+0x6e>
+    port = RTC_ADDR;
+    3bf7:	66 c7 45 f6 70 00    	movw   $0x70,-0xa(%ebp)
+    val = 0x09;  /* year */
+    3bfd:	c6 45 f5 09          	movb   $0x9,-0xb(%ebp)
+    /* http://wiki.osdev.org/Inline_Assembly/Examples */
+    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+    3c01:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+    3c05:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+    3c09:	ee                   	out    %al,(%dx)
+    port = RTC_DATA;
+    3c0a:	66 c7 45 f6 71 00    	movw   $0x71,-0xa(%ebp)
+    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+    3c10:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+    3c14:	89 c2                	mov    %eax,%edx
+    3c16:	ec                   	in     (%dx),%al
+    3c17:	88 45 f5             	mov    %al,-0xb(%ebp)
+    printf(1, "uio: uio succeeded; test FAILED\n");
+    3c1a:	83 ec 08             	sub    $0x8,%esp
+    3c1d:	68 a4 5d 00 00       	push   $0x5da4
+    3c22:	6a 01                	push   $0x1
+    3c24:	e8 2a 06 00 00       	call   4253 <printf>
+    3c29:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3c2c:	e8 7e 04 00 00       	call   40af <exit>
+  } else if(pid < 0){
+    3c31:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    3c35:	79 17                	jns    3c4e <uio+0x8b>
+    printf (1, "fork failed\n");
+    3c37:	83 ec 08             	sub    $0x8,%esp
+    3c3a:	68 bd 46 00 00       	push   $0x46bd
+    3c3f:	6a 01                	push   $0x1
+    3c41:	e8 0d 06 00 00       	call   4253 <printf>
+    3c46:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3c49:	e8 61 04 00 00       	call   40af <exit>
+  }
+  wait();
+    3c4e:	e8 64 04 00 00       	call   40b7 <wait>
+  printf(1, "uio test done\n");
+    3c53:	83 ec 08             	sub    $0x8,%esp
+    3c56:	68 c5 5d 00 00       	push   $0x5dc5
+    3c5b:	6a 01                	push   $0x1
+    3c5d:	e8 f1 05 00 00       	call   4253 <printf>
+    3c62:	83 c4 10             	add    $0x10,%esp
+}
+    3c65:	90                   	nop
+    3c66:	c9                   	leave  
+    3c67:	c3                   	ret    
+
+00003c68 <argptest>:
+
+void argptest()
+{
+    3c68:	f3 0f 1e fb          	endbr32 
+    3c6c:	55                   	push   %ebp
+    3c6d:	89 e5                	mov    %esp,%ebp
+    3c6f:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  fd = open("init", O_RDONLY);
+    3c72:	83 ec 08             	sub    $0x8,%esp
+    3c75:	6a 00                	push   $0x0
+    3c77:	68 d4 5d 00 00       	push   $0x5dd4
+    3c7c:	e8 6e 04 00 00       	call   40ef <open>
+    3c81:	83 c4 10             	add    $0x10,%esp
+    3c84:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if (fd < 0) {
+    3c87:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    3c8b:	79 17                	jns    3ca4 <argptest+0x3c>
+    printf(2, "open failed\n");
+    3c8d:	83 ec 08             	sub    $0x8,%esp
+    3c90:	68 d9 5d 00 00       	push   $0x5dd9
+    3c95:	6a 02                	push   $0x2
+    3c97:	e8 b7 05 00 00       	call   4253 <printf>
+    3c9c:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3c9f:	e8 0b 04 00 00       	call   40af <exit>
+  }
+  read(fd, sbrk(0) - 1, -1);
+    3ca4:	83 ec 0c             	sub    $0xc,%esp
+    3ca7:	6a 00                	push   $0x0
+    3ca9:	e8 89 04 00 00       	call   4137 <sbrk>
+    3cae:	83 c4 10             	add    $0x10,%esp
+    3cb1:	83 e8 01             	sub    $0x1,%eax
+    3cb4:	83 ec 04             	sub    $0x4,%esp
+    3cb7:	6a ff                	push   $0xffffffff
+    3cb9:	50                   	push   %eax
+    3cba:	ff 75 f4             	pushl  -0xc(%ebp)
+    3cbd:	e8 05 04 00 00       	call   40c7 <read>
+    3cc2:	83 c4 10             	add    $0x10,%esp
+  close(fd);
+    3cc5:	83 ec 0c             	sub    $0xc,%esp
+    3cc8:	ff 75 f4             	pushl  -0xc(%ebp)
+    3ccb:	e8 07 04 00 00       	call   40d7 <close>
+    3cd0:	83 c4 10             	add    $0x10,%esp
+  printf(1, "arg test passed\n");
+    3cd3:	83 ec 08             	sub    $0x8,%esp
+    3cd6:	68 e6 5d 00 00       	push   $0x5de6
+    3cdb:	6a 01                	push   $0x1
+    3cdd:	e8 71 05 00 00       	call   4253 <printf>
+    3ce2:	83 c4 10             	add    $0x10,%esp
+}
+    3ce5:	90                   	nop
+    3ce6:	c9                   	leave  
+    3ce7:	c3                   	ret    
+
+00003ce8 <rand>:
+
+unsigned long randstate = 1;
+unsigned int
+rand()
+{
+    3ce8:	f3 0f 1e fb          	endbr32 
+    3cec:	55                   	push   %ebp
+    3ced:	89 e5                	mov    %esp,%ebp
+  randstate = randstate * 1664525 + 1013904223;
+    3cef:	a1 74 65 00 00       	mov    0x6574,%eax
+    3cf4:	69 c0 0d 66 19 00    	imul   $0x19660d,%eax,%eax
+    3cfa:	05 5f f3 6e 3c       	add    $0x3c6ef35f,%eax
+    3cff:	a3 74 65 00 00       	mov    %eax,0x6574
+  return randstate;
+    3d04:	a1 74 65 00 00       	mov    0x6574,%eax
+}
+    3d09:	5d                   	pop    %ebp
+    3d0a:	c3                   	ret    
+
+00003d0b <main>:
+
+int
+main(int argc, char *argv[])
+{
+    3d0b:	f3 0f 1e fb          	endbr32 
+    3d0f:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+    3d13:	83 e4 f0             	and    $0xfffffff0,%esp
+    3d16:	ff 71 fc             	pushl  -0x4(%ecx)
+    3d19:	55                   	push   %ebp
+    3d1a:	89 e5                	mov    %esp,%ebp
+    3d1c:	51                   	push   %ecx
+    3d1d:	83 ec 04             	sub    $0x4,%esp
+  printf(1, "usertests starting\n");
+    3d20:	83 ec 08             	sub    $0x8,%esp
+    3d23:	68 f7 5d 00 00       	push   $0x5df7
+    3d28:	6a 01                	push   $0x1
+    3d2a:	e8 24 05 00 00       	call   4253 <printf>
+    3d2f:	83 c4 10             	add    $0x10,%esp
+
+  if(open("usertests.ran", 0) >= 0){
+    3d32:	83 ec 08             	sub    $0x8,%esp
+    3d35:	6a 00                	push   $0x0
+    3d37:	68 0b 5e 00 00       	push   $0x5e0b
+    3d3c:	e8 ae 03 00 00       	call   40ef <open>
+    3d41:	83 c4 10             	add    $0x10,%esp
+    3d44:	85 c0                	test   %eax,%eax
+    3d46:	78 17                	js     3d5f <main+0x54>
+    printf(1, "already ran user tests -- rebuild fs.img\n");
+    3d48:	83 ec 08             	sub    $0x8,%esp
+    3d4b:	68 1c 5e 00 00       	push   $0x5e1c
+    3d50:	6a 01                	push   $0x1
+    3d52:	e8 fc 04 00 00       	call   4253 <printf>
+    3d57:	83 c4 10             	add    $0x10,%esp
+    exit();
+    3d5a:	e8 50 03 00 00       	call   40af <exit>
+  }
+  close(open("usertests.ran", O_CREATE));
+    3d5f:	83 ec 08             	sub    $0x8,%esp
+    3d62:	68 00 02 00 00       	push   $0x200
+    3d67:	68 0b 5e 00 00       	push   $0x5e0b
+    3d6c:	e8 7e 03 00 00       	call   40ef <open>
+    3d71:	83 c4 10             	add    $0x10,%esp
+    3d74:	83 ec 0c             	sub    $0xc,%esp
+    3d77:	50                   	push   %eax
+    3d78:	e8 5a 03 00 00       	call   40d7 <close>
+    3d7d:	83 c4 10             	add    $0x10,%esp
+
+  argptest();
+    3d80:	e8 e3 fe ff ff       	call   3c68 <argptest>
+  createdelete();
+    3d85:	e8 5c d5 ff ff       	call   12e6 <createdelete>
+  linkunlink();
+    3d8a:	e8 8d df ff ff       	call   1d1c <linkunlink>
+  concreate();
+    3d8f:	e8 d4 db ff ff       	call   1968 <concreate>
+  fourfiles();
+    3d94:	e8 f8 d2 ff ff       	call   1091 <fourfiles>
+  sharedfd();
+    3d99:	e8 0c d1 ff ff       	call   eaa <sharedfd>
+
+  bigargtest();
+    3d9e:	e8 35 fa ff ff       	call   37d8 <bigargtest>
+  bigwrite();
+    3da3:	e8 72 e9 ff ff       	call   271a <bigwrite>
+  bigargtest();
+    3da8:	e8 2b fa ff ff       	call   37d8 <bigargtest>
+  bsstest();
+    3dad:	e8 ac f9 ff ff       	call   375e <bsstest>
+  sbrktest();
+    3db2:	e8 b2 f3 ff ff       	call   3169 <sbrktest>
+  validatetest();
+    3db7:	e8 c0 f8 ff ff       	call   367c <validatetest>
+
+  opentest();
+    3dbc:	e8 4a c5 ff ff       	call   30b <opentest>
+  writetest();
+    3dc1:	e8 f8 c5 ff ff       	call   3be <writetest>
+  writetest1();
+    3dc6:	e8 07 c8 ff ff       	call   5d2 <writetest1>
+  createtest();
+    3dcb:	e8 02 ca ff ff       	call   7d2 <createtest>
+
+  openiputtest();
+    3dd0:	e8 23 c4 ff ff       	call   1f8 <openiputtest>
+  exitiputtest();
+    3dd5:	e8 1b c3 ff ff       	call   f5 <exitiputtest>
+  iputtest();
+    3dda:	e8 21 c2 ff ff       	call   0 <iputtest>
+
+  mem();
+    3ddf:	e8 d1 cf ff ff       	call   db5 <mem>
+  pipe1();
+    3de4:	e8 fc cb ff ff       	call   9e5 <pipe1>
+  preempt();
+    3de9:	e8 e4 cd ff ff       	call   bd2 <preempt>
+  exitwait();
+    3dee:	e8 46 cf ff ff       	call   d39 <exitwait>
+
+  rmdot();
+    3df3:	e8 a0 ed ff ff       	call   2b98 <rmdot>
+  fourteen();
+    3df8:	e8 3b ec ff ff       	call   2a38 <fourteen>
+  bigfile();
+    3dfd:	e8 1a ea ff ff       	call   281c <bigfile>
+  subdir();
+    3e02:	e8 cb e1 ff ff       	call   1fd2 <subdir>
+  linktest();
+    3e07:	e8 16 d9 ff ff       	call   1722 <linktest>
+  unlinkread();
+    3e0c:	e8 4b d7 ff ff       	call   155c <unlinkread>
+  dirfile();
+    3e11:	e8 0b ef ff ff       	call   2d21 <dirfile>
+  iref();
+    3e16:	e8 42 f1 ff ff       	call   2f5d <iref>
+  forktest();
+    3e1b:	e8 7b f2 ff ff       	call   309b <forktest>
+  bigdir(); // slow
+    3e20:	e8 34 e0 ff ff       	call   1e59 <bigdir>
+
+  uio();
+    3e25:	e8 99 fd ff ff       	call   3bc3 <uio>
+
+  exectest();
+    3e2a:	e8 5f cb ff ff       	call   98e <exectest>
+
+  exit();
+    3e2f:	e8 7b 02 00 00       	call   40af <exit>
+
+00003e34 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+    3e34:	55                   	push   %ebp
+    3e35:	89 e5                	mov    %esp,%ebp
+    3e37:	57                   	push   %edi
+    3e38:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+    3e39:	8b 4d 08             	mov    0x8(%ebp),%ecx
+    3e3c:	8b 55 10             	mov    0x10(%ebp),%edx
+    3e3f:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3e42:	89 cb                	mov    %ecx,%ebx
+    3e44:	89 df                	mov    %ebx,%edi
+    3e46:	89 d1                	mov    %edx,%ecx
+    3e48:	fc                   	cld    
+    3e49:	f3 aa                	rep stos %al,%es:(%edi)
+    3e4b:	89 ca                	mov    %ecx,%edx
+    3e4d:	89 fb                	mov    %edi,%ebx
+    3e4f:	89 5d 08             	mov    %ebx,0x8(%ebp)
+    3e52:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+    3e55:	90                   	nop
+    3e56:	5b                   	pop    %ebx
+    3e57:	5f                   	pop    %edi
+    3e58:	5d                   	pop    %ebp
+    3e59:	c3                   	ret    
+
+00003e5a <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+    3e5a:	f3 0f 1e fb          	endbr32 
+    3e5e:	55                   	push   %ebp
+    3e5f:	89 e5                	mov    %esp,%ebp
+    3e61:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+    3e64:	8b 45 08             	mov    0x8(%ebp),%eax
+    3e67:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+    3e6a:	90                   	nop
+    3e6b:	8b 55 0c             	mov    0xc(%ebp),%edx
+    3e6e:	8d 42 01             	lea    0x1(%edx),%eax
+    3e71:	89 45 0c             	mov    %eax,0xc(%ebp)
+    3e74:	8b 45 08             	mov    0x8(%ebp),%eax
+    3e77:	8d 48 01             	lea    0x1(%eax),%ecx
+    3e7a:	89 4d 08             	mov    %ecx,0x8(%ebp)
+    3e7d:	0f b6 12             	movzbl (%edx),%edx
+    3e80:	88 10                	mov    %dl,(%eax)
+    3e82:	0f b6 00             	movzbl (%eax),%eax
+    3e85:	84 c0                	test   %al,%al
+    3e87:	75 e2                	jne    3e6b <strcpy+0x11>
+    ;
+  return os;
+    3e89:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+    3e8c:	c9                   	leave  
+    3e8d:	c3                   	ret    
+
+00003e8e <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    3e8e:	f3 0f 1e fb          	endbr32 
+    3e92:	55                   	push   %ebp
+    3e93:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+    3e95:	eb 08                	jmp    3e9f <strcmp+0x11>
+    p++, q++;
+    3e97:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    3e9b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+    3e9f:	8b 45 08             	mov    0x8(%ebp),%eax
+    3ea2:	0f b6 00             	movzbl (%eax),%eax
+    3ea5:	84 c0                	test   %al,%al
+    3ea7:	74 10                	je     3eb9 <strcmp+0x2b>
+    3ea9:	8b 45 08             	mov    0x8(%ebp),%eax
+    3eac:	0f b6 10             	movzbl (%eax),%edx
+    3eaf:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3eb2:	0f b6 00             	movzbl (%eax),%eax
+    3eb5:	38 c2                	cmp    %al,%dl
+    3eb7:	74 de                	je     3e97 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+    3eb9:	8b 45 08             	mov    0x8(%ebp),%eax
+    3ebc:	0f b6 00             	movzbl (%eax),%eax
+    3ebf:	0f b6 d0             	movzbl %al,%edx
+    3ec2:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3ec5:	0f b6 00             	movzbl (%eax),%eax
+    3ec8:	0f b6 c0             	movzbl %al,%eax
+    3ecb:	29 c2                	sub    %eax,%edx
+    3ecd:	89 d0                	mov    %edx,%eax
+}
+    3ecf:	5d                   	pop    %ebp
+    3ed0:	c3                   	ret    
+
+00003ed1 <strlen>:
+
+uint
+strlen(const char *s)
+{
+    3ed1:	f3 0f 1e fb          	endbr32 
+    3ed5:	55                   	push   %ebp
+    3ed6:	89 e5                	mov    %esp,%ebp
+    3ed8:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+    3edb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    3ee2:	eb 04                	jmp    3ee8 <strlen+0x17>
+    3ee4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+    3ee8:	8b 55 fc             	mov    -0x4(%ebp),%edx
+    3eeb:	8b 45 08             	mov    0x8(%ebp),%eax
+    3eee:	01 d0                	add    %edx,%eax
+    3ef0:	0f b6 00             	movzbl (%eax),%eax
+    3ef3:	84 c0                	test   %al,%al
+    3ef5:	75 ed                	jne    3ee4 <strlen+0x13>
+    ;
+  return n;
+    3ef7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+    3efa:	c9                   	leave  
+    3efb:	c3                   	ret    
+
+00003efc <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    3efc:	f3 0f 1e fb          	endbr32 
+    3f00:	55                   	push   %ebp
+    3f01:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+    3f03:	8b 45 10             	mov    0x10(%ebp),%eax
+    3f06:	50                   	push   %eax
+    3f07:	ff 75 0c             	pushl  0xc(%ebp)
+    3f0a:	ff 75 08             	pushl  0x8(%ebp)
+    3f0d:	e8 22 ff ff ff       	call   3e34 <stosb>
+    3f12:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+    3f15:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+    3f18:	c9                   	leave  
+    3f19:	c3                   	ret    
+
+00003f1a <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    3f1a:	f3 0f 1e fb          	endbr32 
+    3f1e:	55                   	push   %ebp
+    3f1f:	89 e5                	mov    %esp,%ebp
+    3f21:	83 ec 04             	sub    $0x4,%esp
+    3f24:	8b 45 0c             	mov    0xc(%ebp),%eax
+    3f27:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+    3f2a:	eb 14                	jmp    3f40 <strchr+0x26>
+    if(*s == c)
+    3f2c:	8b 45 08             	mov    0x8(%ebp),%eax
+    3f2f:	0f b6 00             	movzbl (%eax),%eax
+    3f32:	38 45 fc             	cmp    %al,-0x4(%ebp)
+    3f35:	75 05                	jne    3f3c <strchr+0x22>
+      return (char*)s;
+    3f37:	8b 45 08             	mov    0x8(%ebp),%eax
+    3f3a:	eb 13                	jmp    3f4f <strchr+0x35>
+  for(; *s; s++)
+    3f3c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    3f40:	8b 45 08             	mov    0x8(%ebp),%eax
+    3f43:	0f b6 00             	movzbl (%eax),%eax
+    3f46:	84 c0                	test   %al,%al
+    3f48:	75 e2                	jne    3f2c <strchr+0x12>
+  return 0;
+    3f4a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+    3f4f:	c9                   	leave  
+    3f50:	c3                   	ret    
+
+00003f51 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    3f51:	f3 0f 1e fb          	endbr32 
+    3f55:	55                   	push   %ebp
+    3f56:	89 e5                	mov    %esp,%ebp
+    3f58:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    3f5b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    3f62:	eb 42                	jmp    3fa6 <gets+0x55>
+    cc = read(0, &c, 1);
+    3f64:	83 ec 04             	sub    $0x4,%esp
+    3f67:	6a 01                	push   $0x1
+    3f69:	8d 45 ef             	lea    -0x11(%ebp),%eax
+    3f6c:	50                   	push   %eax
+    3f6d:	6a 00                	push   $0x0
+    3f6f:	e8 53 01 00 00       	call   40c7 <read>
+    3f74:	83 c4 10             	add    $0x10,%esp
+    3f77:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+    3f7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    3f7e:	7e 33                	jle    3fb3 <gets+0x62>
+      break;
+    buf[i++] = c;
+    3f80:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3f83:	8d 50 01             	lea    0x1(%eax),%edx
+    3f86:	89 55 f4             	mov    %edx,-0xc(%ebp)
+    3f89:	89 c2                	mov    %eax,%edx
+    3f8b:	8b 45 08             	mov    0x8(%ebp),%eax
+    3f8e:	01 c2                	add    %eax,%edx
+    3f90:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    3f94:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+    3f96:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    3f9a:	3c 0a                	cmp    $0xa,%al
+    3f9c:	74 16                	je     3fb4 <gets+0x63>
+    3f9e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    3fa2:	3c 0d                	cmp    $0xd,%al
+    3fa4:	74 0e                	je     3fb4 <gets+0x63>
+  for(i=0; i+1 < max; ){
+    3fa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    3fa9:	83 c0 01             	add    $0x1,%eax
+    3fac:	39 45 0c             	cmp    %eax,0xc(%ebp)
+    3faf:	7f b3                	jg     3f64 <gets+0x13>
+    3fb1:	eb 01                	jmp    3fb4 <gets+0x63>
+      break;
+    3fb3:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+    3fb4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+    3fb7:	8b 45 08             	mov    0x8(%ebp),%eax
+    3fba:	01 d0                	add    %edx,%eax
+    3fbc:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+    3fbf:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+    3fc2:	c9                   	leave  
+    3fc3:	c3                   	ret    
+
+00003fc4 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+    3fc4:	f3 0f 1e fb          	endbr32 
+    3fc8:	55                   	push   %ebp
+    3fc9:	89 e5                	mov    %esp,%ebp
+    3fcb:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    3fce:	83 ec 08             	sub    $0x8,%esp
+    3fd1:	6a 00                	push   $0x0
+    3fd3:	ff 75 08             	pushl  0x8(%ebp)
+    3fd6:	e8 14 01 00 00       	call   40ef <open>
+    3fdb:	83 c4 10             	add    $0x10,%esp
+    3fde:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+    3fe1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    3fe5:	79 07                	jns    3fee <stat+0x2a>
+    return -1;
+    3fe7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+    3fec:	eb 25                	jmp    4013 <stat+0x4f>
+  r = fstat(fd, st);
+    3fee:	83 ec 08             	sub    $0x8,%esp
+    3ff1:	ff 75 0c             	pushl  0xc(%ebp)
+    3ff4:	ff 75 f4             	pushl  -0xc(%ebp)
+    3ff7:	e8 0b 01 00 00       	call   4107 <fstat>
+    3ffc:	83 c4 10             	add    $0x10,%esp
+    3fff:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+    4002:	83 ec 0c             	sub    $0xc,%esp
+    4005:	ff 75 f4             	pushl  -0xc(%ebp)
+    4008:	e8 ca 00 00 00       	call   40d7 <close>
+    400d:	83 c4 10             	add    $0x10,%esp
+  return r;
+    4010:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+    4013:	c9                   	leave  
+    4014:	c3                   	ret    
+
+00004015 <atoi>:
+
+int
+atoi(const char *s)
+{
+    4015:	f3 0f 1e fb          	endbr32 
+    4019:	55                   	push   %ebp
+    401a:	89 e5                	mov    %esp,%ebp
+    401c:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+    401f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+    4026:	eb 25                	jmp    404d <atoi+0x38>
+    n = n*10 + *s++ - '0';
+    4028:	8b 55 fc             	mov    -0x4(%ebp),%edx
+    402b:	89 d0                	mov    %edx,%eax
+    402d:	c1 e0 02             	shl    $0x2,%eax
+    4030:	01 d0                	add    %edx,%eax
+    4032:	01 c0                	add    %eax,%eax
+    4034:	89 c1                	mov    %eax,%ecx
+    4036:	8b 45 08             	mov    0x8(%ebp),%eax
+    4039:	8d 50 01             	lea    0x1(%eax),%edx
+    403c:	89 55 08             	mov    %edx,0x8(%ebp)
+    403f:	0f b6 00             	movzbl (%eax),%eax
+    4042:	0f be c0             	movsbl %al,%eax
+    4045:	01 c8                	add    %ecx,%eax
+    4047:	83 e8 30             	sub    $0x30,%eax
+    404a:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+    404d:	8b 45 08             	mov    0x8(%ebp),%eax
+    4050:	0f b6 00             	movzbl (%eax),%eax
+    4053:	3c 2f                	cmp    $0x2f,%al
+    4055:	7e 0a                	jle    4061 <atoi+0x4c>
+    4057:	8b 45 08             	mov    0x8(%ebp),%eax
+    405a:	0f b6 00             	movzbl (%eax),%eax
+    405d:	3c 39                	cmp    $0x39,%al
+    405f:	7e c7                	jle    4028 <atoi+0x13>
+  return n;
+    4061:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+    4064:	c9                   	leave  
+    4065:	c3                   	ret    
+
+00004066 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+    4066:	f3 0f 1e fb          	endbr32 
+    406a:	55                   	push   %ebp
+    406b:	89 e5                	mov    %esp,%ebp
+    406d:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+    4070:	8b 45 08             	mov    0x8(%ebp),%eax
+    4073:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+    4076:	8b 45 0c             	mov    0xc(%ebp),%eax
+    4079:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+    407c:	eb 17                	jmp    4095 <memmove+0x2f>
+    *dst++ = *src++;
+    407e:	8b 55 f8             	mov    -0x8(%ebp),%edx
+    4081:	8d 42 01             	lea    0x1(%edx),%eax
+    4084:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    4087:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    408a:	8d 48 01             	lea    0x1(%eax),%ecx
+    408d:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+    4090:	0f b6 12             	movzbl (%edx),%edx
+    4093:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+    4095:	8b 45 10             	mov    0x10(%ebp),%eax
+    4098:	8d 50 ff             	lea    -0x1(%eax),%edx
+    409b:	89 55 10             	mov    %edx,0x10(%ebp)
+    409e:	85 c0                	test   %eax,%eax
+    40a0:	7f dc                	jg     407e <memmove+0x18>
+  return vdst;
+    40a2:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+    40a5:	c9                   	leave  
+    40a6:	c3                   	ret    
+
+000040a7 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+    40a7:	b8 01 00 00 00       	mov    $0x1,%eax
+    40ac:	cd 40                	int    $0x40
+    40ae:	c3                   	ret    
+
+000040af <exit>:
+SYSCALL(exit)
+    40af:	b8 02 00 00 00       	mov    $0x2,%eax
+    40b4:	cd 40                	int    $0x40
+    40b6:	c3                   	ret    
+
+000040b7 <wait>:
+SYSCALL(wait)
+    40b7:	b8 03 00 00 00       	mov    $0x3,%eax
+    40bc:	cd 40                	int    $0x40
+    40be:	c3                   	ret    
+
+000040bf <pipe>:
+SYSCALL(pipe)
+    40bf:	b8 04 00 00 00       	mov    $0x4,%eax
+    40c4:	cd 40                	int    $0x40
+    40c6:	c3                   	ret    
+
+000040c7 <read>:
+SYSCALL(read)
+    40c7:	b8 05 00 00 00       	mov    $0x5,%eax
+    40cc:	cd 40                	int    $0x40
+    40ce:	c3                   	ret    
+
+000040cf <write>:
+SYSCALL(write)
+    40cf:	b8 10 00 00 00       	mov    $0x10,%eax
+    40d4:	cd 40                	int    $0x40
+    40d6:	c3                   	ret    
+
+000040d7 <close>:
+SYSCALL(close)
+    40d7:	b8 15 00 00 00       	mov    $0x15,%eax
+    40dc:	cd 40                	int    $0x40
+    40de:	c3                   	ret    
+
+000040df <kill>:
+SYSCALL(kill)
+    40df:	b8 06 00 00 00       	mov    $0x6,%eax
+    40e4:	cd 40                	int    $0x40
+    40e6:	c3                   	ret    
+
+000040e7 <exec>:
+SYSCALL(exec)
+    40e7:	b8 07 00 00 00       	mov    $0x7,%eax
+    40ec:	cd 40                	int    $0x40
+    40ee:	c3                   	ret    
+
+000040ef <open>:
+SYSCALL(open)
+    40ef:	b8 0f 00 00 00       	mov    $0xf,%eax
+    40f4:	cd 40                	int    $0x40
+    40f6:	c3                   	ret    
+
+000040f7 <mknod>:
+SYSCALL(mknod)
+    40f7:	b8 11 00 00 00       	mov    $0x11,%eax
+    40fc:	cd 40                	int    $0x40
+    40fe:	c3                   	ret    
+
+000040ff <unlink>:
+SYSCALL(unlink)
+    40ff:	b8 12 00 00 00       	mov    $0x12,%eax
+    4104:	cd 40                	int    $0x40
+    4106:	c3                   	ret    
+
+00004107 <fstat>:
+SYSCALL(fstat)
+    4107:	b8 08 00 00 00       	mov    $0x8,%eax
+    410c:	cd 40                	int    $0x40
+    410e:	c3                   	ret    
+
+0000410f <link>:
+SYSCALL(link)
+    410f:	b8 13 00 00 00       	mov    $0x13,%eax
+    4114:	cd 40                	int    $0x40
+    4116:	c3                   	ret    
+
+00004117 <mkdir>:
+SYSCALL(mkdir)
+    4117:	b8 14 00 00 00       	mov    $0x14,%eax
+    411c:	cd 40                	int    $0x40
+    411e:	c3                   	ret    
+
+0000411f <chdir>:
+SYSCALL(chdir)
+    411f:	b8 09 00 00 00       	mov    $0x9,%eax
+    4124:	cd 40                	int    $0x40
+    4126:	c3                   	ret    
+
+00004127 <dup>:
+SYSCALL(dup)
+    4127:	b8 0a 00 00 00       	mov    $0xa,%eax
+    412c:	cd 40                	int    $0x40
+    412e:	c3                   	ret    
+
+0000412f <getpid>:
+SYSCALL(getpid)
+    412f:	b8 0b 00 00 00       	mov    $0xb,%eax
+    4134:	cd 40                	int    $0x40
+    4136:	c3                   	ret    
+
+00004137 <sbrk>:
+SYSCALL(sbrk)
+    4137:	b8 0c 00 00 00       	mov    $0xc,%eax
+    413c:	cd 40                	int    $0x40
+    413e:	c3                   	ret    
+
+0000413f <sleep>:
+SYSCALL(sleep)
+    413f:	b8 0d 00 00 00       	mov    $0xd,%eax
+    4144:	cd 40                	int    $0x40
+    4146:	c3                   	ret    
+
+00004147 <uptime>:
+SYSCALL(uptime)
+    4147:	b8 0e 00 00 00       	mov    $0xe,%eax
+    414c:	cd 40                	int    $0x40
+    414e:	c3                   	ret    
+
+0000414f <draw>:
+SYSCALL(draw)
+    414f:	b8 16 00 00 00       	mov    $0x16,%eax
+    4154:	cd 40                	int    $0x40
+    4156:	c3                   	ret    
+
+00004157 <cps>:
+SYSCALL(cps)
+    4157:	b8 17 00 00 00       	mov    $0x17,%eax
+    415c:	cd 40                	int    $0x40
+    415e:	c3                   	ret    
+
+0000415f <yield>:
+SYSCALL(yield)
+    415f:	b8 18 00 00 00       	mov    $0x18,%eax
+    4164:	cd 40                	int    $0x40
+    4166:	c3                   	ret    
+
+00004167 <wait2>:
+SYSCALL(wait2)
+    4167:	b8 19 00 00 00       	mov    $0x19,%eax
+    416c:	cd 40                	int    $0x40
+    416e:	c3                   	ret    
+
+0000416f <set_prio>:
+SYSCALL(set_prio)
+    416f:	b8 1a 00 00 00       	mov    $0x1a,%eax
+    4174:	cd 40                	int    $0x40
+    4176:	c3                   	ret    
+
+00004177 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+    4177:	f3 0f 1e fb          	endbr32 
+    417b:	55                   	push   %ebp
+    417c:	89 e5                	mov    %esp,%ebp
+    417e:	83 ec 18             	sub    $0x18,%esp
+    4181:	8b 45 0c             	mov    0xc(%ebp),%eax
+    4184:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+    4187:	83 ec 04             	sub    $0x4,%esp
+    418a:	6a 01                	push   $0x1
+    418c:	8d 45 f4             	lea    -0xc(%ebp),%eax
+    418f:	50                   	push   %eax
+    4190:	ff 75 08             	pushl  0x8(%ebp)
+    4193:	e8 37 ff ff ff       	call   40cf <write>
+    4198:	83 c4 10             	add    $0x10,%esp
+}
+    419b:	90                   	nop
+    419c:	c9                   	leave  
+    419d:	c3                   	ret    
+
+0000419e <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+    419e:	f3 0f 1e fb          	endbr32 
+    41a2:	55                   	push   %ebp
+    41a3:	89 e5                	mov    %esp,%ebp
+    41a5:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+    41a8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+    41af:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+    41b3:	74 17                	je     41cc <printint+0x2e>
+    41b5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+    41b9:	79 11                	jns    41cc <printint+0x2e>
+    neg = 1;
+    41bb:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+    41c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+    41c5:	f7 d8                	neg    %eax
+    41c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    41ca:	eb 06                	jmp    41d2 <printint+0x34>
+  } else {
+    x = xx;
+    41cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+    41cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+    41d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+    41d9:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    41dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    41df:	ba 00 00 00 00       	mov    $0x0,%edx
+    41e4:	f7 f1                	div    %ecx
+    41e6:	89 d1                	mov    %edx,%ecx
+    41e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    41eb:	8d 50 01             	lea    0x1(%eax),%edx
+    41ee:	89 55 f4             	mov    %edx,-0xc(%ebp)
+    41f1:	0f b6 91 78 65 00 00 	movzbl 0x6578(%ecx),%edx
+    41f8:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+    41fc:	8b 4d 10             	mov    0x10(%ebp),%ecx
+    41ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
+    4202:	ba 00 00 00 00       	mov    $0x0,%edx
+    4207:	f7 f1                	div    %ecx
+    4209:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    420c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    4210:	75 c7                	jne    41d9 <printint+0x3b>
+  if(neg)
+    4212:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    4216:	74 2d                	je     4245 <printint+0xa7>
+    buf[i++] = '-';
+    4218:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    421b:	8d 50 01             	lea    0x1(%eax),%edx
+    421e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+    4221:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+    4226:	eb 1d                	jmp    4245 <printint+0xa7>
+    putc(fd, buf[i]);
+    4228:	8d 55 dc             	lea    -0x24(%ebp),%edx
+    422b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    422e:	01 d0                	add    %edx,%eax
+    4230:	0f b6 00             	movzbl (%eax),%eax
+    4233:	0f be c0             	movsbl %al,%eax
+    4236:	83 ec 08             	sub    $0x8,%esp
+    4239:	50                   	push   %eax
+    423a:	ff 75 08             	pushl  0x8(%ebp)
+    423d:	e8 35 ff ff ff       	call   4177 <putc>
+    4242:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+    4245:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+    4249:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    424d:	79 d9                	jns    4228 <printint+0x8a>
+}
+    424f:	90                   	nop
+    4250:	90                   	nop
+    4251:	c9                   	leave  
+    4252:	c3                   	ret    
+
+00004253 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+    4253:	f3 0f 1e fb          	endbr32 
+    4257:	55                   	push   %ebp
+    4258:	89 e5                	mov    %esp,%ebp
+    425a:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+    425d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+    4264:	8d 45 0c             	lea    0xc(%ebp),%eax
+    4267:	83 c0 04             	add    $0x4,%eax
+    426a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+    426d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    4274:	e9 59 01 00 00       	jmp    43d2 <printf+0x17f>
+    c = fmt[i] & 0xff;
+    4279:	8b 55 0c             	mov    0xc(%ebp),%edx
+    427c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    427f:	01 d0                	add    %edx,%eax
+    4281:	0f b6 00             	movzbl (%eax),%eax
+    4284:	0f be c0             	movsbl %al,%eax
+    4287:	25 ff 00 00 00       	and    $0xff,%eax
+    428c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+    428f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+    4293:	75 2c                	jne    42c1 <printf+0x6e>
+      if(c == '%'){
+    4295:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+    4299:	75 0c                	jne    42a7 <printf+0x54>
+        state = '%';
+    429b:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+    42a2:	e9 27 01 00 00       	jmp    43ce <printf+0x17b>
+      } else {
+        putc(fd, c);
+    42a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    42aa:	0f be c0             	movsbl %al,%eax
+    42ad:	83 ec 08             	sub    $0x8,%esp
+    42b0:	50                   	push   %eax
+    42b1:	ff 75 08             	pushl  0x8(%ebp)
+    42b4:	e8 be fe ff ff       	call   4177 <putc>
+    42b9:	83 c4 10             	add    $0x10,%esp
+    42bc:	e9 0d 01 00 00       	jmp    43ce <printf+0x17b>
+      }
+    } else if(state == '%'){
+    42c1:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+    42c5:	0f 85 03 01 00 00    	jne    43ce <printf+0x17b>
+      if(c == 'd'){
+    42cb:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+    42cf:	75 1e                	jne    42ef <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+    42d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    42d4:	8b 00                	mov    (%eax),%eax
+    42d6:	6a 01                	push   $0x1
+    42d8:	6a 0a                	push   $0xa
+    42da:	50                   	push   %eax
+    42db:	ff 75 08             	pushl  0x8(%ebp)
+    42de:	e8 bb fe ff ff       	call   419e <printint>
+    42e3:	83 c4 10             	add    $0x10,%esp
+        ap++;
+    42e6:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    42ea:	e9 d8 00 00 00       	jmp    43c7 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+    42ef:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+    42f3:	74 06                	je     42fb <printf+0xa8>
+    42f5:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+    42f9:	75 1e                	jne    4319 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+    42fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    42fe:	8b 00                	mov    (%eax),%eax
+    4300:	6a 00                	push   $0x0
+    4302:	6a 10                	push   $0x10
+    4304:	50                   	push   %eax
+    4305:	ff 75 08             	pushl  0x8(%ebp)
+    4308:	e8 91 fe ff ff       	call   419e <printint>
+    430d:	83 c4 10             	add    $0x10,%esp
+        ap++;
+    4310:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    4314:	e9 ae 00 00 00       	jmp    43c7 <printf+0x174>
+      } else if(c == 's'){
+    4319:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+    431d:	75 43                	jne    4362 <printf+0x10f>
+        s = (char*)*ap;
+    431f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    4322:	8b 00                	mov    (%eax),%eax
+    4324:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+    4327:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+    432b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    432f:	75 25                	jne    4356 <printf+0x103>
+          s = "(null)";
+    4331:	c7 45 f4 46 5e 00 00 	movl   $0x5e46,-0xc(%ebp)
+        while(*s != 0){
+    4338:	eb 1c                	jmp    4356 <printf+0x103>
+          putc(fd, *s);
+    433a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    433d:	0f b6 00             	movzbl (%eax),%eax
+    4340:	0f be c0             	movsbl %al,%eax
+    4343:	83 ec 08             	sub    $0x8,%esp
+    4346:	50                   	push   %eax
+    4347:	ff 75 08             	pushl  0x8(%ebp)
+    434a:	e8 28 fe ff ff       	call   4177 <putc>
+    434f:	83 c4 10             	add    $0x10,%esp
+          s++;
+    4352:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+    4356:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4359:	0f b6 00             	movzbl (%eax),%eax
+    435c:	84 c0                	test   %al,%al
+    435e:	75 da                	jne    433a <printf+0xe7>
+    4360:	eb 65                	jmp    43c7 <printf+0x174>
+        }
+      } else if(c == 'c'){
+    4362:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+    4366:	75 1d                	jne    4385 <printf+0x132>
+        putc(fd, *ap);
+    4368:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    436b:	8b 00                	mov    (%eax),%eax
+    436d:	0f be c0             	movsbl %al,%eax
+    4370:	83 ec 08             	sub    $0x8,%esp
+    4373:	50                   	push   %eax
+    4374:	ff 75 08             	pushl  0x8(%ebp)
+    4377:	e8 fb fd ff ff       	call   4177 <putc>
+    437c:	83 c4 10             	add    $0x10,%esp
+        ap++;
+    437f:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+    4383:	eb 42                	jmp    43c7 <printf+0x174>
+      } else if(c == '%'){
+    4385:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+    4389:	75 17                	jne    43a2 <printf+0x14f>
+        putc(fd, c);
+    438b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    438e:	0f be c0             	movsbl %al,%eax
+    4391:	83 ec 08             	sub    $0x8,%esp
+    4394:	50                   	push   %eax
+    4395:	ff 75 08             	pushl  0x8(%ebp)
+    4398:	e8 da fd ff ff       	call   4177 <putc>
+    439d:	83 c4 10             	add    $0x10,%esp
+    43a0:	eb 25                	jmp    43c7 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+    43a2:	83 ec 08             	sub    $0x8,%esp
+    43a5:	6a 25                	push   $0x25
+    43a7:	ff 75 08             	pushl  0x8(%ebp)
+    43aa:	e8 c8 fd ff ff       	call   4177 <putc>
+    43af:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+    43b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+    43b5:	0f be c0             	movsbl %al,%eax
+    43b8:	83 ec 08             	sub    $0x8,%esp
+    43bb:	50                   	push   %eax
+    43bc:	ff 75 08             	pushl  0x8(%ebp)
+    43bf:	e8 b3 fd ff ff       	call   4177 <putc>
+    43c4:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+    43c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+    43ce:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+    43d2:	8b 55 0c             	mov    0xc(%ebp),%edx
+    43d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    43d8:	01 d0                	add    %edx,%eax
+    43da:	0f b6 00             	movzbl (%eax),%eax
+    43dd:	84 c0                	test   %al,%al
+    43df:	0f 85 94 fe ff ff    	jne    4279 <printf+0x26>
+    }
+  }
+}
+    43e5:	90                   	nop
+    43e6:	90                   	nop
+    43e7:	c9                   	leave  
+    43e8:	c3                   	ret    
+
+000043e9 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    43e9:	f3 0f 1e fb          	endbr32 
+    43ed:	55                   	push   %ebp
+    43ee:	89 e5                	mov    %esp,%ebp
+    43f0:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+    43f3:	8b 45 08             	mov    0x8(%ebp),%eax
+    43f6:	83 e8 08             	sub    $0x8,%eax
+    43f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    43fc:	a1 28 66 00 00       	mov    0x6628,%eax
+    4401:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    4404:	eb 24                	jmp    442a <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    4406:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4409:	8b 00                	mov    (%eax),%eax
+    440b:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+    440e:	72 12                	jb     4422 <free+0x39>
+    4410:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    4413:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    4416:	77 24                	ja     443c <free+0x53>
+    4418:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    441b:	8b 00                	mov    (%eax),%eax
+    441d:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+    4420:	72 1a                	jb     443c <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    4422:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4425:	8b 00                	mov    (%eax),%eax
+    4427:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    442a:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    442d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+    4430:	76 d4                	jbe    4406 <free+0x1d>
+    4432:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4435:	8b 00                	mov    (%eax),%eax
+    4437:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+    443a:	73 ca                	jae    4406 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    443c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    443f:	8b 40 04             	mov    0x4(%eax),%eax
+    4442:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+    4449:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    444c:	01 c2                	add    %eax,%edx
+    444e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4451:	8b 00                	mov    (%eax),%eax
+    4453:	39 c2                	cmp    %eax,%edx
+    4455:	75 24                	jne    447b <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+    4457:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    445a:	8b 50 04             	mov    0x4(%eax),%edx
+    445d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4460:	8b 00                	mov    (%eax),%eax
+    4462:	8b 40 04             	mov    0x4(%eax),%eax
+    4465:	01 c2                	add    %eax,%edx
+    4467:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    446a:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    446d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4470:	8b 00                	mov    (%eax),%eax
+    4472:	8b 10                	mov    (%eax),%edx
+    4474:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    4477:	89 10                	mov    %edx,(%eax)
+    4479:	eb 0a                	jmp    4485 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+    447b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    447e:	8b 10                	mov    (%eax),%edx
+    4480:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    4483:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+    4485:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4488:	8b 40 04             	mov    0x4(%eax),%eax
+    448b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+    4492:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    4495:	01 d0                	add    %edx,%eax
+    4497:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+    449a:	75 20                	jne    44bc <free+0xd3>
+    p->s.size += bp->s.size;
+    449c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    449f:	8b 50 04             	mov    0x4(%eax),%edx
+    44a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    44a5:	8b 40 04             	mov    0x4(%eax),%eax
+    44a8:	01 c2                	add    %eax,%edx
+    44aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    44ad:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+    44b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
+    44b3:	8b 10                	mov    (%eax),%edx
+    44b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    44b8:	89 10                	mov    %edx,(%eax)
+    44ba:	eb 08                	jmp    44c4 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+    44bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    44bf:	8b 55 f8             	mov    -0x8(%ebp),%edx
+    44c2:	89 10                	mov    %edx,(%eax)
+  freep = p;
+    44c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+    44c7:	a3 28 66 00 00       	mov    %eax,0x6628
+}
+    44cc:	90                   	nop
+    44cd:	c9                   	leave  
+    44ce:	c3                   	ret    
+
+000044cf <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+    44cf:	f3 0f 1e fb          	endbr32 
+    44d3:	55                   	push   %ebp
+    44d4:	89 e5                	mov    %esp,%ebp
+    44d6:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+    44d9:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+    44e0:	77 07                	ja     44e9 <morecore+0x1a>
+    nu = 4096;
+    44e2:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+    44e9:	8b 45 08             	mov    0x8(%ebp),%eax
+    44ec:	c1 e0 03             	shl    $0x3,%eax
+    44ef:	83 ec 0c             	sub    $0xc,%esp
+    44f2:	50                   	push   %eax
+    44f3:	e8 3f fc ff ff       	call   4137 <sbrk>
+    44f8:	83 c4 10             	add    $0x10,%esp
+    44fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+    44fe:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+    4502:	75 07                	jne    450b <morecore+0x3c>
+    return 0;
+    4504:	b8 00 00 00 00       	mov    $0x0,%eax
+    4509:	eb 26                	jmp    4531 <morecore+0x62>
+  hp = (Header*)p;
+    450b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    450e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+    4511:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    4514:	8b 55 08             	mov    0x8(%ebp),%edx
+    4517:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+    451a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    451d:	83 c0 08             	add    $0x8,%eax
+    4520:	83 ec 0c             	sub    $0xc,%esp
+    4523:	50                   	push   %eax
+    4524:	e8 c0 fe ff ff       	call   43e9 <free>
+    4529:	83 c4 10             	add    $0x10,%esp
+  return freep;
+    452c:	a1 28 66 00 00       	mov    0x6628,%eax
+}
+    4531:	c9                   	leave  
+    4532:	c3                   	ret    
+
+00004533 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+    4533:	f3 0f 1e fb          	endbr32 
+    4537:	55                   	push   %ebp
+    4538:	89 e5                	mov    %esp,%ebp
+    453a:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    453d:	8b 45 08             	mov    0x8(%ebp),%eax
+    4540:	83 c0 07             	add    $0x7,%eax
+    4543:	c1 e8 03             	shr    $0x3,%eax
+    4546:	83 c0 01             	add    $0x1,%eax
+    4549:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+    454c:	a1 28 66 00 00       	mov    0x6628,%eax
+    4551:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    4554:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+    4558:	75 23                	jne    457d <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+    455a:	c7 45 f0 20 66 00 00 	movl   $0x6620,-0x10(%ebp)
+    4561:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    4564:	a3 28 66 00 00       	mov    %eax,0x6628
+    4569:	a1 28 66 00 00       	mov    0x6628,%eax
+    456e:	a3 20 66 00 00       	mov    %eax,0x6620
+    base.s.size = 0;
+    4573:	c7 05 24 66 00 00 00 	movl   $0x0,0x6624
+    457a:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    457d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    4580:	8b 00                	mov    (%eax),%eax
+    4582:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+    4585:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4588:	8b 40 04             	mov    0x4(%eax),%eax
+    458b:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+    458e:	77 4d                	ja     45dd <malloc+0xaa>
+      if(p->s.size == nunits)
+    4590:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4593:	8b 40 04             	mov    0x4(%eax),%eax
+    4596:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+    4599:	75 0c                	jne    45a7 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+    459b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    459e:	8b 10                	mov    (%eax),%edx
+    45a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    45a3:	89 10                	mov    %edx,(%eax)
+    45a5:	eb 26                	jmp    45cd <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+    45a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    45aa:	8b 40 04             	mov    0x4(%eax),%eax
+    45ad:	2b 45 ec             	sub    -0x14(%ebp),%eax
+    45b0:	89 c2                	mov    %eax,%edx
+    45b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    45b5:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+    45b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    45bb:	8b 40 04             	mov    0x4(%eax),%eax
+    45be:	c1 e0 03             	shl    $0x3,%eax
+    45c1:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+    45c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    45c7:	8b 55 ec             	mov    -0x14(%ebp),%edx
+    45ca:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+    45cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    45d0:	a3 28 66 00 00       	mov    %eax,0x6628
+      return (void*)(p + 1);
+    45d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    45d8:	83 c0 08             	add    $0x8,%eax
+    45db:	eb 3b                	jmp    4618 <malloc+0xe5>
+    }
+    if(p == freep)
+    45dd:	a1 28 66 00 00       	mov    0x6628,%eax
+    45e2:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+    45e5:	75 1e                	jne    4605 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+    45e7:	83 ec 0c             	sub    $0xc,%esp
+    45ea:	ff 75 ec             	pushl  -0x14(%ebp)
+    45ed:	e8 dd fe ff ff       	call   44cf <morecore>
+    45f2:	83 c4 10             	add    $0x10,%esp
+    45f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    45f8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+    45fc:	75 07                	jne    4605 <malloc+0xd2>
+        return 0;
+    45fe:	b8 00 00 00 00       	mov    $0x0,%eax
+    4603:	eb 13                	jmp    4618 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    4605:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    4608:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    460b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+    460e:	8b 00                	mov    (%eax),%eax
+    4610:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+    4613:	e9 6d ff ff ff       	jmp    4585 <malloc+0x52>
+  }
+}
+    4618:	c9                   	leave  
+    4619:	c3                   	ret    
diff -ruN xv6-public/xv6-public/usertests.c xv6-public_new/xv6-public/usertests.c
--- xv6-public/xv6-public/usertests.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/usertests.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,1803 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+
+char buf[8192];
+char name[3];
+char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
+int stdout = 1;
+
+// does chdir() call iput(p->cwd) in a transaction?
+void
+iputtest(void)
+{
+  printf(stdout, "iput test\n");
+
+  if(mkdir("iputdir") < 0){
+    printf(stdout, "mkdir failed\n");
+    exit();
+  }
+  if(chdir("iputdir") < 0){
+    printf(stdout, "chdir iputdir failed\n");
+    exit();
+  }
+  if(unlink("../iputdir") < 0){
+    printf(stdout, "unlink ../iputdir failed\n");
+    exit();
+  }
+  if(chdir("/") < 0){
+    printf(stdout, "chdir / failed\n");
+    exit();
+  }
+  printf(stdout, "iput test ok\n");
+}
+
+// does exit() call iput(p->cwd) in a transaction?
+void
+exitiputtest(void)
+{
+  int pid;
+
+  printf(stdout, "exitiput test\n");
+
+  pid = fork();
+  if(pid < 0){
+    printf(stdout, "fork failed\n");
+    exit();
+  }
+  if(pid == 0){
+    if(mkdir("iputdir") < 0){
+      printf(stdout, "mkdir failed\n");
+      exit();
+    }
+    if(chdir("iputdir") < 0){
+      printf(stdout, "child chdir failed\n");
+      exit();
+    }
+    if(unlink("../iputdir") < 0){
+      printf(stdout, "unlink ../iputdir failed\n");
+      exit();
+    }
+    exit();
+  }
+  wait();
+  printf(stdout, "exitiput test ok\n");
+}
+
+// does the error path in open() for attempt to write a
+// directory call iput() in a transaction?
+// needs a hacked kernel that pauses just after the namei()
+// call in sys_open():
+//    if((ip = namei(path)) == 0)
+//      return -1;
+//    {
+//      int i;
+//      for(i = 0; i < 10000; i++)
+//        yield();
+//    }
+void
+openiputtest(void)
+{
+  int pid;
+
+  printf(stdout, "openiput test\n");
+  if(mkdir("oidir") < 0){
+    printf(stdout, "mkdir oidir failed\n");
+    exit();
+  }
+  pid = fork();
+  if(pid < 0){
+    printf(stdout, "fork failed\n");
+    exit();
+  }
+  if(pid == 0){
+    int fd = open("oidir", O_RDWR);
+    if(fd >= 0){
+      printf(stdout, "open directory for write succeeded\n");
+      exit();
+    }
+    exit();
+  }
+  sleep(1);
+  if(unlink("oidir") != 0){
+    printf(stdout, "unlink failed\n");
+    exit();
+  }
+  wait();
+  printf(stdout, "openiput test ok\n");
+}
+
+// simple file system tests
+
+void
+opentest(void)
+{
+  int fd;
+
+  printf(stdout, "open test\n");
+  fd = open("echo", 0);
+  if(fd < 0){
+    printf(stdout, "open echo failed!\n");
+    exit();
+  }
+  close(fd);
+  fd = open("doesnotexist", 0);
+  if(fd >= 0){
+    printf(stdout, "open doesnotexist succeeded!\n");
+    exit();
+  }
+  printf(stdout, "open test ok\n");
+}
+
+void
+writetest(void)
+{
+  int fd;
+  int i;
+
+  printf(stdout, "small file test\n");
+  fd = open("small", O_CREATE|O_RDWR);
+  if(fd >= 0){
+    printf(stdout, "creat small succeeded; ok\n");
+  } else {
+    printf(stdout, "error: creat small failed!\n");
+    exit();
+  }
+  for(i = 0; i < 100; i++){
+    if(write(fd, "aaaaaaaaaa", 10) != 10){
+      printf(stdout, "error: write aa %d new file failed\n", i);
+      exit();
+    }
+    if(write(fd, "bbbbbbbbbb", 10) != 10){
+      printf(stdout, "error: write bb %d new file failed\n", i);
+      exit();
+    }
+  }
+  printf(stdout, "writes ok\n");
+  close(fd);
+  fd = open("small", O_RDONLY);
+  if(fd >= 0){
+    printf(stdout, "open small succeeded ok\n");
+  } else {
+    printf(stdout, "error: open small failed!\n");
+    exit();
+  }
+  i = read(fd, buf, 2000);
+  if(i == 2000){
+    printf(stdout, "read succeeded ok\n");
+  } else {
+    printf(stdout, "read failed\n");
+    exit();
+  }
+  close(fd);
+
+  if(unlink("small") < 0){
+    printf(stdout, "unlink small failed\n");
+    exit();
+  }
+  printf(stdout, "small file test ok\n");
+}
+
+void
+writetest1(void)
+{
+  int i, fd, n;
+
+  printf(stdout, "big files test\n");
+
+  fd = open("big", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(stdout, "error: creat big failed!\n");
+    exit();
+  }
+
+  for(i = 0; i < MAXFILE; i++){
+    ((int*)buf)[0] = i;
+    if(write(fd, buf, 512) != 512){
+      printf(stdout, "error: write big file failed\n", i);
+      exit();
+    }
+  }
+
+  close(fd);
+
+  fd = open("big", O_RDONLY);
+  if(fd < 0){
+    printf(stdout, "error: open big failed!\n");
+    exit();
+  }
+
+  n = 0;
+  for(;;){
+    i = read(fd, buf, 512);
+    if(i == 0){
+      if(n == MAXFILE - 1){
+        printf(stdout, "read only %d blocks from big", n);
+        exit();
+      }
+      break;
+    } else if(i != 512){
+      printf(stdout, "read failed %d\n", i);
+      exit();
+    }
+    if(((int*)buf)[0] != n){
+      printf(stdout, "read content of block %d is %d\n",
+             n, ((int*)buf)[0]);
+      exit();
+    }
+    n++;
+  }
+  close(fd);
+  if(unlink("big") < 0){
+    printf(stdout, "unlink big failed\n");
+    exit();
+  }
+  printf(stdout, "big files ok\n");
+}
+
+void
+createtest(void)
+{
+  int i, fd;
+
+  printf(stdout, "many creates, followed by unlink test\n");
+
+  name[0] = 'a';
+  name[2] = '\0';
+  for(i = 0; i < 52; i++){
+    name[1] = '0' + i;
+    fd = open(name, O_CREATE|O_RDWR);
+    close(fd);
+  }
+  name[0] = 'a';
+  name[2] = '\0';
+  for(i = 0; i < 52; i++){
+    name[1] = '0' + i;
+    unlink(name);
+  }
+  printf(stdout, "many creates, followed by unlink; ok\n");
+}
+
+void dirtest(void)
+{
+  printf(stdout, "mkdir test\n");
+
+  if(mkdir("dir0") < 0){
+    printf(stdout, "mkdir failed\n");
+    exit();
+  }
+
+  if(chdir("dir0") < 0){
+    printf(stdout, "chdir dir0 failed\n");
+    exit();
+  }
+
+  if(chdir("..") < 0){
+    printf(stdout, "chdir .. failed\n");
+    exit();
+  }
+
+  if(unlink("dir0") < 0){
+    printf(stdout, "unlink dir0 failed\n");
+    exit();
+  }
+  printf(stdout, "mkdir test ok\n");
+}
+
+void
+exectest(void)
+{
+  printf(stdout, "exec test\n");
+  if(exec("echo", echoargv) < 0){
+    printf(stdout, "exec echo failed\n");
+    exit();
+  }
+}
+
+// simple fork and pipe read/write
+
+void
+pipe1(void)
+{
+  int fds[2], pid;
+  int seq, i, n, cc, total;
+
+  if(pipe(fds) != 0){
+    printf(1, "pipe() failed\n");
+    exit();
+  }
+  pid = fork();
+  seq = 0;
+  if(pid == 0){
+    close(fds[0]);
+    for(n = 0; n < 5; n++){
+      for(i = 0; i < 1033; i++)
+        buf[i] = seq++;
+      if(write(fds[1], buf, 1033) != 1033){
+        printf(1, "pipe1 oops 1\n");
+        exit();
+      }
+    }
+    exit();
+  } else if(pid > 0){
+    close(fds[1]);
+    total = 0;
+    cc = 1;
+    while((n = read(fds[0], buf, cc)) > 0){
+      for(i = 0; i < n; i++){
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+          printf(1, "pipe1 oops 2\n");
+          return;
+        }
+      }
+      total += n;
+      cc = cc * 2;
+      if(cc > sizeof(buf))
+        cc = sizeof(buf);
+    }
+    if(total != 5 * 1033){
+      printf(1, "pipe1 oops 3 total %d\n", total);
+      exit();
+    }
+    close(fds[0]);
+    wait();
+  } else {
+    printf(1, "fork() failed\n");
+    exit();
+  }
+  printf(1, "pipe1 ok\n");
+}
+
+// meant to be run w/ at most two CPUs
+void
+preempt(void)
+{
+  int pid1, pid2, pid3;
+  int pfds[2];
+
+  printf(1, "preempt: ");
+  pid1 = fork();
+  if(pid1 == 0)
+    for(;;)
+      ;
+
+  pid2 = fork();
+  if(pid2 == 0)
+    for(;;)
+      ;
+
+  pipe(pfds);
+  pid3 = fork();
+  if(pid3 == 0){
+    close(pfds[0]);
+    if(write(pfds[1], "x", 1) != 1)
+      printf(1, "preempt write error");
+    close(pfds[1]);
+    for(;;)
+      ;
+  }
+
+  close(pfds[1]);
+  if(read(pfds[0], buf, sizeof(buf)) != 1){
+    printf(1, "preempt read error");
+    return;
+  }
+  close(pfds[0]);
+  printf(1, "kill... ");
+  kill(pid1);
+  kill(pid2);
+  kill(pid3);
+  printf(1, "wait... ");
+  wait();
+  wait();
+  wait();
+  printf(1, "preempt ok\n");
+}
+
+// try to find any races between exit and wait
+void
+exitwait(void)
+{
+  int i, pid;
+
+  for(i = 0; i < 100; i++){
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      return;
+    }
+    if(pid){
+      if(wait() != pid){
+        printf(1, "wait wrong pid\n");
+        return;
+      }
+    } else {
+      exit();
+    }
+  }
+  printf(1, "exitwait ok\n");
+}
+
+void
+mem(void)
+{
+  void *m1, *m2;
+  int pid, ppid;
+
+  printf(1, "mem test\n");
+  ppid = getpid();
+  if((pid = fork()) == 0){
+    m1 = 0;
+    while((m2 = malloc(10001)) != 0){
+      *(char**)m2 = m1;
+      m1 = m2;
+    }
+    while(m1){
+      m2 = *(char**)m1;
+      free(m1);
+      m1 = m2;
+    }
+    m1 = malloc(1024*20);
+    if(m1 == 0){
+      printf(1, "couldn't allocate mem?!!\n");
+      kill(ppid);
+      exit();
+    }
+    free(m1);
+    printf(1, "mem ok\n");
+    exit();
+  } else {
+    wait();
+  }
+}
+
+// More file system tests
+
+// two processes write to the same file descriptor
+// is the offset shared? does inode locking work?
+void
+sharedfd(void)
+{
+  int fd, pid, i, n, nc, np;
+  char buf[10];
+
+  printf(1, "sharedfd test\n");
+
+  unlink("sharedfd");
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(1, "fstests: cannot open sharedfd for writing");
+    return;
+  }
+  pid = fork();
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+  for(i = 0; i < 1000; i++){
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+      printf(1, "fstests: write sharedfd failed\n");
+      break;
+    }
+  }
+  if(pid == 0)
+    exit();
+  else
+    wait();
+  close(fd);
+  fd = open("sharedfd", 0);
+  if(fd < 0){
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+    return;
+  }
+  nc = np = 0;
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    for(i = 0; i < sizeof(buf); i++){
+      if(buf[i] == 'c')
+        nc++;
+      if(buf[i] == 'p')
+        np++;
+    }
+  }
+  close(fd);
+  unlink("sharedfd");
+  if(nc == 10000 && np == 10000){
+    printf(1, "sharedfd ok\n");
+  } else {
+    printf(1, "sharedfd oops %d %d\n", nc, np);
+    exit();
+  }
+}
+
+// four processes write different files at the same
+// time, to test block allocation.
+void
+fourfiles(void)
+{
+  int fd, pid, i, j, n, total, pi;
+  char *names[] = { "f0", "f1", "f2", "f3" };
+  char *fname;
+
+  printf(1, "fourfiles test\n");
+
+  for(pi = 0; pi < 4; pi++){
+    fname = names[pi];
+    unlink(fname);
+
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      exit();
+    }
+
+    if(pid == 0){
+      fd = open(fname, O_CREATE | O_RDWR);
+      if(fd < 0){
+        printf(1, "create failed\n");
+        exit();
+      }
+
+      memset(buf, '0'+pi, 512);
+      for(i = 0; i < 12; i++){
+        if((n = write(fd, buf, 500)) != 500){
+          printf(1, "write failed %d\n", n);
+          exit();
+        }
+      }
+      exit();
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    wait();
+  }
+
+  for(i = 0; i < 2; i++){
+    fname = names[i];
+    fd = open(fname, 0);
+    total = 0;
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+      for(j = 0; j < n; j++){
+        if(buf[j] != '0'+i){
+          printf(1, "wrong char\n");
+          exit();
+        }
+      }
+      total += n;
+    }
+    close(fd);
+    if(total != 12*500){
+      printf(1, "wrong length %d\n", total);
+      exit();
+    }
+    unlink(fname);
+  }
+
+  printf(1, "fourfiles ok\n");
+}
+
+// four processes create and delete different files in same directory
+void
+createdelete(void)
+{
+  enum { N = 20 };
+  int pid, i, fd, pi;
+  char name[32];
+
+  printf(1, "createdelete test\n");
+
+  for(pi = 0; pi < 4; pi++){
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      exit();
+    }
+
+    if(pid == 0){
+      name[0] = 'p' + pi;
+      name[2] = '\0';
+      for(i = 0; i < N; i++){
+        name[1] = '0' + i;
+        fd = open(name, O_CREATE | O_RDWR);
+        if(fd < 0){
+          printf(1, "create failed\n");
+          exit();
+        }
+        close(fd);
+        if(i > 0 && (i % 2 ) == 0){
+          name[1] = '0' + (i / 2);
+          if(unlink(name) < 0){
+            printf(1, "unlink failed\n");
+            exit();
+          }
+        }
+      }
+      exit();
+    }
+  }
+
+  for(pi = 0; pi < 4; pi++){
+    wait();
+  }
+
+  name[0] = name[1] = name[2] = 0;
+  for(i = 0; i < N; i++){
+    for(pi = 0; pi < 4; pi++){
+      name[0] = 'p' + pi;
+      name[1] = '0' + i;
+      fd = open(name, 0);
+      if((i == 0 || i >= N/2) && fd < 0){
+        printf(1, "oops createdelete %s didn't exist\n", name);
+        exit();
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+        printf(1, "oops createdelete %s did exist\n", name);
+        exit();
+      }
+      if(fd >= 0)
+        close(fd);
+    }
+  }
+
+  for(i = 0; i < N; i++){
+    for(pi = 0; pi < 4; pi++){
+      name[0] = 'p' + i;
+      name[1] = '0' + i;
+      unlink(name);
+    }
+  }
+
+  printf(1, "createdelete ok\n");
+}
+
+// can I unlink a file and still read it?
+void
+unlinkread(void)
+{
+  int fd, fd1;
+
+  printf(1, "unlinkread test\n");
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create unlinkread failed\n");
+    exit();
+  }
+  write(fd, "hello", 5);
+  close(fd);
+
+  fd = open("unlinkread", O_RDWR);
+  if(fd < 0){
+    printf(1, "open unlinkread failed\n");
+    exit();
+  }
+  if(unlink("unlinkread") != 0){
+    printf(1, "unlink unlinkread failed\n");
+    exit();
+  }
+
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+  write(fd1, "yyy", 3);
+  close(fd1);
+
+  if(read(fd, buf, sizeof(buf)) != 5){
+    printf(1, "unlinkread read failed");
+    exit();
+  }
+  if(buf[0] != 'h'){
+    printf(1, "unlinkread wrong data\n");
+    exit();
+  }
+  if(write(fd, buf, 10) != 10){
+    printf(1, "unlinkread write failed\n");
+    exit();
+  }
+  close(fd);
+  unlink("unlinkread");
+  printf(1, "unlinkread ok\n");
+}
+
+void
+linktest(void)
+{
+  int fd;
+
+  printf(1, "linktest\n");
+
+  unlink("lf1");
+  unlink("lf2");
+
+  fd = open("lf1", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(1, "create lf1 failed\n");
+    exit();
+  }
+  if(write(fd, "hello", 5) != 5){
+    printf(1, "write lf1 failed\n");
+    exit();
+  }
+  close(fd);
+
+  if(link("lf1", "lf2") < 0){
+    printf(1, "link lf1 lf2 failed\n");
+    exit();
+  }
+  unlink("lf1");
+
+  if(open("lf1", 0) >= 0){
+    printf(1, "unlinked lf1 but it is still there!\n");
+    exit();
+  }
+
+  fd = open("lf2", 0);
+  if(fd < 0){
+    printf(1, "open lf2 failed\n");
+    exit();
+  }
+  if(read(fd, buf, sizeof(buf)) != 5){
+    printf(1, "read lf2 failed\n");
+    exit();
+  }
+  close(fd);
+
+  if(link("lf2", "lf2") >= 0){
+    printf(1, "link lf2 lf2 succeeded! oops\n");
+    exit();
+  }
+
+  unlink("lf2");
+  if(link("lf2", "lf1") >= 0){
+    printf(1, "link non-existant succeeded! oops\n");
+    exit();
+  }
+
+  if(link(".", "lf1") >= 0){
+    printf(1, "link . lf1 succeeded! oops\n");
+    exit();
+  }
+
+  printf(1, "linktest ok\n");
+}
+
+// test concurrent create/link/unlink of the same file
+void
+concreate(void)
+{
+  char file[3];
+  int i, pid, n, fd;
+  char fa[40];
+  struct {
+    ushort inum;
+    char name[14];
+  } de;
+
+  printf(1, "concreate test\n");
+  file[0] = 'C';
+  file[2] = '\0';
+  for(i = 0; i < 40; i++){
+    file[1] = '0' + i;
+    unlink(file);
+    pid = fork();
+    if(pid && (i % 3) == 1){
+      link("C0", file);
+    } else if(pid == 0 && (i % 5) == 1){
+      link("C0", file);
+    } else {
+      fd = open(file, O_CREATE | O_RDWR);
+      if(fd < 0){
+        printf(1, "concreate create %s failed\n", file);
+        exit();
+      }
+      close(fd);
+    }
+    if(pid == 0)
+      exit();
+    else
+      wait();
+  }
+
+  memset(fa, 0, sizeof(fa));
+  fd = open(".", 0);
+  n = 0;
+  while(read(fd, &de, sizeof(de)) > 0){
+    if(de.inum == 0)
+      continue;
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+      i = de.name[1] - '0';
+      if(i < 0 || i >= sizeof(fa)){
+        printf(1, "concreate weird file %s\n", de.name);
+        exit();
+      }
+      if(fa[i]){
+        printf(1, "concreate duplicate file %s\n", de.name);
+        exit();
+      }
+      fa[i] = 1;
+      n++;
+    }
+  }
+  close(fd);
+
+  if(n != 40){
+    printf(1, "concreate not enough files in directory listing\n");
+    exit();
+  }
+
+  for(i = 0; i < 40; i++){
+    file[1] = '0' + i;
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      exit();
+    }
+    if(((i % 3) == 0 && pid == 0) ||
+       ((i % 3) == 1 && pid != 0)){
+      close(open(file, 0));
+      close(open(file, 0));
+      close(open(file, 0));
+      close(open(file, 0));
+    } else {
+      unlink(file);
+      unlink(file);
+      unlink(file);
+      unlink(file);
+    }
+    if(pid == 0)
+      exit();
+    else
+      wait();
+  }
+
+  printf(1, "concreate ok\n");
+}
+
+// another concurrent link/unlink/create test,
+// to look for deadlocks.
+void
+linkunlink()
+{
+  int pid, i;
+
+  printf(1, "linkunlink test\n");
+
+  unlink("x");
+  pid = fork();
+  if(pid < 0){
+    printf(1, "fork failed\n");
+    exit();
+  }
+
+  unsigned int x = (pid ? 1 : 97);
+  for(i = 0; i < 100; i++){
+    x = x * 1103515245 + 12345;
+    if((x % 3) == 0){
+      close(open("x", O_RDWR | O_CREATE));
+    } else if((x % 3) == 1){
+      link("cat", "x");
+    } else {
+      unlink("x");
+    }
+  }
+
+  if(pid)
+    wait();
+  else
+    exit();
+
+  printf(1, "linkunlink ok\n");
+}
+
+// directory that uses indirect blocks
+void
+bigdir(void)
+{
+  int i, fd;
+  char name[10];
+
+  printf(1, "bigdir test\n");
+  unlink("bd");
+
+  fd = open("bd", O_CREATE);
+  if(fd < 0){
+    printf(1, "bigdir create failed\n");
+    exit();
+  }
+  close(fd);
+
+  for(i = 0; i < 500; i++){
+    name[0] = 'x';
+    name[1] = '0' + (i / 64);
+    name[2] = '0' + (i % 64);
+    name[3] = '\0';
+    if(link("bd", name) != 0){
+      printf(1, "bigdir link failed\n");
+      exit();
+    }
+  }
+
+  unlink("bd");
+  for(i = 0; i < 500; i++){
+    name[0] = 'x';
+    name[1] = '0' + (i / 64);
+    name[2] = '0' + (i % 64);
+    name[3] = '\0';
+    if(unlink(name) != 0){
+      printf(1, "bigdir unlink failed");
+      exit();
+    }
+  }
+
+  printf(1, "bigdir ok\n");
+}
+
+void
+subdir(void)
+{
+  int fd, cc;
+
+  printf(1, "subdir test\n");
+
+  unlink("ff");
+  if(mkdir("dd") != 0){
+    printf(1, "subdir mkdir dd failed\n");
+    exit();
+  }
+
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create dd/ff failed\n");
+    exit();
+  }
+  write(fd, "ff", 2);
+  close(fd);
+
+  if(unlink("dd") >= 0){
+    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+    exit();
+  }
+
+  if(mkdir("/dd/dd") != 0){
+    printf(1, "subdir mkdir dd/dd failed\n");
+    exit();
+  }
+
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create dd/dd/ff failed\n");
+    exit();
+  }
+  write(fd, "FF", 2);
+  close(fd);
+
+  fd = open("dd/dd/../ff", 0);
+  if(fd < 0){
+    printf(1, "open dd/dd/../ff failed\n");
+    exit();
+  }
+  cc = read(fd, buf, sizeof(buf));
+  if(cc != 2 || buf[0] != 'f'){
+    printf(1, "dd/dd/../ff wrong content\n");
+    exit();
+  }
+  close(fd);
+
+  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+    exit();
+  }
+
+  if(unlink("dd/dd/ff") != 0){
+    printf(1, "unlink dd/dd/ff failed\n");
+    exit();
+  }
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+    exit();
+  }
+
+  if(chdir("dd") != 0){
+    printf(1, "chdir dd failed\n");
+    exit();
+  }
+  if(chdir("dd/../../dd") != 0){
+    printf(1, "chdir dd/../../dd failed\n");
+    exit();
+  }
+  if(chdir("dd/../../../dd") != 0){
+    printf(1, "chdir dd/../../dd failed\n");
+    exit();
+  }
+  if(chdir("./..") != 0){
+    printf(1, "chdir ./.. failed\n");
+    exit();
+  }
+
+  fd = open("dd/dd/ffff", 0);
+  if(fd < 0){
+    printf(1, "open dd/dd/ffff failed\n");
+    exit();
+  }
+  if(read(fd, buf, sizeof(buf)) != 2){
+    printf(1, "read dd/dd/ffff wrong len\n");
+    exit();
+  }
+  close(fd);
+
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+    exit();
+  }
+
+  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+    printf(1, "create dd/ff/ff succeeded!\n");
+    exit();
+  }
+  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+    printf(1, "create dd/xx/ff succeeded!\n");
+    exit();
+  }
+  if(open("dd", O_CREATE) >= 0){
+    printf(1, "create dd succeeded!\n");
+    exit();
+  }
+  if(open("dd", O_RDWR) >= 0){
+    printf(1, "open dd rdwr succeeded!\n");
+    exit();
+  }
+  if(open("dd", O_WRONLY) >= 0){
+    printf(1, "open dd wronly succeeded!\n");
+    exit();
+  }
+  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+    exit();
+  }
+  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+    exit();
+  }
+  if(link("dd/ff", "dd/dd/ffff") == 0){
+    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+    exit();
+  }
+  if(mkdir("dd/ff/ff") == 0){
+    printf(1, "mkdir dd/ff/ff succeeded!\n");
+    exit();
+  }
+  if(mkdir("dd/xx/ff") == 0){
+    printf(1, "mkdir dd/xx/ff succeeded!\n");
+    exit();
+  }
+  if(mkdir("dd/dd/ffff") == 0){
+    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+    exit();
+  }
+  if(unlink("dd/xx/ff") == 0){
+    printf(1, "unlink dd/xx/ff succeeded!\n");
+    exit();
+  }
+  if(unlink("dd/ff/ff") == 0){
+    printf(1, "unlink dd/ff/ff succeeded!\n");
+    exit();
+  }
+  if(chdir("dd/ff") == 0){
+    printf(1, "chdir dd/ff succeeded!\n");
+    exit();
+  }
+  if(chdir("dd/xx") == 0){
+    printf(1, "chdir dd/xx succeeded!\n");
+    exit();
+  }
+
+  if(unlink("dd/dd/ffff") != 0){
+    printf(1, "unlink dd/dd/ff failed\n");
+    exit();
+  }
+  if(unlink("dd/ff") != 0){
+    printf(1, "unlink dd/ff failed\n");
+    exit();
+  }
+  if(unlink("dd") == 0){
+    printf(1, "unlink non-empty dd succeeded!\n");
+    exit();
+  }
+  if(unlink("dd/dd") < 0){
+    printf(1, "unlink dd/dd failed\n");
+    exit();
+  }
+  if(unlink("dd") < 0){
+    printf(1, "unlink dd failed\n");
+    exit();
+  }
+
+  printf(1, "subdir ok\n");
+}
+
+// test writes that are larger than the log.
+void
+bigwrite(void)
+{
+  int fd, sz;
+
+  printf(1, "bigwrite test\n");
+
+  unlink("bigwrite");
+  for(sz = 499; sz < 12*512; sz += 471){
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+    if(fd < 0){
+      printf(1, "cannot create bigwrite\n");
+      exit();
+    }
+    int i;
+    for(i = 0; i < 2; i++){
+      int cc = write(fd, buf, sz);
+      if(cc != sz){
+        printf(1, "write(%d) ret %d\n", sz, cc);
+        exit();
+      }
+    }
+    close(fd);
+    unlink("bigwrite");
+  }
+
+  printf(1, "bigwrite ok\n");
+}
+
+void
+bigfile(void)
+{
+  int fd, i, total, cc;
+
+  printf(1, "bigfile test\n");
+
+  unlink("bigfile");
+  fd = open("bigfile", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "cannot create bigfile");
+    exit();
+  }
+  for(i = 0; i < 20; i++){
+    memset(buf, i, 600);
+    if(write(fd, buf, 600) != 600){
+      printf(1, "write bigfile failed\n");
+      exit();
+    }
+  }
+  close(fd);
+
+  fd = open("bigfile", 0);
+  if(fd < 0){
+    printf(1, "cannot open bigfile\n");
+    exit();
+  }
+  total = 0;
+  for(i = 0; ; i++){
+    cc = read(fd, buf, 300);
+    if(cc < 0){
+      printf(1, "read bigfile failed\n");
+      exit();
+    }
+    if(cc == 0)
+      break;
+    if(cc != 300){
+      printf(1, "short read bigfile\n");
+      exit();
+    }
+    if(buf[0] != i/2 || buf[299] != i/2){
+      printf(1, "read bigfile wrong data\n");
+      exit();
+    }
+    total += cc;
+  }
+  close(fd);
+  if(total != 20*600){
+    printf(1, "read bigfile wrong total\n");
+    exit();
+  }
+  unlink("bigfile");
+
+  printf(1, "bigfile test ok\n");
+}
+
+void
+fourteen(void)
+{
+  int fd;
+
+  // DIRSIZ is 14.
+  printf(1, "fourteen test\n");
+
+  if(mkdir("12345678901234") != 0){
+    printf(1, "mkdir 12345678901234 failed\n");
+    exit();
+  }
+  if(mkdir("12345678901234/123456789012345") != 0){
+    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+    exit();
+  }
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+  if(fd < 0){
+    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+    exit();
+  }
+  close(fd);
+  fd = open("12345678901234/12345678901234/12345678901234", 0);
+  if(fd < 0){
+    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+    exit();
+  }
+  close(fd);
+
+  if(mkdir("12345678901234/12345678901234") == 0){
+    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+    exit();
+  }
+  if(mkdir("123456789012345/12345678901234") == 0){
+    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+    exit();
+  }
+
+  printf(1, "fourteen ok\n");
+}
+
+void
+rmdot(void)
+{
+  printf(1, "rmdot test\n");
+  if(mkdir("dots") != 0){
+    printf(1, "mkdir dots failed\n");
+    exit();
+  }
+  if(chdir("dots") != 0){
+    printf(1, "chdir dots failed\n");
+    exit();
+  }
+  if(unlink(".") == 0){
+    printf(1, "rm . worked!\n");
+    exit();
+  }
+  if(unlink("..") == 0){
+    printf(1, "rm .. worked!\n");
+    exit();
+  }
+  if(chdir("/") != 0){
+    printf(1, "chdir / failed\n");
+    exit();
+  }
+  if(unlink("dots/.") == 0){
+    printf(1, "unlink dots/. worked!\n");
+    exit();
+  }
+  if(unlink("dots/..") == 0){
+    printf(1, "unlink dots/.. worked!\n");
+    exit();
+  }
+  if(unlink("dots") != 0){
+    printf(1, "unlink dots failed!\n");
+    exit();
+  }
+  printf(1, "rmdot ok\n");
+}
+
+void
+dirfile(void)
+{
+  int fd;
+
+  printf(1, "dir vs file\n");
+
+  fd = open("dirfile", O_CREATE);
+  if(fd < 0){
+    printf(1, "create dirfile failed\n");
+    exit();
+  }
+  close(fd);
+  if(chdir("dirfile") == 0){
+    printf(1, "chdir dirfile succeeded!\n");
+    exit();
+  }
+  fd = open("dirfile/xx", 0);
+  if(fd >= 0){
+    printf(1, "create dirfile/xx succeeded!\n");
+    exit();
+  }
+  fd = open("dirfile/xx", O_CREATE);
+  if(fd >= 0){
+    printf(1, "create dirfile/xx succeeded!\n");
+    exit();
+  }
+  if(mkdir("dirfile/xx") == 0){
+    printf(1, "mkdir dirfile/xx succeeded!\n");
+    exit();
+  }
+  if(unlink("dirfile/xx") == 0){
+    printf(1, "unlink dirfile/xx succeeded!\n");
+    exit();
+  }
+  if(link("README", "dirfile/xx") == 0){
+    printf(1, "link to dirfile/xx succeeded!\n");
+    exit();
+  }
+  if(unlink("dirfile") != 0){
+    printf(1, "unlink dirfile failed!\n");
+    exit();
+  }
+
+  fd = open(".", O_RDWR);
+  if(fd >= 0){
+    printf(1, "open . for writing succeeded!\n");
+    exit();
+  }
+  fd = open(".", 0);
+  if(write(fd, "x", 1) > 0){
+    printf(1, "write . succeeded!\n");
+    exit();
+  }
+  close(fd);
+
+  printf(1, "dir vs file OK\n");
+}
+
+// test that iput() is called at the end of _namei()
+void
+iref(void)
+{
+  int i, fd;
+
+  printf(1, "empty file name\n");
+
+  // the 50 is NINODE
+  for(i = 0; i < 50 + 1; i++){
+    if(mkdir("irefd") != 0){
+      printf(1, "mkdir irefd failed\n");
+      exit();
+    }
+    if(chdir("irefd") != 0){
+      printf(1, "chdir irefd failed\n");
+      exit();
+    }
+
+    mkdir("");
+    link("README", "");
+    fd = open("", O_CREATE);
+    if(fd >= 0)
+      close(fd);
+    fd = open("xx", O_CREATE);
+    if(fd >= 0)
+      close(fd);
+    unlink("xx");
+  }
+
+  chdir("/");
+  printf(1, "empty file name OK\n");
+}
+
+// test that fork fails gracefully
+// the forktest binary also does this, but it runs out of proc entries first.
+// inside the bigger usertests binary, we run out of memory first.
+void
+forktest(void)
+{
+  int n, pid;
+
+  printf(1, "fork test\n");
+
+  for(n=0; n<1000; n++){
+    pid = fork();
+    if(pid < 0)
+      break;
+    if(pid == 0)
+      exit();
+  }
+
+  if(n == 1000){
+    printf(1, "fork claimed to work 1000 times!\n");
+    exit();
+  }
+
+  for(; n > 0; n--){
+    if(wait() < 0){
+      printf(1, "wait stopped early\n");
+      exit();
+    }
+  }
+
+  if(wait() != -1){
+    printf(1, "wait got too many\n");
+    exit();
+  }
+
+  printf(1, "fork test OK\n");
+}
+
+void
+sbrktest(void)
+{
+  int fds[2], pid, pids[10], ppid;
+  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+  uint amt;
+
+  printf(stdout, "sbrk test\n");
+  oldbrk = sbrk(0);
+
+  // can one sbrk() less than a page?
+  a = sbrk(0);
+  int i;
+  for(i = 0; i < 5000; i++){
+    b = sbrk(1);
+    if(b != a){
+      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+      exit();
+    }
+    *b = 1;
+    a = b + 1;
+  }
+  pid = fork();
+  if(pid < 0){
+    printf(stdout, "sbrk test fork failed\n");
+    exit();
+  }
+  c = sbrk(1);
+  c = sbrk(1);
+  if(c != a + 1){
+    printf(stdout, "sbrk test failed post-fork\n");
+    exit();
+  }
+  if(pid == 0)
+    exit();
+  wait();
+
+  // can one grow address space to something big?
+#define BIG (100*1024*1024)
+  a = sbrk(0);
+  amt = (BIG) - (uint)a;
+  p = sbrk(amt);
+  if (p != a) {
+    printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+    exit();
+  }
+  lastaddr = (char*) (BIG-1);
+  *lastaddr = 99;
+
+  // can one de-allocate?
+  a = sbrk(0);
+  c = sbrk(-4096);
+  if(c == (char*)0xffffffff){
+    printf(stdout, "sbrk could not deallocate\n");
+    exit();
+  }
+  c = sbrk(0);
+  if(c != a - 4096){
+    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+    exit();
+  }
+
+  // can one re-allocate that page?
+  a = sbrk(0);
+  c = sbrk(4096);
+  if(c != a || sbrk(0) != a + 4096){
+    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+    exit();
+  }
+  if(*lastaddr == 99){
+    // should be zero
+    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+    exit();
+  }
+
+  a = sbrk(0);
+  c = sbrk(-(sbrk(0) - oldbrk));
+  if(c != a){
+    printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+    exit();
+  }
+
+  // can we read the kernel's memory?
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    ppid = getpid();
+    pid = fork();
+    if(pid < 0){
+      printf(stdout, "fork failed\n");
+      exit();
+    }
+    if(pid == 0){
+      printf(stdout, "oops could read %x = %x\n", a, *a);
+      kill(ppid);
+      exit();
+    }
+    wait();
+  }
+
+  // if we run the system out of memory, does it clean up the last
+  // failed allocation?
+  if(pipe(fds) != 0){
+    printf(1, "pipe() failed\n");
+    exit();
+  }
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    if((pids[i] = fork()) == 0){
+      // allocate a lot of memory
+      sbrk(BIG - (uint)sbrk(0));
+      write(fds[1], "x", 1);
+      // sit around until killed
+      for(;;) sleep(1000);
+    }
+    if(pids[i] != -1)
+      read(fds[0], &scratch, 1);
+  }
+  // if those failed allocations freed up the pages they did allocate,
+  // we'll be able to allocate here
+  c = sbrk(4096);
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    if(pids[i] == -1)
+      continue;
+    kill(pids[i]);
+    wait();
+  }
+  if(c == (char*)0xffffffff){
+    printf(stdout, "failed sbrk leaked memory\n");
+    exit();
+  }
+
+  if(sbrk(0) > oldbrk)
+    sbrk(-(sbrk(0) - oldbrk));
+
+  printf(stdout, "sbrk test OK\n");
+}
+
+void
+validateint(int *p)
+{
+  int res;
+  asm("mov %%esp, %%ebx\n\t"
+      "mov %3, %%esp\n\t"
+      "int %2\n\t"
+      "mov %%ebx, %%esp" :
+      "=a" (res) :
+      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
+      "ebx");
+}
+
+void
+validatetest(void)
+{
+  int hi, pid;
+  uint p;
+
+  printf(stdout, "validate test\n");
+  hi = 1100*1024;
+
+  for(p = 0; p <= (uint)hi; p += 4096){
+    if((pid = fork()) == 0){
+      // try to crash the kernel by passing in a badly placed integer
+      validateint((int*)p);
+      exit();
+    }
+    sleep(0);
+    sleep(0);
+    kill(pid);
+    wait();
+
+    // try to crash the kernel by passing in a bad string pointer
+    if(link("nosuchfile", (char*)p) != -1){
+      printf(stdout, "link should not succeed\n");
+      exit();
+    }
+  }
+
+  printf(stdout, "validate ok\n");
+}
+
+// does unintialized data start out zero?
+char uninit[10000];
+void
+bsstest(void)
+{
+  int i;
+
+  printf(stdout, "bss test\n");
+  for(i = 0; i < sizeof(uninit); i++){
+    if(uninit[i] != '\0'){
+      printf(stdout, "bss test failed\n");
+      exit();
+    }
+  }
+  printf(stdout, "bss test ok\n");
+}
+
+// does exec return an error if the arguments
+// are larger than a page? or does it write
+// below the stack and wreck the instructions/data?
+void
+bigargtest(void)
+{
+  int pid, fd;
+
+  unlink("bigarg-ok");
+  pid = fork();
+  if(pid == 0){
+    static char *args[MAXARG];
+    int i;
+    for(i = 0; i < MAXARG-1; i++)
+      args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
+    args[MAXARG-1] = 0;
+    printf(stdout, "bigarg test\n");
+    exec("echo", args);
+    printf(stdout, "bigarg test ok\n");
+    fd = open("bigarg-ok", O_CREATE);
+    close(fd);
+    exit();
+  } else if(pid < 0){
+    printf(stdout, "bigargtest: fork failed\n");
+    exit();
+  }
+  wait();
+  fd = open("bigarg-ok", 0);
+  if(fd < 0){
+    printf(stdout, "bigarg test failed!\n");
+    exit();
+  }
+  close(fd);
+  unlink("bigarg-ok");
+}
+
+// what happens when the file system runs out of blocks?
+// answer: balloc panics, so this test is not useful.
+void
+fsfull()
+{
+  int nfiles;
+  int fsblocks = 0;
+
+  printf(1, "fsfull test\n");
+
+  for(nfiles = 0; ; nfiles++){
+    char name[64];
+    name[0] = 'f';
+    name[1] = '0' + nfiles / 1000;
+    name[2] = '0' + (nfiles % 1000) / 100;
+    name[3] = '0' + (nfiles % 100) / 10;
+    name[4] = '0' + (nfiles % 10);
+    name[5] = '\0';
+    printf(1, "writing %s\n", name);
+    int fd = open(name, O_CREATE|O_RDWR);
+    if(fd < 0){
+      printf(1, "open %s failed\n", name);
+      break;
+    }
+    int total = 0;
+    while(1){
+      int cc = write(fd, buf, 512);
+      if(cc < 512)
+        break;
+      total += cc;
+      fsblocks++;
+    }
+    printf(1, "wrote %d bytes\n", total);
+    close(fd);
+    if(total == 0)
+      break;
+  }
+
+  while(nfiles >= 0){
+    char name[64];
+    name[0] = 'f';
+    name[1] = '0' + nfiles / 1000;
+    name[2] = '0' + (nfiles % 1000) / 100;
+    name[3] = '0' + (nfiles % 100) / 10;
+    name[4] = '0' + (nfiles % 10);
+    name[5] = '\0';
+    unlink(name);
+    nfiles--;
+  }
+
+  printf(1, "fsfull test finished\n");
+}
+
+void
+uio()
+{
+  #define RTC_ADDR 0x70
+  #define RTC_DATA 0x71
+
+  ushort port = 0;
+  uchar val = 0;
+  int pid;
+
+  printf(1, "uio test\n");
+  pid = fork();
+  if(pid == 0){
+    port = RTC_ADDR;
+    val = 0x09;  /* year */
+    /* http://wiki.osdev.org/Inline_Assembly/Examples */
+    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+    port = RTC_DATA;
+    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+    printf(1, "uio: uio succeeded; test FAILED\n");
+    exit();
+  } else if(pid < 0){
+    printf (1, "fork failed\n");
+    exit();
+  }
+  wait();
+  printf(1, "uio test done\n");
+}
+
+void argptest()
+{
+  int fd;
+  fd = open("init", O_RDONLY);
+  if (fd < 0) {
+    printf(2, "open failed\n");
+    exit();
+  }
+  read(fd, sbrk(0) - 1, -1);
+  close(fd);
+  printf(1, "arg test passed\n");
+}
+
+unsigned long randstate = 1;
+unsigned int
+rand()
+{
+  randstate = randstate * 1664525 + 1013904223;
+  return randstate;
+}
+
+int
+main(int argc, char *argv[])
+{
+  printf(1, "usertests starting\n");
+
+  if(open("usertests.ran", 0) >= 0){
+    printf(1, "already ran user tests -- rebuild fs.img\n");
+    exit();
+  }
+  close(open("usertests.ran", O_CREATE));
+
+  argptest();
+  createdelete();
+  linkunlink();
+  concreate();
+  fourfiles();
+  sharedfd();
+
+  bigargtest();
+  bigwrite();
+  bigargtest();
+  bsstest();
+  sbrktest();
+  validatetest();
+
+  opentest();
+  writetest();
+  writetest1();
+  createtest();
+
+  openiputtest();
+  exitiputtest();
+  iputtest();
+
+  mem();
+  pipe1();
+  preempt();
+  exitwait();
+
+  rmdot();
+  fourteen();
+  bigfile();
+  subdir();
+  linktest();
+  unlinkread();
+  dirfile();
+  iref();
+  forktest();
+  bigdir(); // slow
+
+  uio();
+
+  exectest();
+
+  exit();
+}
diff -ruN xv6-public/xv6-public/usertests.d xv6-public_new/xv6-public/usertests.d
--- xv6-public/xv6-public/usertests.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/usertests.d	2021-09-30 23:15:14.000000000 +0530
@@ -0,0 +1,2 @@
+usertests.o: usertests.c /usr/include/stdc-predef.h param.h types.h \
+ stat.h user.h fs.h fcntl.h syscall.h traps.h memlayout.h
Binary files xv6-public/xv6-public/usertests.o and xv6-public_new/xv6-public/usertests.o differ
diff -ruN xv6-public/xv6-public/usertests.sym xv6-public_new/xv6-public/usertests.sym
--- xv6-public/xv6-public/usertests.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/usertests.sym	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,111 @@
+00000000 .text
+0000461c .rodata
+00005e50 .eh_frame
+0000655c .data
+000065a0 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 .debug_ranges
+00000000 usertests.c
+000065a0 args.1462
+00000000 ulib.c
+00003e34 stosb
+00000000 printf.c
+00004177 putc
+0000419e printint
+00006578 digits.1098
+00000000 umalloc.c
+00006620 base
+00006628 freep
+000044cf morecore
+00003e5a strcpy
+00000d39 exitwait
+0000415f yield
+0000416f set_prio
+00004253 printf
+00006570 stdout
+000037d8 bigargtest
+00004066 memmove
+000001f8 openiputtest
+000040f7 mknod
+00003f51 gets
+0000412f getpid
+000009e5 pipe1
+00002f5d iref
+00004533 malloc
+0000413f sleep
+000000f5 exitiputtest
+00003918 fsfull
+00004167 wait2
+00001e59 bigdir
+0000309b forktest
+000005d2 writetest1
+0000271a bigwrite
+00000eaa sharedfd
+00006574 randstate
+000040bf pipe
+00006640 uninit
+00002d21 dirfile
+000040cf write
+0000375e bsstest
+0000655c echoargv
+00004107 fstat
+000040df kill
+0000367c validatetest
+00002b98 rmdot
+0000411f chdir
+0000098e exectest
+000040e7 exec
+000040b7 wait
+00003ce8 rand
+000040c7 read
+00000bd2 preempt
+000040ff unlink
+00003c68 argptest
+00000db5 mem
+000040a7 fork
+00004137 sbrk
+00004147 uptime
+00006589 __bss_start
+00003efc memset
+000007d2 createtest
+00003d0b main
+000012e6 createdelete
+00003e8e strcmp
+000003be writetest
+00004127 dup
+00003169 sbrktest
+0000030b opentest
+00001fd2 subdir
+00003bc3 uio
+00001722 linktest
+00008d60 buf
+00000899 dirtest
+00000000 iputtest
+00003fc4 stat
+0000281c bigfile
+00006589 _edata
+0000ad64 _end
+0000155c unlinkread
+0000410f link
+000040af exit
+00004015 atoi
+00001d1c linkunlink
+0000414f draw
+0000ad60 name
+00003ed1 strlen
+000040ef open
+00003f1a strchr
+00001968 concreate
+00004157 cps
+00002a38 fourteen
+00003655 validateint
+00001091 fourfiles
+00004117 mkdir
+000040d7 close
+000043e9 free
diff -ruN xv6-public/xv6-public/usys.S xv6-public_new/xv6-public/usys.S
--- xv6-public/xv6-public/usys.S	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/usys.S	2021-09-30 17:22:36.000000000 +0530
@@ -0,0 +1,36 @@
+#include "syscall.h"
+#include "traps.h"
+
+#define SYSCALL(name) \
+  .globl name; \
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+SYSCALL(exit)
+SYSCALL(wait)
+SYSCALL(pipe)
+SYSCALL(read)
+SYSCALL(write)
+SYSCALL(close)
+SYSCALL(kill)
+SYSCALL(exec)
+SYSCALL(open)
+SYSCALL(mknod)
+SYSCALL(unlink)
+SYSCALL(fstat)
+SYSCALL(link)
+SYSCALL(mkdir)
+SYSCALL(chdir)
+SYSCALL(dup)
+SYSCALL(getpid)
+SYSCALL(sbrk)
+SYSCALL(sleep)
+SYSCALL(uptime)
+SYSCALL(draw)
+SYSCALL(cps)
+SYSCALL(yield)
+SYSCALL(wait2)
+SYSCALL(set_prio)
Binary files xv6-public/xv6-public/usys.o and xv6-public_new/xv6-public/usys.o differ
diff -ruN xv6-public/xv6-public/vectors.S xv6-public_new/xv6-public/vectors.S
--- xv6-public/xv6-public/vectors.S	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/vectors.S	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,1537 @@
+# generated by vectors.pl - do not edit
+# handlers
+.globl alltraps
+.globl vector0
+vector0:
+  pushl $0
+  pushl $0
+  jmp alltraps
+.globl vector1
+vector1:
+  pushl $0
+  pushl $1
+  jmp alltraps
+.globl vector2
+vector2:
+  pushl $0
+  pushl $2
+  jmp alltraps
+.globl vector3
+vector3:
+  pushl $0
+  pushl $3
+  jmp alltraps
+.globl vector4
+vector4:
+  pushl $0
+  pushl $4
+  jmp alltraps
+.globl vector5
+vector5:
+  pushl $0
+  pushl $5
+  jmp alltraps
+.globl vector6
+vector6:
+  pushl $0
+  pushl $6
+  jmp alltraps
+.globl vector7
+vector7:
+  pushl $0
+  pushl $7
+  jmp alltraps
+.globl vector8
+vector8:
+  pushl $8
+  jmp alltraps
+.globl vector9
+vector9:
+  pushl $0
+  pushl $9
+  jmp alltraps
+.globl vector10
+vector10:
+  pushl $10
+  jmp alltraps
+.globl vector11
+vector11:
+  pushl $11
+  jmp alltraps
+.globl vector12
+vector12:
+  pushl $12
+  jmp alltraps
+.globl vector13
+vector13:
+  pushl $13
+  jmp alltraps
+.globl vector14
+vector14:
+  pushl $14
+  jmp alltraps
+.globl vector15
+vector15:
+  pushl $0
+  pushl $15
+  jmp alltraps
+.globl vector16
+vector16:
+  pushl $0
+  pushl $16
+  jmp alltraps
+.globl vector17
+vector17:
+  pushl $17
+  jmp alltraps
+.globl vector18
+vector18:
+  pushl $0
+  pushl $18
+  jmp alltraps
+.globl vector19
+vector19:
+  pushl $0
+  pushl $19
+  jmp alltraps
+.globl vector20
+vector20:
+  pushl $0
+  pushl $20
+  jmp alltraps
+.globl vector21
+vector21:
+  pushl $0
+  pushl $21
+  jmp alltraps
+.globl vector22
+vector22:
+  pushl $0
+  pushl $22
+  jmp alltraps
+.globl vector23
+vector23:
+  pushl $0
+  pushl $23
+  jmp alltraps
+.globl vector24
+vector24:
+  pushl $0
+  pushl $24
+  jmp alltraps
+.globl vector25
+vector25:
+  pushl $0
+  pushl $25
+  jmp alltraps
+.globl vector26
+vector26:
+  pushl $0
+  pushl $26
+  jmp alltraps
+.globl vector27
+vector27:
+  pushl $0
+  pushl $27
+  jmp alltraps
+.globl vector28
+vector28:
+  pushl $0
+  pushl $28
+  jmp alltraps
+.globl vector29
+vector29:
+  pushl $0
+  pushl $29
+  jmp alltraps
+.globl vector30
+vector30:
+  pushl $0
+  pushl $30
+  jmp alltraps
+.globl vector31
+vector31:
+  pushl $0
+  pushl $31
+  jmp alltraps
+.globl vector32
+vector32:
+  pushl $0
+  pushl $32
+  jmp alltraps
+.globl vector33
+vector33:
+  pushl $0
+  pushl $33
+  jmp alltraps
+.globl vector34
+vector34:
+  pushl $0
+  pushl $34
+  jmp alltraps
+.globl vector35
+vector35:
+  pushl $0
+  pushl $35
+  jmp alltraps
+.globl vector36
+vector36:
+  pushl $0
+  pushl $36
+  jmp alltraps
+.globl vector37
+vector37:
+  pushl $0
+  pushl $37
+  jmp alltraps
+.globl vector38
+vector38:
+  pushl $0
+  pushl $38
+  jmp alltraps
+.globl vector39
+vector39:
+  pushl $0
+  pushl $39
+  jmp alltraps
+.globl vector40
+vector40:
+  pushl $0
+  pushl $40
+  jmp alltraps
+.globl vector41
+vector41:
+  pushl $0
+  pushl $41
+  jmp alltraps
+.globl vector42
+vector42:
+  pushl $0
+  pushl $42
+  jmp alltraps
+.globl vector43
+vector43:
+  pushl $0
+  pushl $43
+  jmp alltraps
+.globl vector44
+vector44:
+  pushl $0
+  pushl $44
+  jmp alltraps
+.globl vector45
+vector45:
+  pushl $0
+  pushl $45
+  jmp alltraps
+.globl vector46
+vector46:
+  pushl $0
+  pushl $46
+  jmp alltraps
+.globl vector47
+vector47:
+  pushl $0
+  pushl $47
+  jmp alltraps
+.globl vector48
+vector48:
+  pushl $0
+  pushl $48
+  jmp alltraps
+.globl vector49
+vector49:
+  pushl $0
+  pushl $49
+  jmp alltraps
+.globl vector50
+vector50:
+  pushl $0
+  pushl $50
+  jmp alltraps
+.globl vector51
+vector51:
+  pushl $0
+  pushl $51
+  jmp alltraps
+.globl vector52
+vector52:
+  pushl $0
+  pushl $52
+  jmp alltraps
+.globl vector53
+vector53:
+  pushl $0
+  pushl $53
+  jmp alltraps
+.globl vector54
+vector54:
+  pushl $0
+  pushl $54
+  jmp alltraps
+.globl vector55
+vector55:
+  pushl $0
+  pushl $55
+  jmp alltraps
+.globl vector56
+vector56:
+  pushl $0
+  pushl $56
+  jmp alltraps
+.globl vector57
+vector57:
+  pushl $0
+  pushl $57
+  jmp alltraps
+.globl vector58
+vector58:
+  pushl $0
+  pushl $58
+  jmp alltraps
+.globl vector59
+vector59:
+  pushl $0
+  pushl $59
+  jmp alltraps
+.globl vector60
+vector60:
+  pushl $0
+  pushl $60
+  jmp alltraps
+.globl vector61
+vector61:
+  pushl $0
+  pushl $61
+  jmp alltraps
+.globl vector62
+vector62:
+  pushl $0
+  pushl $62
+  jmp alltraps
+.globl vector63
+vector63:
+  pushl $0
+  pushl $63
+  jmp alltraps
+.globl vector64
+vector64:
+  pushl $0
+  pushl $64
+  jmp alltraps
+.globl vector65
+vector65:
+  pushl $0
+  pushl $65
+  jmp alltraps
+.globl vector66
+vector66:
+  pushl $0
+  pushl $66
+  jmp alltraps
+.globl vector67
+vector67:
+  pushl $0
+  pushl $67
+  jmp alltraps
+.globl vector68
+vector68:
+  pushl $0
+  pushl $68
+  jmp alltraps
+.globl vector69
+vector69:
+  pushl $0
+  pushl $69
+  jmp alltraps
+.globl vector70
+vector70:
+  pushl $0
+  pushl $70
+  jmp alltraps
+.globl vector71
+vector71:
+  pushl $0
+  pushl $71
+  jmp alltraps
+.globl vector72
+vector72:
+  pushl $0
+  pushl $72
+  jmp alltraps
+.globl vector73
+vector73:
+  pushl $0
+  pushl $73
+  jmp alltraps
+.globl vector74
+vector74:
+  pushl $0
+  pushl $74
+  jmp alltraps
+.globl vector75
+vector75:
+  pushl $0
+  pushl $75
+  jmp alltraps
+.globl vector76
+vector76:
+  pushl $0
+  pushl $76
+  jmp alltraps
+.globl vector77
+vector77:
+  pushl $0
+  pushl $77
+  jmp alltraps
+.globl vector78
+vector78:
+  pushl $0
+  pushl $78
+  jmp alltraps
+.globl vector79
+vector79:
+  pushl $0
+  pushl $79
+  jmp alltraps
+.globl vector80
+vector80:
+  pushl $0
+  pushl $80
+  jmp alltraps
+.globl vector81
+vector81:
+  pushl $0
+  pushl $81
+  jmp alltraps
+.globl vector82
+vector82:
+  pushl $0
+  pushl $82
+  jmp alltraps
+.globl vector83
+vector83:
+  pushl $0
+  pushl $83
+  jmp alltraps
+.globl vector84
+vector84:
+  pushl $0
+  pushl $84
+  jmp alltraps
+.globl vector85
+vector85:
+  pushl $0
+  pushl $85
+  jmp alltraps
+.globl vector86
+vector86:
+  pushl $0
+  pushl $86
+  jmp alltraps
+.globl vector87
+vector87:
+  pushl $0
+  pushl $87
+  jmp alltraps
+.globl vector88
+vector88:
+  pushl $0
+  pushl $88
+  jmp alltraps
+.globl vector89
+vector89:
+  pushl $0
+  pushl $89
+  jmp alltraps
+.globl vector90
+vector90:
+  pushl $0
+  pushl $90
+  jmp alltraps
+.globl vector91
+vector91:
+  pushl $0
+  pushl $91
+  jmp alltraps
+.globl vector92
+vector92:
+  pushl $0
+  pushl $92
+  jmp alltraps
+.globl vector93
+vector93:
+  pushl $0
+  pushl $93
+  jmp alltraps
+.globl vector94
+vector94:
+  pushl $0
+  pushl $94
+  jmp alltraps
+.globl vector95
+vector95:
+  pushl $0
+  pushl $95
+  jmp alltraps
+.globl vector96
+vector96:
+  pushl $0
+  pushl $96
+  jmp alltraps
+.globl vector97
+vector97:
+  pushl $0
+  pushl $97
+  jmp alltraps
+.globl vector98
+vector98:
+  pushl $0
+  pushl $98
+  jmp alltraps
+.globl vector99
+vector99:
+  pushl $0
+  pushl $99
+  jmp alltraps
+.globl vector100
+vector100:
+  pushl $0
+  pushl $100
+  jmp alltraps
+.globl vector101
+vector101:
+  pushl $0
+  pushl $101
+  jmp alltraps
+.globl vector102
+vector102:
+  pushl $0
+  pushl $102
+  jmp alltraps
+.globl vector103
+vector103:
+  pushl $0
+  pushl $103
+  jmp alltraps
+.globl vector104
+vector104:
+  pushl $0
+  pushl $104
+  jmp alltraps
+.globl vector105
+vector105:
+  pushl $0
+  pushl $105
+  jmp alltraps
+.globl vector106
+vector106:
+  pushl $0
+  pushl $106
+  jmp alltraps
+.globl vector107
+vector107:
+  pushl $0
+  pushl $107
+  jmp alltraps
+.globl vector108
+vector108:
+  pushl $0
+  pushl $108
+  jmp alltraps
+.globl vector109
+vector109:
+  pushl $0
+  pushl $109
+  jmp alltraps
+.globl vector110
+vector110:
+  pushl $0
+  pushl $110
+  jmp alltraps
+.globl vector111
+vector111:
+  pushl $0
+  pushl $111
+  jmp alltraps
+.globl vector112
+vector112:
+  pushl $0
+  pushl $112
+  jmp alltraps
+.globl vector113
+vector113:
+  pushl $0
+  pushl $113
+  jmp alltraps
+.globl vector114
+vector114:
+  pushl $0
+  pushl $114
+  jmp alltraps
+.globl vector115
+vector115:
+  pushl $0
+  pushl $115
+  jmp alltraps
+.globl vector116
+vector116:
+  pushl $0
+  pushl $116
+  jmp alltraps
+.globl vector117
+vector117:
+  pushl $0
+  pushl $117
+  jmp alltraps
+.globl vector118
+vector118:
+  pushl $0
+  pushl $118
+  jmp alltraps
+.globl vector119
+vector119:
+  pushl $0
+  pushl $119
+  jmp alltraps
+.globl vector120
+vector120:
+  pushl $0
+  pushl $120
+  jmp alltraps
+.globl vector121
+vector121:
+  pushl $0
+  pushl $121
+  jmp alltraps
+.globl vector122
+vector122:
+  pushl $0
+  pushl $122
+  jmp alltraps
+.globl vector123
+vector123:
+  pushl $0
+  pushl $123
+  jmp alltraps
+.globl vector124
+vector124:
+  pushl $0
+  pushl $124
+  jmp alltraps
+.globl vector125
+vector125:
+  pushl $0
+  pushl $125
+  jmp alltraps
+.globl vector126
+vector126:
+  pushl $0
+  pushl $126
+  jmp alltraps
+.globl vector127
+vector127:
+  pushl $0
+  pushl $127
+  jmp alltraps
+.globl vector128
+vector128:
+  pushl $0
+  pushl $128
+  jmp alltraps
+.globl vector129
+vector129:
+  pushl $0
+  pushl $129
+  jmp alltraps
+.globl vector130
+vector130:
+  pushl $0
+  pushl $130
+  jmp alltraps
+.globl vector131
+vector131:
+  pushl $0
+  pushl $131
+  jmp alltraps
+.globl vector132
+vector132:
+  pushl $0
+  pushl $132
+  jmp alltraps
+.globl vector133
+vector133:
+  pushl $0
+  pushl $133
+  jmp alltraps
+.globl vector134
+vector134:
+  pushl $0
+  pushl $134
+  jmp alltraps
+.globl vector135
+vector135:
+  pushl $0
+  pushl $135
+  jmp alltraps
+.globl vector136
+vector136:
+  pushl $0
+  pushl $136
+  jmp alltraps
+.globl vector137
+vector137:
+  pushl $0
+  pushl $137
+  jmp alltraps
+.globl vector138
+vector138:
+  pushl $0
+  pushl $138
+  jmp alltraps
+.globl vector139
+vector139:
+  pushl $0
+  pushl $139
+  jmp alltraps
+.globl vector140
+vector140:
+  pushl $0
+  pushl $140
+  jmp alltraps
+.globl vector141
+vector141:
+  pushl $0
+  pushl $141
+  jmp alltraps
+.globl vector142
+vector142:
+  pushl $0
+  pushl $142
+  jmp alltraps
+.globl vector143
+vector143:
+  pushl $0
+  pushl $143
+  jmp alltraps
+.globl vector144
+vector144:
+  pushl $0
+  pushl $144
+  jmp alltraps
+.globl vector145
+vector145:
+  pushl $0
+  pushl $145
+  jmp alltraps
+.globl vector146
+vector146:
+  pushl $0
+  pushl $146
+  jmp alltraps
+.globl vector147
+vector147:
+  pushl $0
+  pushl $147
+  jmp alltraps
+.globl vector148
+vector148:
+  pushl $0
+  pushl $148
+  jmp alltraps
+.globl vector149
+vector149:
+  pushl $0
+  pushl $149
+  jmp alltraps
+.globl vector150
+vector150:
+  pushl $0
+  pushl $150
+  jmp alltraps
+.globl vector151
+vector151:
+  pushl $0
+  pushl $151
+  jmp alltraps
+.globl vector152
+vector152:
+  pushl $0
+  pushl $152
+  jmp alltraps
+.globl vector153
+vector153:
+  pushl $0
+  pushl $153
+  jmp alltraps
+.globl vector154
+vector154:
+  pushl $0
+  pushl $154
+  jmp alltraps
+.globl vector155
+vector155:
+  pushl $0
+  pushl $155
+  jmp alltraps
+.globl vector156
+vector156:
+  pushl $0
+  pushl $156
+  jmp alltraps
+.globl vector157
+vector157:
+  pushl $0
+  pushl $157
+  jmp alltraps
+.globl vector158
+vector158:
+  pushl $0
+  pushl $158
+  jmp alltraps
+.globl vector159
+vector159:
+  pushl $0
+  pushl $159
+  jmp alltraps
+.globl vector160
+vector160:
+  pushl $0
+  pushl $160
+  jmp alltraps
+.globl vector161
+vector161:
+  pushl $0
+  pushl $161
+  jmp alltraps
+.globl vector162
+vector162:
+  pushl $0
+  pushl $162
+  jmp alltraps
+.globl vector163
+vector163:
+  pushl $0
+  pushl $163
+  jmp alltraps
+.globl vector164
+vector164:
+  pushl $0
+  pushl $164
+  jmp alltraps
+.globl vector165
+vector165:
+  pushl $0
+  pushl $165
+  jmp alltraps
+.globl vector166
+vector166:
+  pushl $0
+  pushl $166
+  jmp alltraps
+.globl vector167
+vector167:
+  pushl $0
+  pushl $167
+  jmp alltraps
+.globl vector168
+vector168:
+  pushl $0
+  pushl $168
+  jmp alltraps
+.globl vector169
+vector169:
+  pushl $0
+  pushl $169
+  jmp alltraps
+.globl vector170
+vector170:
+  pushl $0
+  pushl $170
+  jmp alltraps
+.globl vector171
+vector171:
+  pushl $0
+  pushl $171
+  jmp alltraps
+.globl vector172
+vector172:
+  pushl $0
+  pushl $172
+  jmp alltraps
+.globl vector173
+vector173:
+  pushl $0
+  pushl $173
+  jmp alltraps
+.globl vector174
+vector174:
+  pushl $0
+  pushl $174
+  jmp alltraps
+.globl vector175
+vector175:
+  pushl $0
+  pushl $175
+  jmp alltraps
+.globl vector176
+vector176:
+  pushl $0
+  pushl $176
+  jmp alltraps
+.globl vector177
+vector177:
+  pushl $0
+  pushl $177
+  jmp alltraps
+.globl vector178
+vector178:
+  pushl $0
+  pushl $178
+  jmp alltraps
+.globl vector179
+vector179:
+  pushl $0
+  pushl $179
+  jmp alltraps
+.globl vector180
+vector180:
+  pushl $0
+  pushl $180
+  jmp alltraps
+.globl vector181
+vector181:
+  pushl $0
+  pushl $181
+  jmp alltraps
+.globl vector182
+vector182:
+  pushl $0
+  pushl $182
+  jmp alltraps
+.globl vector183
+vector183:
+  pushl $0
+  pushl $183
+  jmp alltraps
+.globl vector184
+vector184:
+  pushl $0
+  pushl $184
+  jmp alltraps
+.globl vector185
+vector185:
+  pushl $0
+  pushl $185
+  jmp alltraps
+.globl vector186
+vector186:
+  pushl $0
+  pushl $186
+  jmp alltraps
+.globl vector187
+vector187:
+  pushl $0
+  pushl $187
+  jmp alltraps
+.globl vector188
+vector188:
+  pushl $0
+  pushl $188
+  jmp alltraps
+.globl vector189
+vector189:
+  pushl $0
+  pushl $189
+  jmp alltraps
+.globl vector190
+vector190:
+  pushl $0
+  pushl $190
+  jmp alltraps
+.globl vector191
+vector191:
+  pushl $0
+  pushl $191
+  jmp alltraps
+.globl vector192
+vector192:
+  pushl $0
+  pushl $192
+  jmp alltraps
+.globl vector193
+vector193:
+  pushl $0
+  pushl $193
+  jmp alltraps
+.globl vector194
+vector194:
+  pushl $0
+  pushl $194
+  jmp alltraps
+.globl vector195
+vector195:
+  pushl $0
+  pushl $195
+  jmp alltraps
+.globl vector196
+vector196:
+  pushl $0
+  pushl $196
+  jmp alltraps
+.globl vector197
+vector197:
+  pushl $0
+  pushl $197
+  jmp alltraps
+.globl vector198
+vector198:
+  pushl $0
+  pushl $198
+  jmp alltraps
+.globl vector199
+vector199:
+  pushl $0
+  pushl $199
+  jmp alltraps
+.globl vector200
+vector200:
+  pushl $0
+  pushl $200
+  jmp alltraps
+.globl vector201
+vector201:
+  pushl $0
+  pushl $201
+  jmp alltraps
+.globl vector202
+vector202:
+  pushl $0
+  pushl $202
+  jmp alltraps
+.globl vector203
+vector203:
+  pushl $0
+  pushl $203
+  jmp alltraps
+.globl vector204
+vector204:
+  pushl $0
+  pushl $204
+  jmp alltraps
+.globl vector205
+vector205:
+  pushl $0
+  pushl $205
+  jmp alltraps
+.globl vector206
+vector206:
+  pushl $0
+  pushl $206
+  jmp alltraps
+.globl vector207
+vector207:
+  pushl $0
+  pushl $207
+  jmp alltraps
+.globl vector208
+vector208:
+  pushl $0
+  pushl $208
+  jmp alltraps
+.globl vector209
+vector209:
+  pushl $0
+  pushl $209
+  jmp alltraps
+.globl vector210
+vector210:
+  pushl $0
+  pushl $210
+  jmp alltraps
+.globl vector211
+vector211:
+  pushl $0
+  pushl $211
+  jmp alltraps
+.globl vector212
+vector212:
+  pushl $0
+  pushl $212
+  jmp alltraps
+.globl vector213
+vector213:
+  pushl $0
+  pushl $213
+  jmp alltraps
+.globl vector214
+vector214:
+  pushl $0
+  pushl $214
+  jmp alltraps
+.globl vector215
+vector215:
+  pushl $0
+  pushl $215
+  jmp alltraps
+.globl vector216
+vector216:
+  pushl $0
+  pushl $216
+  jmp alltraps
+.globl vector217
+vector217:
+  pushl $0
+  pushl $217
+  jmp alltraps
+.globl vector218
+vector218:
+  pushl $0
+  pushl $218
+  jmp alltraps
+.globl vector219
+vector219:
+  pushl $0
+  pushl $219
+  jmp alltraps
+.globl vector220
+vector220:
+  pushl $0
+  pushl $220
+  jmp alltraps
+.globl vector221
+vector221:
+  pushl $0
+  pushl $221
+  jmp alltraps
+.globl vector222
+vector222:
+  pushl $0
+  pushl $222
+  jmp alltraps
+.globl vector223
+vector223:
+  pushl $0
+  pushl $223
+  jmp alltraps
+.globl vector224
+vector224:
+  pushl $0
+  pushl $224
+  jmp alltraps
+.globl vector225
+vector225:
+  pushl $0
+  pushl $225
+  jmp alltraps
+.globl vector226
+vector226:
+  pushl $0
+  pushl $226
+  jmp alltraps
+.globl vector227
+vector227:
+  pushl $0
+  pushl $227
+  jmp alltraps
+.globl vector228
+vector228:
+  pushl $0
+  pushl $228
+  jmp alltraps
+.globl vector229
+vector229:
+  pushl $0
+  pushl $229
+  jmp alltraps
+.globl vector230
+vector230:
+  pushl $0
+  pushl $230
+  jmp alltraps
+.globl vector231
+vector231:
+  pushl $0
+  pushl $231
+  jmp alltraps
+.globl vector232
+vector232:
+  pushl $0
+  pushl $232
+  jmp alltraps
+.globl vector233
+vector233:
+  pushl $0
+  pushl $233
+  jmp alltraps
+.globl vector234
+vector234:
+  pushl $0
+  pushl $234
+  jmp alltraps
+.globl vector235
+vector235:
+  pushl $0
+  pushl $235
+  jmp alltraps
+.globl vector236
+vector236:
+  pushl $0
+  pushl $236
+  jmp alltraps
+.globl vector237
+vector237:
+  pushl $0
+  pushl $237
+  jmp alltraps
+.globl vector238
+vector238:
+  pushl $0
+  pushl $238
+  jmp alltraps
+.globl vector239
+vector239:
+  pushl $0
+  pushl $239
+  jmp alltraps
+.globl vector240
+vector240:
+  pushl $0
+  pushl $240
+  jmp alltraps
+.globl vector241
+vector241:
+  pushl $0
+  pushl $241
+  jmp alltraps
+.globl vector242
+vector242:
+  pushl $0
+  pushl $242
+  jmp alltraps
+.globl vector243
+vector243:
+  pushl $0
+  pushl $243
+  jmp alltraps
+.globl vector244
+vector244:
+  pushl $0
+  pushl $244
+  jmp alltraps
+.globl vector245
+vector245:
+  pushl $0
+  pushl $245
+  jmp alltraps
+.globl vector246
+vector246:
+  pushl $0
+  pushl $246
+  jmp alltraps
+.globl vector247
+vector247:
+  pushl $0
+  pushl $247
+  jmp alltraps
+.globl vector248
+vector248:
+  pushl $0
+  pushl $248
+  jmp alltraps
+.globl vector249
+vector249:
+  pushl $0
+  pushl $249
+  jmp alltraps
+.globl vector250
+vector250:
+  pushl $0
+  pushl $250
+  jmp alltraps
+.globl vector251
+vector251:
+  pushl $0
+  pushl $251
+  jmp alltraps
+.globl vector252
+vector252:
+  pushl $0
+  pushl $252
+  jmp alltraps
+.globl vector253
+vector253:
+  pushl $0
+  pushl $253
+  jmp alltraps
+.globl vector254
+vector254:
+  pushl $0
+  pushl $254
+  jmp alltraps
+.globl vector255
+vector255:
+  pushl $0
+  pushl $255
+  jmp alltraps
+
+# vector table
+.data
+.globl vectors
+vectors:
+  .long vector0
+  .long vector1
+  .long vector2
+  .long vector3
+  .long vector4
+  .long vector5
+  .long vector6
+  .long vector7
+  .long vector8
+  .long vector9
+  .long vector10
+  .long vector11
+  .long vector12
+  .long vector13
+  .long vector14
+  .long vector15
+  .long vector16
+  .long vector17
+  .long vector18
+  .long vector19
+  .long vector20
+  .long vector21
+  .long vector22
+  .long vector23
+  .long vector24
+  .long vector25
+  .long vector26
+  .long vector27
+  .long vector28
+  .long vector29
+  .long vector30
+  .long vector31
+  .long vector32
+  .long vector33
+  .long vector34
+  .long vector35
+  .long vector36
+  .long vector37
+  .long vector38
+  .long vector39
+  .long vector40
+  .long vector41
+  .long vector42
+  .long vector43
+  .long vector44
+  .long vector45
+  .long vector46
+  .long vector47
+  .long vector48
+  .long vector49
+  .long vector50
+  .long vector51
+  .long vector52
+  .long vector53
+  .long vector54
+  .long vector55
+  .long vector56
+  .long vector57
+  .long vector58
+  .long vector59
+  .long vector60
+  .long vector61
+  .long vector62
+  .long vector63
+  .long vector64
+  .long vector65
+  .long vector66
+  .long vector67
+  .long vector68
+  .long vector69
+  .long vector70
+  .long vector71
+  .long vector72
+  .long vector73
+  .long vector74
+  .long vector75
+  .long vector76
+  .long vector77
+  .long vector78
+  .long vector79
+  .long vector80
+  .long vector81
+  .long vector82
+  .long vector83
+  .long vector84
+  .long vector85
+  .long vector86
+  .long vector87
+  .long vector88
+  .long vector89
+  .long vector90
+  .long vector91
+  .long vector92
+  .long vector93
+  .long vector94
+  .long vector95
+  .long vector96
+  .long vector97
+  .long vector98
+  .long vector99
+  .long vector100
+  .long vector101
+  .long vector102
+  .long vector103
+  .long vector104
+  .long vector105
+  .long vector106
+  .long vector107
+  .long vector108
+  .long vector109
+  .long vector110
+  .long vector111
+  .long vector112
+  .long vector113
+  .long vector114
+  .long vector115
+  .long vector116
+  .long vector117
+  .long vector118
+  .long vector119
+  .long vector120
+  .long vector121
+  .long vector122
+  .long vector123
+  .long vector124
+  .long vector125
+  .long vector126
+  .long vector127
+  .long vector128
+  .long vector129
+  .long vector130
+  .long vector131
+  .long vector132
+  .long vector133
+  .long vector134
+  .long vector135
+  .long vector136
+  .long vector137
+  .long vector138
+  .long vector139
+  .long vector140
+  .long vector141
+  .long vector142
+  .long vector143
+  .long vector144
+  .long vector145
+  .long vector146
+  .long vector147
+  .long vector148
+  .long vector149
+  .long vector150
+  .long vector151
+  .long vector152
+  .long vector153
+  .long vector154
+  .long vector155
+  .long vector156
+  .long vector157
+  .long vector158
+  .long vector159
+  .long vector160
+  .long vector161
+  .long vector162
+  .long vector163
+  .long vector164
+  .long vector165
+  .long vector166
+  .long vector167
+  .long vector168
+  .long vector169
+  .long vector170
+  .long vector171
+  .long vector172
+  .long vector173
+  .long vector174
+  .long vector175
+  .long vector176
+  .long vector177
+  .long vector178
+  .long vector179
+  .long vector180
+  .long vector181
+  .long vector182
+  .long vector183
+  .long vector184
+  .long vector185
+  .long vector186
+  .long vector187
+  .long vector188
+  .long vector189
+  .long vector190
+  .long vector191
+  .long vector192
+  .long vector193
+  .long vector194
+  .long vector195
+  .long vector196
+  .long vector197
+  .long vector198
+  .long vector199
+  .long vector200
+  .long vector201
+  .long vector202
+  .long vector203
+  .long vector204
+  .long vector205
+  .long vector206
+  .long vector207
+  .long vector208
+  .long vector209
+  .long vector210
+  .long vector211
+  .long vector212
+  .long vector213
+  .long vector214
+  .long vector215
+  .long vector216
+  .long vector217
+  .long vector218
+  .long vector219
+  .long vector220
+  .long vector221
+  .long vector222
+  .long vector223
+  .long vector224
+  .long vector225
+  .long vector226
+  .long vector227
+  .long vector228
+  .long vector229
+  .long vector230
+  .long vector231
+  .long vector232
+  .long vector233
+  .long vector234
+  .long vector235
+  .long vector236
+  .long vector237
+  .long vector238
+  .long vector239
+  .long vector240
+  .long vector241
+  .long vector242
+  .long vector243
+  .long vector244
+  .long vector245
+  .long vector246
+  .long vector247
+  .long vector248
+  .long vector249
+  .long vector250
+  .long vector251
+  .long vector252
+  .long vector253
+  .long vector254
+  .long vector255
Binary files xv6-public/xv6-public/vectors.o and xv6-public_new/xv6-public/vectors.o differ
diff -ruN xv6-public/xv6-public/vectors.pl xv6-public_new/xv6-public/vectors.pl
--- xv6-public/xv6-public/vectors.pl	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/vectors.pl	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,47 @@
+#!/usr/bin/perl -w
+
+# Generate vectors.S, the trap/interrupt entry points.
+# There has to be one entry point per interrupt number
+# since otherwise there's no way for trap() to discover
+# the interrupt number.
+
+print "# generated by vectors.pl - do not edit\n";
+print "# handlers\n";
+print ".globl alltraps\n";
+for(my $i = 0; $i < 256; $i++){
+    print ".globl vector$i\n";
+    print "vector$i:\n";
+    if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
+        print "  pushl \$0\n";
+    }
+    print "  pushl \$$i\n";
+    print "  jmp alltraps\n";
+}
+
+print "\n# vector table\n";
+print ".data\n";
+print ".globl vectors\n";
+print "vectors:\n";
+for(my $i = 0; $i < 256; $i++){
+    print "  .long vector$i\n";
+}
+
+# sample output:
+#   # handlers
+#   .globl alltraps
+#   .globl vector0
+#   vector0:
+#     pushl $0
+#     pushl $0
+#     jmp alltraps
+#   ...
+#   
+#   # vector table
+#   .data
+#   .globl vectors
+#   vectors:
+#     .long vector0
+#     .long vector1
+#     .long vector2
+#   ...
+
diff -ruN xv6-public/xv6-public/vm.c xv6-public_new/xv6-public/vm.c
--- xv6-public/xv6-public/vm.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/vm.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,394 @@
+#include "param.h"
+#include "types.h"
+#include "defs.h"
+#include "x86.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+#include "elf.h"
+
+extern char data[];  // defined by kernel.ld
+pde_t *kpgdir;  // for use in scheduler()
+
+// Set up CPU's kernel segment descriptors.
+// Run once on entry on each CPU.
+void
+seginit(void)
+{
+  struct cpu *c;
+
+  // Map "logical" addresses to virtual addresses using identity map.
+  // Cannot share a CODE descriptor for both kernel and user
+  // because it would have to have DPL_USR, but the CPU forbids
+  // an interrupt from CPL=0 to DPL=3.
+  c = &cpus[cpuid()];
+  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
+  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
+  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+  lgdt(c->gdt, sizeof(c->gdt));
+}
+
+// Return the address of the PTE in page table pgdir
+// that corresponds to virtual address va.  If alloc!=0,
+// create any required page table pages.
+static pte_t *
+walkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+  if(*pde & PTE_P){
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+  } else {
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+      return 0;
+    // Make sure all those PTE_P bits are zero.
+    memset(pgtab, 0, PGSIZE);
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+  }
+  return &pgtab[PTX(va)];
+}
+
+// Create PTEs for virtual addresses starting at va that refer to
+// physical addresses starting at pa. va and size might not
+// be page-aligned.
+static int
+mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+{
+  char *a, *last;
+  pte_t *pte;
+
+  a = (char*)PGROUNDDOWN((uint)va);
+  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+  for(;;){
+    if((pte = walkpgdir(pgdir, a, 1)) == 0)
+      return -1;
+    if(*pte & PTE_P)
+      panic("remap");
+    *pte = pa | perm | PTE_P;
+    if(a == last)
+      break;
+    a += PGSIZE;
+    pa += PGSIZE;
+  }
+  return 0;
+}
+
+// There is one page table per process, plus one that's used when
+// a CPU is not running any process (kpgdir). The kernel uses the
+// current process's page table during system calls and interrupts;
+// page protection bits prevent user code from using the kernel's
+// mappings.
+//
+// setupkvm() and exec() set up every page table like this:
+//
+//   0..KERNBASE: user memory (text+data+stack+heap), mapped to
+//                phys memory allocated by the kernel
+//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
+//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
+//                for the kernel's instructions and r/o data
+//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
+//                                  rw data + free physical memory
+//   0xfe000000..0: mapped direct (devices such as ioapic)
+//
+// The kernel allocates physical memory for its heap and for user memory
+// between V2P(end) and the end of physical memory (PHYSTOP)
+// (directly addressable from end..P2V(PHYSTOP)).
+
+// This table defines the kernel's mappings, which are present in
+// every process's page table.
+static struct kmap {
+  void *virt;
+  uint phys_start;
+  uint phys_end;
+  int perm;
+} kmap[] = {
+ { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
+ { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
+ { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory
+ { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices
+};
+
+// Set up kernel part of a page table.
+pde_t*
+setupkvm(void)
+{
+  pde_t *pgdir;
+  struct kmap *k;
+
+  if((pgdir = (pde_t*)kalloc()) == 0)
+    return 0;
+  memset(pgdir, 0, PGSIZE);
+  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+    panic("PHYSTOP too high");
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+                (uint)k->phys_start, k->perm) < 0) {
+      freevm(pgdir);
+      return 0;
+    }
+  return pgdir;
+}
+
+// Allocate one page table for the machine for the kernel address
+// space for scheduler processes.
+void
+kvmalloc(void)
+{
+  kpgdir = setupkvm();
+  switchkvm();
+}
+
+// Switch h/w page table register to the kernel-only page table,
+// for when no process is running.
+void
+switchkvm(void)
+{
+  lcr3(V2P(kpgdir));   // switch to the kernel page table
+}
+
+// Switch TSS and h/w page table to correspond to process p.
+void
+switchuvm(struct proc *p)
+{
+  if(p == 0)
+    panic("switchuvm: no process");
+  if(p->kstack == 0)
+    panic("switchuvm: no kstack");
+  if(p->pgdir == 0)
+    panic("switchuvm: no pgdir");
+
+  pushcli();
+  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
+                                sizeof(mycpu()->ts)-1, 0);
+  mycpu()->gdt[SEG_TSS].s = 0;
+  mycpu()->ts.ss0 = SEG_KDATA << 3;
+  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
+  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
+  // forbids I/O instructions (e.g., inb and outb) from user space
+  mycpu()->ts.iomb = (ushort) 0xFFFF;
+  ltr(SEG_TSS << 3);
+  lcr3(V2P(p->pgdir));  // switch to process's address space
+  popcli();
+}
+
+// Load the initcode into address 0 of pgdir.
+// sz must be less than a page.
+void
+inituvm(pde_t *pgdir, char *init, uint sz)
+{
+  char *mem;
+
+  if(sz >= PGSIZE)
+    panic("inituvm: more than a page");
+  mem = kalloc();
+  memset(mem, 0, PGSIZE);
+  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+  memmove(mem, init, sz);
+}
+
+// Load a program segment into pgdir.  addr must be page-aligned
+// and the pages from addr to addr+sz must already be mapped.
+int
+loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
+{
+  uint i, pa, n;
+  pte_t *pte;
+
+  if((uint) addr % PGSIZE != 0)
+    panic("loaduvm: addr must be page aligned");
+  for(i = 0; i < sz; i += PGSIZE){
+    if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
+      panic("loaduvm: address should exist");
+    pa = PTE_ADDR(*pte);
+    if(sz - i < PGSIZE)
+      n = sz - i;
+    else
+      n = PGSIZE;
+    if(readi(ip, P2V(pa), offset+i, n) != n)
+      return -1;
+  }
+  return 0;
+}
+
+// Allocate page tables and physical memory to grow process from oldsz to
+// newsz, which need not be page aligned.  Returns new size or 0 on error.
+int
+allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+{
+  char *mem;
+  uint a;
+
+  if(newsz >= KERNBASE)
+    return 0;
+  if(newsz < oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(oldsz);
+  for(; a < newsz; a += PGSIZE){
+    mem = kalloc();
+    if(mem == 0){
+      cprintf("allocuvm out of memory\n");
+      deallocuvm(pgdir, newsz, oldsz);
+      return 0;
+    }
+    memset(mem, 0, PGSIZE);
+    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+      cprintf("allocuvm out of memory (2)\n");
+      deallocuvm(pgdir, newsz, oldsz);
+      kfree(mem);
+      return 0;
+    }
+  }
+  return newsz;
+}
+
+// Deallocate user pages to bring the process size from oldsz to
+// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+// need to be less than oldsz.  oldsz can be larger than the actual
+// process size.  Returns the new process size.
+int
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+{
+  pte_t *pte;
+  uint a, pa;
+
+  if(newsz >= oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(newsz);
+  for(; a  < oldsz; a += PGSIZE){
+    pte = walkpgdir(pgdir, (char*)a, 0);
+    if(!pte)
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+    else if((*pte & PTE_P) != 0){
+      pa = PTE_ADDR(*pte);
+      if(pa == 0)
+        panic("kfree");
+      char *v = P2V(pa);
+      kfree(v);
+      *pte = 0;
+    }
+  }
+  return newsz;
+}
+
+// Free a page table and all the physical memory pages
+// in the user part.
+void
+freevm(pde_t *pgdir)
+{
+  uint i;
+
+  if(pgdir == 0)
+    panic("freevm: no pgdir");
+  deallocuvm(pgdir, KERNBASE, 0);
+  for(i = 0; i < NPDENTRIES; i++){
+    if(pgdir[i] & PTE_P){
+      char * v = P2V(PTE_ADDR(pgdir[i]));
+      kfree(v);
+    }
+  }
+  kfree((char*)pgdir);
+}
+
+// Clear PTE_U on a page. Used to create an inaccessible
+// page beneath the user stack.
+void
+clearpteu(pde_t *pgdir, char *uva)
+{
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+  if(pte == 0)
+    panic("clearpteu");
+  *pte &= ~PTE_U;
+}
+
+// Given a parent process's page table, create a copy
+// of it for a child.
+pde_t*
+copyuvm(pde_t *pgdir, uint sz)
+{
+  pde_t *d;
+  pte_t *pte;
+  uint pa, i, flags;
+  char *mem;
+
+  if((d = setupkvm()) == 0)
+    return 0;
+  for(i = 0; i < sz; i += PGSIZE){
+    if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
+      panic("copyuvm: pte should exist");
+    if(!(*pte & PTE_P))
+      panic("copyuvm: page not present");
+    pa = PTE_ADDR(*pte);
+    flags = PTE_FLAGS(*pte);
+    if((mem = kalloc()) == 0)
+      goto bad;
+    memmove(mem, (char*)P2V(pa), PGSIZE);
+    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
+      kfree(mem);
+      goto bad;
+    }
+  }
+  return d;
+
+bad:
+  freevm(d);
+  return 0;
+}
+
+//PAGEBREAK!
+// Map user virtual address to kernel address.
+char*
+uva2ka(pde_t *pgdir, char *uva)
+{
+  pte_t *pte;
+
+  pte = walkpgdir(pgdir, uva, 0);
+  if((*pte & PTE_P) == 0)
+    return 0;
+  if((*pte & PTE_U) == 0)
+    return 0;
+  return (char*)P2V(PTE_ADDR(*pte));
+}
+
+// Copy len bytes from p to user address va in page table pgdir.
+// Most useful when pgdir is not the current page table.
+// uva2ka ensures this only works for PTE_U pages.
+int
+copyout(pde_t *pgdir, uint va, void *p, uint len)
+{
+  char *buf, *pa0;
+  uint n, va0;
+
+  buf = (char*)p;
+  while(len > 0){
+    va0 = (uint)PGROUNDDOWN(va);
+    pa0 = uva2ka(pgdir, (char*)va0);
+    if(pa0 == 0)
+      return -1;
+    n = PGSIZE - (va - va0);
+    if(n > len)
+      n = len;
+    memmove(pa0 + (va - va0), buf, n);
+    len -= n;
+    buf += n;
+    va = va0 + PGSIZE;
+  }
+  return 0;
+}
+
+//PAGEBREAK!
+// Blank page.
+//PAGEBREAK!
+// Blank page.
+//PAGEBREAK!
+// Blank page.
+
diff -ruN xv6-public/xv6-public/vm.d xv6-public_new/xv6-public/vm.d
--- xv6-public/xv6-public/vm.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/vm.d	2021-09-30 23:15:18.000000000 +0530
@@ -0,0 +1,2 @@
+vm.o: vm.c /usr/include/stdc-predef.h param.h types.h defs.h x86.h \
+ memlayout.h mmu.h proc.h elf.h
Binary files xv6-public/xv6-public/vm.o and xv6-public_new/xv6-public/vm.o differ
diff -ruN xv6-public/xv6-public/wc.asm xv6-public_new/xv6-public/wc.asm
--- xv6-public/xv6-public/wc.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/wc.asm	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,1306 @@
+
+_wc:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <wc>:
+
+char buf[512];
+
+void
+wc(int fd, char *name)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	55                   	push   %ebp
+   5:	89 e5                	mov    %esp,%ebp
+   7:	83 ec 28             	sub    $0x28,%esp
+  int i, n;
+  int l, w, c, inword;
+
+  l = w = c = 0;
+   a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+  11:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  14:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  17:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  inword = 0;
+  1d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+  24:	eb 69                	jmp    8f <wc+0x8f>
+    for(i=0; i<n; i++){
+  26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  2d:	eb 58                	jmp    87 <wc+0x87>
+      c++;
+  2f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
+      if(buf[i] == '\n')
+  33:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  36:	05 a0 0c 00 00       	add    $0xca0,%eax
+  3b:	0f b6 00             	movzbl (%eax),%eax
+  3e:	3c 0a                	cmp    $0xa,%al
+  40:	75 04                	jne    46 <wc+0x46>
+        l++;
+  42:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+      if(strchr(" \r\t\n\v", buf[i]))
+  46:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  49:	05 a0 0c 00 00       	add    $0xca0,%eax
+  4e:	0f b6 00             	movzbl (%eax),%eax
+  51:	0f be c0             	movsbl %al,%eax
+  54:	83 ec 08             	sub    $0x8,%esp
+  57:	50                   	push   %eax
+  58:	68 ab 09 00 00       	push   $0x9ab
+  5d:	e8 49 02 00 00       	call   2ab <strchr>
+  62:	83 c4 10             	add    $0x10,%esp
+  65:	85 c0                	test   %eax,%eax
+  67:	74 09                	je     72 <wc+0x72>
+        inword = 0;
+  69:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  70:	eb 11                	jmp    83 <wc+0x83>
+      else if(!inword){
+  72:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  76:	75 0b                	jne    83 <wc+0x83>
+        w++;
+  78:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
+        inword = 1;
+  7c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
+    for(i=0; i<n; i++){
+  83:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  87:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  8a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+  8d:	7c a0                	jl     2f <wc+0x2f>
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+  8f:	83 ec 04             	sub    $0x4,%esp
+  92:	68 00 02 00 00       	push   $0x200
+  97:	68 a0 0c 00 00       	push   $0xca0
+  9c:	ff 75 08             	pushl  0x8(%ebp)
+  9f:	e8 b4 03 00 00       	call   458 <read>
+  a4:	83 c4 10             	add    $0x10,%esp
+  a7:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  aa:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  ae:	0f 8f 72 ff ff ff    	jg     26 <wc+0x26>
+      }
+    }
+  }
+  if(n < 0){
+  b4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+  b8:	79 17                	jns    d1 <wc+0xd1>
+    printf(1, "wc: read error\n");
+  ba:	83 ec 08             	sub    $0x8,%esp
+  bd:	68 b1 09 00 00       	push   $0x9b1
+  c2:	6a 01                	push   $0x1
+  c4:	e8 1b 05 00 00       	call   5e4 <printf>
+  c9:	83 c4 10             	add    $0x10,%esp
+    exit();
+  cc:	e8 6f 03 00 00       	call   440 <exit>
+  }
+  printf(1, "%d %d %d %s\n", l, w, c, name);
+  d1:	83 ec 08             	sub    $0x8,%esp
+  d4:	ff 75 0c             	pushl  0xc(%ebp)
+  d7:	ff 75 e8             	pushl  -0x18(%ebp)
+  da:	ff 75 ec             	pushl  -0x14(%ebp)
+  dd:	ff 75 f0             	pushl  -0x10(%ebp)
+  e0:	68 c1 09 00 00       	push   $0x9c1
+  e5:	6a 01                	push   $0x1
+  e7:	e8 f8 04 00 00       	call   5e4 <printf>
+  ec:	83 c4 20             	add    $0x20,%esp
+}
+  ef:	90                   	nop
+  f0:	c9                   	leave  
+  f1:	c3                   	ret    
+
+000000f2 <main>:
+
+int
+main(int argc, char *argv[])
+{
+  f2:	f3 0f 1e fb          	endbr32 
+  f6:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+  fa:	83 e4 f0             	and    $0xfffffff0,%esp
+  fd:	ff 71 fc             	pushl  -0x4(%ecx)
+ 100:	55                   	push   %ebp
+ 101:	89 e5                	mov    %esp,%ebp
+ 103:	53                   	push   %ebx
+ 104:	51                   	push   %ecx
+ 105:	83 ec 10             	sub    $0x10,%esp
+ 108:	89 cb                	mov    %ecx,%ebx
+  int fd, i;
+
+  if(argc <= 1){
+ 10a:	83 3b 01             	cmpl   $0x1,(%ebx)
+ 10d:	7f 17                	jg     126 <main+0x34>
+    wc(0, "");
+ 10f:	83 ec 08             	sub    $0x8,%esp
+ 112:	68 ce 09 00 00       	push   $0x9ce
+ 117:	6a 00                	push   $0x0
+ 119:	e8 e2 fe ff ff       	call   0 <wc>
+ 11e:	83 c4 10             	add    $0x10,%esp
+    exit();
+ 121:	e8 1a 03 00 00       	call   440 <exit>
+  }
+
+  for(i = 1; i < argc; i++){
+ 126:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+ 12d:	e9 83 00 00 00       	jmp    1b5 <main+0xc3>
+    if((fd = open(argv[i], 0)) < 0){
+ 132:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 135:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 13c:	8b 43 04             	mov    0x4(%ebx),%eax
+ 13f:	01 d0                	add    %edx,%eax
+ 141:	8b 00                	mov    (%eax),%eax
+ 143:	83 ec 08             	sub    $0x8,%esp
+ 146:	6a 00                	push   $0x0
+ 148:	50                   	push   %eax
+ 149:	e8 32 03 00 00       	call   480 <open>
+ 14e:	83 c4 10             	add    $0x10,%esp
+ 151:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 154:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 158:	79 29                	jns    183 <main+0x91>
+      printf(1, "wc: cannot open %s\n", argv[i]);
+ 15a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 15d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 164:	8b 43 04             	mov    0x4(%ebx),%eax
+ 167:	01 d0                	add    %edx,%eax
+ 169:	8b 00                	mov    (%eax),%eax
+ 16b:	83 ec 04             	sub    $0x4,%esp
+ 16e:	50                   	push   %eax
+ 16f:	68 cf 09 00 00       	push   $0x9cf
+ 174:	6a 01                	push   $0x1
+ 176:	e8 69 04 00 00       	call   5e4 <printf>
+ 17b:	83 c4 10             	add    $0x10,%esp
+      exit();
+ 17e:	e8 bd 02 00 00       	call   440 <exit>
+    }
+    wc(fd, argv[i]);
+ 183:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 186:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+ 18d:	8b 43 04             	mov    0x4(%ebx),%eax
+ 190:	01 d0                	add    %edx,%eax
+ 192:	8b 00                	mov    (%eax),%eax
+ 194:	83 ec 08             	sub    $0x8,%esp
+ 197:	50                   	push   %eax
+ 198:	ff 75 f0             	pushl  -0x10(%ebp)
+ 19b:	e8 60 fe ff ff       	call   0 <wc>
+ 1a0:	83 c4 10             	add    $0x10,%esp
+    close(fd);
+ 1a3:	83 ec 0c             	sub    $0xc,%esp
+ 1a6:	ff 75 f0             	pushl  -0x10(%ebp)
+ 1a9:	e8 ba 02 00 00       	call   468 <close>
+ 1ae:	83 c4 10             	add    $0x10,%esp
+  for(i = 1; i < argc; i++){
+ 1b1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+ 1b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1b8:	3b 03                	cmp    (%ebx),%eax
+ 1ba:	0f 8c 72 ff ff ff    	jl     132 <main+0x40>
+  }
+  exit();
+ 1c0:	e8 7b 02 00 00       	call   440 <exit>
+
+000001c5 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+ 1c5:	55                   	push   %ebp
+ 1c6:	89 e5                	mov    %esp,%ebp
+ 1c8:	57                   	push   %edi
+ 1c9:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+ 1ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
+ 1cd:	8b 55 10             	mov    0x10(%ebp),%edx
+ 1d0:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 1d3:	89 cb                	mov    %ecx,%ebx
+ 1d5:	89 df                	mov    %ebx,%edi
+ 1d7:	89 d1                	mov    %edx,%ecx
+ 1d9:	fc                   	cld    
+ 1da:	f3 aa                	rep stos %al,%es:(%edi)
+ 1dc:	89 ca                	mov    %ecx,%edx
+ 1de:	89 fb                	mov    %edi,%ebx
+ 1e0:	89 5d 08             	mov    %ebx,0x8(%ebp)
+ 1e3:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+ 1e6:	90                   	nop
+ 1e7:	5b                   	pop    %ebx
+ 1e8:	5f                   	pop    %edi
+ 1e9:	5d                   	pop    %ebp
+ 1ea:	c3                   	ret    
+
+000001eb <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+ 1eb:	f3 0f 1e fb          	endbr32 
+ 1ef:	55                   	push   %ebp
+ 1f0:	89 e5                	mov    %esp,%ebp
+ 1f2:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+ 1f5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1f8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+ 1fb:	90                   	nop
+ 1fc:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 1ff:	8d 42 01             	lea    0x1(%edx),%eax
+ 202:	89 45 0c             	mov    %eax,0xc(%ebp)
+ 205:	8b 45 08             	mov    0x8(%ebp),%eax
+ 208:	8d 48 01             	lea    0x1(%eax),%ecx
+ 20b:	89 4d 08             	mov    %ecx,0x8(%ebp)
+ 20e:	0f b6 12             	movzbl (%edx),%edx
+ 211:	88 10                	mov    %dl,(%eax)
+ 213:	0f b6 00             	movzbl (%eax),%eax
+ 216:	84 c0                	test   %al,%al
+ 218:	75 e2                	jne    1fc <strcpy+0x11>
+    ;
+  return os;
+ 21a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 21d:	c9                   	leave  
+ 21e:	c3                   	ret    
+
+0000021f <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 21f:	f3 0f 1e fb          	endbr32 
+ 223:	55                   	push   %ebp
+ 224:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+ 226:	eb 08                	jmp    230 <strcmp+0x11>
+    p++, q++;
+ 228:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 22c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+ 230:	8b 45 08             	mov    0x8(%ebp),%eax
+ 233:	0f b6 00             	movzbl (%eax),%eax
+ 236:	84 c0                	test   %al,%al
+ 238:	74 10                	je     24a <strcmp+0x2b>
+ 23a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 23d:	0f b6 10             	movzbl (%eax),%edx
+ 240:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 243:	0f b6 00             	movzbl (%eax),%eax
+ 246:	38 c2                	cmp    %al,%dl
+ 248:	74 de                	je     228 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+ 24a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 24d:	0f b6 00             	movzbl (%eax),%eax
+ 250:	0f b6 d0             	movzbl %al,%edx
+ 253:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 256:	0f b6 00             	movzbl (%eax),%eax
+ 259:	0f b6 c0             	movzbl %al,%eax
+ 25c:	29 c2                	sub    %eax,%edx
+ 25e:	89 d0                	mov    %edx,%eax
+}
+ 260:	5d                   	pop    %ebp
+ 261:	c3                   	ret    
+
+00000262 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 262:	f3 0f 1e fb          	endbr32 
+ 266:	55                   	push   %ebp
+ 267:	89 e5                	mov    %esp,%ebp
+ 269:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 26c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+ 273:	eb 04                	jmp    279 <strlen+0x17>
+ 275:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+ 279:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 27c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 27f:	01 d0                	add    %edx,%eax
+ 281:	0f b6 00             	movzbl (%eax),%eax
+ 284:	84 c0                	test   %al,%al
+ 286:	75 ed                	jne    275 <strlen+0x13>
+    ;
+  return n;
+ 288:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 28b:	c9                   	leave  
+ 28c:	c3                   	ret    
+
+0000028d <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 28d:	f3 0f 1e fb          	endbr32 
+ 291:	55                   	push   %ebp
+ 292:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+ 294:	8b 45 10             	mov    0x10(%ebp),%eax
+ 297:	50                   	push   %eax
+ 298:	ff 75 0c             	pushl  0xc(%ebp)
+ 29b:	ff 75 08             	pushl  0x8(%ebp)
+ 29e:	e8 22 ff ff ff       	call   1c5 <stosb>
+ 2a3:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 2a6:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2a9:	c9                   	leave  
+ 2aa:	c3                   	ret    
+
+000002ab <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 2ab:	f3 0f 1e fb          	endbr32 
+ 2af:	55                   	push   %ebp
+ 2b0:	89 e5                	mov    %esp,%ebp
+ 2b2:	83 ec 04             	sub    $0x4,%esp
+ 2b5:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 2b8:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 2bb:	eb 14                	jmp    2d1 <strchr+0x26>
+    if(*s == c)
+ 2bd:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2c0:	0f b6 00             	movzbl (%eax),%eax
+ 2c3:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 2c6:	75 05                	jne    2cd <strchr+0x22>
+      return (char*)s;
+ 2c8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2cb:	eb 13                	jmp    2e0 <strchr+0x35>
+  for(; *s; s++)
+ 2cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 2d1:	8b 45 08             	mov    0x8(%ebp),%eax
+ 2d4:	0f b6 00             	movzbl (%eax),%eax
+ 2d7:	84 c0                	test   %al,%al
+ 2d9:	75 e2                	jne    2bd <strchr+0x12>
+  return 0;
+ 2db:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 2e0:	c9                   	leave  
+ 2e1:	c3                   	ret    
+
+000002e2 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 2e2:	f3 0f 1e fb          	endbr32 
+ 2e6:	55                   	push   %ebp
+ 2e7:	89 e5                	mov    %esp,%ebp
+ 2e9:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 2ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 2f3:	eb 42                	jmp    337 <gets+0x55>
+    cc = read(0, &c, 1);
+ 2f5:	83 ec 04             	sub    $0x4,%esp
+ 2f8:	6a 01                	push   $0x1
+ 2fa:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 2fd:	50                   	push   %eax
+ 2fe:	6a 00                	push   $0x0
+ 300:	e8 53 01 00 00       	call   458 <read>
+ 305:	83 c4 10             	add    $0x10,%esp
+ 308:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 30b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 30f:	7e 33                	jle    344 <gets+0x62>
+      break;
+    buf[i++] = c;
+ 311:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 314:	8d 50 01             	lea    0x1(%eax),%edx
+ 317:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 31a:	89 c2                	mov    %eax,%edx
+ 31c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 31f:	01 c2                	add    %eax,%edx
+ 321:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 325:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 327:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 32b:	3c 0a                	cmp    $0xa,%al
+ 32d:	74 16                	je     345 <gets+0x63>
+ 32f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 333:	3c 0d                	cmp    $0xd,%al
+ 335:	74 0e                	je     345 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 337:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 33a:	83 c0 01             	add    $0x1,%eax
+ 33d:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 340:	7f b3                	jg     2f5 <gets+0x13>
+ 342:	eb 01                	jmp    345 <gets+0x63>
+      break;
+ 344:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 345:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 348:	8b 45 08             	mov    0x8(%ebp),%eax
+ 34b:	01 d0                	add    %edx,%eax
+ 34d:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 350:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 353:	c9                   	leave  
+ 354:	c3                   	ret    
+
+00000355 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 355:	f3 0f 1e fb          	endbr32 
+ 359:	55                   	push   %ebp
+ 35a:	89 e5                	mov    %esp,%ebp
+ 35c:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 35f:	83 ec 08             	sub    $0x8,%esp
+ 362:	6a 00                	push   $0x0
+ 364:	ff 75 08             	pushl  0x8(%ebp)
+ 367:	e8 14 01 00 00       	call   480 <open>
+ 36c:	83 c4 10             	add    $0x10,%esp
+ 36f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 372:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 376:	79 07                	jns    37f <stat+0x2a>
+    return -1;
+ 378:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 37d:	eb 25                	jmp    3a4 <stat+0x4f>
+  r = fstat(fd, st);
+ 37f:	83 ec 08             	sub    $0x8,%esp
+ 382:	ff 75 0c             	pushl  0xc(%ebp)
+ 385:	ff 75 f4             	pushl  -0xc(%ebp)
+ 388:	e8 0b 01 00 00       	call   498 <fstat>
+ 38d:	83 c4 10             	add    $0x10,%esp
+ 390:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 393:	83 ec 0c             	sub    $0xc,%esp
+ 396:	ff 75 f4             	pushl  -0xc(%ebp)
+ 399:	e8 ca 00 00 00       	call   468 <close>
+ 39e:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 3a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 3a4:	c9                   	leave  
+ 3a5:	c3                   	ret    
+
+000003a6 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 3a6:	f3 0f 1e fb          	endbr32 
+ 3aa:	55                   	push   %ebp
+ 3ab:	89 e5                	mov    %esp,%ebp
+ 3ad:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 3b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 3b7:	eb 25                	jmp    3de <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 3b9:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 3bc:	89 d0                	mov    %edx,%eax
+ 3be:	c1 e0 02             	shl    $0x2,%eax
+ 3c1:	01 d0                	add    %edx,%eax
+ 3c3:	01 c0                	add    %eax,%eax
+ 3c5:	89 c1                	mov    %eax,%ecx
+ 3c7:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3ca:	8d 50 01             	lea    0x1(%eax),%edx
+ 3cd:	89 55 08             	mov    %edx,0x8(%ebp)
+ 3d0:	0f b6 00             	movzbl (%eax),%eax
+ 3d3:	0f be c0             	movsbl %al,%eax
+ 3d6:	01 c8                	add    %ecx,%eax
+ 3d8:	83 e8 30             	sub    $0x30,%eax
+ 3db:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 3de:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3e1:	0f b6 00             	movzbl (%eax),%eax
+ 3e4:	3c 2f                	cmp    $0x2f,%al
+ 3e6:	7e 0a                	jle    3f2 <atoi+0x4c>
+ 3e8:	8b 45 08             	mov    0x8(%ebp),%eax
+ 3eb:	0f b6 00             	movzbl (%eax),%eax
+ 3ee:	3c 39                	cmp    $0x39,%al
+ 3f0:	7e c7                	jle    3b9 <atoi+0x13>
+  return n;
+ 3f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 3f5:	c9                   	leave  
+ 3f6:	c3                   	ret    
+
+000003f7 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 3f7:	f3 0f 1e fb          	endbr32 
+ 3fb:	55                   	push   %ebp
+ 3fc:	89 e5                	mov    %esp,%ebp
+ 3fe:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 401:	8b 45 08             	mov    0x8(%ebp),%eax
+ 404:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 407:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 40a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 40d:	eb 17                	jmp    426 <memmove+0x2f>
+    *dst++ = *src++;
+ 40f:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 412:	8d 42 01             	lea    0x1(%edx),%eax
+ 415:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 418:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 41b:	8d 48 01             	lea    0x1(%eax),%ecx
+ 41e:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 421:	0f b6 12             	movzbl (%edx),%edx
+ 424:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 426:	8b 45 10             	mov    0x10(%ebp),%eax
+ 429:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 42c:	89 55 10             	mov    %edx,0x10(%ebp)
+ 42f:	85 c0                	test   %eax,%eax
+ 431:	7f dc                	jg     40f <memmove+0x18>
+  return vdst;
+ 433:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 436:	c9                   	leave  
+ 437:	c3                   	ret    
+
+00000438 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 438:	b8 01 00 00 00       	mov    $0x1,%eax
+ 43d:	cd 40                	int    $0x40
+ 43f:	c3                   	ret    
+
+00000440 <exit>:
+SYSCALL(exit)
+ 440:	b8 02 00 00 00       	mov    $0x2,%eax
+ 445:	cd 40                	int    $0x40
+ 447:	c3                   	ret    
+
+00000448 <wait>:
+SYSCALL(wait)
+ 448:	b8 03 00 00 00       	mov    $0x3,%eax
+ 44d:	cd 40                	int    $0x40
+ 44f:	c3                   	ret    
+
+00000450 <pipe>:
+SYSCALL(pipe)
+ 450:	b8 04 00 00 00       	mov    $0x4,%eax
+ 455:	cd 40                	int    $0x40
+ 457:	c3                   	ret    
+
+00000458 <read>:
+SYSCALL(read)
+ 458:	b8 05 00 00 00       	mov    $0x5,%eax
+ 45d:	cd 40                	int    $0x40
+ 45f:	c3                   	ret    
+
+00000460 <write>:
+SYSCALL(write)
+ 460:	b8 10 00 00 00       	mov    $0x10,%eax
+ 465:	cd 40                	int    $0x40
+ 467:	c3                   	ret    
+
+00000468 <close>:
+SYSCALL(close)
+ 468:	b8 15 00 00 00       	mov    $0x15,%eax
+ 46d:	cd 40                	int    $0x40
+ 46f:	c3                   	ret    
+
+00000470 <kill>:
+SYSCALL(kill)
+ 470:	b8 06 00 00 00       	mov    $0x6,%eax
+ 475:	cd 40                	int    $0x40
+ 477:	c3                   	ret    
+
+00000478 <exec>:
+SYSCALL(exec)
+ 478:	b8 07 00 00 00       	mov    $0x7,%eax
+ 47d:	cd 40                	int    $0x40
+ 47f:	c3                   	ret    
+
+00000480 <open>:
+SYSCALL(open)
+ 480:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 485:	cd 40                	int    $0x40
+ 487:	c3                   	ret    
+
+00000488 <mknod>:
+SYSCALL(mknod)
+ 488:	b8 11 00 00 00       	mov    $0x11,%eax
+ 48d:	cd 40                	int    $0x40
+ 48f:	c3                   	ret    
+
+00000490 <unlink>:
+SYSCALL(unlink)
+ 490:	b8 12 00 00 00       	mov    $0x12,%eax
+ 495:	cd 40                	int    $0x40
+ 497:	c3                   	ret    
+
+00000498 <fstat>:
+SYSCALL(fstat)
+ 498:	b8 08 00 00 00       	mov    $0x8,%eax
+ 49d:	cd 40                	int    $0x40
+ 49f:	c3                   	ret    
+
+000004a0 <link>:
+SYSCALL(link)
+ 4a0:	b8 13 00 00 00       	mov    $0x13,%eax
+ 4a5:	cd 40                	int    $0x40
+ 4a7:	c3                   	ret    
+
+000004a8 <mkdir>:
+SYSCALL(mkdir)
+ 4a8:	b8 14 00 00 00       	mov    $0x14,%eax
+ 4ad:	cd 40                	int    $0x40
+ 4af:	c3                   	ret    
+
+000004b0 <chdir>:
+SYSCALL(chdir)
+ 4b0:	b8 09 00 00 00       	mov    $0x9,%eax
+ 4b5:	cd 40                	int    $0x40
+ 4b7:	c3                   	ret    
+
+000004b8 <dup>:
+SYSCALL(dup)
+ 4b8:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 4bd:	cd 40                	int    $0x40
+ 4bf:	c3                   	ret    
+
+000004c0 <getpid>:
+SYSCALL(getpid)
+ 4c0:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 4c5:	cd 40                	int    $0x40
+ 4c7:	c3                   	ret    
+
+000004c8 <sbrk>:
+SYSCALL(sbrk)
+ 4c8:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 4cd:	cd 40                	int    $0x40
+ 4cf:	c3                   	ret    
+
+000004d0 <sleep>:
+SYSCALL(sleep)
+ 4d0:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 4d5:	cd 40                	int    $0x40
+ 4d7:	c3                   	ret    
+
+000004d8 <uptime>:
+SYSCALL(uptime)
+ 4d8:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 4dd:	cd 40                	int    $0x40
+ 4df:	c3                   	ret    
+
+000004e0 <draw>:
+SYSCALL(draw)
+ 4e0:	b8 16 00 00 00       	mov    $0x16,%eax
+ 4e5:	cd 40                	int    $0x40
+ 4e7:	c3                   	ret    
+
+000004e8 <cps>:
+SYSCALL(cps)
+ 4e8:	b8 17 00 00 00       	mov    $0x17,%eax
+ 4ed:	cd 40                	int    $0x40
+ 4ef:	c3                   	ret    
+
+000004f0 <yield>:
+SYSCALL(yield)
+ 4f0:	b8 18 00 00 00       	mov    $0x18,%eax
+ 4f5:	cd 40                	int    $0x40
+ 4f7:	c3                   	ret    
+
+000004f8 <wait2>:
+SYSCALL(wait2)
+ 4f8:	b8 19 00 00 00       	mov    $0x19,%eax
+ 4fd:	cd 40                	int    $0x40
+ 4ff:	c3                   	ret    
+
+00000500 <set_prio>:
+SYSCALL(set_prio)
+ 500:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 505:	cd 40                	int    $0x40
+ 507:	c3                   	ret    
+
+00000508 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 508:	f3 0f 1e fb          	endbr32 
+ 50c:	55                   	push   %ebp
+ 50d:	89 e5                	mov    %esp,%ebp
+ 50f:	83 ec 18             	sub    $0x18,%esp
+ 512:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 515:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 518:	83 ec 04             	sub    $0x4,%esp
+ 51b:	6a 01                	push   $0x1
+ 51d:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 520:	50                   	push   %eax
+ 521:	ff 75 08             	pushl  0x8(%ebp)
+ 524:	e8 37 ff ff ff       	call   460 <write>
+ 529:	83 c4 10             	add    $0x10,%esp
+}
+ 52c:	90                   	nop
+ 52d:	c9                   	leave  
+ 52e:	c3                   	ret    
+
+0000052f <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 52f:	f3 0f 1e fb          	endbr32 
+ 533:	55                   	push   %ebp
+ 534:	89 e5                	mov    %esp,%ebp
+ 536:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 539:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 540:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 544:	74 17                	je     55d <printint+0x2e>
+ 546:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 54a:	79 11                	jns    55d <printint+0x2e>
+    neg = 1;
+ 54c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 553:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 556:	f7 d8                	neg    %eax
+ 558:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 55b:	eb 06                	jmp    563 <printint+0x34>
+  } else {
+    x = xx;
+ 55d:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 560:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 563:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 56a:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 56d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 570:	ba 00 00 00 00       	mov    $0x0,%edx
+ 575:	f7 f1                	div    %ecx
+ 577:	89 d1                	mov    %edx,%ecx
+ 579:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 57c:	8d 50 01             	lea    0x1(%eax),%edx
+ 57f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 582:	0f b6 91 54 0c 00 00 	movzbl 0xc54(%ecx),%edx
+ 589:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 58d:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 590:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 593:	ba 00 00 00 00       	mov    $0x0,%edx
+ 598:	f7 f1                	div    %ecx
+ 59a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 59d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 5a1:	75 c7                	jne    56a <printint+0x3b>
+  if(neg)
+ 5a3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 5a7:	74 2d                	je     5d6 <printint+0xa7>
+    buf[i++] = '-';
+ 5a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5ac:	8d 50 01             	lea    0x1(%eax),%edx
+ 5af:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 5b2:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 5b7:	eb 1d                	jmp    5d6 <printint+0xa7>
+    putc(fd, buf[i]);
+ 5b9:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 5bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 5bf:	01 d0                	add    %edx,%eax
+ 5c1:	0f b6 00             	movzbl (%eax),%eax
+ 5c4:	0f be c0             	movsbl %al,%eax
+ 5c7:	83 ec 08             	sub    $0x8,%esp
+ 5ca:	50                   	push   %eax
+ 5cb:	ff 75 08             	pushl  0x8(%ebp)
+ 5ce:	e8 35 ff ff ff       	call   508 <putc>
+ 5d3:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 5d6:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 5da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 5de:	79 d9                	jns    5b9 <printint+0x8a>
+}
+ 5e0:	90                   	nop
+ 5e1:	90                   	nop
+ 5e2:	c9                   	leave  
+ 5e3:	c3                   	ret    
+
+000005e4 <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 5e4:	f3 0f 1e fb          	endbr32 
+ 5e8:	55                   	push   %ebp
+ 5e9:	89 e5                	mov    %esp,%ebp
+ 5eb:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 5ee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 5f5:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 5f8:	83 c0 04             	add    $0x4,%eax
+ 5fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 5fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 605:	e9 59 01 00 00       	jmp    763 <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 60a:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 60d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 610:	01 d0                	add    %edx,%eax
+ 612:	0f b6 00             	movzbl (%eax),%eax
+ 615:	0f be c0             	movsbl %al,%eax
+ 618:	25 ff 00 00 00       	and    $0xff,%eax
+ 61d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 620:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 624:	75 2c                	jne    652 <printf+0x6e>
+      if(c == '%'){
+ 626:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 62a:	75 0c                	jne    638 <printf+0x54>
+        state = '%';
+ 62c:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 633:	e9 27 01 00 00       	jmp    75f <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 638:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 63b:	0f be c0             	movsbl %al,%eax
+ 63e:	83 ec 08             	sub    $0x8,%esp
+ 641:	50                   	push   %eax
+ 642:	ff 75 08             	pushl  0x8(%ebp)
+ 645:	e8 be fe ff ff       	call   508 <putc>
+ 64a:	83 c4 10             	add    $0x10,%esp
+ 64d:	e9 0d 01 00 00       	jmp    75f <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 652:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 656:	0f 85 03 01 00 00    	jne    75f <printf+0x17b>
+      if(c == 'd'){
+ 65c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 660:	75 1e                	jne    680 <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 662:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 665:	8b 00                	mov    (%eax),%eax
+ 667:	6a 01                	push   $0x1
+ 669:	6a 0a                	push   $0xa
+ 66b:	50                   	push   %eax
+ 66c:	ff 75 08             	pushl  0x8(%ebp)
+ 66f:	e8 bb fe ff ff       	call   52f <printint>
+ 674:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 677:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 67b:	e9 d8 00 00 00       	jmp    758 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 680:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 684:	74 06                	je     68c <printf+0xa8>
+ 686:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 68a:	75 1e                	jne    6aa <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 68c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 68f:	8b 00                	mov    (%eax),%eax
+ 691:	6a 00                	push   $0x0
+ 693:	6a 10                	push   $0x10
+ 695:	50                   	push   %eax
+ 696:	ff 75 08             	pushl  0x8(%ebp)
+ 699:	e8 91 fe ff ff       	call   52f <printint>
+ 69e:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 6a1:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 6a5:	e9 ae 00 00 00       	jmp    758 <printf+0x174>
+      } else if(c == 's'){
+ 6aa:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 6ae:	75 43                	jne    6f3 <printf+0x10f>
+        s = (char*)*ap;
+ 6b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 6b3:	8b 00                	mov    (%eax),%eax
+ 6b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 6b8:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 6bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 6c0:	75 25                	jne    6e7 <printf+0x103>
+          s = "(null)";
+ 6c2:	c7 45 f4 e3 09 00 00 	movl   $0x9e3,-0xc(%ebp)
+        while(*s != 0){
+ 6c9:	eb 1c                	jmp    6e7 <printf+0x103>
+          putc(fd, *s);
+ 6cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6ce:	0f b6 00             	movzbl (%eax),%eax
+ 6d1:	0f be c0             	movsbl %al,%eax
+ 6d4:	83 ec 08             	sub    $0x8,%esp
+ 6d7:	50                   	push   %eax
+ 6d8:	ff 75 08             	pushl  0x8(%ebp)
+ 6db:	e8 28 fe ff ff       	call   508 <putc>
+ 6e0:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 6e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 6e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 6ea:	0f b6 00             	movzbl (%eax),%eax
+ 6ed:	84 c0                	test   %al,%al
+ 6ef:	75 da                	jne    6cb <printf+0xe7>
+ 6f1:	eb 65                	jmp    758 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 6f3:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 6f7:	75 1d                	jne    716 <printf+0x132>
+        putc(fd, *ap);
+ 6f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 6fc:	8b 00                	mov    (%eax),%eax
+ 6fe:	0f be c0             	movsbl %al,%eax
+ 701:	83 ec 08             	sub    $0x8,%esp
+ 704:	50                   	push   %eax
+ 705:	ff 75 08             	pushl  0x8(%ebp)
+ 708:	e8 fb fd ff ff       	call   508 <putc>
+ 70d:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 710:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 714:	eb 42                	jmp    758 <printf+0x174>
+      } else if(c == '%'){
+ 716:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 71a:	75 17                	jne    733 <printf+0x14f>
+        putc(fd, c);
+ 71c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 71f:	0f be c0             	movsbl %al,%eax
+ 722:	83 ec 08             	sub    $0x8,%esp
+ 725:	50                   	push   %eax
+ 726:	ff 75 08             	pushl  0x8(%ebp)
+ 729:	e8 da fd ff ff       	call   508 <putc>
+ 72e:	83 c4 10             	add    $0x10,%esp
+ 731:	eb 25                	jmp    758 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 733:	83 ec 08             	sub    $0x8,%esp
+ 736:	6a 25                	push   $0x25
+ 738:	ff 75 08             	pushl  0x8(%ebp)
+ 73b:	e8 c8 fd ff ff       	call   508 <putc>
+ 740:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 743:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 746:	0f be c0             	movsbl %al,%eax
+ 749:	83 ec 08             	sub    $0x8,%esp
+ 74c:	50                   	push   %eax
+ 74d:	ff 75 08             	pushl  0x8(%ebp)
+ 750:	e8 b3 fd ff ff       	call   508 <putc>
+ 755:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 758:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 75f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 763:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 766:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 769:	01 d0                	add    %edx,%eax
+ 76b:	0f b6 00             	movzbl (%eax),%eax
+ 76e:	84 c0                	test   %al,%al
+ 770:	0f 85 94 fe ff ff    	jne    60a <printf+0x26>
+    }
+  }
+}
+ 776:	90                   	nop
+ 777:	90                   	nop
+ 778:	c9                   	leave  
+ 779:	c3                   	ret    
+
+0000077a <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 77a:	f3 0f 1e fb          	endbr32 
+ 77e:	55                   	push   %ebp
+ 77f:	89 e5                	mov    %esp,%ebp
+ 781:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 784:	8b 45 08             	mov    0x8(%ebp),%eax
+ 787:	83 e8 08             	sub    $0x8,%eax
+ 78a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 78d:	a1 88 0c 00 00       	mov    0xc88,%eax
+ 792:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 795:	eb 24                	jmp    7bb <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 797:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 79a:	8b 00                	mov    (%eax),%eax
+ 79c:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 79f:	72 12                	jb     7b3 <free+0x39>
+ 7a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7a4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 7a7:	77 24                	ja     7cd <free+0x53>
+ 7a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7ac:	8b 00                	mov    (%eax),%eax
+ 7ae:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 7b1:	72 1a                	jb     7cd <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7b6:	8b 00                	mov    (%eax),%eax
+ 7b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 7bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7be:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 7c1:	76 d4                	jbe    797 <free+0x1d>
+ 7c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7c6:	8b 00                	mov    (%eax),%eax
+ 7c8:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 7cb:	73 ca                	jae    797 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 7cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7d0:	8b 40 04             	mov    0x4(%eax),%eax
+ 7d3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 7da:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7dd:	01 c2                	add    %eax,%edx
+ 7df:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7e2:	8b 00                	mov    (%eax),%eax
+ 7e4:	39 c2                	cmp    %eax,%edx
+ 7e6:	75 24                	jne    80c <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 7e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7eb:	8b 50 04             	mov    0x4(%eax),%edx
+ 7ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 7f1:	8b 00                	mov    (%eax),%eax
+ 7f3:	8b 40 04             	mov    0x4(%eax),%eax
+ 7f6:	01 c2                	add    %eax,%edx
+ 7f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 7fb:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 801:	8b 00                	mov    (%eax),%eax
+ 803:	8b 10                	mov    (%eax),%edx
+ 805:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 808:	89 10                	mov    %edx,(%eax)
+ 80a:	eb 0a                	jmp    816 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 80c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 80f:	8b 10                	mov    (%eax),%edx
+ 811:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 814:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 816:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 819:	8b 40 04             	mov    0x4(%eax),%eax
+ 81c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 823:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 826:	01 d0                	add    %edx,%eax
+ 828:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 82b:	75 20                	jne    84d <free+0xd3>
+    p->s.size += bp->s.size;
+ 82d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 830:	8b 50 04             	mov    0x4(%eax),%edx
+ 833:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 836:	8b 40 04             	mov    0x4(%eax),%eax
+ 839:	01 c2                	add    %eax,%edx
+ 83b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 83e:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 841:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 844:	8b 10                	mov    (%eax),%edx
+ 846:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 849:	89 10                	mov    %edx,(%eax)
+ 84b:	eb 08                	jmp    855 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 84d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 850:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 853:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 855:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 858:	a3 88 0c 00 00       	mov    %eax,0xc88
+}
+ 85d:	90                   	nop
+ 85e:	c9                   	leave  
+ 85f:	c3                   	ret    
+
+00000860 <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 860:	f3 0f 1e fb          	endbr32 
+ 864:	55                   	push   %ebp
+ 865:	89 e5                	mov    %esp,%ebp
+ 867:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 86a:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 871:	77 07                	ja     87a <morecore+0x1a>
+    nu = 4096;
+ 873:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 87a:	8b 45 08             	mov    0x8(%ebp),%eax
+ 87d:	c1 e0 03             	shl    $0x3,%eax
+ 880:	83 ec 0c             	sub    $0xc,%esp
+ 883:	50                   	push   %eax
+ 884:	e8 3f fc ff ff       	call   4c8 <sbrk>
+ 889:	83 c4 10             	add    $0x10,%esp
+ 88c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 88f:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 893:	75 07                	jne    89c <morecore+0x3c>
+    return 0;
+ 895:	b8 00 00 00 00       	mov    $0x0,%eax
+ 89a:	eb 26                	jmp    8c2 <morecore+0x62>
+  hp = (Header*)p;
+ 89c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 89f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 8a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8a5:	8b 55 08             	mov    0x8(%ebp),%edx
+ 8a8:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 8ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8ae:	83 c0 08             	add    $0x8,%eax
+ 8b1:	83 ec 0c             	sub    $0xc,%esp
+ 8b4:	50                   	push   %eax
+ 8b5:	e8 c0 fe ff ff       	call   77a <free>
+ 8ba:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 8bd:	a1 88 0c 00 00       	mov    0xc88,%eax
+}
+ 8c2:	c9                   	leave  
+ 8c3:	c3                   	ret    
+
+000008c4 <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 8c4:	f3 0f 1e fb          	endbr32 
+ 8c8:	55                   	push   %ebp
+ 8c9:	89 e5                	mov    %esp,%ebp
+ 8cb:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 8ce:	8b 45 08             	mov    0x8(%ebp),%eax
+ 8d1:	83 c0 07             	add    $0x7,%eax
+ 8d4:	c1 e8 03             	shr    $0x3,%eax
+ 8d7:	83 c0 01             	add    $0x1,%eax
+ 8da:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 8dd:	a1 88 0c 00 00       	mov    0xc88,%eax
+ 8e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 8e5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 8e9:	75 23                	jne    90e <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 8eb:	c7 45 f0 80 0c 00 00 	movl   $0xc80,-0x10(%ebp)
+ 8f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 8f5:	a3 88 0c 00 00       	mov    %eax,0xc88
+ 8fa:	a1 88 0c 00 00       	mov    0xc88,%eax
+ 8ff:	a3 80 0c 00 00       	mov    %eax,0xc80
+    base.s.size = 0;
+ 904:	c7 05 84 0c 00 00 00 	movl   $0x0,0xc84
+ 90b:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 90e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 911:	8b 00                	mov    (%eax),%eax
+ 913:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 916:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 919:	8b 40 04             	mov    0x4(%eax),%eax
+ 91c:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 91f:	77 4d                	ja     96e <malloc+0xaa>
+      if(p->s.size == nunits)
+ 921:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 924:	8b 40 04             	mov    0x4(%eax),%eax
+ 927:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 92a:	75 0c                	jne    938 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 92c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 92f:	8b 10                	mov    (%eax),%edx
+ 931:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 934:	89 10                	mov    %edx,(%eax)
+ 936:	eb 26                	jmp    95e <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 938:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 93b:	8b 40 04             	mov    0x4(%eax),%eax
+ 93e:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 941:	89 c2                	mov    %eax,%edx
+ 943:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 946:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 949:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 94c:	8b 40 04             	mov    0x4(%eax),%eax
+ 94f:	c1 e0 03             	shl    $0x3,%eax
+ 952:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 955:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 958:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 95b:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 95e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 961:	a3 88 0c 00 00       	mov    %eax,0xc88
+      return (void*)(p + 1);
+ 966:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 969:	83 c0 08             	add    $0x8,%eax
+ 96c:	eb 3b                	jmp    9a9 <malloc+0xe5>
+    }
+    if(p == freep)
+ 96e:	a1 88 0c 00 00       	mov    0xc88,%eax
+ 973:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 976:	75 1e                	jne    996 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 978:	83 ec 0c             	sub    $0xc,%esp
+ 97b:	ff 75 ec             	pushl  -0x14(%ebp)
+ 97e:	e8 dd fe ff ff       	call   860 <morecore>
+ 983:	83 c4 10             	add    $0x10,%esp
+ 986:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 989:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 98d:	75 07                	jne    996 <malloc+0xd2>
+        return 0;
+ 98f:	b8 00 00 00 00       	mov    $0x0,%eax
+ 994:	eb 13                	jmp    9a9 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 996:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 999:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 99c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 99f:	8b 00                	mov    (%eax),%eax
+ 9a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 9a4:	e9 6d ff ff ff       	jmp    916 <malloc+0x52>
+  }
+}
+ 9a9:	c9                   	leave  
+ 9aa:	c3                   	ret    
diff -ruN xv6-public/xv6-public/wc.c xv6-public_new/xv6-public/wc.c
--- xv6-public/xv6-public/wc.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/wc.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,54 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+char buf[512];
+
+void
+wc(int fd, char *name)
+{
+  int i, n;
+  int l, w, c, inword;
+
+  l = w = c = 0;
+  inword = 0;
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    for(i=0; i<n; i++){
+      c++;
+      if(buf[i] == '\n')
+        l++;
+      if(strchr(" \r\t\n\v", buf[i]))
+        inword = 0;
+      else if(!inword){
+        w++;
+        inword = 1;
+      }
+    }
+  }
+  if(n < 0){
+    printf(1, "wc: read error\n");
+    exit();
+  }
+  printf(1, "%d %d %d %s\n", l, w, c, name);
+}
+
+int
+main(int argc, char *argv[])
+{
+  int fd, i;
+
+  if(argc <= 1){
+    wc(0, "");
+    exit();
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], 0)) < 0){
+      printf(1, "wc: cannot open %s\n", argv[i]);
+      exit();
+    }
+    wc(fd, argv[i]);
+    close(fd);
+  }
+  exit();
+}
diff -ruN xv6-public/xv6-public/wc.d xv6-public_new/xv6-public/wc.d
--- xv6-public/xv6-public/wc.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/wc.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1 @@
+wc.o: wc.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/wc.o and xv6-public_new/xv6-public/wc.o differ
diff -ruN xv6-public/xv6-public/wc.sym xv6-public_new/xv6-public/wc.sym
--- xv6-public/xv6-public/wc.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/wc.sym	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,67 @@
+00000000 .text
+000009ab .rodata
+000009ec .eh_frame
+00000c54 .data
+00000c80 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 wc.c
+00000000 ulib.c
+000001c5 stosb
+00000000 printf.c
+00000508 putc
+0000052f printint
+00000c54 digits.1098
+00000000 umalloc.c
+00000c80 base
+00000c88 freep
+00000860 morecore
+000001eb strcpy
+000004f0 yield
+00000500 set_prio
+000005e4 printf
+000003f7 memmove
+00000488 mknod
+000002e2 gets
+000004c0 getpid
+000008c4 malloc
+000004d0 sleep
+000004f8 wait2
+00000450 pipe
+00000460 write
+00000498 fstat
+00000470 kill
+000004b0 chdir
+00000478 exec
+00000448 wait
+00000458 read
+00000490 unlink
+00000000 wc
+00000438 fork
+000004c8 sbrk
+000004d8 uptime
+00000c65 __bss_start
+0000028d memset
+000000f2 main
+0000021f strcmp
+000004b8 dup
+00000ca0 buf
+00000355 stat
+00000c65 _edata
+00000ea0 _end
+000004a0 link
+00000440 exit
+000003a6 atoi
+000004e0 draw
+00000262 strlen
+00000480 open
+000002ab strchr
+000004e8 cps
+000004a8 mkdir
+00000468 close
+0000077a free
diff -ruN xv6-public/xv6-public/x86.h xv6-public_new/xv6-public/x86.h
--- xv6-public/xv6-public/x86.h	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/x86.h	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,183 @@
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port)
+{
+  uchar data;
+
+  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
+  return data;
+}
+
+static inline void
+insl(int port, void *addr, int cnt)
+{
+  asm volatile("cld; rep insl" :
+               "=D" (addr), "=c" (cnt) :
+               "d" (port), "0" (addr), "1" (cnt) :
+               "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data)
+{
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+}
+
+static inline void
+outw(ushort port, ushort data)
+{
+  asm volatile("out %0,%1" : : "a" (data), "d" (port));
+}
+
+static inline void
+outsl(int port, const void *addr, int cnt)
+{
+  asm volatile("cld; rep outsl" :
+               "=S" (addr), "=c" (cnt) :
+               "d" (port), "0" (addr), "1" (cnt) :
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosb" :
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+
+static inline void
+stosl(void *addr, int data, int cnt)
+{
+  asm volatile("cld; rep stosl" :
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+
+struct segdesc;
+
+static inline void
+lgdt(struct segdesc *p, int size)
+{
+  volatile ushort pd[3];
+
+  pd[0] = size-1;
+  pd[1] = (uint)p;
+  pd[2] = (uint)p >> 16;
+
+  asm volatile("lgdt (%0)" : : "r" (pd));
+}
+
+struct gatedesc;
+
+static inline void
+lidt(struct gatedesc *p, int size)
+{
+  volatile ushort pd[3];
+
+  pd[0] = size-1;
+  pd[1] = (uint)p;
+  pd[2] = (uint)p >> 16;
+
+  asm volatile("lidt (%0)" : : "r" (pd));
+}
+
+static inline void
+ltr(ushort sel)
+{
+  asm volatile("ltr %0" : : "r" (sel));
+}
+
+static inline uint
+readeflags(void)
+{
+  uint eflags;
+  asm volatile("pushfl; popl %0" : "=r" (eflags));
+  return eflags;
+}
+
+static inline void
+loadgs(ushort v)
+{
+  asm volatile("movw %0, %%gs" : : "r" (v));
+}
+
+static inline void
+cli(void)
+{
+  asm volatile("cli");
+}
+
+static inline void
+sti(void)
+{
+  asm volatile("sti");
+}
+
+static inline uint
+xchg(volatile uint *addr, uint newval)
+{
+  uint result;
+
+  // The + in "+m" denotes a read-modify-write operand.
+  asm volatile("lock; xchgl %0, %1" :
+               "+m" (*addr), "=a" (result) :
+               "1" (newval) :
+               "cc");
+  return result;
+}
+
+static inline uint
+rcr2(void)
+{
+  uint val;
+  asm volatile("movl %%cr2,%0" : "=r" (val));
+  return val;
+}
+
+static inline void
+lcr3(uint val)
+{
+  asm volatile("movl %0,%%cr3" : : "r" (val));
+}
+
+//PAGEBREAK: 36
+// Layout of the trap frame built on the stack by the
+// hardware and by trapasm.S, and passed to trap().
+struct trapframe {
+  // registers as pushed by pusha
+  uint edi;
+  uint esi;
+  uint ebp;
+  uint oesp;      // useless & ignored
+  uint ebx;
+  uint edx;
+  uint ecx;
+  uint eax;
+
+  // rest of trap frame
+  ushort gs;
+  ushort padding1;
+  ushort fs;
+  ushort padding2;
+  ushort es;
+  ushort padding3;
+  ushort ds;
+  ushort padding4;
+  uint trapno;
+
+  // below here defined by x86 hardware
+  uint err;
+  uint eip;
+  ushort cs;
+  ushort padding5;
+  uint eflags;
+
+  // below here only when crossing rings, such as from user to kernel
+  uint esp;
+  ushort ss;
+  ushort padding6;
+};
Binary files xv6-public/xv6-public/xv6.img and xv6-public_new/xv6-public/xv6.img differ
diff -ruN xv6-public/xv6-public/zombie.asm xv6-public_new/xv6-public/zombie.asm
--- xv6-public/xv6-public/zombie.asm	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/zombie.asm	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,1142 @@
+
+_zombie:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00000000 <main>:
+#include "stat.h"
+#include "user.h"
+
+int
+main(void)
+{
+   0:	f3 0f 1e fb          	endbr32 
+   4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
+   8:	83 e4 f0             	and    $0xfffffff0,%esp
+   b:	ff 71 fc             	pushl  -0x4(%ecx)
+   e:	55                   	push   %ebp
+   f:	89 e5                	mov    %esp,%ebp
+  11:	51                   	push   %ecx
+  12:	83 ec 04             	sub    $0x4,%esp
+  if(fork() > 0)
+  15:	e8 89 02 00 00       	call   2a3 <fork>
+  1a:	85 c0                	test   %eax,%eax
+  1c:	7e 0d                	jle    2b <main+0x2b>
+    sleep(5);  // Let child exit before parent.
+  1e:	83 ec 0c             	sub    $0xc,%esp
+  21:	6a 05                	push   $0x5
+  23:	e8 13 03 00 00       	call   33b <sleep>
+  28:	83 c4 10             	add    $0x10,%esp
+  exit();
+  2b:	e8 7b 02 00 00       	call   2ab <exit>
+
+00000030 <stosb>:
+               "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt)
+{
+  30:	55                   	push   %ebp
+  31:	89 e5                	mov    %esp,%ebp
+  33:	57                   	push   %edi
+  34:	53                   	push   %ebx
+  asm volatile("cld; rep stosb" :
+  35:	8b 4d 08             	mov    0x8(%ebp),%ecx
+  38:	8b 55 10             	mov    0x10(%ebp),%edx
+  3b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  3e:	89 cb                	mov    %ecx,%ebx
+  40:	89 df                	mov    %ebx,%edi
+  42:	89 d1                	mov    %edx,%ecx
+  44:	fc                   	cld    
+  45:	f3 aa                	rep stos %al,%es:(%edi)
+  47:	89 ca                	mov    %ecx,%edx
+  49:	89 fb                	mov    %edi,%ebx
+  4b:	89 5d 08             	mov    %ebx,0x8(%ebp)
+  4e:	89 55 10             	mov    %edx,0x10(%ebp)
+               "=D" (addr), "=c" (cnt) :
+               "0" (addr), "1" (cnt), "a" (data) :
+               "memory", "cc");
+}
+  51:	90                   	nop
+  52:	5b                   	pop    %ebx
+  53:	5f                   	pop    %edi
+  54:	5d                   	pop    %ebp
+  55:	c3                   	ret    
+
+00000056 <strcpy>:
+#include "user.h"
+#include "x86.h"
+
+char*
+strcpy(char *s, const char *t)
+{
+  56:	f3 0f 1e fb          	endbr32 
+  5a:	55                   	push   %ebp
+  5b:	89 e5                	mov    %esp,%ebp
+  5d:	83 ec 10             	sub    $0x10,%esp
+  char *os;
+
+  os = s;
+  60:	8b 45 08             	mov    0x8(%ebp),%eax
+  63:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while((*s++ = *t++) != 0)
+  66:	90                   	nop
+  67:	8b 55 0c             	mov    0xc(%ebp),%edx
+  6a:	8d 42 01             	lea    0x1(%edx),%eax
+  6d:	89 45 0c             	mov    %eax,0xc(%ebp)
+  70:	8b 45 08             	mov    0x8(%ebp),%eax
+  73:	8d 48 01             	lea    0x1(%eax),%ecx
+  76:	89 4d 08             	mov    %ecx,0x8(%ebp)
+  79:	0f b6 12             	movzbl (%edx),%edx
+  7c:	88 10                	mov    %dl,(%eax)
+  7e:	0f b6 00             	movzbl (%eax),%eax
+  81:	84 c0                	test   %al,%al
+  83:	75 e2                	jne    67 <strcpy+0x11>
+    ;
+  return os;
+  85:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  88:	c9                   	leave  
+  89:	c3                   	ret    
+
+0000008a <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  8a:	f3 0f 1e fb          	endbr32 
+  8e:	55                   	push   %ebp
+  8f:	89 e5                	mov    %esp,%ebp
+  while(*p && *p == *q)
+  91:	eb 08                	jmp    9b <strcmp+0x11>
+    p++, q++;
+  93:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  97:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+  while(*p && *p == *q)
+  9b:	8b 45 08             	mov    0x8(%ebp),%eax
+  9e:	0f b6 00             	movzbl (%eax),%eax
+  a1:	84 c0                	test   %al,%al
+  a3:	74 10                	je     b5 <strcmp+0x2b>
+  a5:	8b 45 08             	mov    0x8(%ebp),%eax
+  a8:	0f b6 10             	movzbl (%eax),%edx
+  ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+  ae:	0f b6 00             	movzbl (%eax),%eax
+  b1:	38 c2                	cmp    %al,%dl
+  b3:	74 de                	je     93 <strcmp+0x9>
+  return (uchar)*p - (uchar)*q;
+  b5:	8b 45 08             	mov    0x8(%ebp),%eax
+  b8:	0f b6 00             	movzbl (%eax),%eax
+  bb:	0f b6 d0             	movzbl %al,%edx
+  be:	8b 45 0c             	mov    0xc(%ebp),%eax
+  c1:	0f b6 00             	movzbl (%eax),%eax
+  c4:	0f b6 c0             	movzbl %al,%eax
+  c7:	29 c2                	sub    %eax,%edx
+  c9:	89 d0                	mov    %edx,%eax
+}
+  cb:	5d                   	pop    %ebp
+  cc:	c3                   	ret    
+
+000000cd <strlen>:
+
+uint
+strlen(const char *s)
+{
+  cd:	f3 0f 1e fb          	endbr32 
+  d1:	55                   	push   %ebp
+  d2:	89 e5                	mov    %esp,%ebp
+  d4:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  for(n = 0; s[n]; n++)
+  d7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  de:	eb 04                	jmp    e4 <strlen+0x17>
+  e0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  e4:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  e7:	8b 45 08             	mov    0x8(%ebp),%eax
+  ea:	01 d0                	add    %edx,%eax
+  ec:	0f b6 00             	movzbl (%eax),%eax
+  ef:	84 c0                	test   %al,%al
+  f1:	75 ed                	jne    e0 <strlen+0x13>
+    ;
+  return n;
+  f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  f6:	c9                   	leave  
+  f7:	c3                   	ret    
+
+000000f8 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  f8:	f3 0f 1e fb          	endbr32 
+  fc:	55                   	push   %ebp
+  fd:	89 e5                	mov    %esp,%ebp
+  stosb(dst, c, n);
+  ff:	8b 45 10             	mov    0x10(%ebp),%eax
+ 102:	50                   	push   %eax
+ 103:	ff 75 0c             	pushl  0xc(%ebp)
+ 106:	ff 75 08             	pushl  0x8(%ebp)
+ 109:	e8 22 ff ff ff       	call   30 <stosb>
+ 10e:	83 c4 0c             	add    $0xc,%esp
+  return dst;
+ 111:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 114:	c9                   	leave  
+ 115:	c3                   	ret    
+
+00000116 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 116:	f3 0f 1e fb          	endbr32 
+ 11a:	55                   	push   %ebp
+ 11b:	89 e5                	mov    %esp,%ebp
+ 11d:	83 ec 04             	sub    $0x4,%esp
+ 120:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 123:	88 45 fc             	mov    %al,-0x4(%ebp)
+  for(; *s; s++)
+ 126:	eb 14                	jmp    13c <strchr+0x26>
+    if(*s == c)
+ 128:	8b 45 08             	mov    0x8(%ebp),%eax
+ 12b:	0f b6 00             	movzbl (%eax),%eax
+ 12e:	38 45 fc             	cmp    %al,-0x4(%ebp)
+ 131:	75 05                	jne    138 <strchr+0x22>
+      return (char*)s;
+ 133:	8b 45 08             	mov    0x8(%ebp),%eax
+ 136:	eb 13                	jmp    14b <strchr+0x35>
+  for(; *s; s++)
+ 138:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+ 13c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 13f:	0f b6 00             	movzbl (%eax),%eax
+ 142:	84 c0                	test   %al,%al
+ 144:	75 e2                	jne    128 <strchr+0x12>
+  return 0;
+ 146:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+ 14b:	c9                   	leave  
+ 14c:	c3                   	ret    
+
+0000014d <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 14d:	f3 0f 1e fb          	endbr32 
+ 151:	55                   	push   %ebp
+ 152:	89 e5                	mov    %esp,%ebp
+ 154:	83 ec 18             	sub    $0x18,%esp
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 157:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+ 15e:	eb 42                	jmp    1a2 <gets+0x55>
+    cc = read(0, &c, 1);
+ 160:	83 ec 04             	sub    $0x4,%esp
+ 163:	6a 01                	push   $0x1
+ 165:	8d 45 ef             	lea    -0x11(%ebp),%eax
+ 168:	50                   	push   %eax
+ 169:	6a 00                	push   $0x0
+ 16b:	e8 53 01 00 00       	call   2c3 <read>
+ 170:	83 c4 10             	add    $0x10,%esp
+ 173:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if(cc < 1)
+ 176:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 17a:	7e 33                	jle    1af <gets+0x62>
+      break;
+    buf[i++] = c;
+ 17c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 17f:	8d 50 01             	lea    0x1(%eax),%edx
+ 182:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 185:	89 c2                	mov    %eax,%edx
+ 187:	8b 45 08             	mov    0x8(%ebp),%eax
+ 18a:	01 c2                	add    %eax,%edx
+ 18c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 190:	88 02                	mov    %al,(%edx)
+    if(c == '\n' || c == '\r')
+ 192:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 196:	3c 0a                	cmp    $0xa,%al
+ 198:	74 16                	je     1b0 <gets+0x63>
+ 19a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+ 19e:	3c 0d                	cmp    $0xd,%al
+ 1a0:	74 0e                	je     1b0 <gets+0x63>
+  for(i=0; i+1 < max; ){
+ 1a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 1a5:	83 c0 01             	add    $0x1,%eax
+ 1a8:	39 45 0c             	cmp    %eax,0xc(%ebp)
+ 1ab:	7f b3                	jg     160 <gets+0x13>
+ 1ad:	eb 01                	jmp    1b0 <gets+0x63>
+      break;
+ 1af:	90                   	nop
+      break;
+  }
+  buf[i] = '\0';
+ 1b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+ 1b3:	8b 45 08             	mov    0x8(%ebp),%eax
+ 1b6:	01 d0                	add    %edx,%eax
+ 1b8:	c6 00 00             	movb   $0x0,(%eax)
+  return buf;
+ 1bb:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 1be:	c9                   	leave  
+ 1bf:	c3                   	ret    
+
+000001c0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1c0:	f3 0f 1e fb          	endbr32 
+ 1c4:	55                   	push   %ebp
+ 1c5:	89 e5                	mov    %esp,%ebp
+ 1c7:	83 ec 18             	sub    $0x18,%esp
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1ca:	83 ec 08             	sub    $0x8,%esp
+ 1cd:	6a 00                	push   $0x0
+ 1cf:	ff 75 08             	pushl  0x8(%ebp)
+ 1d2:	e8 14 01 00 00       	call   2eb <open>
+ 1d7:	83 c4 10             	add    $0x10,%esp
+ 1da:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(fd < 0)
+ 1dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 1e1:	79 07                	jns    1ea <stat+0x2a>
+    return -1;
+ 1e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+ 1e8:	eb 25                	jmp    20f <stat+0x4f>
+  r = fstat(fd, st);
+ 1ea:	83 ec 08             	sub    $0x8,%esp
+ 1ed:	ff 75 0c             	pushl  0xc(%ebp)
+ 1f0:	ff 75 f4             	pushl  -0xc(%ebp)
+ 1f3:	e8 0b 01 00 00       	call   303 <fstat>
+ 1f8:	83 c4 10             	add    $0x10,%esp
+ 1fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  close(fd);
+ 1fe:	83 ec 0c             	sub    $0xc,%esp
+ 201:	ff 75 f4             	pushl  -0xc(%ebp)
+ 204:	e8 ca 00 00 00       	call   2d3 <close>
+ 209:	83 c4 10             	add    $0x10,%esp
+  return r;
+ 20c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+ 20f:	c9                   	leave  
+ 210:	c3                   	ret    
+
+00000211 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 211:	f3 0f 1e fb          	endbr32 
+ 215:	55                   	push   %ebp
+ 216:	89 e5                	mov    %esp,%ebp
+ 218:	83 ec 10             	sub    $0x10,%esp
+  int n;
+
+  n = 0;
+ 21b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 222:	eb 25                	jmp    249 <atoi+0x38>
+    n = n*10 + *s++ - '0';
+ 224:	8b 55 fc             	mov    -0x4(%ebp),%edx
+ 227:	89 d0                	mov    %edx,%eax
+ 229:	c1 e0 02             	shl    $0x2,%eax
+ 22c:	01 d0                	add    %edx,%eax
+ 22e:	01 c0                	add    %eax,%eax
+ 230:	89 c1                	mov    %eax,%ecx
+ 232:	8b 45 08             	mov    0x8(%ebp),%eax
+ 235:	8d 50 01             	lea    0x1(%eax),%edx
+ 238:	89 55 08             	mov    %edx,0x8(%ebp)
+ 23b:	0f b6 00             	movzbl (%eax),%eax
+ 23e:	0f be c0             	movsbl %al,%eax
+ 241:	01 c8                	add    %ecx,%eax
+ 243:	83 e8 30             	sub    $0x30,%eax
+ 246:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  while('0' <= *s && *s <= '9')
+ 249:	8b 45 08             	mov    0x8(%ebp),%eax
+ 24c:	0f b6 00             	movzbl (%eax),%eax
+ 24f:	3c 2f                	cmp    $0x2f,%al
+ 251:	7e 0a                	jle    25d <atoi+0x4c>
+ 253:	8b 45 08             	mov    0x8(%ebp),%eax
+ 256:	0f b6 00             	movzbl (%eax),%eax
+ 259:	3c 39                	cmp    $0x39,%al
+ 25b:	7e c7                	jle    224 <atoi+0x13>
+  return n;
+ 25d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+ 260:	c9                   	leave  
+ 261:	c3                   	ret    
+
+00000262 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 262:	f3 0f 1e fb          	endbr32 
+ 266:	55                   	push   %ebp
+ 267:	89 e5                	mov    %esp,%ebp
+ 269:	83 ec 10             	sub    $0x10,%esp
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+ 26c:	8b 45 08             	mov    0x8(%ebp),%eax
+ 26f:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  src = vsrc;
+ 272:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 275:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  while(n-- > 0)
+ 278:	eb 17                	jmp    291 <memmove+0x2f>
+    *dst++ = *src++;
+ 27a:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 27d:	8d 42 01             	lea    0x1(%edx),%eax
+ 280:	89 45 f8             	mov    %eax,-0x8(%ebp)
+ 283:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 286:	8d 48 01             	lea    0x1(%eax),%ecx
+ 289:	89 4d fc             	mov    %ecx,-0x4(%ebp)
+ 28c:	0f b6 12             	movzbl (%edx),%edx
+ 28f:	88 10                	mov    %dl,(%eax)
+  while(n-- > 0)
+ 291:	8b 45 10             	mov    0x10(%ebp),%eax
+ 294:	8d 50 ff             	lea    -0x1(%eax),%edx
+ 297:	89 55 10             	mov    %edx,0x10(%ebp)
+ 29a:	85 c0                	test   %eax,%eax
+ 29c:	7f dc                	jg     27a <memmove+0x18>
+  return vdst;
+ 29e:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+ 2a1:	c9                   	leave  
+ 2a2:	c3                   	ret    
+
+000002a3 <fork>:
+  name: \
+    movl $SYS_ ## name, %eax; \
+    int $T_SYSCALL; \
+    ret
+
+SYSCALL(fork)
+ 2a3:	b8 01 00 00 00       	mov    $0x1,%eax
+ 2a8:	cd 40                	int    $0x40
+ 2aa:	c3                   	ret    
+
+000002ab <exit>:
+SYSCALL(exit)
+ 2ab:	b8 02 00 00 00       	mov    $0x2,%eax
+ 2b0:	cd 40                	int    $0x40
+ 2b2:	c3                   	ret    
+
+000002b3 <wait>:
+SYSCALL(wait)
+ 2b3:	b8 03 00 00 00       	mov    $0x3,%eax
+ 2b8:	cd 40                	int    $0x40
+ 2ba:	c3                   	ret    
+
+000002bb <pipe>:
+SYSCALL(pipe)
+ 2bb:	b8 04 00 00 00       	mov    $0x4,%eax
+ 2c0:	cd 40                	int    $0x40
+ 2c2:	c3                   	ret    
+
+000002c3 <read>:
+SYSCALL(read)
+ 2c3:	b8 05 00 00 00       	mov    $0x5,%eax
+ 2c8:	cd 40                	int    $0x40
+ 2ca:	c3                   	ret    
+
+000002cb <write>:
+SYSCALL(write)
+ 2cb:	b8 10 00 00 00       	mov    $0x10,%eax
+ 2d0:	cd 40                	int    $0x40
+ 2d2:	c3                   	ret    
+
+000002d3 <close>:
+SYSCALL(close)
+ 2d3:	b8 15 00 00 00       	mov    $0x15,%eax
+ 2d8:	cd 40                	int    $0x40
+ 2da:	c3                   	ret    
+
+000002db <kill>:
+SYSCALL(kill)
+ 2db:	b8 06 00 00 00       	mov    $0x6,%eax
+ 2e0:	cd 40                	int    $0x40
+ 2e2:	c3                   	ret    
+
+000002e3 <exec>:
+SYSCALL(exec)
+ 2e3:	b8 07 00 00 00       	mov    $0x7,%eax
+ 2e8:	cd 40                	int    $0x40
+ 2ea:	c3                   	ret    
+
+000002eb <open>:
+SYSCALL(open)
+ 2eb:	b8 0f 00 00 00       	mov    $0xf,%eax
+ 2f0:	cd 40                	int    $0x40
+ 2f2:	c3                   	ret    
+
+000002f3 <mknod>:
+SYSCALL(mknod)
+ 2f3:	b8 11 00 00 00       	mov    $0x11,%eax
+ 2f8:	cd 40                	int    $0x40
+ 2fa:	c3                   	ret    
+
+000002fb <unlink>:
+SYSCALL(unlink)
+ 2fb:	b8 12 00 00 00       	mov    $0x12,%eax
+ 300:	cd 40                	int    $0x40
+ 302:	c3                   	ret    
+
+00000303 <fstat>:
+SYSCALL(fstat)
+ 303:	b8 08 00 00 00       	mov    $0x8,%eax
+ 308:	cd 40                	int    $0x40
+ 30a:	c3                   	ret    
+
+0000030b <link>:
+SYSCALL(link)
+ 30b:	b8 13 00 00 00       	mov    $0x13,%eax
+ 310:	cd 40                	int    $0x40
+ 312:	c3                   	ret    
+
+00000313 <mkdir>:
+SYSCALL(mkdir)
+ 313:	b8 14 00 00 00       	mov    $0x14,%eax
+ 318:	cd 40                	int    $0x40
+ 31a:	c3                   	ret    
+
+0000031b <chdir>:
+SYSCALL(chdir)
+ 31b:	b8 09 00 00 00       	mov    $0x9,%eax
+ 320:	cd 40                	int    $0x40
+ 322:	c3                   	ret    
+
+00000323 <dup>:
+SYSCALL(dup)
+ 323:	b8 0a 00 00 00       	mov    $0xa,%eax
+ 328:	cd 40                	int    $0x40
+ 32a:	c3                   	ret    
+
+0000032b <getpid>:
+SYSCALL(getpid)
+ 32b:	b8 0b 00 00 00       	mov    $0xb,%eax
+ 330:	cd 40                	int    $0x40
+ 332:	c3                   	ret    
+
+00000333 <sbrk>:
+SYSCALL(sbrk)
+ 333:	b8 0c 00 00 00       	mov    $0xc,%eax
+ 338:	cd 40                	int    $0x40
+ 33a:	c3                   	ret    
+
+0000033b <sleep>:
+SYSCALL(sleep)
+ 33b:	b8 0d 00 00 00       	mov    $0xd,%eax
+ 340:	cd 40                	int    $0x40
+ 342:	c3                   	ret    
+
+00000343 <uptime>:
+SYSCALL(uptime)
+ 343:	b8 0e 00 00 00       	mov    $0xe,%eax
+ 348:	cd 40                	int    $0x40
+ 34a:	c3                   	ret    
+
+0000034b <draw>:
+SYSCALL(draw)
+ 34b:	b8 16 00 00 00       	mov    $0x16,%eax
+ 350:	cd 40                	int    $0x40
+ 352:	c3                   	ret    
+
+00000353 <cps>:
+SYSCALL(cps)
+ 353:	b8 17 00 00 00       	mov    $0x17,%eax
+ 358:	cd 40                	int    $0x40
+ 35a:	c3                   	ret    
+
+0000035b <yield>:
+SYSCALL(yield)
+ 35b:	b8 18 00 00 00       	mov    $0x18,%eax
+ 360:	cd 40                	int    $0x40
+ 362:	c3                   	ret    
+
+00000363 <wait2>:
+SYSCALL(wait2)
+ 363:	b8 19 00 00 00       	mov    $0x19,%eax
+ 368:	cd 40                	int    $0x40
+ 36a:	c3                   	ret    
+
+0000036b <set_prio>:
+SYSCALL(set_prio)
+ 36b:	b8 1a 00 00 00       	mov    $0x1a,%eax
+ 370:	cd 40                	int    $0x40
+ 372:	c3                   	ret    
+
+00000373 <putc>:
+#include "stat.h"
+#include "user.h"
+
+static void
+putc(int fd, char c)
+{
+ 373:	f3 0f 1e fb          	endbr32 
+ 377:	55                   	push   %ebp
+ 378:	89 e5                	mov    %esp,%ebp
+ 37a:	83 ec 18             	sub    $0x18,%esp
+ 37d:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 380:	88 45 f4             	mov    %al,-0xc(%ebp)
+  write(fd, &c, 1);
+ 383:	83 ec 04             	sub    $0x4,%esp
+ 386:	6a 01                	push   $0x1
+ 388:	8d 45 f4             	lea    -0xc(%ebp),%eax
+ 38b:	50                   	push   %eax
+ 38c:	ff 75 08             	pushl  0x8(%ebp)
+ 38f:	e8 37 ff ff ff       	call   2cb <write>
+ 394:	83 c4 10             	add    $0x10,%esp
+}
+ 397:	90                   	nop
+ 398:	c9                   	leave  
+ 399:	c3                   	ret    
+
+0000039a <printint>:
+
+static void
+printint(int fd, int xx, int base, int sgn)
+{
+ 39a:	f3 0f 1e fb          	endbr32 
+ 39e:	55                   	push   %ebp
+ 39f:	89 e5                	mov    %esp,%ebp
+ 3a1:	83 ec 28             	sub    $0x28,%esp
+  static char digits[] = "0123456789ABCDEF";
+  char buf[16];
+  int i, neg;
+  uint x;
+
+  neg = 0;
+ 3a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+  if(sgn && xx < 0){
+ 3ab:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+ 3af:	74 17                	je     3c8 <printint+0x2e>
+ 3b1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+ 3b5:	79 11                	jns    3c8 <printint+0x2e>
+    neg = 1;
+ 3b7:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+    x = -xx;
+ 3be:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3c1:	f7 d8                	neg    %eax
+ 3c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 3c6:	eb 06                	jmp    3ce <printint+0x34>
+  } else {
+    x = xx;
+ 3c8:	8b 45 0c             	mov    0xc(%ebp),%eax
+ 3cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  }
+
+  i = 0;
+ 3ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  do{
+    buf[i++] = digits[x % base];
+ 3d5:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 3d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 3db:	ba 00 00 00 00       	mov    $0x0,%edx
+ 3e0:	f7 f1                	div    %ecx
+ 3e2:	89 d1                	mov    %edx,%ecx
+ 3e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 3e7:	8d 50 01             	lea    0x1(%eax),%edx
+ 3ea:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 3ed:	0f b6 91 64 0a 00 00 	movzbl 0xa64(%ecx),%edx
+ 3f4:	88 54 05 dc          	mov    %dl,-0x24(%ebp,%eax,1)
+  }while((x /= base) != 0);
+ 3f8:	8b 4d 10             	mov    0x10(%ebp),%ecx
+ 3fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
+ 3fe:	ba 00 00 00 00       	mov    $0x0,%edx
+ 403:	f7 f1                	div    %ecx
+ 405:	89 45 ec             	mov    %eax,-0x14(%ebp)
+ 408:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 40c:	75 c7                	jne    3d5 <printint+0x3b>
+  if(neg)
+ 40e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 412:	74 2d                	je     441 <printint+0xa7>
+    buf[i++] = '-';
+ 414:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 417:	8d 50 01             	lea    0x1(%eax),%edx
+ 41a:	89 55 f4             	mov    %edx,-0xc(%ebp)
+ 41d:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)
+
+  while(--i >= 0)
+ 422:	eb 1d                	jmp    441 <printint+0xa7>
+    putc(fd, buf[i]);
+ 424:	8d 55 dc             	lea    -0x24(%ebp),%edx
+ 427:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 42a:	01 d0                	add    %edx,%eax
+ 42c:	0f b6 00             	movzbl (%eax),%eax
+ 42f:	0f be c0             	movsbl %al,%eax
+ 432:	83 ec 08             	sub    $0x8,%esp
+ 435:	50                   	push   %eax
+ 436:	ff 75 08             	pushl  0x8(%ebp)
+ 439:	e8 35 ff ff ff       	call   373 <putc>
+ 43e:	83 c4 10             	add    $0x10,%esp
+  while(--i >= 0)
+ 441:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+ 445:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 449:	79 d9                	jns    424 <printint+0x8a>
+}
+ 44b:	90                   	nop
+ 44c:	90                   	nop
+ 44d:	c9                   	leave  
+ 44e:	c3                   	ret    
+
+0000044f <printf>:
+
+// Print to the given fd. Only understands %d, %x, %p, %s.
+void
+printf(int fd, const char *fmt, ...)
+{
+ 44f:	f3 0f 1e fb          	endbr32 
+ 453:	55                   	push   %ebp
+ 454:	89 e5                	mov    %esp,%ebp
+ 456:	83 ec 28             	sub    $0x28,%esp
+  char *s;
+  int c, i, state;
+  uint *ap;
+
+  state = 0;
+ 459:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  ap = (uint*)(void*)&fmt + 1;
+ 460:	8d 45 0c             	lea    0xc(%ebp),%eax
+ 463:	83 c0 04             	add    $0x4,%eax
+ 466:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 469:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+ 470:	e9 59 01 00 00       	jmp    5ce <printf+0x17f>
+    c = fmt[i] & 0xff;
+ 475:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 478:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 47b:	01 d0                	add    %edx,%eax
+ 47d:	0f b6 00             	movzbl (%eax),%eax
+ 480:	0f be c0             	movsbl %al,%eax
+ 483:	25 ff 00 00 00       	and    $0xff,%eax
+ 488:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+    if(state == 0){
+ 48b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+ 48f:	75 2c                	jne    4bd <printf+0x6e>
+      if(c == '%'){
+ 491:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 495:	75 0c                	jne    4a3 <printf+0x54>
+        state = '%';
+ 497:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
+ 49e:	e9 27 01 00 00       	jmp    5ca <printf+0x17b>
+      } else {
+        putc(fd, c);
+ 4a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 4a6:	0f be c0             	movsbl %al,%eax
+ 4a9:	83 ec 08             	sub    $0x8,%esp
+ 4ac:	50                   	push   %eax
+ 4ad:	ff 75 08             	pushl  0x8(%ebp)
+ 4b0:	e8 be fe ff ff       	call   373 <putc>
+ 4b5:	83 c4 10             	add    $0x10,%esp
+ 4b8:	e9 0d 01 00 00       	jmp    5ca <printf+0x17b>
+      }
+    } else if(state == '%'){
+ 4bd:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
+ 4c1:	0f 85 03 01 00 00    	jne    5ca <printf+0x17b>
+      if(c == 'd'){
+ 4c7:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
+ 4cb:	75 1e                	jne    4eb <printf+0x9c>
+        printint(fd, *ap, 10, 1);
+ 4cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 4d0:	8b 00                	mov    (%eax),%eax
+ 4d2:	6a 01                	push   $0x1
+ 4d4:	6a 0a                	push   $0xa
+ 4d6:	50                   	push   %eax
+ 4d7:	ff 75 08             	pushl  0x8(%ebp)
+ 4da:	e8 bb fe ff ff       	call   39a <printint>
+ 4df:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 4e2:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 4e6:	e9 d8 00 00 00       	jmp    5c3 <printf+0x174>
+      } else if(c == 'x' || c == 'p'){
+ 4eb:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
+ 4ef:	74 06                	je     4f7 <printf+0xa8>
+ 4f1:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
+ 4f5:	75 1e                	jne    515 <printf+0xc6>
+        printint(fd, *ap, 16, 0);
+ 4f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 4fa:	8b 00                	mov    (%eax),%eax
+ 4fc:	6a 00                	push   $0x0
+ 4fe:	6a 10                	push   $0x10
+ 500:	50                   	push   %eax
+ 501:	ff 75 08             	pushl  0x8(%ebp)
+ 504:	e8 91 fe ff ff       	call   39a <printint>
+ 509:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 50c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 510:	e9 ae 00 00 00       	jmp    5c3 <printf+0x174>
+      } else if(c == 's'){
+ 515:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
+ 519:	75 43                	jne    55e <printf+0x10f>
+        s = (char*)*ap;
+ 51b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 51e:	8b 00                	mov    (%eax),%eax
+ 520:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        ap++;
+ 523:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+        if(s == 0)
+ 527:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 52b:	75 25                	jne    552 <printf+0x103>
+          s = "(null)";
+ 52d:	c7 45 f4 16 08 00 00 	movl   $0x816,-0xc(%ebp)
+        while(*s != 0){
+ 534:	eb 1c                	jmp    552 <printf+0x103>
+          putc(fd, *s);
+ 536:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 539:	0f b6 00             	movzbl (%eax),%eax
+ 53c:	0f be c0             	movsbl %al,%eax
+ 53f:	83 ec 08             	sub    $0x8,%esp
+ 542:	50                   	push   %eax
+ 543:	ff 75 08             	pushl  0x8(%ebp)
+ 546:	e8 28 fe ff ff       	call   373 <putc>
+ 54b:	83 c4 10             	add    $0x10,%esp
+          s++;
+ 54e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while(*s != 0){
+ 552:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 555:	0f b6 00             	movzbl (%eax),%eax
+ 558:	84 c0                	test   %al,%al
+ 55a:	75 da                	jne    536 <printf+0xe7>
+ 55c:	eb 65                	jmp    5c3 <printf+0x174>
+        }
+      } else if(c == 'c'){
+ 55e:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
+ 562:	75 1d                	jne    581 <printf+0x132>
+        putc(fd, *ap);
+ 564:	8b 45 e8             	mov    -0x18(%ebp),%eax
+ 567:	8b 00                	mov    (%eax),%eax
+ 569:	0f be c0             	movsbl %al,%eax
+ 56c:	83 ec 08             	sub    $0x8,%esp
+ 56f:	50                   	push   %eax
+ 570:	ff 75 08             	pushl  0x8(%ebp)
+ 573:	e8 fb fd ff ff       	call   373 <putc>
+ 578:	83 c4 10             	add    $0x10,%esp
+        ap++;
+ 57b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
+ 57f:	eb 42                	jmp    5c3 <printf+0x174>
+      } else if(c == '%'){
+ 581:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
+ 585:	75 17                	jne    59e <printf+0x14f>
+        putc(fd, c);
+ 587:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 58a:	0f be c0             	movsbl %al,%eax
+ 58d:	83 ec 08             	sub    $0x8,%esp
+ 590:	50                   	push   %eax
+ 591:	ff 75 08             	pushl  0x8(%ebp)
+ 594:	e8 da fd ff ff       	call   373 <putc>
+ 599:	83 c4 10             	add    $0x10,%esp
+ 59c:	eb 25                	jmp    5c3 <printf+0x174>
+      } else {
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+ 59e:	83 ec 08             	sub    $0x8,%esp
+ 5a1:	6a 25                	push   $0x25
+ 5a3:	ff 75 08             	pushl  0x8(%ebp)
+ 5a6:	e8 c8 fd ff ff       	call   373 <putc>
+ 5ab:	83 c4 10             	add    $0x10,%esp
+        putc(fd, c);
+ 5ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+ 5b1:	0f be c0             	movsbl %al,%eax
+ 5b4:	83 ec 08             	sub    $0x8,%esp
+ 5b7:	50                   	push   %eax
+ 5b8:	ff 75 08             	pushl  0x8(%ebp)
+ 5bb:	e8 b3 fd ff ff       	call   373 <putc>
+ 5c0:	83 c4 10             	add    $0x10,%esp
+      }
+      state = 0;
+ 5c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+  for(i = 0; fmt[i]; i++){
+ 5ca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
+ 5ce:	8b 55 0c             	mov    0xc(%ebp),%edx
+ 5d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 5d4:	01 d0                	add    %edx,%eax
+ 5d6:	0f b6 00             	movzbl (%eax),%eax
+ 5d9:	84 c0                	test   %al,%al
+ 5db:	0f 85 94 fe ff ff    	jne    475 <printf+0x26>
+    }
+  }
+}
+ 5e1:	90                   	nop
+ 5e2:	90                   	nop
+ 5e3:	c9                   	leave  
+ 5e4:	c3                   	ret    
+
+000005e5 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 5e5:	f3 0f 1e fb          	endbr32 
+ 5e9:	55                   	push   %ebp
+ 5ea:	89 e5                	mov    %esp,%ebp
+ 5ec:	83 ec 10             	sub    $0x10,%esp
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 5ef:	8b 45 08             	mov    0x8(%ebp),%eax
+ 5f2:	83 e8 08             	sub    $0x8,%eax
+ 5f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 5f8:	a1 80 0a 00 00       	mov    0xa80,%eax
+ 5fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 600:	eb 24                	jmp    626 <free+0x41>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 602:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 605:	8b 00                	mov    (%eax),%eax
+ 607:	39 45 fc             	cmp    %eax,-0x4(%ebp)
+ 60a:	72 12                	jb     61e <free+0x39>
+ 60c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 60f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 612:	77 24                	ja     638 <free+0x53>
+ 614:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 617:	8b 00                	mov    (%eax),%eax
+ 619:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 61c:	72 1a                	jb     638 <free+0x53>
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 61e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 621:	8b 00                	mov    (%eax),%eax
+ 623:	89 45 fc             	mov    %eax,-0x4(%ebp)
+ 626:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 629:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+ 62c:	76 d4                	jbe    602 <free+0x1d>
+ 62e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 631:	8b 00                	mov    (%eax),%eax
+ 633:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 636:	73 ca                	jae    602 <free+0x1d>
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+ 638:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 63b:	8b 40 04             	mov    0x4(%eax),%eax
+ 63e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 645:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 648:	01 c2                	add    %eax,%edx
+ 64a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 64d:	8b 00                	mov    (%eax),%eax
+ 64f:	39 c2                	cmp    %eax,%edx
+ 651:	75 24                	jne    677 <free+0x92>
+    bp->s.size += p->s.ptr->s.size;
+ 653:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 656:	8b 50 04             	mov    0x4(%eax),%edx
+ 659:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 65c:	8b 00                	mov    (%eax),%eax
+ 65e:	8b 40 04             	mov    0x4(%eax),%eax
+ 661:	01 c2                	add    %eax,%edx
+ 663:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 666:	89 50 04             	mov    %edx,0x4(%eax)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 669:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 66c:	8b 00                	mov    (%eax),%eax
+ 66e:	8b 10                	mov    (%eax),%edx
+ 670:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 673:	89 10                	mov    %edx,(%eax)
+ 675:	eb 0a                	jmp    681 <free+0x9c>
+  } else
+    bp->s.ptr = p->s.ptr;
+ 677:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 67a:	8b 10                	mov    (%eax),%edx
+ 67c:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 67f:	89 10                	mov    %edx,(%eax)
+  if(p + p->s.size == bp){
+ 681:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 684:	8b 40 04             	mov    0x4(%eax),%eax
+ 687:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+ 68e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 691:	01 d0                	add    %edx,%eax
+ 693:	39 45 f8             	cmp    %eax,-0x8(%ebp)
+ 696:	75 20                	jne    6b8 <free+0xd3>
+    p->s.size += bp->s.size;
+ 698:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 69b:	8b 50 04             	mov    0x4(%eax),%edx
+ 69e:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6a1:	8b 40 04             	mov    0x4(%eax),%eax
+ 6a4:	01 c2                	add    %eax,%edx
+ 6a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6a9:	89 50 04             	mov    %edx,0x4(%eax)
+    p->s.ptr = bp->s.ptr;
+ 6ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
+ 6af:	8b 10                	mov    (%eax),%edx
+ 6b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6b4:	89 10                	mov    %edx,(%eax)
+ 6b6:	eb 08                	jmp    6c0 <free+0xdb>
+  } else
+    p->s.ptr = bp;
+ 6b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6bb:	8b 55 f8             	mov    -0x8(%ebp),%edx
+ 6be:	89 10                	mov    %edx,(%eax)
+  freep = p;
+ 6c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
+ 6c3:	a3 80 0a 00 00       	mov    %eax,0xa80
+}
+ 6c8:	90                   	nop
+ 6c9:	c9                   	leave  
+ 6ca:	c3                   	ret    
+
+000006cb <morecore>:
+
+static Header*
+morecore(uint nu)
+{
+ 6cb:	f3 0f 1e fb          	endbr32 
+ 6cf:	55                   	push   %ebp
+ 6d0:	89 e5                	mov    %esp,%ebp
+ 6d2:	83 ec 18             	sub    $0x18,%esp
+  char *p;
+  Header *hp;
+
+  if(nu < 4096)
+ 6d5:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
+ 6dc:	77 07                	ja     6e5 <morecore+0x1a>
+    nu = 4096;
+ 6de:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
+  p = sbrk(nu * sizeof(Header));
+ 6e5:	8b 45 08             	mov    0x8(%ebp),%eax
+ 6e8:	c1 e0 03             	shl    $0x3,%eax
+ 6eb:	83 ec 0c             	sub    $0xc,%esp
+ 6ee:	50                   	push   %eax
+ 6ef:	e8 3f fc ff ff       	call   333 <sbrk>
+ 6f4:	83 c4 10             	add    $0x10,%esp
+ 6f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  if(p == (char*)-1)
+ 6fa:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+ 6fe:	75 07                	jne    707 <morecore+0x3c>
+    return 0;
+ 700:	b8 00 00 00 00       	mov    $0x0,%eax
+ 705:	eb 26                	jmp    72d <morecore+0x62>
+  hp = (Header*)p;
+ 707:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 70a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  hp->s.size = nu;
+ 70d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 710:	8b 55 08             	mov    0x8(%ebp),%edx
+ 713:	89 50 04             	mov    %edx,0x4(%eax)
+  free((void*)(hp + 1));
+ 716:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 719:	83 c0 08             	add    $0x8,%eax
+ 71c:	83 ec 0c             	sub    $0xc,%esp
+ 71f:	50                   	push   %eax
+ 720:	e8 c0 fe ff ff       	call   5e5 <free>
+ 725:	83 c4 10             	add    $0x10,%esp
+  return freep;
+ 728:	a1 80 0a 00 00       	mov    0xa80,%eax
+}
+ 72d:	c9                   	leave  
+ 72e:	c3                   	ret    
+
+0000072f <malloc>:
+
+void*
+malloc(uint nbytes)
+{
+ 72f:	f3 0f 1e fb          	endbr32 
+ 733:	55                   	push   %ebp
+ 734:	89 e5                	mov    %esp,%ebp
+ 736:	83 ec 18             	sub    $0x18,%esp
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 739:	8b 45 08             	mov    0x8(%ebp),%eax
+ 73c:	83 c0 07             	add    $0x7,%eax
+ 73f:	c1 e8 03             	shr    $0x3,%eax
+ 742:	83 c0 01             	add    $0x1,%eax
+ 745:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  if((prevp = freep) == 0){
+ 748:	a1 80 0a 00 00       	mov    0xa80,%eax
+ 74d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 750:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+ 754:	75 23                	jne    779 <malloc+0x4a>
+    base.s.ptr = freep = prevp = &base;
+ 756:	c7 45 f0 78 0a 00 00 	movl   $0xa78,-0x10(%ebp)
+ 75d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 760:	a3 80 0a 00 00       	mov    %eax,0xa80
+ 765:	a1 80 0a 00 00       	mov    0xa80,%eax
+ 76a:	a3 78 0a 00 00       	mov    %eax,0xa78
+    base.s.size = 0;
+ 76f:	c7 05 7c 0a 00 00 00 	movl   $0x0,0xa7c
+ 776:	00 00 00 
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 779:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 77c:	8b 00                	mov    (%eax),%eax
+ 77e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 781:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 784:	8b 40 04             	mov    0x4(%eax),%eax
+ 787:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 78a:	77 4d                	ja     7d9 <malloc+0xaa>
+      if(p->s.size == nunits)
+ 78c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 78f:	8b 40 04             	mov    0x4(%eax),%eax
+ 792:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+ 795:	75 0c                	jne    7a3 <malloc+0x74>
+        prevp->s.ptr = p->s.ptr;
+ 797:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 79a:	8b 10                	mov    (%eax),%edx
+ 79c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 79f:	89 10                	mov    %edx,(%eax)
+ 7a1:	eb 26                	jmp    7c9 <malloc+0x9a>
+      else {
+        p->s.size -= nunits;
+ 7a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7a6:	8b 40 04             	mov    0x4(%eax),%eax
+ 7a9:	2b 45 ec             	sub    -0x14(%ebp),%eax
+ 7ac:	89 c2                	mov    %eax,%edx
+ 7ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7b1:	89 50 04             	mov    %edx,0x4(%eax)
+        p += p->s.size;
+ 7b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7b7:	8b 40 04             	mov    0x4(%eax),%eax
+ 7ba:	c1 e0 03             	shl    $0x3,%eax
+ 7bd:	01 45 f4             	add    %eax,-0xc(%ebp)
+        p->s.size = nunits;
+ 7c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
+ 7c6:	89 50 04             	mov    %edx,0x4(%eax)
+      }
+      freep = prevp;
+ 7c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+ 7cc:	a3 80 0a 00 00       	mov    %eax,0xa80
+      return (void*)(p + 1);
+ 7d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 7d4:	83 c0 08             	add    $0x8,%eax
+ 7d7:	eb 3b                	jmp    814 <malloc+0xe5>
+    }
+    if(p == freep)
+ 7d9:	a1 80 0a 00 00       	mov    0xa80,%eax
+ 7de:	39 45 f4             	cmp    %eax,-0xc(%ebp)
+ 7e1:	75 1e                	jne    801 <malloc+0xd2>
+      if((p = morecore(nunits)) == 0)
+ 7e3:	83 ec 0c             	sub    $0xc,%esp
+ 7e6:	ff 75 ec             	pushl  -0x14(%ebp)
+ 7e9:	e8 dd fe ff ff       	call   6cb <morecore>
+ 7ee:	83 c4 10             	add    $0x10,%esp
+ 7f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+ 7f4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+ 7f8:	75 07                	jne    801 <malloc+0xd2>
+        return 0;
+ 7fa:	b8 00 00 00 00       	mov    $0x0,%eax
+ 7ff:	eb 13                	jmp    814 <malloc+0xe5>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 801:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 804:	89 45 f0             	mov    %eax,-0x10(%ebp)
+ 807:	8b 45 f4             	mov    -0xc(%ebp),%eax
+ 80a:	8b 00                	mov    (%eax),%eax
+ 80c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if(p->s.size >= nunits){
+ 80f:	e9 6d ff ff ff       	jmp    781 <malloc+0x52>
+  }
+}
+ 814:	c9                   	leave  
+ 815:	c3                   	ret    
diff -ruN xv6-public/xv6-public/zombie.c xv6-public_new/xv6-public/zombie.c
--- xv6-public/xv6-public/zombie.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/zombie.c	2021-08-11 00:51:34.000000000 +0530
@@ -0,0 +1,14 @@
+// Create a zombie process that
+// must be reparented at exit.
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(void)
+{
+  if(fork() > 0)
+    sleep(5);  // Let child exit before parent.
+  exit();
+}
diff -ruN xv6-public/xv6-public/zombie.d xv6-public_new/xv6-public/zombie.d
--- xv6-public/xv6-public/zombie.d	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/zombie.d	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1 @@
+zombie.o: zombie.c /usr/include/stdc-predef.h types.h stat.h user.h
Binary files xv6-public/xv6-public/zombie.o and xv6-public_new/xv6-public/zombie.o differ
diff -ruN xv6-public/xv6-public/zombie.sym xv6-public_new/xv6-public/zombie.sym
--- xv6-public/xv6-public/zombie.sym	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public_new/xv6-public/zombie.sym	2021-09-30 23:15:16.000000000 +0530
@@ -0,0 +1,65 @@
+00000000 .text
+00000816 .rodata
+00000820 .eh_frame
+00000a64 .data
+00000a78 .bss
+00000000 .comment
+00000000 .debug_aranges
+00000000 .debug_info
+00000000 .debug_abbrev
+00000000 .debug_line
+00000000 .debug_str
+00000000 .debug_loc
+00000000 zombie.c
+00000000 ulib.c
+00000030 stosb
+00000000 printf.c
+00000373 putc
+0000039a printint
+00000a64 digits.1098
+00000000 umalloc.c
+00000a78 base
+00000a80 freep
+000006cb morecore
+00000056 strcpy
+0000035b yield
+0000036b set_prio
+0000044f printf
+00000262 memmove
+000002f3 mknod
+0000014d gets
+0000032b getpid
+0000072f malloc
+0000033b sleep
+00000363 wait2
+000002bb pipe
+000002cb write
+00000303 fstat
+000002db kill
+0000031b chdir
+000002e3 exec
+000002b3 wait
+000002c3 read
+000002fb unlink
+000002a3 fork
+00000333 sbrk
+00000343 uptime
+00000a75 __bss_start
+000000f8 memset
+00000000 main
+0000008a strcmp
+00000323 dup
+000001c0 stat
+00000a75 _edata
+00000a84 _end
+0000030b link
+000002ab exit
+00000211 atoi
+0000034b draw
+000000cd strlen
+000002eb open
+00000116 strchr
+00000353 cps
+00000313 mkdir
+000002d3 close
+000005e5 free
diff -ruN xv6-public/zombie.c xv6-public_new/zombie.c
--- xv6-public/zombie.c	2021-09-30 23:28:57.832395800 +0530
+++ xv6-public_new/zombie.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,14 +0,0 @@
-// Create a zombie process that
-// must be reparented at exit.
-
-#include "types.h"
-#include "stat.h"
-#include "user.h"
-
-int
-main(void)
-{
-  if(fork() > 0)
-    sleep(5);  // Let child exit before parent.
-  exit();
-}
